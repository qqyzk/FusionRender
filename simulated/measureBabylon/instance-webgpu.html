<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>My first babylon.js app</title>
		<style>
			body { margin: 0; }
		</style>
        <script src="./src/babylon.js"></script>
        <script src="./src/babylon.glTFFileLoader.js"></script>
	</head>
	<body>
        <input  id="button" type="button" value="start" >  
        <canvas id="renderCanvas"></canvas>
       
		<script>
            
            var btn = document.getElementById("button");  
        	btn.onclick = function conduct(){
			let initTime = ( performance || Date ).now()
			let loaded=false;
			let startFlag = true;
			let frameCount = 0;
			let startTime = null;
			let shouldLog = true;
			let first = true;
			let frameSum=0;
            var engine=null;
            // get the canvas DOM element
            var canvas = document.getElementById('renderCanvas');
            canvas.width=window.innerWidth/2;
            canvas.height=window.innerHeight/2;
            // Load the 3D engine
            async function createDefaultEngine(){
                engine = new BABYLON.WebGPUEngine(canvas, {antialias:true,adaptToDeviceRatio:true});
                await engine.initAsync();
            }
           
            // CreateScene function that creates and return the scene
            var createScene = function(){
                
                // Create a basic BJS Scene object
                var scene = new BABYLON.Scene(engine);
              

                // Create a FreeCamera
                var camera = new BABYLON.ArcRotateCamera("Camera", -Math.PI / 5, Math.PI / 3, 200, BABYLON.Vector3.Zero(), scene);
	            camera.attachControl(canvas, true);

                // Create a basic light, aiming 0, 1, 0 - meaning, to the sky
                var light = new BABYLON.HemisphericLight('light1', new BABYLON.Vector3(0, 1, 0), scene);
                

                var box = BABYLON.BoxBuilder.CreateBox("root", {size: 1});

                var numPerSide = 32, size = 90, ofst = size / (numPerSide - 1);

                var m = BABYLON.Matrix.Identity();
                var col = 0, index = 0;

                let instanceCount = numPerSide * numPerSide * numPerSide;

                let matricesData = new Float32Array(16 * instanceCount);
                let colorData = new Float32Array(4 * instanceCount);

                for (var x = 0; x < numPerSide; x++) {
                    m.m[12] = -size / 2 + ofst * x;
                    for (var y = 0; y < numPerSide; y++) {
                        m.m[13] = -size / 2 + ofst * y;
                        for (var z = 0; z < numPerSide; z++) {
                            m.m[14] = -size / 2 + ofst * z;

                            m.copyToArray(matricesData, index * 16);

                            var coli = Math.floor(col);

                            colorData[index * 4 + 0] = ((coli & 0xff0000) >> 16) / 255;
                            colorData[index * 4 + 1] = ((coli & 0x00ff00) >>  8) / 255;
                            colorData[index * 4 + 2] = ((coli & 0x0000ff) >>  0) / 255;
                            colorData[index * 4 + 3] = 1.0;

                            index++;
                            col += 0xffffff / instanceCount;
                        }
                    }
                }

                box.thinInstanceSetBuffer("matrix", matricesData, 16);
                box.thinInstanceSetBuffer("color", colorData, 4);

                box.material = new BABYLON.StandardMaterial("material");
                box.material.disableLighting = true;
                box.material.emissiveColor = BABYLON.Color3.White();
                loaded=true;
                return scene;
            }
            createDefaultEngine().then(()=>{
                // call the createScene function
                var scene = createScene();
                // run the render loop
                // Register and execute a render loop. The engine can have more than one render function
                engine.runRenderLoop(function(){
                    // Render the scene
                    let frameStart = performance.now();

                    scene.render();
                    if (loaded){
					let time = performance.now();
					let frameEnd = performance.now();
					frameSum += frameEnd - frameStart;
					if (startFlag) {
						startTime = time;
						startFlag = false;
						console.log('startTime',startTime,'duration',startTime-initTime);
						// console.log(renderer.info)
						// let programs=renderer.info.programs
						// console.log(programs[0].vertexShader)
					}
					frameCount += 1;
					if(frameCount % 1000 === 0) {
						let fps = 1000 * frameCount / (time - startTime);
						let ft = frameSum/frameCount;
						console.log(frameCount,fps,'fps',ft,'ft');
					} 
					if ((time - startTime) /1000 > 60 && shouldLog){
						shouldLog = false;
						let fps = 1000 * frameCount / (time - startTime);
						let ft = frameSum/frameCount;
						console.log('1min', (time - startTime)/1000, frameCount,fps,'fps',ft,'ft');
					}
            	}
                });
                // the canvas/window resize event handler
                window.addEventListener('resize', function(){
                    engine.resize();
                
                });
            })
           
        }
		</script>
	</body>
</html>