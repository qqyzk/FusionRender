var Qf=Object.defineProperty,Vf=(i,e,t)=>e in i?Qf(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,o=(i,e,t)=>(Vf(i,typeof e!="symbol"?e+"":e,t),t),b;let z=(b=class{constructor(i=1,e=1,t=1,r=1){o(this,"r",0),o(this,"g",0),o(this,"b",0),o(this,"a",0),this.setTo(i,e,t,r)}convertToHDRRGB(){return this.r=this.r*Math.pow(2.4,this.a),this.g=this.g*Math.pow(2.4,this.a),this.b=this.b*Math.pow(2.4,this.a),this}unSerialized(i){return this.r=i.r,this.g=i.g,this.b=i.b,this.a=i.a,this}hexToRGB(i){return this.r=(i>>16&255)/255,this.g=(i>>8&255)/255,this.b=(i&255)/255,this}hexToRGBA(i){return this.a=(i>>24&255)/255,this.r=(i>>16&255)/255,this.g=(i>>8&255)/255,this.b=(i&255)/255,this}static random(i=1){let e=new b;return e.a=i,e.r=i*Math.random(),e.g=i*Math.random(),e.b=i*Math.random(),e}setTo(i,e,t,r){this.r=Math.max(i,0),this.g=Math.max(e,0),this.b=Math.max(t,0),this.a=Math.max(r,0)}setHex(i){if(typeof i!="string"||b.NON_HEX_CHARS.test(i)||!b.VALID_HEX_SIZE.test(i))throw new TypeError("Expected a valid hex string");i=i.replace(/^#/,"");let e=1;i.length===8&&(e=Number.parseInt(i.slice(6,8),16)/255,i=i.slice(0,6)),i.length===4&&(e=Number.parseInt(i.slice(3,4).repeat(2),16)/255,i=i.slice(0,3)),i.length===3&&(i=i[0]+i[0]+i[1]+i[1]+i[2]+i[2]);const t=Number.parseInt(i,16),r=t>>16,s=t>>8&255,a=t&255,n=e;this.a=n,this.r=r/255,this.g=s/255,this.b=a/255}getHex(){let i=t=>{t*=255;let r=t.toString(16);return r.length===1&&(r="0"+r),r};return i(this.r)+i(this.g)+i(this.b)+i(this.a)}get rgb(){return[this.r*255>>>0,this.g*255>>>0,this.b*255>>>0]}set rgb(i){this.setTo(i[0]/255,i[1]/255,i[2]/255,this.a)}get rgba(){return[this.r*255>>>0,this.g*255>>>0,this.b*255>>>0,this.a*255>>>0]}set rgba(i){this.setTo(i[0]/255,i[1]/255,i[2]/255,i[3]/255)}clone(){return new b().copyFrom(this)}copyFrom(i){return this.r=i.r,this.g=i.g,this.b=i.b,this.a=i.a,this}copyFromArray(i,e=255){return this.r=i[0]/e,this.g=i[1]/e,this.b=i[2]/e,this.a=i[3]/e,this}copyFromVector(i){return this.r=i.x,this.g=i.y,this.b=i.z,this.a=i.w,this}static hexRGBColor(i,e=null){return e=e||new b,e.hexToRGB(i),e}},o(b,"COLOR_RED",new b(1,0,0,1)),o(b,"COLOR_GREEN",new b(0,1,0,1)),o(b,"COLOR_BLUE",new b(0,0,1,1)),o(b,"COLOR_WHITE",new b(1,1,1,1)),o(b,"COLOR_0",new b),o(b,"COLOR_1",new b),o(b,"COLOR_2",new b),o(b,"HEX_CHARACTERS","a-f\\d"),o(b,"MATCH_3OR4_HEX",`#?[${b.HEX_CHARACTERS}]{3}[${b.HEX_CHARACTERS}]?`),o(b,"MATCH_6OR8_HEX",`#?[${b.HEX_CHARACTERS}]{6}([${b.HEX_CHARACTERS}]{2})?`),o(b,"NON_HEX_CHARS",new RegExp(`[^#${b.HEX_CHARACTERS}]`,"gi")),o(b,"VALID_HEX_SIZE",new RegExp(`^${b.MATCH_3OR4_HEX}$|^${b.MATCH_6OR8_HEX}$`,"i")),o(b,"PRIMARY",4149685),o(b,"PRIMARYDARK",3162015),o(b,"ACCENT",16728193),o(b,"WHITE",16777215),o(b,"IVORY",16777200),o(b,"LIGHTYELLOW",16777184),o(b,"YELLOW",16776960),o(b,"SNOW",16775930),o(b,"FLORALWHITE",16775920),o(b,"LEMONCHIFFON",16775885),o(b,"CORNSILK",16775388),o(b,"SEASHELL",16774638),o(b,"LAVENDERBLUSH",16773365),o(b,"PAPAYAWHIP",16773077),o(b,"BLANCHEDALMOND",16772045),o(b,"MISTYROSE",16770273),o(b,"BISQUE",16770244),o(b,"MOCCASIN",16770229),o(b,"NAVAJOWHITE",16768685),o(b,"PEACHPUFF",16767673),o(b,"GOLD",16766720),o(b,"PINK",16761035),o(b,"LIGHTPINK",16758465),o(b,"ORANGE",16753920),o(b,"LIGHTSALMON",16752762),o(b,"DARKORANGE",16747520),o(b,"CORAL",16744272),o(b,"HOTPINK",16738740),o(b,"TOMATO",16737095),o(b,"ORANGERED",16729344),o(b,"DEEPPINK",16716947),o(b,"FUCHSIA",16711935),o(b,"MAGENTA",16711935),o(b,"RED",16711680),o(b,"OLDLACE",16643558),o(b,"LIGHTGOLDENRODYELLOW",16448210),o(b,"LINEN",16445670),o(b,"ANTIQUEWHITE",16444375),o(b,"SALMON",16416882),o(b,"GHOSTWHITE",16316671),o(b,"MINTCREAM",16121850),o(b,"WHITESMOKE",16119285),o(b,"BEIGE",16119260),o(b,"WHEAT",16113331),o(b,"SANDYBROWN",16032864),o(b,"AZURE",15794175),o(b,"HONEYDEW",15794160),o(b,"ALICEBLUE",15792383),o(b,"KHAKI",15787660),o(b,"LIGHTCORAL",15761536),o(b,"PALEGOLDENROD",15657130),o(b,"VIOLET",15631086),o(b,"DARKSALMON",15308410),o(b,"LAVENDER",15132410),o(b,"LIGHTCYAN",14745599),o(b,"BURLYWOOD",14596231),o(b,"PLUM",14524637),o(b,"GAINSBORO",14474460),o(b,"CRIMSON",14423100),o(b,"PALEVIOLETRED",14381203),o(b,"GOLDENROD",14329120),o(b,"ORCHID",14315734),o(b,"THISTLE",14204888),o(b,"LIGHTGREY",13882323),o(b,"TAN",13808780),o(b,"CHOCOLATE",13789470),o(b,"PERU",13468991),o(b,"INDIANRED",13458524),o(b,"MEDIUMVIOLETRED",13047173),o(b,"SILVER",12632256),o(b,"DARKKHAKI",12433259),o(b,"ROSYBROWN",12357519),o(b,"MEDIUMORCHID",12211667),o(b,"DARKGOLDENROD",12092939),o(b,"FIREBRICK",11674146),o(b,"POWDERBLUE",11591910),o(b,"LIGHTSTEELBLUE",11584734),o(b,"PALETURQUOISE",11529966),o(b,"GREENYELLOW",11403055),o(b,"LIGHTBLUE",11393254),o(b,"DARKGRAY",11119017),o(b,"BROWN",10824234),o(b,"SIENNA",10506797),o(b,"DARKORCHID",10040012),o(b,"PALEGREEN",10025880),o(b,"DARKVIOLET",9699539),o(b,"MEDIUMPURPLE",9662683),o(b,"LIGHTGREEN",9498256),o(b,"DARKSEAGREEN",9419919),o(b,"SADDLEBROWN",9127187),o(b,"DARKMAGENTA",9109643),o(b,"DARKRED",9109504),o(b,"BLUEVIOLET",9055202),o(b,"LIGHTSKYBLUE",8900346),o(b,"SKYBLUE",8900331),o(b,"GRAY",8421504),o(b,"OLIVE",8421376),o(b,"PURPLE",8388736),o(b,"MAROON",8388608),o(b,"AQUAMARINE",8388564),o(b,"CHARTREUSE",8388352),o(b,"LAWNGREEN",8190976),o(b,"MEDIUMSLATEBLUE",8087790),o(b,"LIGHTSLATEGRAY",7833753),o(b,"SLATEGRAY",7372944),o(b,"OLIVEDRAB",7048739),o(b,"SLATEBLUE",6970061),o(b,"DIMGRAY",6908265),o(b,"MEDIUMAQUAMARINE",6737322),o(b,"CORNFLOWERBLUE",6591981),o(b,"CADETBLUE",6266528),o(b,"DARKOLIVEGREEN",5597999),o(b,"INDIGO",4915330),o(b,"MEDIUMTURQUOISE",4772300),o(b,"DARKSLATEBLUE",4734347),o(b,"STEELBLUE",4620980),o(b,"ROYALBLUE",4286945),o(b,"TURQUOISE",4251856),o(b,"MEDIUMSEAGREEN",3978097),o(b,"LIMEGREEN",3329330),o(b,"DARKSLATEGRAY",3100495),o(b,"SEAGREEN",3050327),o(b,"FORESTGREEN",2263842),o(b,"LIGHTSEAGREEN",2142890),o(b,"DODGERBLUE",2003199),o(b,"MIDNIGHTBLUE",1644912),o(b,"AQUA",65535),o(b,"CYAN",65535),o(b,"SPRINGGREEN",65407),o(b,"LIME",65280),o(b,"MEDIUMSPRINGGREEN",64154),o(b,"DARKTURQUOISE",52945),o(b,"DEEPSKYBLUE",49151),o(b,"DARKCYAN",35723),o(b,"TEAL",32896),o(b,"GREEN",32768),o(b,"DARKGREEN",25600),o(b,"BLUE",255),o(b,"MEDIUMBLUE",205),o(b,"DARKBLUE",139),o(b,"NAVY",128),o(b,"BLACK",0),b);class he{static start(e){this._startTime=performance.now(),this._timeLabel=e}static end(){console.log(this._timeLabel,performance.now()-this._startTime)}}o(he,"time",0),o(he,"frame",0),o(he,"delta",0),o(he,"_startTime",0),o(he,"_timeLabel","");class je{constructor(e=null,t=null){o(this,"target"),o(this,"currentTarget"),o(this,"type"),o(this,"data"),o(this,"param"),o(this,"time",0),o(this,"delay",0),o(this,"mouseCode",0),o(this,"ctrlKey"),o(this,"altKey"),o(this,"shiftKey"),o(this,"targetTouches"),o(this,"changedTouches"),o(this,"touches"),o(this,"_stopImmediatePropagation",!1),o(this,"view"),this.type=e,this.data=t}stopImmediatePropagation(){this._stopImmediatePropagation=!0}reset(){this._stopImmediatePropagation=!1}get isStopImmediatePropagation(){return this._stopImmediatePropagation}}class Lr{constructor(e=null,t=null,r=null,s=null,a=0){o(this,"id",0),o(this,"current"),this.type=e,this.thisObject=t,this.handler=r,this.param=s,this.priority=a}equalCurrentListener(e,t,r,s){return this.type==e&&this.thisObject==r&&this.handler==t&&this.param==s}dispose(){this.handler=null,this.thisObject=null,this.param=null,this.priority=0}}o(Lr,"event_id_count",0);class hi{constructor(){o(this,"listeners",{}),o(this,"data")}dispatchEvent(e){var t=this.listeners[e.type];if(t!=null){t=t.slice();for(var r=0;r<t.length;r++){var s=t[r];if(s.handler){try{e.param=s.param,e.currentTarget=s,s.thisObject,s.handler.call(s.thisObject,e)}catch{}if(e.isStopImmediatePropagation)break}}}}destroy(){for(var e in this.listeners)for(var t=this.listeners[e];t.length>0;){var r=t[0];r.handler=null,r.thisObject=null,t.splice(0,1)}}addEventListener(e,t,r,s=null,a=0){if(this.listeners[e]==null&&(this.listeners[e]=[]),!this.hasEventListener(e,t,r)){var n=new Lr(e,r,t,s,a);return n.id=++Lr.event_id_count,n.current=this,this.listeners[e].push(n),this.listeners[e].sort(function(l,h){return h.priority-l.priority}),n.id}for(let l=0;l<this.listeners[e].length;l++){let h=this.listeners[e][l];if(h.equalCurrentListener(e,t,r,s))return h.id}return 0}removeEventListener(e,t,r){if(this.hasEventListener(e,t,r))for(var s=0;s<this.listeners[e].length;s++){var a=this.listeners[e][s];if(a.equalCurrentListener(e,t,r,a.param)){a.handler=null,a.thisObject=null,this.listeners[e].splice(s,1);return}}}removeEventListenerAt(e){for(var t in this.listeners)for(var r=0;r<this.listeners[t].length;r++){var s=this.listeners[t][r];if(s.id==e)return s.handler=null,s.thisObject=null,this.listeners[t].splice(r,1),!0}return!1}removeAllEventListener(e=null){let t;if(e){if(this.listeners[e]){for(var r=0;r<this.listeners[e].length;r++)t=this.listeners[e][r],t.dispose(),this.listeners[e].splice(r,1);delete this.listeners[e]}}else for(let s in this.listeners){for(var r=0;r<this.listeners[s].length;r++)t=this.listeners[s][r],t.dispose(),this.listeners[s].splice(r,1);delete this.listeners[s]}}containEventListener(e){return this.listeners[e]==null?!1:this.listeners[e].length>0}hasEventListener(e,t=null,r=null){if(this.listeners[e]==null)return!1;if(r&&t)for(var s=0;s<this.listeners[e].length;s++){var a=this.listeners[e][s];if(a.equalCurrentListener(e,t,r,a.param))return!0}return!1}}class Qt extends je{constructor(){super(...arguments),o(this,"keyCode",0)}}o(Qt,"KEY_DOWN","onKeyDown"),o(Qt,"KEY_UP","onKeyUp");class R extends je{constructor(){super(...arguments),o(this,"pointerId"),o(this,"pointerType"),o(this,"isPrimary"),o(this,"pressure"),o(this,"mouseX"),o(this,"mouseY"),o(this,"movementX"),o(this,"movementY"),o(this,"deltaX"),o(this,"deltaY"),o(this,"deltaZ")}reset(){super.reset(),this.mouseX=0,this.mouseY=0,this.movementX=0,this.movementY=0,this.deltaX=0,this.deltaY=0,this.deltaZ=0}}o(R,"PICK_OVER","onPickOver"),o(R,"PICK_OVER_GUI","onPickOverGUI"),o(R,"PICK_CLICK","onPickClick"),o(R,"PICK_CLICK_GUI","onPickClickGUI"),o(R,"PICK_OUT","onPickOut"),o(R,"PICK_OUT_GUI","onPickOutGUI"),o(R,"PICK_MOVE","onPickMove"),o(R,"PICK_UP","onPickUp"),o(R,"PICK_UP_GUI","onPickUpGUI"),o(R,"PICK_DOWN","onPickDown"),o(R,"PICK_DOWN_GUI","onPickDownGUI"),o(R,"POINTER_RIGHT_CLICK","onPointerRightClick"),o(R,"POINTER_MID_UP","onPointerMidUp"),o(R,"POINTER_MID_DOWN","onPointerMidDown"),o(R,"POINTER_CLICK","onPointerClick"),o(R,"POINTER_MOVE","onPointerMove"),o(R,"POINTER_DOWN","onPointerDown"),o(R,"POINTER_UP","onPointerUp"),o(R,"POINTER_OUT","onPointerOut"),o(R,"POINTER_OVER","onPointerOver"),o(R,"POINTER_WHEEL","onPointerWheel");const X=class{constructor(i=0,e=0,t=0,r=0){o(this,"x",0),o(this,"y",0),o(this,"z",0),o(this,"w",1),o(this,"index",0),this.set(i,e,t,r),this.index=X._index++}static get ZERO(){return new X(0,0,0)}static get ONE(){return new X(1,1,1)}static get LEFT(){return new X(-1,0,0)}static get RIGHT(){return new X(1,0,0)}static get UP(){return new X(0,1,0)}static get DOWN(){return new X(0,-1,0)}static get BACK(){return new X(0,0,-1)}static get FORWARD(){return new X(0,0,1)}set a(i){this.w=i}set r(i){this.x=i}set g(i){this.y=i}set b(i){this.z=i}get a(){return this.w}get r(){return this.x}get g(){return this.y}get b(){return this.z}get length(){return Math.sqrt(this.lengthSquared)}get lengthSquared(){return this.x*this.x+this.y*this.y+this.z*this.z}get position(){return this}static getTowPointbyDir(i,e,t,r,s){s==X.Z_AXIS?(e.x=i.y,e.y=-i.x,t.x=-i.y,t.y=i.x,e.scaleBy(r*.5),t.scaleBy(r*.5)):s==X.Y_AXIS&&(e.x=i.z,e.z=-i.x,t.x=-i.z,t.z=i.x,e.scaleBy(r*.5),t.scaleBy(r*.5))}static pointToLine(i,e,t){let r=0,s,a,n;if(s=X.distance(i,e),a=X.distance(i,t),n=X.distance(e,t),n<=1e-6||a<=1e-6)return r=0,r;if(s<=1e-6||n*n>=s*s+a*a)return r=a,r;if(a*a>=s*s+n*n)return r=n,r;let l=(s+a+n)/2;return r=2*Math.sqrt(l*(l-s)*(l-a)*(l-n))/s,r}static dot(i,e){return i.x*e.x+i.y*e.y+i.z*e.z}static getPoints(i,e){let t=[];for(let r=0;r<i;r++){const s=new X(Math.random()*e-e*.5,Math.random()*e-e*.5,Math.random()*e-e*.5);t.push(s)}return t}static getPointNumbers(i,e){let t=[];for(let r=0;r<i;r++)t.push(Math.random()*e-e*.5,Math.random()*e-e*.5,Math.random()*e-e*.5);return t}static getAngle(i,e){let t=i.dotProduct(e)/(i.length*e.length);return Math.acos(t)*180/Math.PI}static sqrMagnitude(i){return i.x*i.x+i.y*i.y+i.z*i.z}static getZYAngle(i,e){return this.calAngle(i.y,i.z,e.y,e.z)}static sub(i,e,t=null){return t=t||new X,t.x=i.x-e.x,t.y=i.y-e.y,t.z=i.z-e.z,t}static add(i,e,t=null){return t=t||new X,t.x=i.x+e.x,t.y=i.y+e.y,t.z=i.z+e.z,t}static smoothDamp(i,e,t,r,s,a){return null}static distance(i,e){var t=i.x-e.x,r=i.y-e.y,s=i.z-e.z;return Math.sqrt(t*t+r*r+s*s)}static squareDistance(i,e){var t=i.x-e.x,r=i.y-e.y,s=i.z-e.z;return t*t+r*r+s*s}static distanceXZ(i,e){var t=i.x-e.x,r=0,s=i.z-e.z;return Math.sqrt(t*t+r*r+s*s)}set(i,e,t,r=1){return this.x=i,this.y=e,this.z=t,this.w=r,this}add(i,e=null){e||(e=new X);var t=this.x,r=this.y,s=this.z,a=this.w,n=i.x,l=i.y,h=i.z,u=i.w;return e.setTo(t+n,r+l,s+h,a+u),e}subVectors(i,e){return this.x=i.x-e.x,this.y=i.y-e.y,this.z=i.z-e.z,this}distanceToSquared(i){let e=this.x-i.x,t=this.y-i.y,r=this.z-i.z;return e*e+t*t+r*r}addXYZW(i,e,t,r,s=null){s||(s=new X);var a=this.x,n=this.y,l=this.z,h=this.w,u=i,c=e,f=t,d=r;return s.setTo(a+u,n+c,l+f,h+d),s}clone(){return new X(this.x,this.y,this.z,this.w)}copyFrom(i){var e=this;return e.x=i.x,e.y=i.y,e.z=i.z,e.w=i.w,e}decrementBy(i){this.x-=i.x,this.y-=i.y,this.z-=i.z}dotProduct(i){return this.x*i.x+this.y*i.y+this.z*i.z}equals(i,e=!1){return this.x==i.x&&this.y==i.y&&this.z==i.z&&(!e||this.w==i.w)}incrementBy(i){this.x+=i.x,this.y+=i.y,this.z+=i.z}divide(i){return i instanceof X?new X(this.x/i.x,this.y/i.y,this.z/i.z):(this.x=this.x/i,this.y=this.y/i,this.z=this.z/i,this)}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}normalize(i=1){let e=this;if(this.length!=0){var t=i/this.length;return this.x*=t,this.y*=t,this.z*=t,e}return e}applyQuaternion(i){const e=this.x,t=this.y,r=this.z,s=i.x,a=i.y,n=i.z,l=i.w,h=l*e+a*r-n*t,u=l*t+n*e-s*r,c=l*r+s*t-a*e,f=-s*e-a*t-n*r;return this.x=h*l+f*-s+u*-n-c*-a,this.y=u*l+f*-a+c*-s-h*-n,this.z=c*l+f*-n+h*-a-u*-s,this}scaleBy(i){return this.x*=i,this.y*=i,this.z*=i,this}mul(i){let e=new X;return e.x=this.x*i,e.y=this.y*i,e.z=this.z*i,e}scale(i){return this.x*=i.x,this.y*=i.y,this.z*=i.z,this}scaleToRef(i,e){return e||(e=new X),e.x=this.x*i,e.y=this.y*i,e.z=this.z*i,e}setTo(i,e,t,r=1){this.x=i,this.y=e,this.z=t,this.w=r}copy(i){return this.x=i.x,this.y=i.y,this.z=i.z,this.w=i.w,this}subtract(i,e=null){return e||(e=new X),e.setTo(this.x-i.x,this.y-i.y,this.z-i.z),e}multiply(i,e=null){e||(e=new X);var t=this.x,r=this.y,s=this.z,a=i.x,n=i.y,l=i.z;return e.setTo(t*a,r*n,s*l),e}divided(i,e=null){e||(e=new X);var t=this.x,r=this.y,s=this.z,a=i.x,n=i.y,l=i.z;return e.setTo(t/a,r/n,s/l),e}div(i,e){e||(e=new X);var t=this.x,r=this.y,s=this.z,a=this.w;return e.setTo(t/i,r/i,s/i,a/i),e}lerp(i,e,t){var r=i.x,s=i.y,a=i.z,n=i.w,l=e.x,h=e.y,u=e.z,c=e.w;this.x=(l-r)*t+r,this.y=(h-s)*t+s,this.z=(u-a)*t+a,this.w=(c-n)*t+n}clamp(i,e){return this.x=Math.max(i.x,Math.min(e.x,this.x)),this.y=Math.max(i.y,Math.min(e.y,this.y)),this.z=Math.max(i.z,Math.min(e.z,this.z)),this}toString(){return"<"+this.x+", "+this.y+", "+this.z+">"}normalizeToWay2D_XY(){let i=Math.abs(this.x),e=Math.abs(this.y);i>e?this.x>0?this.copyFrom(X.RIGHT):this.copyFrom(X.LEFT):this.y>0?this.copyFrom(X.DOWN):this.copyFrom(X.UP)}toArray(){return[this.x,this.y,this.z]}copyToBytes(i){i.setFloat32(0*Float32Array.BYTES_PER_ELEMENT,this.x,!0),i.setFloat32(1*Float32Array.BYTES_PER_ELEMENT,this.y,!0),i.setFloat32(2*Float32Array.BYTES_PER_ELEMENT,this.z,!0)}crossProduct(i,e=null){return e=e||new X,e.x=this.y*i.z-this.z*i.y,e.y=this.z*i.x-this.x*i.z,e.z=this.x*i.y-this.y*i.x,e.w=1,e}crossVectors(i,e){return i.crossProduct(e,this),this}multiplyScalar(i){return this.x*=i,this.y*=i,this.z*=i,this}setFromArray(i,e=0){this.x=i[e],this.y=i[e+1],this.z=i[e+2]}divideScalar(i){return this.multiplyScalar(1/i)}clampLength(i,e){let t=this.length;return this.divideScalar(t||1).multiplyScalar(Math.max(i,Math.min(e,t)))}setScalar(i){return this.x=i,this.y=i,this.z=i,this}static calAngle(i,e,t,r){const s=n(t,r,i,e);let a=Math.acos(s)*180/Math.PI;return t<i&&(a=-a),a;function n(h,u,c,f){let d=[h-c,u-f];return l(d,[0,-1])}function l(h,u){let c=h[0]*u[0]+h[1]*u[1],f=Math.sqrt(h[0]*h[0]+h[1]*h[1])*Math.sqrt(u[0]*u[0]+u[1]*u[1]);return c/f}}};let g=X;o(g,"MAX",new X(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE)),o(g,"MIN",new X(Number.MIN_VALUE,Number.MIN_VALUE,Number.MIN_VALUE)),o(g,"SAFE_MAX",new X(Number.MAX_SAFE_INTEGER,Number.MAX_SAFE_INTEGER,Number.MAX_SAFE_INTEGER,Number.MAX_SAFE_INTEGER)),o(g,"SAFE_MIN",new X(Number.MIN_SAFE_INTEGER,Number.MIN_SAFE_INTEGER,Number.MIN_SAFE_INTEGER,Number.MIN_SAFE_INTEGER)),o(g,"X_AXIS",new X(1,0,0)),o(g,"neg_X_AXIS",new X(-1,0,0)),o(g,"Y_AXIS",new X(0,1,0)),o(g,"Z_AXIS",new X(0,0,1)),o(g,"HELP_0",new X),o(g,"HELP_1",new X),o(g,"HELP_2",new X),o(g,"EPSILON",1e-5),o(g,"HELP_3",new X),o(g,"HELP_4",new X),o(g,"HELP_5",new X),o(g,"HELP_6",new X),o(g,"_index",0);class Sn{constructor(e){o(this,"canvasX"),o(this,"canvasY"),o(this,"identifier"),o(this,"clientX"),o(this,"clientY"),o(this,"pageX"),o(this,"pageY"),o(this,"screenX"),o(this,"screenY"),this.canvasX=e.clientX,this.canvasY=e.clientY,this.identifier=e.identifier,this.clientX=e.clientX,this.clientY=e.clientY,this.pageX=e.pageX,this.pageY=e.pageY,this.screenX=e.screenX,this.screenY=e.screenY}}class In extends hi{constructor(){super(...arguments),o(this,"canvasX",0),o(this,"canvasY",0),o(this,"isMouseDown",!1),o(this,"isRightMouseDown",!1),o(this,"canvas"),o(this,"mouseX",0),o(this,"mouseY",0),o(this,"wheelDelta",0),o(this,"mouseOffsetX",0),o(this,"mouseOffsetY",0),o(this,"mouseLastX",0),o(this,"mouseLastY",0),o(this,"_time",0),o(this,"_keyStatus"),o(this,"_mouseStatus"),o(this,"_isTouchStart"),o(this,"_keyEvent3d"),o(this,"_pointerEvent3D"),o(this,"_windowsEvent3d"),o(this,"_gp",!1),o(this,"_oldPosition1",null),o(this,"_oldPosition2",null),o(this,"_downTime",0)}initCanvas(e){this.canvas=e,e.onpointerdown=r=>{r.button==0?this.mouseStart(r):r.button==1?this.middleDown(r):r.button==2&&this.mouseStart(r)},e.onpointerup=r=>{r.button==0?this.mouseEnd(r):r.button==1?this.middleUp(r):r.button==2&&this.mouseEnd(r)},e.onpointerenter=r=>{this.mouseOver(r)},e.onpointermove=r=>{this.mouseMove(r)},e.onpointercancel=r=>{this.mouseEnd(r)},e.onpointerleave=r=>{this.mouseEnd(r)},e.onpointerout=r=>{this.mouseEnd(r)},e.addEventListener("click",r=>{r.button==2?(this.isRightMouseDown=!1,this.rightClick(r)):r.button==0&&(this.isMouseDown=!1,this.mouseClick(r))},!0),e.addEventListener("wheel",r=>this.mouseWheel(r),{passive:!1}),window.addEventListener("keydown",r=>this.keyDown(r),!0),window.addEventListener("keyup",r=>this.keyUp(r),!0),e.oncontextmenu=function(){return!1};let t=this.canvas.getBoundingClientRect();this.canvasX=t.left,this.canvasY=t.top,this._keyStatus={},this._mouseStatus={},this._isTouchStart=!1,this._keyEvent3d=new Qt,this._pointerEvent3D=new R,this._windowsEvent3d=new je}onPinch(e,t,r,s){this._oldPosition1=new g(e,t),this._oldPosition2=new g(r,s)}onSwipe(e,t){this.mouseX=e,this.mouseY=t,this._oldPosition1=null,this._oldPosition2=null,this._time=new Date().getTime()}GetTargetTouches(e){for(var t=new Array,r=0;r<e.length;r++){var s=new Sn(e[r]);t.push(s)}return t}rightClick(e){this._pointerEvent3D.reset(),this._pointerEvent3D.mouseCode=e.button,this._pointerEvent3D.mouseX=e.clientX-this.canvasX,this._pointerEvent3D.mouseY=e.clientY-this.canvasY,this._pointerEvent3D.type=R.POINTER_RIGHT_CLICK,this._pointerEvent3D.ctrlKey=e.ctrlKey,this._pointerEvent3D.altKey=e.altKey,this._pointerEvent3D.shiftKey=e.shiftKey,this.dispatchEvent(this._pointerEvent3D)}middleDown(e){this._pointerEvent3D.reset(),this._pointerEvent3D.mouseCode=e.button,this._pointerEvent3D.mouseX=e.clientX-this.canvasX,this._pointerEvent3D.mouseY=e.clientY-this.canvasY,this._pointerEvent3D.type=R.POINTER_MID_DOWN,this._pointerEvent3D.ctrlKey=e.ctrlKey,this._pointerEvent3D.altKey=e.altKey,this._pointerEvent3D.shiftKey=e.shiftKey,this._pointerEvent3D.pointerId=e.pointerId,this._pointerEvent3D.pointerType=e.pointerType,this._pointerEvent3D.isPrimary=e.isPrimary,this._pointerEvent3D.pressure=e.pressure,this.dispatchEvent(this._pointerEvent3D)}middleUp(e){this._pointerEvent3D.reset(),this._pointerEvent3D.mouseCode=e.button,this._pointerEvent3D.mouseX=e.clientX-this.canvasX,this._pointerEvent3D.mouseY=e.clientY-this.canvasY,this._pointerEvent3D.type=R.POINTER_MID_UP,this._pointerEvent3D.ctrlKey=e.ctrlKey,this._pointerEvent3D.altKey=e.altKey,this._pointerEvent3D.shiftKey=e.shiftKey,this._pointerEvent3D.pointerId=e.pointerId,this._pointerEvent3D.pointerType=e.pointerType,this._pointerEvent3D.isPrimary=e.isPrimary,this._pointerEvent3D.pressure=e.pressure,this.dispatchEvent(this._pointerEvent3D)}mouseClick(e){this._pointerEvent3D.reset(),this._pointerEvent3D.mouseCode=e.button,this._pointerEvent3D.mouseX=e.clientX-this.canvasX,this._pointerEvent3D.mouseY=e.clientY-this.canvasY,this._pointerEvent3D.type=R.POINTER_CLICK,this._pointerEvent3D.ctrlKey=e.ctrlKey,this._pointerEvent3D.altKey=e.altKey,this._pointerEvent3D.shiftKey=e.shiftKey,this.dispatchEvent(this._pointerEvent3D)}mouseEnd(e){this.isMouseDown=!1,this.mouseLastX=this.mouseX,this.mouseLastY=this.mouseY,this.mouseX=e.clientX-this.canvasX,this.mouseY=e.clientY-this.canvasY,this.mouseOffsetX=this.mouseX-this.mouseLastX,this.mouseOffsetY=this.mouseY-this.mouseLastY,this._pointerEvent3D.reset(),this._pointerEvent3D.mouseCode=e.button,this._mouseStatus[this._pointerEvent3D.mouseCode]=!1,this._pointerEvent3D.type=R.POINTER_UP,this._pointerEvent3D.ctrlKey=e.ctrlKey,this._pointerEvent3D.altKey=e.altKey,this._pointerEvent3D.shiftKey=e.shiftKey,this._pointerEvent3D.pointerId=e.pointerId,this._pointerEvent3D.pointerType=e.pointerType,this._pointerEvent3D.isPrimary=e.isPrimary,this._pointerEvent3D.pressure=e.pressure,this._pointerEvent3D.mouseX=this.mouseX,this._pointerEvent3D.mouseY=this.mouseY,this.dispatchEvent(this._pointerEvent3D)}mouseStart(e){this.isMouseDown=!0,this.mouseLastX=this.mouseX,this.mouseLastY=this.mouseY,this.mouseX=e.clientX-this.canvasX,this.mouseY=e.clientY-this.canvasY,this.mouseOffsetX=this.mouseX-this.mouseLastX,this.mouseOffsetY=this.mouseY-this.mouseLastY,this._pointerEvent3D.reset(),this._pointerEvent3D.mouseCode=e.button,this._pointerEvent3D.ctrlKey=e.ctrlKey,this._pointerEvent3D.altKey=e.altKey,this._pointerEvent3D.shiftKey=e.shiftKey,this._pointerEvent3D.pointerId=e.pointerId,this._pointerEvent3D.pointerType=e.pointerType,this._pointerEvent3D.isPrimary=e.isPrimary,this._pointerEvent3D.pressure=e.pressure,this._pointerEvent3D.mouseX=this.mouseX,this._pointerEvent3D.mouseY=this.mouseY,this._pointerEvent3D.type=R.POINTER_DOWN,this.dispatchEvent(this._pointerEvent3D)}mouseMove(e){this.mouseLastX=this.mouseX,this.mouseLastY=this.mouseY,this.mouseX=e.clientX-this.canvasX,this.mouseY=e.clientY-this.canvasY,this.mouseOffsetX=this.mouseX-this.mouseLastX,this.mouseOffsetY=this.mouseY-this.mouseLastY,this._pointerEvent3D.reset(),this._pointerEvent3D.type=R.POINTER_MOVE,this._pointerEvent3D.ctrlKey=e.ctrlKey,this._pointerEvent3D.altKey=e.altKey,this._pointerEvent3D.shiftKey=e.shiftKey,this._pointerEvent3D.pointerId=e.pointerId,this._pointerEvent3D.pointerType=e.pointerType,this._pointerEvent3D.isPrimary=e.isPrimary,this._pointerEvent3D.pressure=e.pressure,this._pointerEvent3D.mouseX=this.mouseX,this._pointerEvent3D.mouseY=this.mouseY,this._pointerEvent3D.movementX=e.movementX,this._pointerEvent3D.movementY=e.movementY,this.dispatchEvent(this._pointerEvent3D)}mouseOver(e){this.isMouseDown=!1,this.mouseLastX=this.mouseX,this.mouseLastY=this.mouseY,this.mouseX=e.clientX-this.canvasX,this.mouseY=e.clientY-this.canvasY,this.mouseOffsetX=this.mouseX-this.mouseLastX,this.mouseOffsetY=this.mouseY-this.mouseLastY,this._pointerEvent3D.reset(),this._pointerEvent3D.type=R.POINTER_OVER,this._pointerEvent3D.ctrlKey=e.ctrlKey,this._pointerEvent3D.altKey=e.altKey,this._pointerEvent3D.shiftKey=e.shiftKey,this._pointerEvent3D.pointerId=e.pointerId,this._pointerEvent3D.pointerType=e.pointerType,this._pointerEvent3D.isPrimary=e.isPrimary,this._pointerEvent3D.pressure=e.pressure,this._pointerEvent3D.mouseX=this.mouseX,this._pointerEvent3D.mouseY=this.mouseY,this.dispatchEvent(this._pointerEvent3D)}mouseWheel(e){e.preventDefault(),this.mouseLastX=this.mouseX,this.mouseLastY=this.mouseY,this.mouseX=e.clientX-this.canvasX,this.mouseY=e.clientY-this.canvasY,this.mouseOffsetX=this.mouseX-this.mouseLastX,this.mouseOffsetY=this.mouseY-this.mouseLastY,"wheelDelta"in e?(this._pointerEvent3D.delay=e.wheelDelta,this.wheelDelta=e.wheelDelta):"delta"in e&&(this.wheelDelta=e.delta),this._pointerEvent3D.reset(),this._pointerEvent3D.type=R.POINTER_WHEEL,this._pointerEvent3D.ctrlKey=e.ctrlKey,this._pointerEvent3D.altKey=e.altKey,this._pointerEvent3D.shiftKey=e.shiftKey,this._pointerEvent3D.mouseX=this.mouseX,this._pointerEvent3D.mouseY=this.mouseY,this._pointerEvent3D.deltaX=e.deltaX,this._pointerEvent3D.deltaY=e.deltaY,this._pointerEvent3D.deltaZ=e.deltaZ,this.dispatchEvent(this._pointerEvent3D)}keyDown(e){this._keyEvent3d.reset(),this._keyEvent3d.keyCode=e.keyCode,this._keyEvent3d.ctrlKey=e.ctrlKey,this._keyEvent3d.altKey=e.altKey,this._keyEvent3d.shiftKey=e.shiftKey,this._keyStatus[e.keyCode]||(this._keyStatus[e.keyCode]=!0,this._keyEvent3d.type=Qt.KEY_DOWN,this.dispatchEvent(this._keyEvent3d))}keyUp(e){this._keyEvent3d.reset(),this._keyEvent3d.keyCode=e.keyCode,this._keyStatus[e.keyCode]=!1,this._keyEvent3d.type=Qt.KEY_UP,this.dispatchEvent(this._keyEvent3d)}GetSlideAngle(e,t){return Math.atan2(t,e)*180/Math.PI}GetSlideDirection(e,t,r,s){var a=t-s,n=r-e,l=0;if(Math.abs(n)<2&&Math.abs(a)<2)return l;var h=this.GetSlideAngle(n,a);return h>=-45&&h<45?l=4:h>=45&&h<135?l=1:h>=-135&&h<-45?l=2:(h>=135&&h<=180||h>=-180&&h<-135)&&(l=3),l}}const Hf="0.6.9";class Yf{constructor(){o(this,"adapter"),o(this,"device"),o(this,"context"),o(this,"aspect"),o(this,"presentationSize",[0,0]),o(this,"presentationFormat"),o(this,"canvas"),o(this,"windowWidth"),o(this,"windowHeight"),o(this,"canvasConfig"),o(this,"super",1),o(this,"_pixelRatio",1)}get pixelRatio(){return this._pixelRatio}async init(e){var t;if(this.canvasConfig=e,e&&e.canvas){if(this.canvas=e.canvas,this.canvas===null)throw new Error("no Canvas");const a=this.canvas.clientWidth,n=this.canvas.clientHeight;this.resize(this.canvas.clientWidth,this.canvas.clientHeight),a!=this.canvas.clientWidth&&(this.canvas.style.width=a+"px"),n!=this.canvas.clientHeight&&(this.canvas.style.height=n+"px")}else this.canvas=document.createElement("canvas"),this.canvas.style.position="absolute",this.canvas.style.top="0px",this.canvas.style.left="0px",this.canvas.style.width="100%",this.canvas.style.height="100%",this.canvas.style.zIndex=e?.zIndex?e.zIndex.toString():"0",document.body.appendChild(this.canvas);if(e&&e.backgroundImage?(this.canvas.style.background=`url(${e.backgroundImage})`,this.canvas.style["background-size"]="cover",this.canvas.style["background-position"]="center"):this.canvas.style.background="transparent",this.canvas.style["touch-action"]="none",this.canvas.style["object-fit"]="cover",navigator.gpu===void 0)throw new Error("Your browser does not support WebGPU!");if(this.adapter=await navigator.gpu.requestAdapter({powerPreference:"high-performance"}),this.adapter==null)throw new Error("Your browser does not support WebGPU!");if(this.device=await this.adapter.requestDevice({requiredFeatures:["bgra8unorm-storage","depth-clip-control","depth32float-stencil8","indirect-first-instance","rg11b10ufloat-renderable"],requiredLimits:{minUniformBufferOffsetAlignment:256,maxStorageBufferBindingSize:this.adapter.limits.maxStorageBufferBindingSize}}),this.device==null)throw new Error("Your browser does not support WebGPU!");this._pixelRatio=((t=this.canvasConfig)==null?void 0:t.devicePixelRatio)||window.devicePixelRatio||1,this._pixelRatio=Math.min(this._pixelRatio,2),this.device.label="device",this.presentationFormat=navigator.gpu.getPreferredCanvasFormat(),this.context=this.canvas.getContext("webgpu"),this.context.configure({device:this.device,format:this.presentationFormat,usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT,alphaMode:"premultiplied",colorSpace:"display-p3"}),this.resize(this.canvas.clientWidth,this.canvas.clientHeight);let r;return new ResizeObserver(()=>{clearTimeout(r),r=setTimeout(()=>{this.resize(this.canvas.clientWidth,this.canvas.clientHeight)},50)}).observe(this.canvas),!0}resize(e,t){this.canvas.width=this.windowWidth=Math.floor(e*this.pixelRatio*this.super),this.canvas.height=this.windowHeight=Math.floor(t*this.pixelRatio*this.super),this.presentationSize[0]=this.windowWidth,this.presentationSize[1]=this.windowHeight,this.aspect=this.windowWidth/this.windowHeight}}let S=new Yf;class Ci{}o(Ci,"Bloom_Brightness_frag_wgsl",`
    struct uniformData {
        luminosityThreshold: f32
    };

    struct FragmentOutput {
        @location(0) o_Target: vec4<f32>
    };

    var<private> fragUV1: vec2<f32>;
    var<private> o_Target: vec4<f32>;
    @group(1) @binding(0)
    var baseMapSampler: sampler;
    @group(1) @binding(1)
    var baseMap: texture_2d<f32>;
    @group(2) @binding(0)
    var<uniform> global: uniformData;

    fn Brightness(c: vec3<f32>) -> f32 {
        var c1: vec3<f32>;

        c1 = c;
        let e8: vec3<f32> = c1;
        let e10: vec3<f32> = c1;
        let e12: vec3<f32> = c1;
        let e14: vec3<f32> = c1;
        let e17: vec3<f32> = c1;
        let e19: vec3<f32> = c1;
        let e21: vec3<f32> = c1;
        let e23: vec3<f32> = c1;
        let e25: vec3<f32> = c1;
        let e28: vec3<f32> = c1;
        return max(max(e23.x, e25.y), e28.z);
    }

    fn main1() {
        var uv: vec2<f32>;
        var LinearColor: vec4<f32>;
        var TotalLuminance: f32;
        var BloomLuminance: f32;
        var BloomAmount: f32;

        let e6: vec2<f32> = fragUV1;
        uv = e6.xy;
        let e11: vec2<f32> = uv;
        uv.y = (1.0 - e11.y);
        let e15: vec2<f32> = uv;
        let e16: vec4<f32> = textureSample(baseMap, baseMapSampler, e15);
        LinearColor = e16;
        let e18: vec4<f32> = LinearColor;
        let e27: vec4<f32> = LinearColor;
        let e36: vec4<f32> = LinearColor;
        let e38: vec3<f32> = min(vec3<f32>(f32(65000), f32(65000), f32(65000)), e36.xyz);
        LinearColor.x = e38.x;
        LinearColor.y = e38.y;
        LinearColor.z = e38.z;
        let e45: vec4<f32> = LinearColor;
        let e47: vec4<f32> = LinearColor;
        let e49: f32 = Brightness(e47.xyz);
        TotalLuminance = e49;
        let e51: f32 = TotalLuminance;
        let e52: f32 = global.luminosityThreshold;
        BloomLuminance = (e51 - e52);
        let e55: f32 = BloomLuminance;
        let e60: f32 = BloomLuminance;
        BloomAmount = clamp((e60 * 0.5), 0.0, 1.0);
        let e67: f32 = BloomAmount;
        let e68: vec4<f32> = LinearColor;
        o_Target = vec4<f32>((e67 * e68.xyz), f32(0));
        return;
    }

    @fragment
    fn main(@location(0) fragUV: vec2<f32>) -> FragmentOutput {
        fragUV1 = fragUV;
        main1();
        let e13: vec4<f32> = o_Target;
        return FragmentOutput(e13);
    }
    `),o(Ci,"Bloom_blur_frag_wgsl",`
      struct uniformData {
          texSize: vec2<f32>,
          hScale: f32,
          vScale: f32,
          horizontal: f32
      };

      struct FragmentOutput {
          @location(0) o_Target: vec4<f32>
      };

      var<private> fragUV1: vec2<f32>;
      var<private> o_Target: vec4<f32>;
      @group(1) @binding(0)
      var baseMapSampler: sampler;
      @group(1) @binding(1)
      var baseMap: texture_2d<f32>;
      @group(2) @binding(0)
      var<uniform> global: uniformData;

      fn main1() {
       
          return;
      }

      const buffer1: array<f32,5> = array<f32,5>(0.22702699899673462, 0.194594606757164, 0.12162160128355026, 0.05405399948358536, 0.01621600054204464);

      @fragment
      fn main(@location(0) fragUV: vec2<f32>) -> FragmentOutput {
          var result: vec3<f32>;
          var i: i32 = 1;
          var j: i32 = 1;
          var uv: vec2<f32> = fragUV;
          uv.y = (1.0 - uv.y);
          var tex_offset: vec2<f32> = (vec2<f32>(1.0) / vec2<f32>(global.texSize));
          let color: vec4<f32> = textureSample(baseMap, baseMapSampler, uv);
          result = (color.xyz * buffer1[0]);
        
          if ((global.horizontal > 1.0)) {
              {
                  loop {
                      if (!((i < 5))) {
                          break;
                      }
                      {
                          let c1: vec4<f32> = textureSample(baseMap, baseMapSampler, (uv + vec2<f32>(((tex_offset.x * f32(i)) * global.hScale), 0.0)));
                          result = (result + (c1.xyz * buffer1[i]));
                          let e101: vec4<f32> = textureSample(baseMap, baseMapSampler, (uv - vec2<f32>(((tex_offset.x * f32(i)) * global.hScale), 0.0)));
                          result = (result + (e101.xyz * buffer1[i]));
                      }
                      continuing {
                          i = (i + 1);
                      }
                  }
              }
          }
          if ((global.horizontal < 1.0)) {
              {
                  loop {
                      let e114: i32 = j;
                      if (!((e114 < 5))) {
                          break;
                      }
                      {
                          let e144: vec4<f32> = textureSample(baseMap, baseMapSampler, (uv + vec2<f32>(0.0, ((tex_offset.y * f32(j)) * global.vScale))));
                          result = (result + (e144.xyz * buffer1[j]));
                          let e175: vec4<f32> = textureSample(baseMap, baseMapSampler, (uv - vec2<f32>(0.0, ((tex_offset.y * f32(j)) * global.vScale))));
                          result = (result + (e175.xyz *  buffer1[j]));
                      }
                      continuing {
                          j = (j + 1);
                      }
                  }
              }
          }
          o_Target = vec4<f32>(result, 1.0);
          return FragmentOutput(o_Target);
      }
    `),o(Ci,"Bloom_composite_frag_wgsl",`
    #include "ColorUtil"
      struct UniformData {
          tintColor:vec4<f32>,
          bloomStrength: f32,
          exposure: f32,
          bloomRadius: f32,
      };

      struct FragmentOutput {
          @location(0) o_Target: vec4<f32>
      };

      var<private> fragUV1: vec2<f32>;
      var<private> o_Target: vec4<f32>;
      @group(1) @binding(0)
      var baseMapSampler: sampler;
      @group(1) @binding(1)
      var baseMap: texture_2d<f32>;
      @group(1) @binding(2)
      var blurTex1Sampler: sampler;
      @group(1) @binding(3)
      var blurTex1: texture_2d<f32>;
      @group(1) @binding(4)
      var blurTex2Sampler: sampler;
      @group(1) @binding(5)
      var blurTex2: texture_2d<f32>;
      @group(1) @binding(6)
      var blurTex3Sampler: sampler;
      @group(1) @binding(7)
      var blurTex3: texture_2d<f32>;
      @group(1) @binding(8)
      var blurTex4Sampler: sampler;
      @group(1) @binding(9)
      var blurTex4: texture_2d<f32>;
      @group(1) @binding(10)
      var blurTex5Sampler: sampler;
      @group(1) @binding(11)
      var blurTex5: texture_2d<f32>;
      @group(2) @binding(0)
      var<uniform> global: UniformData;

      const bloomFactors = array<f32,5>(1.0, 0.800000011920929, 0.6000000238418579, 0.4000000059604645, 0.20000000298023224);
     
      fn lerpBloomFactor(factor: f32) -> f32 {
          var mirrorFactor: f32 = (1.2000000476837158 - factor);
          return mix(factor, mirrorFactor, global.bloomRadius);
      }

      fn main1() {
    
          return;
      } 

      @fragment
      fn main(@location(0) fragUV: vec2<f32>) -> FragmentOutput {
          var uv: vec2<f32> = fragUV;
          uv.y = (1.0 - uv.y);
        
          let e38: f32 = lerpBloomFactor(bloomFactors[0]);
          let e46: vec4<f32> = textureSample(blurTex1, blurTex1Sampler, uv);
          let e52: f32 = lerpBloomFactor(bloomFactors[1]);
          let e60: vec4<f32> = textureSample(blurTex2, blurTex2Sampler, uv);
          let e67: f32 = lerpBloomFactor(bloomFactors[2]);
          let e75: vec4<f32> = textureSample(blurTex3, blurTex3Sampler, uv);
          let e82: f32 = lerpBloomFactor(bloomFactors[3]);
          let e90: vec4<f32> = textureSample(blurTex4, blurTex4Sampler, uv);
          let e97: f32 = lerpBloomFactor(bloomFactors[4]);
          let e105: vec4<f32> = textureSample(blurTex5, blurTex5Sampler, uv);
          o_Target = ((((((((e38 * vec4<f32>(array<vec3<f32>,5>(vec3<f32>(1.0, 1.0, 1.0), vec3<f32>(1.0, 1.0, 1.0), vec3<f32>(1.0, 1.0, 1.0), vec3<f32>(1.0, 1.0, 1.0), vec3<f32>(1.0, 1.0, 1.0))[0], 1.0)) * e46) + ((e52 * vec4<f32>(array<vec3<f32>,5>(vec3<f32>(1.0, 1.0, 1.0), vec3<f32>(1.0, 1.0, 1.0), vec3<f32>(1.0, 1.0, 1.0), vec3<f32>(1.0, 1.0, 1.0), vec3<f32>(1.0, 1.0, 1.0))[1], 1.0)) * e60)) + ((e67 * vec4<f32>(array<vec3<f32>,5>(vec3<f32>(1.0, 1.0, 1.0), vec3<f32>(1.0, 1.0, 1.0), vec3<f32>(1.0, 1.0, 1.0), vec3<f32>(1.0, 1.0, 1.0), vec3<f32>(1.0, 1.0, 1.0))[2], 1.0)) * e75)) + ((e82 * vec4<f32>(array<vec3<f32>,5>(vec3<f32>(1.0, 1.0, 1.0), vec3<f32>(1.0, 1.0, 1.0), vec3<f32>(1.0, 1.0, 1.0), vec3<f32>(1.0, 1.0, 1.0), vec3<f32>(1.0, 1.0, 1.0))[3], 1.0)) * e90)) + ((e97 * vec4<f32>(array<vec3<f32>,5>(vec3<f32>(1.0, 1.0, 1.0), vec3<f32>(1.0, 1.0, 1.0), vec3<f32>(1.0, 1.0, 1.0), vec3<f32>(1.0, 1.0, 1.0), vec3<f32>(1.0, 1.0, 1.0))[4], 1.0)) * e105))));
          
          let baseColor: vec4<f32> = textureSample(baseMap, baseMapSampler, uv);
          
          var bloomLight = global.bloomStrength * o_Target.rgb;

          bloomLight = getHDRColor(bloomLight.rgb,global.exposure);
          bloomLight = LinearToGammaSpace(bloomLight);

          o_Target =  baseColor + vec4<f32>(bloomLight * global.tintColor.rgb, baseColor.a) ;
          o_Target.a = min(o_Target.a,1.0);
          return FragmentOutput(o_Target);
      }
  `);let En=`
        var<private> colorSet : array<vec3<f32>, 9> = array<vec3<f32>, 9>(
            vec3<f32>(1.0, 0.0, 0.0),
            vec3<f32>(1.0, 0.5, 0.0),
            vec3<f32>(0.5, 1.0, 0.0),
            vec3<f32>(0.0, 1.0, 0.0),
            vec3<f32>(0.0, 1.0, 0.5),
            vec3<f32>(0.0, 0.5, 1.0),
            vec3<f32>(0.0, 0.0, 1.0),
            vec3<f32>(0.5, 0.0, 1.0),
            vec3<f32>(1.0, 0.0, 0.5)
        );

        #if DEBUG_CLUSTER
        fn debugCluster(fragCoord:vec4<f32>) {
            #if USE_LIGHT
              var tileID : u32 = getClusterId3().z;
              let clusterDebug = vec4<f32>(colorSet[tileID % 9u], 1.0);
              ORI_FragmentOutput.color = clusterDebug ;
            #endif
          }
      
          fn debugClusterBox(fragCoord:vec4<f32>) {
            #if USE_LIGHT
              let clusterId3 : vec3<u32> = getClusterId3();
              let px = f32(clusterId3.x) / clustersUniform.clusterTileX ;
              let py = f32(clusterId3.y) / clustersUniform.clusterTileY ;
              let pz = f32(clusterId3.z) / clustersUniform.clusterTileZ ;
              ORI_FragmentOutput.color = vec4<f32>(px,py,pz, 1.0);

              var screenUV = ORI_VertexVarying.fragCoord.xy / vec2<f32>( globalUniform.windowWidth , globalUniform.windowHeight );
              ORI_FragmentOutput.color = vec4<f32>(screenUV.x,screenUV.y,0.0, 1.0);

              // let clusterId : u32 = getClusterIndex();
              // let cluster = clusterBuffer[clusterId];
        
              // let midPoint : vec3<f32> = (cluster.maxPoint.xyz - cluster.minPoint.xyz) * vec3<f32>(0.5);
              // let center : vec3<f32> = cluster.minPoint.xyz + midPoint;
              // let radius : f32 = length(midPoint) ;
        
              // let fragToBoundsCenter : vec3<f32> = ORI_VertexVarying.viewPosition.xyz - center;
              // let distToBoundsCenter : f32 = length(fragToBoundsCenter);
              // let normDist : f32 = distToBoundsCenter / radius;
              // ORI_FragmentOutput.color = vec4<f32>(normDist,normDist,normDist, 1.0);
            #endif
          }
      
          fn debugClusterLightCount(fragCoord:vec4<f32>){
            #if USE_LIGHT
            //LightIndex
              let cluster : LightIndex = getCluster();
              let lightCount : u32 = u32(cluster.count);
              let lightFactor : f32 = f32(lightCount) / f32(clustersUniform.maxNumLightsPerCluster);
              ORI_FragmentOutput.color =  mix(vec4<f32>(0.0, 0.0,0.0, 1.0), vec4<f32>(1.0, 1.0, 1.0, 1.0), vec4<f32>(lightFactor, lightFactor, lightFactor, lightFactor));
            #endif
          }
          #endif
    `;class Ur{}o(Ur,"sky_vs_frag_wgsl",`
    #include "WorldMatrixUniform"
    #include "GlobalUniform"

    struct VertexOutput {
      @location(0) fragUV: vec2<f32>,
      @location(1) vWorldPos: vec4<f32>,
      @location(2) vWorldNormal: vec3<f32>,
      @builtin(position) member: vec4<f32>
    };

    var<private> ORI_VertexOut: VertexOutput ;

    @vertex
    fn main( 
      @builtin(instance_index) index : u32,
      @location(0) position: vec3<f32>,
      @location(1) normal: vec3<f32>,
      @location(2) uv: vec2<f32>
    ) -> VertexOutput {
      ORI_VertexOut.fragUV = uv;
      let modelMat = models.matrix[u32(index)];
      let vm = globalUniform.viewMat * modelMat;
      let normalMatrix = mat3x3<f32>(vm[0].xyz,vm[1].xyz,vm[2].xyz);
	    ORI_VertexOut.vWorldNormal = normalize( normalMatrix * normal );
      ORI_VertexOut.vWorldPos = modelMat * vec4<f32>(position.xyz,1.0) ;

      var fixProjMat = globalUniform.projMat ;
      fixProjMat[2].z = 1.0 ;//99999.0 / (99999.0 - 1.0) ;
      fixProjMat[3].z = -1.0 ;//(-1.0 * 99999.0) / (99999.0 - 1.0) ;

      var fixViewMat = globalUniform.viewMat ;
      fixViewMat[3].x = 0.0 ;
      fixViewMat[3].y = 0.0 ;
      fixViewMat[3].z = 0.0 ;

      var clipPos = fixProjMat * fixViewMat * ORI_VertexOut.vWorldPos;
      ORI_VertexOut.member = clipPos;
      return ORI_VertexOut;
    }
  `),o(Ur,"sky_fs_frag_wgsl",`
    #include "GlobalUniform"

    struct uniformData {
        exposure: f32,
        roughness: f32
    };

    struct FragmentOutput {
        @location(0) o_Target: vec4<f32>,
        #if USE_WORLDPOS
          @location(1) o_Position: vec4<f32>,
        #endif
        #if USEGBUFFER
          @location(2) o_Normal: vec4<f32>,
          @location(3) o_Material: vec4<f32>
        #endif
    };

    @group(1) @binding(0)
    var baseMapSampler: sampler;
    @group(1) @binding(1)
    var baseMap: texture_cube<f32>;

    @group(2) @binding(0)
    var<uniform> global: uniformData;

    fn LinearToGammaSpace(linRGB: vec3<f32>) -> vec3<f32> {
      var linRGB1 = max(linRGB, vec3<f32>(0.0));
      linRGB1 = pow(linRGB1, vec3<f32>(0.4166666567325592));
      return max(((1.0549999475479126 * linRGB1) - vec3<f32>(0.054999999701976776)), vec3<f32>(0.0));
    }

    @fragment
    fn main(@location(0) fragUV: vec2<f32>, @location(1) vWorldPos: vec4<f32>, @location(2) vWorldNormal: vec3<f32>) -> FragmentOutput {
        let maxLevel: u32 = textureNumLevels(baseMap);
        var textureColor:vec3<f32> = textureSampleLevel(baseMap, baseMapSampler, normalize(vWorldPos.xyz), global.roughness * f32(maxLevel) ).xyz;
        #if IS_HDR_SKY
        textureColor = LinearToGammaSpace(textureColor);
        #endif
        let o_Target: vec4<f32> =vec4<f32>(textureColor, 1.0) * globalUniform.skyExposure ;
        var normal_rgba8unorm = (vWorldNormal + 1.0) * 0.5;
        normal_rgba8unorm = clamp(normal_rgba8unorm, vec3<f32>(0.0), vec3<f32>(1.0));

        return FragmentOutput(
          o_Target,
          #if USE_WORLDPOS
              vWorldPos,
          #endif
          #if USEGBUFFER
              vec4<f32>(normal_rgba8unorm,0.0),
              vec4<f32>(0.0,1.0,0.0,0.0)
          #endif
        );
    }
    `);let Bn=`
#include "BRDF_frag"
#include "ClusterLight"
#include "ShadowMapping_frag"

#if USE_IES_PROFILE
  #include "IESProfiles_frag"
#endif



const LUMEN = 10.764;



fn calcAttenuation( d : f32 ,  falloffStart : f32 ,  falloffEnd : f32)-> f32
{
    // Linear falloff.
    return saturate((falloffEnd-d) / (falloffEnd - falloffStart));
}

fn directLighting( albedo:vec3<f32>, N:vec3<f32>, V:vec3<f32>,  roughness:f32 , metallic:f32 , light:LightData , shadowBias:f32 ) -> vec3<f32> {
    var color = vec3<f32>(0.0) ;
    #if USE_LIGHT
      var L = -normalize(light.direction.xyz) ;
      let lightCC = pow( light.lightColor.rgb,vec3<f32>(2.2));
      var lightColor = getHDRColor( lightCC.rgb , light.linear )  ;
      var att = light.intensity / LUMEN ;
      if(light.castShadow>=0){
          #if USE_SHADOWMAPING
            for (var j: i32 = 0; j < 8; j += 1) {
                if(j == light.castShadow){
                  att *= shadowStrut.directShadowVisibility[j] ; 
                }
            }
          #endif
      }

      #if USE_LAMBERT
        color = vec3<f32>(1.0,1.0,1.0) ;
      #endif 

      #if USE_BRDF
        color = simpleBRDF(albedo,N,V,L,att,lightColor,roughness,metallic) ;
      #endif 
    #endif 
    return color;
}

fn pointLighting( albedo:vec3<f32>,WP:vec3<f32>, N:vec3<f32>, V:vec3<f32>, roughness:f32 , metallic:f32 ,light:LightData ) -> vec3<f32> {
    var color = vec3<f32>(0.0) ;
    let lightPos = light.position.xyz;
    var dir = lightPos.xyz - WP ;
    let dist = length(dir);
    if(dist != 0.0){
      dir *= 1.0 / dist ;
    }
    if( abs(dist) < light.range ){
        var L = dir ;
        var atten = 1.0 ;
        atten = 1.0 - smoothstep(0.0,light.range,dist) ;
        atten *= 1.0 / max(light.radius,0.001) * light.intensity / LUMEN;
        if( light.castShadow >= 0 )
        {
            #if USE_SHADOWMAPING
              // atten *= shadowStrut.pointShadows[light.castShadow] ; 
              for (var j: i32 = 0; j < 8; j += 1) {
                  if(j == light.castShadow){
                    atten *= shadowStrut.pointShadows[j] ; 
                  }
              }
            #endif
        }

        #if USE_IES_PROFILE
          atten *= getLightIESProfileAtt(WP,light);
        #endif

        var lightColor = light.lightColor.rgb  ;
        lightColor = getHDRColor(lightColor , light.linear )  ;

        #if USE_LAMBERT
          color = vec3<f32>(1.0,1.0,1.0) ;
        #endif 

        #if USE_BRDF
          color = (simpleBRDF(albedo,N,V,L,atten,lightColor,roughness,metallic))  ;
        #endif 
    } 
    return color ;
}

fn getDistanceAtten(  light:LightData , dist : f32 ) -> f32 {
  return 1.0 - smoothstep(0.0,light.range,dist) ;
}

fn spotLighting( albedo:vec3<f32>,WP:vec3<f32>, N:vec3<f32>, V:vec3<f32>, roughness:f32 , metallic:f32 ,light:LightData ) -> vec3<f32> {
    let lightPos = light.position.xyz;
    var dir = lightPos.xyz - WP ;
    let dist = length(dir) ;
    if(dist != 0.0){
      dir *= 1.0 / dist ;
    }
    var color = vec3<f32>(0.0) ;
    if( abs(dist) < light.range * 2.0 ){
        var L = dir ;
        let theta = dot(-L, normalize(light.direction));
        let angle = acos(theta) ;
        var atten = 1.0 ;
        var lightColor = light.lightColor.rgb  ;

        atten = 1.0 - smoothstep(0.0,light.range,dist) ;
        atten *= 1.0 / max(light.radius,0.1) * light.intensity / LUMEN;
        if(angle < light.outerCutOff){
          if(angle > light.innerCutOff){
            atten *= 1.0 - smoothstep(light.innerCutOff, light.outerCutOff, angle) ;
          }
        }else{
            atten = 0.0 ;
        }

        if( light.castShadow >= 0 )
        {
            #if USE_SHADOWMAPING
            for (var j: i32 = 0; j < 8; j += 1) {
                if(j == light.castShadow){
                  atten *= shadowStrut.pointShadows[j] ; 
                }
            }
          #endif
        }

        #if USE_IES_PROFILE
            atten *= getLightIESProfileAtt(WP,light);
        #endif

        lightColor = getHDRColor(lightColor , light.linear ) ;

        #if USE_LAMBERT
          color = vec3<f32>(1.0,0.5,1.0) ;
        #endif 

        #if USE_BRDF
          color = (simpleBRDF(albedo,N,V,L,atten,lightColor,roughness,metallic)) ;
        #endif 
    }
    return  color ;
}
`,Bs=`
var<private> PI: f32 = 3.14159265359;


fn applyQuaternion(position:vec3<f32>, q:vec4<f32>) -> vec3<f32>{
  let x:f32 = position.x;
  let y:f32 = position.y;
  let z:f32 = position.z;

  let qx:f32 = q.x;
  let qy:f32 = q.y;
  let qz:f32 = q.z;
  let qw:f32 = q.w;

  let ix:f32 = qw * x + qy * z - qz * y;
  let iy:f32 = qw * y + qz * x - qx * z;
  let iz:f32 = qw * z + qx * y - qy * x;
  let iw:f32 = -qx * x - qy * y - qz * z;

  var ret: vec3<f32>;
  ret.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  ret.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  ret.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;

  return ret;
}

fn inverse( m:mat3x3<f32>) -> mat3x3<f32>{
  var a00 = m[0][0];
  var a01 = m[0][1];
  var a02 = m[0][2];
  var a10 = m[1][0];
  var a11 = m[1][1];
  var a12 = m[1][2];
  var a20 = m[2][0];
  var a21 = m[2][1];
  var a22 = m[2][2];

  var b01 = a22 * a11 - a12 * a21;
  var b11 = -a22 * a10 + a12 * a20;
  var b21 = a21 * a10 - a11 * a20;

  var det = a00 * b01 + a01 * b11 + a02 * b21 ;
  return mat3x3<f32>(
      vec3<f32>(b01/ det, (-a22 * a01 + a02 * a21)/ det, (a12 * a01 - a02 * a11)/ det),
      vec3<f32>(b11/ det, (a22 * a00 - a02 * a20)/ det, (-a12 * a00 + a02 * a10)/ det),
      vec3<f32>(b21/ det, (-a21 * a00 + a01 * a20)/ det, (a11 * a00 - a01 * a10)/ det)
  );
}

fn dir_to_faceId(pt:vec3<f32>) -> i32 {
    //**** nx px ny py nz pz
    var abs_x = abs(pt.x);
    var abs_y = abs(pt.y);
    var abs_z = abs(pt.z);
    var coord = max(max(abs_x, abs_y), abs_z);
    if(coord == -pt.x){  return 0;}
    if(coord == pt.x) { return 1;}

    if(coord == -pt.y){  return 2;}
    if(coord == pt.y) { return 3;}

    if(coord == -pt.z) { return 4;}
    return 5;
  }

  fn convert_xyz_to_cube_uv(x:f32, y:f32, z:f32 ) -> vec2<f32>
  {
    var dir = vec3<f32>(x, y, z);
    var absX = abs(dir.x);
    var absY = abs(dir.y);
    var absZ = abs(dir.z);

    var isXPositive = 0;
    if(dir.x > 0.0){isXPositive = 1;}
    var isYPositive = 0;
    if(dir.y > 0.0){isYPositive = 1;}
    var isZPositive = 0;
    if(dir.z > 0.0){isZPositive = 1;}

    var maxAxis:f32 = 0.0;
    var uc:f32 = 0.0;
    var vc:f32 = 0.0;

    // POSITIVE X
    if (isXPositive == 1 && absX >= absY && absX >= absZ) {
      // u (0 to 1) goes from +z to -z
      // v (0 to 1) goes from -y to +y
      maxAxis = absX;
      uc = -z;
      vc = y;
    }
    // NEGATIVE X
    if (isXPositive ==0 && absX >= absY && absX >= absZ) {
      // u (0 to 1) goes from -z to +z
      // v (0 to 1) goes from -y to +y
      maxAxis = absX;
      uc = z;
      vc = y;
    }
    // POSITIVE Y
    if (isYPositive==1 && absY >= absX && absY >= absZ) {
      // u (0 to 1) goes from -x to +x
      // v (0 to 1) goes from +z to -z
      maxAxis = absY;
      uc = x;
      vc = -z;
    }
    // NEGATIVE Y
    if (isYPositive ==0 && absY >= absX && absY >= absZ) {
      // u (0 to 1) goes from -x to +x
      // v (0 to 1) goes from -z to +z
      maxAxis = absY;
      uc = x;
      vc = z;
    }
    // POSITIVE Z
    if (isZPositive == 1&& absZ >= absX && absZ >= absY) {
      // u (0 to 1) goes from -x to +x
      // v (0 to 1) goes from -y to +y
      maxAxis = absZ;
      uc = x;
      vc = y;
    }
    // NEGATIVE Z
    if (isZPositive ==0 && absZ >= absX && absZ >= absY) {
      // u (0 to 1) goes from +x to -x
      // v (0 to 1) goes from -y to +y
      maxAxis = absZ;
      uc = -x;
      vc = y;
    }

    // Convert range from -1 to 1 to 0 to 1
    var u = 0.5f * (uc / maxAxis + 1.0f);
    var v = 0.5f * (vc / maxAxis + 1.0f);

    return vec2(u, v);
  }

    // Returns \xB11
    fn signNotZero( v1:vec2<f32>) -> vec2<f32> {
        var v:vec2<f32> = v1;
        if(v.x >= 0.0){
            v.x = 1.0;
        }else{
            v.x = -1.0;
        }
        if(v.y >= 0.0){
            v.y = 1.0;
        }else{
            v.y= -1.0;
        }
        return v;
    }

    fn octEncode( v:vec3<f32> ) -> vec2<f32> {
        var l1norm = abs(v.x) + abs(v.y) + abs(v.z);
        var result = v.xy * (1.0 / l1norm);
        if (v.z < 0.0) {
            result = (1.0 - abs(result.yx)) * signNotZero(result.xy);
        }
        return result;
    }

    // Returns a unit vector. Argument o is an octahedral vector packed via octEncode,on the [-1, +1] square*/
    fn octDecode( o:vec2<f32> ) -> vec3<f32> {
        var v = vec3<f32>(o.x, o.y, 1.0 - abs(o.x) - abs(o.y));
        if (v.z < 0.0) {
            var tmp = (1.0 - abs(v.yx)) * signNotZero(v.xy);
            v.x = tmp.x;
            v.y = tmp.y;
        }
        return normalize(v);
    }

    fn Linear01Depth(z:f32,near:f32,far:f32)-> f32{
        let ZBufferZ = (-1.0+(far/near)) / far;
        let ZBufferW = near /far ;
        return 1.0 / (ZBufferZ * z + ZBufferW) ;
    }

    
    fn LinearizeDepth( depth:f32 , nearPlane:f32 , farPlane:f32 )-> f32 {
      var z = depth * 2.0 - 1.0;
      return (2.0 * nearPlane * farPlane) / (farPlane + nearPlane - z * (farPlane - nearPlane));
    }

    fn logDepth(depth : f32, far:f32) -> f32 {
      return log2(depth + 1.0) * 2.0 / (log(far + 1.0) / 0.6931471805599453) * 0.5;
    }

    fn log2Depth(depth : f32, near:f32, far:f32) -> f32 {
      let pt = pow((far / near),depth);
      return near * pt / (far / near);
    }

   


    fn QuaternionToMatrix(q: vec4<f32>) -> mat4x4<f32> {
      // If q is guaranteed to be a unit quaternion, s will always
      // be 1.  In that case, this calculation can be optimized out.
      //float norm = GetNorm (q);
      //float s = (norm > 0.0) ? 2.0/norm : 0;

      var result: mat4x4<f32>;
  
      // Precalculate coordinate products
      let x = q.x * 2.0;
      let y = q.y * 2.0;
      let z = q.z * 2.0;
      let xx = q.x * x;
      let yy = q.y * y;
      let zz = q.z * z;
      let xy = q.x * y;
      let xz = q.x * z;
      let yz = q.y * z;
      let wx = q.w * x;
      let wy = q.w * y;
      let wz = q.w * z;
  
      // Calculate 3x3 matrix from orthonormal basis
      result[0][0] = 1.0 - (yy + zz);
      result[0][1] = xy + wz;
      result[0][2] = xz - wy;
      result[0][3] = 0.0;
  
      result[1][0] = xy - wz;
      result[1][1] = 1.0 - (xx + zz);
      result[1][2] = yz + wx;
      result[1][3] = 0.0;
  
      result[2][0] = xz + wy;
      result[2][1] = yz - wx;
      result[2][2] = 1.0 - (xx + yy);
      result[2][3] = 0.0;
  
      result[3][0] = 0.0;
      result[3][1] = 0.0;
      result[3][2] = 0.0;
      result[3][3] = 1.0;

      return result;
    }

    fn MakeScaleMatrix(scale: vec3<f32>) -> mat4x4<f32> {
        return mat4x4<f32>(
          scale.x, 0.0, 0.0, 0.0,
          0.0, scale.y, 0.0, 0.0,
          0.0, 0.0, scale.z, 0.0,
          0.0, 0.0, 0.0, 1.0,
        );
    }

    fn MakeRotationMatrix(rotationQuaternion: vec4<f32>) -> mat4x4<f32> {
        return QuaternionToMatrix(rotationQuaternion);
    }

    fn MakeTranslationMatrix(translation: vec3<f32>) -> mat4x4<f32> {
        return mat4x4<f32>(
          1.0, 0.0, 0.0, 0.0,
          0.0, 1.0, 0.0, 0.0,
          0.0, 0.0, 1.0, 0.0,
          translation.x, translation.y, translation.z, 1.0,
        );
    }

    fn MakeMatrix4x4(scale: vec3<f32>, rotationQuaternion: vec4<f32>, translation: vec3<f32>) -> mat4x4<f32> {
        var scaleMat: mat4x4<f32> = MakeScaleMatrix(scale);
        var rotationMat: mat4x4<f32> = MakeRotationMatrix(rotationQuaternion);
        var translationMat: mat4x4<f32> = MakeTranslationMatrix(translation);
        return translationMat * scaleMat * rotationMat;
    }

    fn mixMatrix4x4(a: mat4x4<f32>, b: mat4x4<f32>, t:f32) -> mat4x4<f32> {
      return a * (1.0 - t) + b * t;
      // return mat4x4<f32>(
      //   mix(a[0], b[0], t),
      //   mix(a[1], b[1], t),
      //   mix(a[2], b[2], t),
      //   mix(a[3], b[3], t)
      // );
    }

    fn decodeDepth( color:vec4<f32> ) -> f32{
      var depth = 0.0 ;
      const bitShifts = vec4<f32>(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0); 
      depth = dot(color, bitShifts);
      return depth;
    }

    fn encodeDepth( depth:f32 ) -> vec4<f32>{
      const bitSh  = vec4<f32>(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0);
      const bitMsk = vec4<f32>(0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);
      var comp:vec4<f32>;
      comp  = depth * bitSh;
      comp  = fract(comp);
      comp -= comp.xxyz * bitMsk;
      return comp;
    }
`,Tn=`
        struct MaterialUniform {
          transformUV1:vec4<f32>,
          transformUV2:vec4<f32>,

          baseColor: vec4<f32>,
          emissiveColor: vec4<f32>,
          materialF0: vec4<f32>,
          envIntensity: f32,
          normalScale: f32,
          roughness: f32,
          metallic: f32,
          ao: f32,

          roughness_min: f32,
          roughness_max: f32,
          metallic_min: f32,
          metallic_max: f32,
          emissiveIntensity: f32,
          alphaCutoff: f32,
          ior: f32,
          clearcoatColor: vec4<f32>,
          clearcoatWeight: f32,
          clearcoatFactor: f32,
          clearcoatRoughnessFactor: f32,
        };
      
        @group(2) @binding(0)
        var<uniform> materialUniform: MaterialUniform;
      `,Mn=`
struct MaterialUniform {
  transformUV1:vec4<f32>,
  transformUV2:vec4<f32>,
  baseColor: vec4<f32>,
  alphaCutoff: f32,
};

@group(2) @binding(0)
var<uniform> materialUniform: MaterialUniform;
`,Dn=`
    #include "Common_frag"
    #include "GlobalUniform"

    fn UnLit(){
        let alpha = ORI_ShadingInput.BaseColor.a ;
        ORI_FragmentOutput.color = vec4<f32>(ORI_ShadingInput.BaseColor.rgb * alpha , alpha) ;

        #if USE_WORLDPOS
            ORI_FragmentOutput.worldPos = vec4<f32>(ORI_VertexVarying.vWorldPos.xyzw);
        #endif

        #if USEGBUFFER
            var normal_rgba8unorm = (ORI_VertexVarying.vWorldNormal + 1.0) * 0.5;
            normal_rgba8unorm = clamp(normal_rgba8unorm, vec3<f32>(0.0), vec3<f32>(1.0));
            ORI_FragmentOutput.worldNormal = vec4<f32>(normal_rgba8unorm,1.0);
            ORI_FragmentOutput.material = vec4<f32>(1.0,1.0,0.0,1.0);
        #endif
    }

    fn debugFragmentOut(){

    }
`;class Or{static groupBindingAndFunctions(e,t){return`
            struct JointsMatrix {
                matrix : array<mat4x4<f32>>
            };

            @group(${e}) @binding(${t})
            var<storage, read> jointsMatrixIndexTable: array<f32>;

            @group(${e}) @binding(${t+1})
            var<storage, read> jointsInverseMatrix: JointsMatrix;

            @group(${e}) @binding(${t+2})
            var<storage, read> jointsIndexMapingTable: array<f32>;

            const MAX_JOINT_NUM = 8;
            fn getSkeletonWorldMatrix(joints: array<f32, MAX_JOINT_NUM>, weights: array<f32, MAX_JOINT_NUM>, num: u32) -> mat4x4<f32> {
                var result: mat4x4<f32>;
                for(var i: u32 = 0; i < num; i = i + 1) {
                    let jointId = i32(joints[i]);
                    let jointIndex = u32(jointsIndexMapingTable[jointId]);
                    let jointMatrixIndex = u32(jointsMatrixIndexTable[jointIndex]);
                    let joint = models.matrix[jointMatrixIndex] * jointsInverseMatrix.matrix[jointId] * weights[i];
                    result += joint;
                }
                return result;
            }

            fn getSkeletonWorldMatrix_4(joints: vec4<f32>, weights: vec4<f32>) -> mat4x4<f32> {
                return getSkeletonWorldMatrix(array<f32, MAX_JOINT_NUM>(
                    joints.x, joints.y, joints.z, joints.w,
                    0, 0, 0, 0,
                ), array<f32, MAX_JOINT_NUM>(
                    weights.x, weights.y, weights.z, weights.w,
                    0, 0, 0, 0,
                ), 4);
            }
    
            fn getSkeletonWorldMatrix_8(joints0: vec4<f32>, weights0: vec4<f32>, joints1: vec4<f32>, weights1: vec4<f32>) -> mat4x4<f32> {
                return getSkeletonWorldMatrix(array<f32, MAX_JOINT_NUM>(
                    joints0.x, joints0.y, joints0.z, joints0.w,
                    joints1.x, joints1.y, joints1.z, joints1.w,
                ), array<f32, MAX_JOINT_NUM>(
                    weights0.x, weights0.y, weights0.z, weights0.w,
                    weights1.x, weights1.y, weights1.z, weights1.w,
                ), 8);
            }
        `}}class Le{static getMorphTargetShaderBinding(e,t){return`
            fn blendMorphTargetPosition(vertexID:i32, posIn:vec3<f32>) -> vec3<f32>{
                let offset:i32 = vertexID * 3;
                var pos = posIn * morphTargetConfig.morphBaseInfluence;
                pos += vec3<f32>(morphTargetOpPositions[offset], morphTargetOpPositions[offset + 1], morphTargetOpPositions[offset + 2]);
                return pos;
            }

            #if USE_MORPHNORMALS
                fn blendMorphTargetNormal(vertexID:i32, normalIn:vec3<f32>) -> vec3<f32>{
                    let offset:i32 = vertexID * 3;
                    var normal = normalIn * morphTargetConfig.morphBaseInfluence;
                    normal += vec3<f32>(morphTargetOpNormals[offset], morphTargetOpNormals[offset + 1], morphTargetOpNormals[offset + 2]);
                    return normal;
                }
            #endif

            struct MorphTargetConfigData {
                morphBaseInfluence:f32,
                morphTargetCount:f32,
                totalVertexCount:f32,
                computeWorkGroupXY:f32,
            };
            
            @group(${e}) @binding(${t})
            var<uniform> morphTargetConfig: MorphTargetConfigData;
            
            @group(${e}) @binding(${t+1})
            var<storage,read> morphTargetOpPositions: array<f32>;

            #if USE_MORPHNORMALS
                @group(${e}) @binding(${t+2})
                var<storage,read> morphTargetOpNormals: array<f32>;
            #endif
`}static getMorphTargetAttr(e){return`@location(${e}) vIndex: f32,`}static getMorphTargetCalcVertex(){return`
            vertexPosition = blendMorphTargetPosition(i32(vertex.vIndex), vertexPosition);

            #if USE_MORPHNORMALS
                vertexNormal = blendMorphTargetNormal(i32(vertex.vIndex), vertexNormal);
            #endif
        `}}o(Le,"CsMain",`
        struct MorphTargetConfigData {
            morphBaseInfluence:f32,
            morphTargetCount:f32,
            totalVertexCount:f32,
            computeWorkGroupXY:f32,
        };

        @group(0) @binding(0) var<uniform> morphTargetConfig: MorphTargetConfigData;
        @group(0) @binding(1) var<storage, read> morphTargetInfluence : array<f32>;
        @group(0) @binding(2) var<storage, read> morphTargetPositions : array<f32>;
        @group(0) @binding(3) var<storage, read_write> morphTargetOpPositions : array<f32>;
        
        #if USE_MORPHNORMALS
            @group(0) @binding(4) var<storage, read> morphTargetNormals : array<f32>;
            @group(0) @binding(5) var<storage, read_write> morphTargetOpNormals : array<f32>;
        #endif
        
        @compute @workgroup_size( 8 , 8 , 1 )
        fn CsMain(@builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
        {
            let vertexIndex:i32 = i32(globalInvocation_id.y) * i32(morphTargetConfig.computeWorkGroupXY) + i32(globalInvocation_id.x);
        
            let morphTargetCount:i32 = i32(morphTargetConfig.morphTargetCount);
            let totalVertexCount:i32 = i32(morphTargetConfig.totalVertexCount);
            var vertexPosition:vec3<f32> = vec3<f32>(0.0);
            var vertexNormal:vec3<f32> = vec3<f32>(0.0);
            if(vertexIndex < totalVertexCount)
            {
                for(var i:i32 = 0; i < morphTargetCount; i ++){
                    let offset:i32 = (i * totalVertexCount + vertexIndex) * 3;
                    let morphPosition = vec3<f32>(morphTargetPositions[offset], morphTargetPositions[offset + 1], morphTargetPositions[offset + 2]);
                    vertexPosition += morphTargetInfluence[i] * morphPosition;
                }

                var writeOffset = vertexIndex * 3;
                //op position
                morphTargetOpPositions[writeOffset] = vertexPosition.x;
                morphTargetOpPositions[writeOffset + 1] = vertexPosition.y;
                morphTargetOpPositions[writeOffset + 2] = vertexPosition.z;

                #if USE_MORPHNORMALS
                    for(var i:i32 = 0; i < morphTargetCount; i ++){
                        let offset:i32 = (i * totalVertexCount + vertexIndex) * 3;
                        let morphNormal = vec3<f32>(morphTargetNormals[offset], morphTargetNormals[offset + 1], morphTargetNormals[offset + 2]);
                        vertexNormal += morphTargetInfluence[i] * morphNormal;
                    }

                    //op normal
                    morphTargetOpNormals[writeOffset] = vertexNormal.x;
                    morphTargetOpNormals[writeOffset + 1] = vertexNormal.y;
                    morphTargetOpNormals[writeOffset + 2] = vertexNormal.z;
                #endif
            }
        }
`);let Pn=`
    #if USE_MORPHTARGETS
    ${Le.getMorphTargetShaderBinding(3,0)}
    #endif

    #if USE_SKELETON
    ${Or.groupBindingAndFunctions(3,0)} 
    #endif

    struct VertexAttributes{
    @builtin(instance_index) index : u32,
    @location(0) position: vec3<f32>,
    @location(1) normal: vec3<f32>,
    @location(2) uv: vec2<f32>,
    @location(3) TEXCOORD_1: vec2<f32>,

    #if USE_TANGENT
        @location(4) TANGENT: vec4<f32>,
        #if USE_SKELETON
            @location(5) joints0: vec4<f32>,
            @location(6) weights0: vec4<f32>,
            #if USE_JOINT_VEC8
            @location(7) joints1: vec4<f32>,
            @location(8) weights1: vec4<f32>,
        #endif
        #elseif USE_MORPHTARGETS
            ${Le.getMorphTargetAttr(5)}
        #endif
    #elseif USE_SKELETON
        @location(4) joints0: vec4<f32>,
        @location(5) weights0: vec4<f32>,
        #if USE_JOINT_VEC8
        @location(6) joints1: vec4<f32>,
        @location(7) weights1: vec4<f32>,
        #endif
    #elseif USE_MORPHTARGETS
        ${Le.getMorphTargetAttr(4)}
    #endif
    }

    struct VertexOutput {
    @location(0) varying_UV0: vec2<f32>,
    @location(1) varying_UV1: vec2<f32>,
    @location(2) varying_ViewPos: vec4<f32>,
    @location(3) varying_Clip: vec4<f32>,
    @location(4) varying_WPos: vec4<f32>,
    @location(5) varying_WNormal: vec3<f32>,
    @location(6) varying_Color: vec4<f32>,

    #if USE_SHADOWMAPING
        @location(7) varying_ShadowPos: vec4<f32>,
    #endif

    #if USE_TANGENT
        @location(8) varying_Tangent: vec4<f32>,
    #endif

    @builtin(position) member: vec4<f32>
    };

    var<private> ORI_VertexOut: VertexOutput ;

    fn ORI_Vert(vertex:VertexAttributes){
    var vertexPosition = vertex.position;
    var vertexNormal = vertex.normal;

    #if USE_MORPHTARGETS
    ${Le.getMorphTargetCalcVertex()}    
    #endif

    #if USE_SKELETON
        #if USE_JOINT_VEC8
            let skeletonNormal = getSkeletonWorldMatrix_8(vertex.joints0, vertex.weights0, vertex.joints1, vertex.weights1);
            ORI_MATRIX_M *= skeletonNormal ;
        #else
            let skeletonNormal = getSkeletonWorldMatrix_4(vertex.joints0, vertex.weights0);
            ORI_MATRIX_M *= skeletonNormal ;
        #endif
    #endif

    #if USE_TANGENT
        ORI_VertexOut.varying_Tangent = vertex.TANGENT ;
    #endif

    ORI_NORMALMATRIX = transpose(inverse( mat3x3<f32>(ORI_MATRIX_M[0].xyz,ORI_MATRIX_M[1].xyz,ORI_MATRIX_M[2].xyz) ));

    var worldPos = (ORI_MATRIX_M * vec4<f32>(vertexPosition.xyz, 1.0));
    var viewPosition = ORI_MATRIX_V * worldPos;
    var clipPosition = ORI_MATRIX_P * viewPosition ;

    ORI_CameraWorldDir = normalize(ORI_CAMERAMATRIX[3].xyz - worldPos.xyz) ;

    ORI_VertexOut.varying_UV0 = vertex.uv.xy ;
    ORI_VertexOut.varying_UV1 = vertex.TEXCOORD_1.xy;
    ORI_VertexOut.varying_ViewPos = viewPosition ;
    ORI_VertexOut.varying_Clip = clipPosition ;
    ORI_VertexOut.varying_WPos = worldPos ;
    ORI_VertexOut.varying_WPos.w = f32(vertex.index);
    ORI_VertexOut.varying_WNormal = normalize(ORI_NORMALMATRIX * vertexNormal.xyz) ;

    ORI_VertexOut.member = clipPosition ;
    }
`,Rn=`
struct MaterialUniform {
  transformUV1:vec4<f32>,
  transformUV2:vec4<f32>,
  baseColor: vec4<f32>,
  rectClip: vec4<f32>,
  alphaCutoff: f32,
};

@group(2) @binding(0)
var<uniform> materialUniform: MaterialUniform;
`,Ln=`
    struct IrradianceVolumeData {
        //0
        orientationIndex:f32,
            hysteresis:f32,
            OctRTSideSize:f32,
            OctRTMaxSize:f32,

            //1
            startX:f32,
            startY:f32,
            startZ:f32,
            ProbeSpace:f32,

            //2
            gridXCount:f32,
            gridYCount:f32,
            gridZCount:f32,
            maxDistance:f32,

            //3
            depthSharpness:f32,
            ProbeSourceTextureSize:f32,
            ProbeSize:f32,
            bounceIntensity:f32,

            //4
            probeRoughness:f32,
            normalBias:f32,
            irradianceChebyshevBias:f32,
            rayNumber:f32,

            //5
            irradianceDistanceBias:f32,
            indirectIntensity:f32,
            ddgiGamma:f32,
            lerpHysteresis:f32,
            //6

            debugX:f32,
            debugY:f32,
            debugZ:f32,
            slot0:f32,

            //..
            v7:vec4<f32>,
    }
`,Un=`
    #include "MathShader"
    #include "FastMathShader"
    #include "InstanceUniform"

    var<private> ORI_MATRIX_P: mat4x4<f32>;
    var<private> ORI_MATRIX_V: mat4x4<f32>;
    var<private> ORI_MATRIX_M: mat4x4<f32>;
    var<private> ORI_MATRIX_PV: mat4x4<f32>;
    var<private> ORI_MATRIX_PVInv: mat4x4<f32>;
    var<private> ORI_MATRIX_World: mat4x4<f32>;
    var<private> ORI_CAMERAMATRIX: mat4x4<f32>;
    var<private> ORI_NORMALMATRIX: mat3x3<f32>;
    var<private> ORI_CameraWorldDir: vec3<f32>;
    var<private> ORI_ViewDir: vec3<f32>;

    var<private> TIME: vec4<f32>;
    var<private> MOUSE: vec4<f32>;
    var<private> SCREEN: vec4<f32>;

    var<private> ProjectionParams: vec4<f32>;

    fn vertex_inline(vertex:VertexAttributes){
        TIME.x = globalUniform.frame;
        TIME.y = globalUniform.time;
        TIME.z = globalUniform.delta;

        MOUSE.x = globalUniform.mouseX;
        MOUSE.y = globalUniform.mouseY;

        SCREEN.x = globalUniform.windowWidth;
        SCREEN.y = globalUniform.windowHeight;

        ProjectionParams.x = globalUniform.near;
        ProjectionParams.y = globalUniform.far;
        ProjectionParams.z = 1.0 + 1.0 / globalUniform.far;

        ORI_MATRIX_P = globalUniform.projMat ;
        ORI_MATRIX_V = globalUniform.viewMat ;
        ORI_MATRIX_PV = ORI_MATRIX_P * ORI_MATRIX_V ;
        ORI_MATRIX_PVInv = globalUniform.pvMatrixInv ;
        ORI_CAMERAMATRIX = globalUniform.cameraWorldMatrix ;

        ORI_MATRIX_M = models.matrix[u32(vertex.index)];
            
        #if USE_INSTANCEDRAW
            let modelID = instanceDrawID.matrixIDs[vertex.index];
            ORI_MATRIX_M = models.matrix[modelID];
        #endif
    }
`,On=`
  #include "GlobalUniform"
  #include "FragmentVarying"
  #include "ColorPassFragmentOutput"
  #include "ShadingInput"

  var<private> ORI_FragmentOutput: FragmentOutput;
  var<private> ORI_VertexVarying: FragmentVarying;
  var<private> ORI_ShadingInput: ShadingInput;
  var<private> viewDir:vec3<f32>;
  @fragment
  fn FragMain( vertex_varying:FragmentVarying ) -> FragmentOutput {
    ORI_VertexVarying = vertex_varying;
    ORI_FragmentOutput.color = vec4<f32>(1.0, 0.0, 0.0, 1.0);
    viewDir = normalize(globalUniform.CameraPos.xyz - ORI_VertexVarying.vWorldPos.xyz) ;
    #if USE_WORLDPOS
      ORI_FragmentOutput.worldPos = ORI_VertexVarying.vWorldPos;
    #endif
    #if USEGBUFFER
      ORI_FragmentOutput.worldNormal = vec4<f32>(ORI_ShadingInput.Normal.rgb ,1.0); 
      ORI_FragmentOutput.material = vec4<f32>(0.0,1.0,0.0,0.0);
    #endif
    frag();
    
    #if USE_DEBUG
      debugFragmentOut();
    #endif

    // var d1 = logDepth( ORI_VertexVarying.fragCoord.w , globalUniform.far);
    // ORI_FragmentOutput.out_depth = d1 ;

    #if USE_OUTDEPTH
      #if USE_LOGDEPTH
        ORI_FragmentOutput.out_depth = log2Depth(ORI_VertexVarying.fragCoord.z,globalUniform.near,globalUniform.far) ;
      #else
        ORI_FragmentOutput.out_depth = ORI_ShadingInput.FragDepth ;
      #endif
    #endif

    // var d1 = log2(ORI_VertexVarying.fragCoord.w + 1.0) * 2.0 / (log(f + 1.0) / 0.6931471805599453) * 0.5 ;
    // 2.0 / (Math.log(camera.far + 1.0) / Math.LN2)
    // ORI_FragmentOutput.out_depth = d1 ;

    return ORI_FragmentOutput ;
  }


`,Nn=`
    #include "WorldMatrixUniform"
    #include "VertexAttributes_vert"
    #include "GlobalUniform"
    #include "Inline_vert"
    @vertex
    fn VertMain( vertex:VertexAttributes ) -> VertexOutput {
        vertex_inline(vertex);
        vert(vertex);
        return ORI_VertexOut ;
    }
`,Fn=`
    @group(1) @binding(auto)
    var brdflutMapSampler: sampler;
    @group(1) @binding(auto)
    var brdflutMap: texture_2d<f32>;
`,kn=`
    @group(1) @binding(auto)
    var prefilterMapSampler: sampler;
    @group(1) @binding(auto)
    var prefilterMap: texture_cube<f32>;
    @group(1) @binding(auto)
    var envMapSampler: sampler;
    @group(1) @binding(auto)
    var envMap: texture_cube<f32>;
`;class lt{}o(lt,"Cascades",4);let Ts=`

  struct GlobalUniform {
    projMat: mat4x4<f32>,
    viewMat: mat4x4<f32>,
    cameraWorldMatrix: mat4x4<f32>,
    pvMatrixInv : mat4x4<f32>,
    shadowMatrix: array<mat4x4<f32>, 8u>,
    csmShadowBias: vec4<f32>,
    csmMatrix: array<mat4x4<f32>,${lt.Cascades}>,

    CameraPos: vec3<f32>,
    frame: f32,

    time: f32,
    delta: f32,
    shadowBias: f32,
    skyExposure: f32,

    renderPassState:f32,
    quadScale: f32,
    hdrExposure: f32,
    renderState_left: i32,

    renderState_right: i32,
    renderState_split: f32,
    mouseX: f32,
    mouseY: f32,

    windowWidth: f32,
    windowHeight: f32,
    near: f32,
    far: f32,

    pointShadowBias: f32,
    shadowMapSize: f32,
    shadowSoft: f32,
    enableCSM:f32,

    csmMargin:f32,
    notUsed1:f32,
    notUsed2:f32,
    notUsed3:f32
    
  };

  @group(0) @binding(0)
  var<uniform> globalUniform: GlobalUniform;
`,zn=`
    #if USE_INSTANCEDRAW
        struct InstanceUniform {
            matrixIDs : array<i32>
        };
        @group(2) @binding(7)
        var<storage, read> instanceDrawID : InstanceUniform;
    #endif
`,Xa=`
    struct Uniforms {
        matrix : array<mat4x4<f32>>
    };

    @group(0) @binding(1)
    var<storage, read> models : Uniforms;
`,Gn=`
  fn Pow3(  x : f32 ) -> f32
  {
      var xx = x*x;
      return x * xx;
  }

  fn Pow4(  x : f32 ) -> f32
  {
      var xx = x*x;
      return xx * xx;
  }

  fn pow5(x: f32) -> f32 {
      var x2 = x * x;
      return x2 * x2 * x;
  }

  fn rcp( x:f32 ) -> f32
  {
      return 1.0 / x;
  }

  fn rsqrt3( a : vec3<f32> ) -> vec3<f32>
  {
    return pow(a, vec3<f32>(-0.5));
  }

  fn rsqrt( a : f32 ) -> f32
  {
    return pow(a, -0.5);
  }
`,Qn=`
    fn perturbNormal(  worldPos:vec3<f32>,  surf_norm:vec3<f32>,  mapN:vec3<f32> , normalScale:f32 , face:f32 ) -> vec3<f32> {
        var q0 = vec3<f32>( dpdx( worldPos.x ), dpdx( worldPos.y ), dpdx( worldPos.z ) );
        var q1 = vec3<f32>( dpdy( worldPos.x ), dpdy( worldPos.y ), dpdy( worldPos.z ) );
        var st0 = dpdx( ORI_VertexVarying.fragUV0.xy );
        var st1 = dpdy( ORI_VertexVarying.fragUV0.xy );
        var N = surf_norm;
        var q1perp = cross( q1, N );
        var q0perp = cross( N, q0 );

        #if USE_TANGENT
            var T = ORI_VertexVarying.TANGENT.xyz ;
        #else
            var T = q1perp * st0.x + q0perp * st1.x;
        #endif
        
        var B = q1perp * st0.y + q0perp * st1.y;

        var det = max( dot( T, T ), dot( B, B ) );
        var scale = 1.0 ;
        if( det != 0.0 ){
            scale = inverseSqrt( det ) ;
        }
        #if USE_TANGENT
            scale = scale * ORI_VertexVarying.TANGENT.w ;
        #endif

        scale *= normalScale;
        return normalize( (T * ( -mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z ) * face ) ;
    }

    fn unpackNormalMap( normal : vec3<f32> ) -> vec3<f32>
    {
        var normalTex = vec3<f32>( normal.xyz * 2.0 - 1.0 ) ;
        return (normalTex);
    }

    fn unPackNormal(normal : vec3<f32> , height:f32 ) -> vec3<f32>{
        var face = 1.0 ;
        if(ORI_VertexVarying.face){
            face = 1.0 ;
        }else{
            face = -1.0 ;
        }

        #if USE_RGNORMAL
            return unPackRGNormal(normal,height,face);
        #else
            var n = normal ;
            #if USE_NORMALFILPY
            n.y = 1.0 - n.y ; 
            #endif
            
            var mapNormal: vec3<f32> = unpackNormalMap(n) ;
            return perturbNormal(ORI_VertexVarying.vWorldPos.xyz , ORI_VertexVarying.vWorldNormal.xyz , mapNormal , height , face  ) ;
        #endif
    }

    fn unPackRGNormal(normal : vec3<f32> , height:f32 , face:f32) -> vec3<f32> {
        var d = normal.rg * 2.0 - 1.0 ;
        var l = 1.0 - saturate(dot(d,d));
        var s = sqrt(l);
        var rg = d * height ; 
        var mapNormal = vec3<f32>(rg,s);
        var outN = perturbNormal(ORI_VertexVarying.vWorldPos.xyz,ORI_VertexVarying.vWorldNormal,mapNormal,1.0,face) ;
        return outN ;
    }
`,Vn=`
    struct FragmentVarying {
        @location(0) fragUV0: vec2<f32>,
        @location(1) fragUV1: vec2<f32>,
        @location(2) viewPosition: vec4<f32>,
        @location(3) fragPosition: vec4<f32>,
        @location(4) vWorldPos: vec4<f32>,
        @location(5) vWorldNormal: vec3<f32>,
        @location(6) vColor: vec4<f32>,

        #if USE_SHADOWMAPING
            @location(7) vShadowPos: vec4<f32>,
        #endif

        #if USE_TANGENT
            @location(8) TANGENT: vec4<f32>,
        #endif
        
        @builtin(front_facing) face: bool,
        @builtin(position) fragCoord : vec4<f32>
    };
`,Wa=`
    struct FragmentOutput {
        @location(0) color: vec4<f32>,
        #if USE_WORLDPOS
            @location(1) worldPos: vec4<f32>,
        #endif
        #if USEGBUFFER
            @location(2) worldNormal: vec4<f32>,
            @location(3) material: vec4<f32>,
        #endif

        #if USE_OUTDEPTH
            @builtin(frag_depth) out_depth: f32
        #endif
    };
`,Hn=`
    struct ShadingInput{
        BaseColor:vec4<f32>,
        Roughness:f32,
        Metallic:f32,
        Specular:f32,
        EmissiveColor:vec4<f32>,
        SurfaceColor:vec4<f32>,
        Normal:vec3<f32>,
        Tangent:vec4<f32>,
        WorldPositionOffset:vec3<f32>,
        AmbientOcclusion:f32,
        PixelDepthOffset:f32,

        Opacity:f32,
        OpacityMask:f32,

        Refraction:f32,
        FragDepth:f32
    }
`,Yn=`
    #if USE_IES_PROFILE 
        @group(1) @binding(auto)
        var iesTextureArrayMapSampler : sampler;
        @group(1) @binding(auto)
        var iesTextureArrayMap: texture_2d_array<f32> ;
    #endif

    fn getLightIESProfileAtt( wPos : vec3<f32> , light:LightData ) -> f32
    {
        #if USE_IES_PROFILE 
            let tangent = vec3<f32>(1.0,0.0,0.0);
            let lightBitangent = normalize( cross( tangent, light.direction ) );
            let lightMatrix = mat4x4( vec4<f32>(light.direction.xyz, 0.0), vec4<f32>(lightBitangent.xyz, 0.0), vec4<f32>(tangent.xyz, 0.0), vec4<f32>(0.0, 0.0, 0.0, 1.0) );
            let lightMatrixInv = transpose(lightMatrix);
            let lightPos = light.position.xyz;
            let l = lightPos - wPos; 
            let toLight = normalize(l);
            let localToLight = (vec4<f32>(toLight.xyz, 0.0) * lightMatrixInv).xyz;
            let dotProd = dot(toLight, light.direction);
            let angle = asin(dotProd);
            let normAngle = (angle / PI) + 0.5 ;
            let tangentAngle = atan2( -localToLight.z, -localToLight.x ); 
            let normTangentAngle = tangentAngle / (PI * 2.0) + 0.5 ;
            if(light.ies >= 0.0){
                return textureSampleLevel(iesTextureArrayMap, iesTextureArrayMapSampler, vec2<f32>(normAngle , normTangentAngle) , i32(light.ies) , 0.0).r ;
            }else{
                return 1.0;
            }
        #else 
            return 1.0;
        #endif
    }

`,Xn=`
    #if USE_SHADOWMAPING
    @group(1) @binding(auto) var shadowMapSampler: sampler;
    @group(1) @binding(auto) var shadowMap: texture_depth_2d_array;
    #endif

    @group(1) @binding(auto) var pointShadowMapSampler: sampler;
    @group(1) @binding(auto) var pointShadowMap: texture_depth_cube_array;

    struct ShadowStruct{
      directShadowVisibility: array<f32, 8>,
      pointShadows: array<f32, 8>,
    }

    var<private>shadowStrut: ShadowStruct;

    struct ShadowBuffer{
      nDirShadowStart: i32,
      nDirShadowEnd: i32,
      nPointShadowStart: i32,
      nPointShadowEnd: i32,
      shadowLights:array<u32,16>
    }

    #if DEBUG_CLUSTER
        @group(2) @binding(6) var<storage,read> shadowBuffer: ShadowBuffer;
    #else
        @group(2) @binding(5) var<storage,read> shadowBuffer: ShadowBuffer;
    #endif

    fn useShadow(){
        shadowStrut.directShadowVisibility = array<f32, 8>( 1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0) ;
        shadowStrut.pointShadows = array<f32, 8>( 1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0) ;
        directShadowMaping(globalUniform.shadowBias);
        pointShadowMapCompare(globalUniform.pointShadowBias);
    }

    fn calcBasicBias(shadowWorldSize:f32, shadowDepthTexSize:f32, near:f32, far:f32) -> f32{
      var bias = shadowWorldSize / shadowDepthTexSize;
      bias = bias / (far - near);
      return bias * 2.0;
    }

    const dirCount:i32 = 8 ;
    const pointCount:i32 = 8 ;
    const csmCount:i32 = ${lt.Cascades} ;
    var<private> csmLevel:i32 = -1;
    fn directShadowMaping(shadowBias: f32)  {
      #if USE_SHADOWMAPING
        let enableCSM:bool = globalUniform.enableCSM > 0.5;
        for (var i: i32 = 0; i < dirCount ; i = i + 1) {
          if( i >= shadowBuffer.nDirShadowStart && i < shadowBuffer.nDirShadowEnd ){
            let ldx = shadowBuffer.shadowLights[i];
            var light = lightBuffer[ldx];
            var shadowIndex = i32(light.castShadow);
            var visibility = 1.0;
            var shadowMatrix:mat4x4<f32>;
            #if USE_CSM
              if(enableCSM && shadowIndex == 0){
                var totalWeight = 0.0;
                visibility = 0.0;
                var validCount = 0;
                for(var csm:i32 = 0; csm < csmCount; csm ++){
                  var csmShadowBias = globalUniform.csmShadowBias[csm];
                  shadowMatrix = globalUniform.csmMatrix[csm];
                  let csmShadowResult = directShadowMapingIndex(light, shadowMatrix, csm, csmShadowBias);
                  if(csmShadowResult.y < 0.5){
                    validCount ++;

                    var uv = 2.0 * csmShadowResult.zw - vec2<f32>(1.0);
                    uv = saturate(vec2<f32>(1.0) - abs(uv));
                    uv /= clamp(globalUniform.csmMargin, 0.01, 0.5);
                    var weight:f32 = min(uv.x, 1.0);
                    weight = min(weight, uv.y);

                    if(validCount == 1 && csm == csmCount - 1){
                      visibility = 1.0 - weight + csmShadowResult.x * weight;
                      totalWeight = 1.0;
                    }else{
                      weight *= 1.0 - totalWeight;
                      visibility += csmShadowResult.x * weight;
                      totalWeight += weight;
                    }
                    // if(weight < 1.0){
                    //   visibility += 0.1;
                    // }
                    if(validCount >= 2 || totalWeight >= 0.99){
                      csmLevel = csm;
                      break;
                    }
                  }
                }
                totalWeight += 0.0001;
                if(validCount == 0){
                  visibility = 1.0;
                }else{
                  visibility = visibility / totalWeight;
                }
              }else{
                shadowMatrix = globalUniform.shadowMatrix[shadowIndex];
                if(enableCSM) {
                  shadowIndex += csmCount - 1;
                }
                visibility = directShadowMapingIndex(light, shadowMatrix, shadowIndex, shadowBias).x;
              }
            #else
              shadowMatrix = globalUniform.shadowMatrix[shadowIndex];
              visibility = directShadowMapingIndex(light, shadowMatrix, shadowIndex, shadowBias).x;
            #endif 
            shadowStrut.directShadowVisibility[i] = visibility;
          }
        }
      #endif
    }

    fn directShadowMapingIndex(light:LightData, matrix:mat4x4<f32>, depthTexIndex:i32, shadowBias:f32) -> vec4<f32>
    {
      var visibility = 1.0;
      var isOutSideArea:f32 = 1.0;
      var varying_shadowUV:vec2<f32> = vec2<f32>(0.0);
      #if USE_SHADOWMAPING
        var shadowPosTmp = matrix * vec4<f32>(ORI_VertexVarying.vWorldPos.xyz, 1.0);
        var shadowPos = shadowPosTmp.xyz / shadowPosTmp.w;
        varying_shadowUV = shadowPos.xy * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5, 0.5);
        if (varying_shadowUV.x <= 1.0
          && varying_shadowUV.x >= 0.0
          && varying_shadowUV.y <= 1.0
          && varying_shadowUV.y >= 0.0
          && shadowPosTmp.z <= 1.0
          && shadowPosTmp.z >= 0.0)
        {
          visibility = 0.0;
          isOutSideArea = 0.0;
          var uvOnePixel = 1.0 / vec2<f32>(globalUniform.shadowMapSize);
          var totalWeight = 0.0;
          var NoL = abs(dot(normalize(ORI_VertexVarying.vWorldNormal), normalize(light.direction)));
          var bias = shadowBias / max(NoL, 0.000001);
          for (var y = -1; y <= 1; y++) {
            for (var x = -1; x <= 1; x++) {
              var offset = vec2<f32>(f32(x), f32(y)) * uvOnePixel;
              
              // visibility += textureSampleCompare(shadowMap, shadowMapSampler, varying_shadowUV + offset, depthTexIndex, shadowPos.z - bias);
              var depth = textureSampleLevel(shadowMap, shadowMapSampler, varying_shadowUV + offset, depthTexIndex, 0);
              if ((shadowPos.z - bias ) < depth) {
                visibility += 1.0 ;//* dot(offsetDir, dir.xyz);
              }
              totalWeight += 1.0;
            }
          }
          visibility /= totalWeight;
          visibility += 0.001;
        }
      #endif
      return vec4<f32>(visibility, isOutSideArea, varying_shadowUV);
    }

    fn pointShadowMapCompare(shadowBias: f32){
      let worldPos = ORI_VertexVarying.vWorldPos.xyz;
      let offset = 0.1;

      for (var i: i32 = 0; i < pointCount ; i = i + 1) {
        if( i >= shadowBuffer.nPointShadowStart && i < shadowBuffer.nPointShadowEnd ){
          let ldx = shadowBuffer.shadowLights[i];
          let light = lightBuffer[ldx] ;

          #if USE_SHADOWMAPING
          let lightPos = light.position.xyz;
          var shadow = 0.0;
          let frgToLight = worldPos - lightPos.xyz;
          var dir: vec3<f32> = normalize(frgToLight);
          var len = length(frgToLight);
          var bias = max(shadowBias * globalUniform.far * (1.0 - dot(ORI_ShadingInput.Normal, dir)), 0.005);
  
          #if USE_PCF_SHADOW
          let samples = 4.0;
          for (var x: f32 = -offset; x < offset; x += offset / (samples * 0.5)) {
            for (var y: f32 = -offset; y < offset; y += offset / (samples * 0.5)) {
              for (var z: f32 = -offset; z < offset; z += offset / (samples * 0.5)) {
                let offsetDir = normalize(dir.xyz + vec3<f32>(x, y, z));
                var depth = textureSampleLevel(pointShadowMap, pointShadowMapSampler, offsetDir, light.castShadow, 0);
                depth *= globalUniform.far;
                if ((len - bias) > depth) {
                  shadow += 1.0 * dot(offsetDir, dir.xyz);
                }
              }
            }
          }
          shadow = min(max(shadow / (samples * samples * samples), 0.0), 1.0);
          #endif
  
          #if USE_SOFT_SHADOW
          let vDis = length(globalUniform.CameraPos.xyz - worldPos.xyz);
          let sampleRadies = globalUniform.shadowSoft;
          let samples = 20;
          for (var j: i32 = 0; j < samples; j += 1) {
            let offsetDir = normalize(dir.xyz + sampleOffsetDir[j] * sampleRadies);
            var depth = textureSampleLevel(pointShadowMap, pointShadowMapSampler, offsetDir, light.castShadow, 0);
            depth *= globalUniform.far;
            if ((len - bias) > depth) {
              shadow += 1.0 * dot(offsetDir, dir.xyz);
            }
          }
          shadow = min(max(shadow / f32(samples), 0.0), 1.0);
          #endif
  
          #if USE_HARD_SHADOW
          var depth = textureSampleLevel(pointShadowMap, pointShadowMapSampler, dir.xyz, light.castShadow, 0);
          depth *= globalUniform.far;
          if ((len - bias) > depth) {
            shadow = 1.0;
          }
          #endif
  
          for (var j = 0; j < pointCount ; j+=1 ) {
              if(i32(light.castShadow) == j){
                shadowStrut.pointShadows[j] = 1.0 - shadow ;
              }
          }
          #endif
        }
        }
    }

    #if USE_SOFT_SHADOW
    var<private>sampleOffsetDir : array<vec3<f32>, 20> = array<vec3<f32>, 20>(
      vec3<f32>(1.0, 1.0, 1.0), vec3<f32>(1.0, -1.0, 1.0), vec3<f32>(-1.0, -1.0, 1.0), vec3<f32>(-1.0, 1.0, 1.0),
      vec3<f32>(1.0, 1.0, -1.0), vec3<f32>(1.0, -1.0, -1.0), vec3<f32>(-1.0, -1.0, -1.0), vec3<f32>(-1.0, 1.0, -1.0),
      vec3<f32>(1.0, 1.0, 0.0), vec3<f32>(1.0, -1.0, 0.0), vec3<f32>(-1.0, -1.0, 0.0), vec3<f32>(-1.0, 1.0, 0.0),
      vec3<f32>(1.0, 0.0, 1.0), vec3<f32>(-1.0, 0.0, 1.0), vec3<f32>(1.0, 0.0, -1.0), vec3<f32>(-1.0, 0.0, -1.0),
      vec3<f32>(0.0, 1.0, 1.0), vec3<f32>(0.0, -1.0, 1.0), vec3<f32>(0.0, -1.0, -1.0), vec3<f32>(0.0, 1.0, -1.0),
    );
    #endif
`,Wn=`
#include "IrradianceVolumeData_frag"
    fn pow3(  x : f32 ) -> f32
    {
        return x*x*x;
    }

    struct IrradianceField {
        probeStartPosition: vec4<f32>,
        probeCounts:vec4<f32>,
        probeStep:f32,
        irradianceTextureWidth:f32,
        irradianceTextureHeight:f32,
        irradianceProbeSideLength:f32,
    };

    @group(1) @binding(auto)
    var irradianceMapSampler: sampler;
    @group(1) @binding(auto)
    var irradianceMap: texture_2d<f32>;
    @group(1) @binding(auto)
    var irradianceDepthMapSampler: sampler;
    @group(1) @binding(auto)
    var irradianceDepthMap: texture_2d<f32>;
    @group(2) @binding(7)
    var<storage,read> irradianceData : IrradianceVolumeData ;

    var<private> irradianceFieldSurface: IrradianceField;
    var<private> energyPreservation: f32 = 0.85;
    var<private> quaternion:vec4<f32> = vec4<f32>(0.0, -0.7071067811865475, 0.7071067811865475, 0.0);

    fn getIrradianceFieldSurface() -> IrradianceField{
        let data = irradianceData ;
        irradianceFieldSurface.probeStartPosition = vec4<f32>(data.startX, data.startY, data.startZ, 0.0);
        irradianceFieldSurface.probeCounts = vec4<f32>(data.gridXCount, data.gridYCount, data.gridZCount, 0.0);
        irradianceFieldSurface.probeStep = data.ProbeSpace;
        irradianceFieldSurface.irradianceTextureWidth = data.OctRTMaxSize;
        irradianceFieldSurface.irradianceTextureHeight = data.OctRTMaxSize;
        irradianceFieldSurface.irradianceProbeSideLength = data.OctRTSideSize;
        return irradianceFieldSurface;
    }

    fn rotateDir(n:vec3<f32>) -> vec3<f32>{
       return normalize(applyQuaternion(-n, quaternion));
    }

    fn square1f(v:f32) -> f32 {
        return v * v ;
     }

   fn square(v:vec3<f32>) -> vec3<f32>{
      return v*v;
   }

    fn getIrradiance() -> vec4<f32>{
        var irradiance = sampleIrradianceField();
        var outerVolumeFactor:f32 = getOuterVolume(irradianceFieldSurface, ORI_VertexVarying.vWorldPos.xyz);
        irradiance *= outerVolumeFactor;
       return irradiance ;
    }
    
    fn debugProbe(id:i32) -> vec4<f32>{
        getIrradianceFieldSurface();
        var direction = normalize(ORI_VertexVarying.vWorldNormal);
        direction = applyQuaternion(-direction, quaternion);
        var probeTextureUV : vec2<f32> = textureCoordFromDirection(normalize(direction),
            id,
            irradianceFieldSurface.irradianceTextureWidth,
            irradianceFieldSurface.irradianceTextureHeight,
            irradianceFieldSurface.irradianceProbeSideLength);

        var probeIrradiance: vec4<f32> = textureSampleLevel(irradianceMap, irradianceMapSampler, probeTextureUV ,0.0);
        return probeIrradiance;
    }
    
    fn debugProbeDepth(id:i32) -> vec4<f32>{
        getIrradianceFieldSurface();
        var direction = normalize(ORI_VertexVarying.vWorldNormal);
        direction = applyQuaternion(-direction, quaternion);
        var probeTextureUV : vec2<f32> = textureCoordFromDirection(normalize(direction),
            id,
            irradianceFieldSurface.irradianceTextureWidth,
            irradianceFieldSurface.irradianceTextureHeight,
            irradianceFieldSurface.irradianceProbeSideLength);
        
        var probeIrradiance: vec4<f32> = textureSampleLevel(irradianceDepthMap, irradianceDepthMapSampler, probeTextureUV ,0.0);
        probeIrradiance.x = probeIrradiance.x / irradianceData.maxDistance;
        probeIrradiance.y = 0.0;
        probeIrradiance.z = 0.0;
        probeIrradiance.w = 1.0;
        return probeIrradiance;
    }
    
    fn getOuterVolume(L:IrradianceField, position:vec3<f32>) -> f32{
        let halfWidth:vec3<f32> = 0.5 * (L.probeCounts.xyz - 1.0) * L.probeStep;
        let edgeWidth:vec3<f32> = halfWidth + L.probeStep;
        let centerPosition:vec3<f32> = halfWidth + L.probeStartPosition.xyz;
        let clampPos = min(edgeWidth, abs(position - centerPosition));
        
        let factorX = getOuterAxis(clampPos.x, edgeWidth.x, L.probeStep);
        let factorY = getOuterAxis(clampPos.y, edgeWidth.y, L.probeStep);
        let factorZ = getOuterAxis(clampPos.z, edgeWidth.z, L.probeStep);
        return factorX * factorY * factorZ;
    }
    
    fn getOuterAxis(current:f32, edge:f32, space:f32) -> f32{
        return clamp((edge - current) / space, 0.0, 1.0);
    }

    fn getBaseGridCoord(L:IrradianceField, X:vec3<f32>) -> vec3<i32> {
        var offsetIndex = (X - L.probeStartPosition.xyz) / irradianceFieldSurface.probeStep;
        return clamp(vec3<i32>(offsetIndex.xyz), vec3<i32>(0), vec3<i32>(L.probeCounts.xyz) - 1);
    }

    fn gridCoordToProbeIndex(L:IrradianceField, grid:vec3<i32>) -> i32
    {
        return grid.x + i32(L.probeCounts.x) * grid.z + grid.y * i32(L.probeCounts.z * L.probeCounts.x);
    }

    fn gridCoordToPosition(L:IrradianceField, grid:vec3<i32>) -> vec3<f32>
    {
        var pos:vec3<f32> = vec3<f32>(grid.xyz) * L.probeStep + L.probeStartPosition.xyz;
        return pos;
    }

    fn textureCoordFromDirection(dir:vec3<f32>, probeIndex:i32, width:f32, height:f32, sideLength:f32) -> vec2<f32>
    {
        var uv = getWriteOctUVByID(dir, u32(probeIndex), sideLength) ;
        uv.x = uv.x / irradianceFieldSurface.irradianceTextureWidth;
        uv.y = uv.y / irradianceFieldSurface.irradianceTextureHeight;
        return uv ;
    }

    fn getWriteOctUVByID(dir:vec3<f32> , probeID:u32, size: f32) -> vec2<f32>
    {
        var blockCount = u32(irradianceFieldSurface.probeCounts.x * irradianceFieldSurface.probeCounts.z) ;
        var offsetX = (probeID % blockCount) % u32(irradianceFieldSurface.probeCounts.x) ;
        var offsetY = u32(irradianceFieldSurface.probeCounts.z - 1.0) - (probeID % blockCount) / u32(irradianceFieldSurface.probeCounts.x) ;
        var offsetZ = probeID / blockCount ;

        var pixelCoord = (( octEncode(dir) + 1.0 ) * 0.5) * vec2<f32>(size,size) ;

        var blockOffset = vec2<f32>(0.0);
        blockOffset.x = f32(offsetX) * size;
        blockOffset.y = f32(offsetY) * size + f32(offsetZ) * irradianceFieldSurface.probeCounts.z * size;

        let mapHeight = u32(irradianceFieldSurface.irradianceTextureHeight);
        var probeCounts:vec3<f32> = irradianceFieldSurface.probeCounts.xyz;

        var gridOffsetFrom = vec2<i32>(blockOffset) + 1;
        var gridOffsetTo = offsetByCol(gridOffsetFrom, size, mapHeight, probeCounts);

        pixelCoord = pixelCoord + vec2<f32>(gridOffsetTo - 1) + vec2<f32>(vec2<i32>(vec2<f32>(gridOffsetTo) / size) * 2);

        return pixelCoord + 1.0 ;
    }

    fn offsetByCol(pixelCoord0:vec2<i32>, octSideSize:f32, mapHeight:u32, counts:vec3<f32>) -> vec2<i32>
    {
      var pixelCoord = pixelCoord0;
      let blockSize:vec2<i32> = vec2<i32>(i32(octSideSize * counts.x),  i32(octSideSize * counts.z));
      let blockSizeYBorder:i32 = i32((octSideSize + 2.0) * counts.z);
      let blockMaxRowBorder:i32 = i32(mapHeight) / blockSizeYBorder;
      let pixelCountYMax:i32 = blockMaxRowBorder * i32(octSideSize * counts.z);
      let col:i32 = pixelCoord.y / pixelCountYMax;
      pixelCoord.x = col * i32(octSideSize * counts.x) + pixelCoord.x;
      pixelCoord.y = pixelCoord.y % pixelCountYMax;
      return pixelCoord;
    }

    var<private> wpNormal:vec3<f32> ;
    fn sampleIrradianceField() -> vec4<f32>{
        wpNormal = ORI_ShadingInput.Normal.xyz ;
        var wo:vec3<f32> = ORI_CameraWorldDir ;
        var wsN:vec3<f32> = normalize(wpNormal);
        var direction:vec3<f32> = wpNormal;
        var worldPosition: vec3<f32> = ORI_VertexVarying.vWorldPos.xyz;
   
        getIrradianceFieldSurface();

        let surfaceBias = (wsN + 3.0 * wo) * irradianceData.normalBias ;

        var irradiance = vec3<f32>(0.0, 0.0, 0.0);
        var accumulatedWeights = 0.0;
        var biasedWorldPosition = (worldPosition + surfaceBias);

        var baseProbeCoords: vec3<i32> = getBaseGridCoord(irradianceFieldSurface, worldPosition);
        
        var baseProbeWorldPosition: vec3<f32> = gridCoordToPosition(irradianceFieldSurface, baseProbeCoords) ;
        
        var gridSpaceDistance = (biasedWorldPosition - baseProbeWorldPosition);

        // alpha is how far from the floor(currentVertex) position. on [0, 1] for each axis.
        var alpha: vec3<f32> = clamp(gridSpaceDistance / (irradianceFieldSurface.probeStep), vec3<f32>(0.0), vec3<f32>(1.0));
        // let irradianceDir = rotateDir(wsN.xyz);
        // Iterate over adjacent probe cage
        for (var i:i32 = 0; i < 8; i = i + 1) {
            var adjacentProbeOffset : vec3<i32> = vec3<i32>(i, i32(f32(i) * 0.5), i32(f32(i) * 0.25)) & vec3<i32>(1);
            var adjacentProbeCoords: vec3<i32> = clamp(baseProbeCoords + adjacentProbeOffset, vec3<i32>(0),  vec3<i32>(irradianceFieldSurface.probeCounts.xyz) - 1) ;
            
            var adjacentProbeIndex :i32 = gridCoordToProbeIndex(irradianceFieldSurface, adjacentProbeCoords);
            var adjacentProbeWorldPosition :vec3<f32> = gridCoordToPosition(irradianceFieldSurface, adjacentProbeCoords) ;//+ (wsN + 3.0 * w_o) * globalUniform.normalBias;
         
            var worldPosToAdjProbe = normalize(adjacentProbeWorldPosition - worldPosition);
            var biasedPosToAdjProbe = normalize(adjacentProbeWorldPosition - biasedWorldPosition);
            var biasedPosToAdjProbeDist = length(adjacentProbeWorldPosition - biasedWorldPosition);

            let trilinear = max(vec3<f32>(0.001), mix(1.0 - alpha, alpha, vec3<f32>(adjacentProbeOffset)));
            let trilinearWeight = (trilinear.x * trilinear.y * trilinear.z);
            var weight = 1.0;

            var wrapShading = (dot(worldPosToAdjProbe, direction) + 1.0) * 0.5;
            weight *= (wrapShading * wrapShading) + 0.2;

            var depthDir = -biasedPosToAdjProbe;//probe - world
            depthDir = applyQuaternion(depthDir, quaternion);
            var probeTextureUV : vec2<f32> = textureCoordFromDirection(depthDir.xyz,
                adjacentProbeIndex,
                irradianceFieldSurface.irradianceTextureWidth,
                irradianceFieldSurface.irradianceTextureHeight,
                irradianceFieldSurface.irradianceProbeSideLength);

            var filteredDistance : vec2<f32> = 2.0 * textureSampleLevel(irradianceDepthMap, irradianceDepthMapSampler, probeTextureUV,0.0).rg ;
           
            var variance = abs((filteredDistance.x * filteredDistance.x) - filteredDistance.y);

            var chebyshevWeight = 1.0;
            if(biasedPosToAdjProbeDist > filteredDistance.x ) // occluded
            {
                var v = biasedPosToAdjProbeDist - filteredDistance.x ;
                chebyshevWeight = variance / (variance + (v * v));
                // Increase the contrast in the weight
                chebyshevWeight = max((chebyshevWeight * chebyshevWeight * chebyshevWeight), 0.0);
            }

            weight *= max(0.05, chebyshevWeight);
            weight = max(0.000001, weight);

            let crushThreshold = 0.2;
            if (weight < crushThreshold)
            {
                weight *= (weight * weight) * (1.0 / (crushThreshold * crushThreshold));
            }

            weight *= trilinearWeight;
            
            //worldPosToAdjProbe
            let rotateDir = applyQuaternion(-direction, quaternion);
            probeTextureUV = textureCoordFromDirection((rotateDir),
            adjacentProbeIndex,
            irradianceFieldSurface.irradianceTextureWidth,
            irradianceFieldSurface.irradianceTextureHeight,
            irradianceFieldSurface.irradianceProbeSideLength);

            var probeIrradiance: vec3<f32> = textureSampleLevel(irradianceMap, irradianceMapSampler, probeTextureUV ,0.0).xyz;

            var exponent =  irradianceData.ddgiGamma * 0.5;
            probeIrradiance = pow(probeIrradiance, vec3<f32>(exponent));
            
            irradiance += (weight * probeIrradiance);
            accumulatedWeights += weight;
        }

        if(accumulatedWeights == 0.0){
            return vec4<f32>(0.0, 0.0, 0.0,1.0);
        }

        irradiance *= (1.0 / accumulatedWeights);   
        irradiance *= irradiance;                   

        irradiance *= 6.2831853071795864;
        irradiance *= irradianceData.indirectIntensity;
        return vec4<f32>(irradiance,1.0) ;
    }

`,jn=`
#include "Clearcoat_frag"
    #include "EnvMap_frag"
    #include "BrdfLut_frag"
    #include "ColorUtil_frag"
    
    struct FragData {
        Ao: f32,
        Metallic: f32,
        Roughness: f32,

        Albedo: vec4<f32>,
        Emissive: vec3<f32>,

        N: vec3<f32>,
        V: vec3<f32>,
        R: vec3<f32>,

        F0: vec3<f32>,
        F: vec3<f32>,
        KS: vec3<f32>,
        KD: vec3<f32>,
        Shadow: f32,
        Indirect: f32,
        Reflectance: f32,

        NoV: f32,
        FaceDirection:f32,

        ClearcoatRoughness:f32,
        EnvColor: vec3<f32>,
        Irradiance: vec3<f32>,

        LightChannel: vec3<f32>,
        TangentChannel: vec3<f32>,
    };

    var<private> fragData: FragData;

    struct BxDFContext
    {
        NoV : f32 ,
        NoL : f32 ,
        VoL : f32 ,
        NoH : f32 ,
        VoH : f32
    };

    fn getContext( N:vec3<f32>, V:vec3<f32>, H:vec3<f32>, L:vec3<f32> ) -> BxDFContext
    {
        var Context:BxDFContext ;
        Context.NoL = saturate(dot(N, L))  ;
        Context.NoV = saturate(dot(N, V))  ;
        Context.VoL = saturate(dot(V, L)) ;
        Context.NoH = saturate(dot(N, H));
        Context.VoH = saturate(dot(V, H));

        // Context.NoL = max(dot(N, L),0.0);
        // Context.NoV = max(dot(N, V),0.0);
        // Context.VoL = max(dot(V, L),0.0) ;
        // Context.NoH = saturate(dot(N, H));
        // Context.VoH = max(dot(V, H),0.0);
        return Context ;
    }

    // convert roughness to mipmapLevel
    fn roughnessToMipmapLevel( roughness: f32 , mipmapCount:i32 ) -> f32{
        let level = roughness * (1.7 - 0.7 * roughness );
        return level * f32(mipmapCount);
    }

    fn IORToF0(ior:f32)->f32{
        var dc = ior - 1.0 ;
        dc *= dc ;
        var dt = ior + 1.0 ;
        dt *= dt ;
        return dc / dt ;
    }

    fn Fd90( NoL:f32, roughness:f32) -> f32
    {
        return (2.0 * NoL * roughness) + 0.4;
    }

    fn KDisneyTerm( NoL:f32, NoV:f32 , roughness:f32) -> f32
    {
        return (1.0 + Fd90(NoL, roughness) * pow(1.0 - NoL, 5.0)) * (1.0 + Fd90(NoV, roughness) * pow(1.0 - NoV, 5.0));
    }

    fn FresnelSchlick( NoV:f32,  F0:vec3<f32>) -> vec3<f32>
    {
        return F0 + (1.0 - F0) * pow(1.0 - NoV, 5.0);
    }

    fn FresnelTerm( cosA:f32,  F0:vec3<f32>) -> vec3<f32>
    {
        let t = pow5( 1.0 - cosA );
        return F0 + (1.0 - F0) * t;
    }

    fn FresnelLerp( cosA:f32, F0:vec3<f32> , F90:vec3<f32>) -> vec3<f32>
    {
        let t = pow5( 1.0 - cosA );
        return mix( F0 ,F90,t ) ;
    }

    fn FresnelSchlickRoughness( NoV:f32,  F0:vec3<f32>,  roughness:f32) -> vec3<f32>
    {
        return F0 + (max(vec3(roughness), F0) - F0) * pow(1.0 - NoV, 5.0);
    }

    fn DistributionGGX( NdotH:f32 ,  roughness:f32 ) -> f32
    {
        let alpha = roughness * roughness;
        let alpha2 = roughness * roughness;

        let NdotH2 = NdotH * NdotH;

        let nom   = alpha2;
        var denom = (NdotH2 * (alpha2 - 1.0) + 1.0);
        denom = PI * denom * denom;

        return nom / denom;
    }

    // [Heitz 2014, "Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs"]
    fn Vis_SmithJoint( NoV : f32 ,  NoL : f32 ,  a2 : f32) -> f32
    {
        var Vis_SmithV = NoL * sqrt(NoV * (NoV - NoV * a2) + a2);
        var Vis_SmithL = NoV * sqrt(NoL * (NoL - NoL * a2) + a2);
        return 0.5 * rcp(Vis_SmithV + Vis_SmithL);
    }

    fn GeometrySchlickGGX( NdotV : f32 , roughness : f32 ) -> f32
    {
        //roughness compute ks
        let r = (roughness + 1.0);
        let k = (r*r) / 8.0;

        let nom   = NdotV;
        let denom = NdotV * (1.0 - k) + k;
        
        return nom / denom;
    }
    
    fn GeometrySmith( NdotV:f32 , NdotL:f32 , roughness : f32) -> f32
    {
        // let NdotV = max(dot(N, V), 0.0);
        // let NdotL = max(dot(N, L), 0.0);
        let ggx1 = GeometrySchlickGGX(NdotV, roughness);
        let ggx2 = GeometrySchlickGGX(NdotL, roughness);
        return ggx1 * ggx2;
    }

    fn GeometryAttenuationGGXSmith( NdotL:f32,  NdotV:f32,  roughness:f32) -> f32
    {
        var NdotL2 = NdotL * NdotL;
        var NdotV2 = NdotV * NdotV;
        var kRough2 = roughness * roughness + 0.0001;

        var ggxL = (2.0 * NdotL) / (NdotL + sqrt(NdotL2 + kRough2 * (1.0 - NdotL2)));
        var ggxV = (2.0 * NdotV) / (NdotV + sqrt(NdotV2 + kRough2 * (1.0 - NdotV2)));

        return ggxL * ggxV;
    }

    fn colorLinear( colorVector:vec3<f32> ) -> vec3<f32>
    {
        var linearColor = pow(colorVector.rgb, vec3<f32>(2.2));
        return linearColor;
    }

    fn computeFresnelSchlick( NoV:f32 , F0:vec3<f32>) -> vec3<f32>
    {
        return F0 + (1.0 - F0) * pow(clamp(1.0 - NoV,0.0,1.0), 5.0);
    }

    fn computeFresnelSchlickRoughness(NoV:f32 , F0:vec3<f32>,  roughness:f32) -> vec3<f32>
    {
        return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(clamp(1.0 - fragData.NoV,0.0,1.0), 5.0);
    }

    fn computeDistributionGGX( N:vec3<f32>,  H:vec3<f32>,  roughness:f32) -> f32
    {
        var alpha = roughness * roughness;
        var alpha2 = alpha * alpha; 

        var NdotH = saturate(dot(N, H));
        var NdotH2 = NdotH * NdotH;

        return (alpha2) / (PI * (NdotH2 * (alpha2 - 1.0) + 1.0) * (NdotH2 * (alpha2 - 1.0) + 1.0));
    }

    fn D_GGX( NoH:f32,  roughness:f32 ) -> f32
    {
        var d = ( NoH * roughness - NoH ) * NoH + 1.0;	// 2 mad
        return roughness / ( PI*d*d );					// 4 mul, 1 rcp
    }

    fn computeGeometryAttenuationGGXSmith( NdotL:f32 ,  NdotV:f32,  roughness:f32) -> f32
    {
        var NdotL2 = NdotL * NdotL;
        var NdotV2 = NdotV * NdotV;
        var kRough2 = roughness * roughness + 0.0001;

        var ggxL = (2.0 * NdotL) / (NdotL + sqrt(NdotL2 + kRough2 * (1.0 - NdotL2)));
        var ggxV = (2.0 * NdotV) / (NdotV + sqrt(NdotV2 + kRough2 * (1.0 - NdotV2)));

        return ggxL * ggxV;
    }

    fn Vis_Smith(  NoL:f32 ,  NoV:f32,  a2:f32 )-> f32
    {
        var Vis_SmithV = NoV + sqrt( NoV * (NoV - NoV * a2) + a2 );
        var Vis_SmithL = NoL + sqrt( NoL * (NoL - NoL * a2) + a2 );
        return rcp( Vis_SmithV * Vis_SmithL );
    }

    fn simpleBRDF( albedo:vec3<f32>, N:vec3<f32>, V:vec3<f32>,L:vec3<f32>,att:f32,lightColor:vec3<f32>,roughness:f32 ,metallic:f32)-> vec3<f32>{
        let H = normalize(V + L);
        let Context:BxDFContext = getContext(N,V,H,L);

        let F0 = mix(vec3<f32>(materialUniform.materialF0.rgb), albedo , metallic);
        let D = DistributionGGX( Context.NoH , roughness);
        let G = GeometrySmith(Context.NoV,Context.NoL, roughness );
        let F = FresnelSchlick(Context.VoH, vec3<f32>(F0));
        let specular = ( D * G * F ) / (4.0 * Context.NoV * Context.NoL + 0.001);
        let kS = F;
        var kd = 1.0 - kS ;
        kd *= 1.0 - metallic ;
        var diffuse = kd * (albedo.rgb / PI ) ;
        let ambient = specular.rgb ;

        fragData.KD += kd;
        fragData.KS += F;

        var col = (diffuse + ambient) * Context.NoL * lightColor * att ;
        // var col = (diffuse + ambient) * Context.NoL * lightColor ;
        return (col.rgb ) ;
    }

    fn getSpecularDominantDir (  N : vec3<f32> , R : vec3<f32> , roughness : f32 ) -> vec3<f32>
    {
        var smoothness = saturate (1.0 - roughness );
        var lerpFactor = smoothness * ( sqrt ( smoothness ) + roughness );
        // The result is not normalized as we fetch in a cubemap
        return mix (N, R, lerpFactor );
    }

    fn approximateSpecularIBL( specularColor:vec3<f32> , roughness:f32 , R:vec3<f32> , NoV:f32 ) -> vec3<f32> {
       
        let MAX_REFLECTION_LOD  = i32(textureNumLevels(prefilterMap)) ;
        let mip = roughnessToMipmapLevel(roughness,MAX_REFLECTION_LOD);
        var prefilteredColor: vec3<f32> = (textureSampleLevel(prefilterMap, prefilterMapSampler, getSpecularDominantDir(fragData.N,R,roughness) , mip ).rgb);
        prefilteredColor = globalUniform.skyExposure * (prefilteredColor);
        var envBRDF = textureSampleLevel(brdflutMap, brdflutMapSampler, vec2<f32>(NoV, roughness) , 0.0 ) ;
        return prefilteredColor * (specularColor.rgb * envBRDF.x + saturate( 50.0 * specularColor.g ) * envBRDF.y) ;
    }

    fn fresnel_coat(n:vec3<f32>,v:vec3<f32>,ior:f32) -> f32 {
        var f0 = (1.0-ior)/(1.0+ior);
        f0 = f0 * f0  ;
        let fr = pow((f0 + (1.0 - f0)*(1.0 - abs( max(dot(n,v),0.0) ))) , 5.0 ) ;  
        return fr ;
    }

    fn reflectEnvMap(n:vec3<f32> , v:vec3<f32> , roughness:f32) -> vec3<f32> {
        let MAX_REFLECTION_LOD  = i32(textureNumLevels(envMap)) ;
        let mip = roughnessToMipmapLevel(roughness,MAX_REFLECTION_LOD);
        let R = 2.0 * dot( v , n ) * n - v ;
        var prefilteredColor: vec3<f32> = globalUniform.skyExposure * (textureSampleLevel(envMap, envMapSampler, R , mip ).rgb);
        prefilteredColor = LinearToGammaSpace(prefilteredColor);
        return prefilteredColor ;
    }

    fn Specular_D_GGX( NoH:f32,  roughness:f32 ) -> f32
    {
        let a2 = roughness * roughness ;
        let f = (NoH * a2 - NoH) * NoH + 1.0;
        return a2 / (PI * f * f) ;
    }

    fn V_Kelemen( LoH : f32 ) -> f32 {
        return 0.25 / (LoH * LoH);
    }

    fn F_Schlick( f0:vec3<f32> ,  f90 : f32 ,  VoH : f32 ) -> vec3<f32> {
        return f0 + (f90 - f0) * pow(1.0 - VoH,5.0);
    }

    fn F_Schlick2(  SpecularColor:vec3<f32>,  VoH :f32 )-> vec3<f32> {
        var Fc = pow5( 1.0 - VoH );
        let rt = clamp(50.0 * SpecularColor.g,0.0,1.0) ;
        return rt * Fc + (1.0 - Fc) * SpecularColor;
    }

    fn oneMinusReflectivity ( metallic : f32 , F0:f32 ) -> f32 {
        let range = 1.0 - F0;
        return range - metallic * range;
    }

    //https://google.github.io/filament/Filament.html materialsystem/clearcoatmodel/clearcoatparameterization
    fn CoatSpecular_brdf( f:vec3<f32>, s:vec3<f32>, n:vec3<f32> , v:vec3<f32> , l:vec3<f32> , att:f32 , layer :vec3<f32> , clearcoatRoughnessFactor:f32 ) -> vec3<f32> {
        let H = normalize(v + l); 
        let VdotNc = max(dot(v,n),0.0);
        let LdotNc = max(dot(l,n),0.0);
        let NoH = max(dot(n,H),0.0);
        let LoH = saturate(dot(l, H))  ;
        let NoL = max(dot(n,l),0.0);

        let Fd = f ; 
        let Fr = s ; 

        let factor = clamp(clearcoatRoughnessFactor,0.089,1.0);
        let clearCoatRoughness = factor * factor ;

        let Dc = D_GGX( NoH , factor ) ;
        let Vc = V_Kelemen( LoH ) * NoL ;
        let Fc = F_Schlick(vec3<f32>(0.04), 2.0 , LoH); 
        let Frc = (Dc * Vc) * Fc ;
        // return layer * vec3<f32>((Fd + Fr * (1.0 - Fc)) * (1.0 - Fc) + Frc) * ( 0.5 + NoL * 0.5 ) ;
        return vec3<f32>(Frc) ;
    }

    #if USE_CLEARCOAT
    fn approximate_coating(base:vec3<f32> , clearColor: vec3<f32>, n:vec3<f32> , v:vec3<f32> , light:LightData , clearcoatRoughnessFactor:f32 ) -> vec3<f32> {
        let factor = clamp(clearcoatRoughnessFactor,0.084,1.0);
        var clearcoatAlpha = factor * factor + fragData.ClearcoatRoughness;

        // var lightColor = getHDRColor( lightCC.rgb , light.linear )  ;
        var att = light.intensity / LUMEN ;
        let l = light.direction ;
   
        let NdotV = max(dot(n,v),0.0);
        let MAX_REFLECTION_LOD  = f32(textureNumLevels(prefilterMap)) ;
        // let mip = roughnessToMipmapLevel(clearcoatAlpha,MAX_REFLECTION_LOD);
        let R = 2.0 * dot( v , n ) * n - v ;
        var envIBL: vec3<f32> = globalUniform.skyExposure * (textureSampleLevel(prefilterMap, prefilterMapSampler, R , MAX_REFLECTION_LOD * clearcoatRoughnessFactor ).rgb) ;
        // envIBL = LinearToGammaSpace(envIBL);

        let clearCoat = materialUniform.clearcoatFactor ;
        // let f = FresnelSchlickRoughness( max(dot(n,v),0.0) , vec3<f32>(0.0) , clearcoatAlpha ) ;
        let clearcoat_brdf =  CoatSpecular_brdf( vec3<f32>(0.04) , vec3<f32>( 0.04 ) , n , v , -l , att , vec3<f32>( 0.04 ) , factor ) ;

        // return clearcoat_brdf;+ fragData.ClearcoatRoughness 
        return mix(base, clearcoat_brdf,materialUniform.clearcoatWeight ) ;
    }
    #endif
   
`,qn=`
  #include "Clearcoat_frag"
  #include "BRDF_frag"
  #include "MathShader"
  #include "FastMathShader"
  #include "Common_frag"
  #include "GlobalUniform"

  #include "PhysicMaterialUniform_frag"
  #include "NormalMap_frag"
  #include "LightingFunction_frag"
  #include "Irradiance_frag"
  #include "ColorUtil_frag"
  #include "BxdfDebug_frag"


 
  //ORI_ShadingInput
  fn initFragData() {
      fragData.Albedo = ORI_ShadingInput.BaseColor * ORI_ShadingInput.BaseColor.a ;
      fragData.Ao = ORI_ShadingInput.AmbientOcclusion ; 
      fragData.Roughness = clamp(ORI_ShadingInput.Roughness,0.003,1.0) ; 
      fragData.Metallic = ORI_ShadingInput.Metallic ; 
      fragData.Emissive = ORI_ShadingInput.EmissiveColor.rgb ; 
      fragData.N = ORI_ShadingInput.Normal;
      let viewDir = normalize(globalUniform.CameraPos.xyz - ORI_VertexVarying.vWorldPos.xyz) ;
      fragData.V = viewDir ;
    //   fragData.V = normalize(globalUniform.cameraWorldMatrix[3].xyz - ORI_VertexVarying.vWorldPos.xyz) ;

      let R = 2.0 * dot( fragData.V , fragData.N ) * fragData.N - fragData.V ;
      fragData.R = R ;//reflect( fragData.V , fragData.N ) ;

      fragData.NoV = saturate(dot(fragData.N, fragData.V)) ;

      fragData.F0 = mix(vec3<f32>(materialUniform.materialF0.rgb), fragData.Albedo.rgb, fragData.Metallic);
      
      fragData.F = computeFresnelSchlick(fragData.NoV, fragData.F0);
      fragData.KD = vec3<f32>(fragData.F) ;
      fragData.KS = vec3<f32>(0.0) ;

      fragData.Indirect = 0.0 ;
      fragData.Reflectance = 1.0 ;

      fragData.ClearcoatRoughness = materialUniform.clearcoatRoughnessFactor ;
      #if USE_CLEARCOAT_ROUGHNESS
        fragData.ClearcoatRoughness = getClearcoatRoughness() * materialUniform.clearcoatRoughnessFactor;
      #endif
  }

  fn BxDFShading(){
      initFragData();

      var irradiance = vec3<f32>(0.0) ;
      #if USEGI
          irradiance += getIrradiance().rgb ;
      #else
          let MAX_REFLECTION_LOD  = f32(textureNumLevels(prefilterMap)) ;
          irradiance += (globalUniform.skyExposure * textureSampleLevel(prefilterMap, prefilterMapSampler, fragData.N.xyz, 0.8 * (MAX_REFLECTION_LOD) ).rgb);
      #endif
      irradiance = LinearToGammaSpace(irradiance.rgb);
      fragData.Irradiance = irradiance.rgb ;

      #if USE_TANGENT
        fragData.TangentChannel = vec3<f32>(ORI_VertexVarying.TANGENT.w);// ORI_VertexVarying.TANGENT.xyz * ORI_VertexVarying.TANGENT.w ;
      #endif

      //***********lighting-PBR part********* 
      var specColor = vec3<f32>(0.0) ;
      let lightIndex = getCluster();
      let start = max(lightIndex.start, 0.0);
      let count = max(lightIndex.count, 0.0);
      let end = max(start + count , 0.0);
      for(var i:i32 = i32(start) ; i < i32(end); i += 1 )
      {
        let light = getLight(i32(i));

        switch (light.lightType) {
          case PointLightType: {
            specColor += pointLighting( fragData.Albedo.rgb,ORI_VertexVarying.vWorldPos.xyz,fragData.N,fragData.V,fragData.Roughness,fragData.Metallic,light) ;
          }
          case DirectLightType: {
            specColor += directLighting( fragData.Albedo.rgb ,fragData.N,fragData.V,fragData.Roughness ,fragData.Metallic, light , globalUniform.shadowBias) ;
          }
          case SpotLightType: {
            specColor += spotLighting( fragData.Albedo.rgb,ORI_VertexVarying.vWorldPos.xyz,fragData.N,fragData.V,fragData.Roughness,fragData.Metallic , light ) ;
          }
          default: {
          }
        }
      }
      fragData.LightChannel = specColor ;


      //***********lighting-PBR part********* 
      var F = FresnelSchlickRoughness(fragData.NoV, fragData.F0, fragData.Roughness);
      var kS = F;
      var kD = vec3(1.0) - kS;
      kD = kD * (1.0 - fragData.Metallic);
      let env =  materialUniform.envIntensity * approximateSpecularIBL( F , fragData.Roughness , fragData.R , fragData.NoV ) ;
      fragData.EnvColor = env ;
      //***********indirect-specular part********* 
      
      var surfaceReduction = 1.0/(fragData.Roughness*fragData.Roughness+1.0);   //Reduce the reflection coefficient of non-metallic materials     
      var oneMinusReflectivity = oneMinusReflectivity(fragData.Metallic , materialUniform.materialF0.r );// materialUniform.materialF0.a - materialUniform.materialF0.a * fragData.Metallic ;
      var grazingTerm = clamp((1.0 - fragData.Roughness ) + (1.0 - oneMinusReflectivity),0.0,1.0);
      var t = pow5(fragData.NoV);
      var fresnelLerp = FresnelLerp(fragData.NoV,fragData.F0.rgb,vec3<f32>(grazingTerm)) ;   //Controlling Fresnel and metallic reflections
      var iblSpecularResult = surfaceReduction*env*fresnelLerp ;
      //***********indirect-specular part********* 
      
      //***********indirect-ambient part********* 
      var kdLast = (1.0 - fragData.F0.r) * (1.0 - fragData.Metallic);     //Dim the edges, there should be more specular reflection at the edges
      var iblDiffuseResult = irradiance * kdLast * fragData.Albedo.rgb ;
      //***********indirect-ambient part********* 
      let sunLight = lightBuffer[0] ;
      var indirectResult = (iblSpecularResult + iblDiffuseResult) * fragData.Ao * max(sunLight.quadratic,0.05) ;
      // let test = indirectResult ;

      ORI_FragmentOutput.color = vec4<f32>(0.0);

      // Using stripped down, 'pure log', formula. Parameterized by grey points and dynamic range covered.
      #if USEGBUFFER
          var normal_rgba8unorm = (ORI_VertexVarying.vWorldNormal + 1.0) * 0.5;
          normal_rgba8unorm = clamp(normal_rgba8unorm, vec3<f32>(0.0), vec3<f32>(1.0));
      #endif
      
      // ORI_FragmentOutput.color = vec4<f32>(ORI_FragmentOutput.color.xyz,fragData.Albedo.a) ;
      #if USE_WORLDPOS
          ORI_FragmentOutput.worldPos = vec4<f32>(ORI_VertexVarying.vWorldPos.xyzw);
      #endif

      #if USEGBUFFER
          ORI_FragmentOutput.worldNormal = vec4<f32>(normal_rgba8unorm,1.0);
          ORI_FragmentOutput.material = vec4<f32>(1.0,fragData.Roughness,fragData.Metallic,1.0);
      #endif
      
      var color = specColor + indirectResult ;
      color += fragData.Emissive.xyz ;

      var clearCoatColor = vec3<f32>(0.0);
      #if USE_CLEARCOAT
        let clearCoatBaseColor = vec3<f32>(1.0) * materialUniform.baseColor.rgb ;
        let clearNormal = fragData.N ;
        let clearcoatRoughness = fragData.ClearcoatRoughness ;
        let att = sunLight.intensity / LUMEN ;
        let clearCoatLayer = ClearCoat_BRDF( color , materialUniform.clearcoatColor.rgb , materialUniform.ior , clearNormal , -sunLight.direction ,-fragData.V , materialUniform.clearcoatWeight , clearcoatRoughness , att );
        color = vec3<f32>(clearCoatLayer.rgb/fragData.Albedo.a) ; 
      #endif
      
      ORI_FragmentOutput.color = vec4<f32>(LinearToGammaSpace(color.rgb),fragData.Albedo.a) ;

      // var iblSpecularResult = surfaceReduction*env*fresnelLerp ;
      // ORI_FragmentOutput.color = vec4<f32>(vec3<f32>(test),fragData.Albedo.a) ;
  }

  `,Kn=`
    #if USE_CLEARCOAT_ROUGHNESS
    @group(1) @binding(auto)
    var clearCoatRoughnessMapSampler: sampler;
    @group(1) @binding(auto)
    var clearCoatRoughnessMap: texture_2d<f32>;

    fn getClearcoatRoughness() -> f32{
        let clearcoatRoughness = textureSample(clearCoatRoughnessMap, clearCoatRoughnessMapSampler, ORI_VertexVarying.fragUV0.xy).r;
        return clearcoatRoughness;
    }
    #else
    fn getClearcoatRoughness() -> f32{
        return 1.0;
    }
    #endif

    #if USE_CLEARCOAT
    fn ClearCoat_BRDF( baseColor:vec3<f32>, clearCoatColor:vec3<f32> , ior:f32 ,N:vec3<f32>, L:vec3<f32> ,  V:vec3<f32> , clearCoatStrength:f32, clearCoatPerceptualRoughness:f32 , att:f32) -> vec3<f32> {
        var factor = clamp(clearCoatPerceptualRoughness, 0.0001, 1.0);
        var clearCoatRoughness = factor * factor;

        let H = normalize(-V + L);
        let R = 2.0 * dot( -V , N ) * N + V ;
        let LoH = dot(L,H);
        let NoV = max(dot(N,-V),0.0);
        let NoL = max(dot(N,L),0.0);
        let NoH = max(dot(N,H),0.00001);

        let Fr = FresnelSchlickRoughness( NoV , vec3<f32>(0.0) , clearCoatRoughness ) ;
        var Fd = clearCoatColor / 3.1415926 ;
        let F0 = IORToF0(ior) ;
        // clear coat BRDF
        var Dc = D_GGX(NoH,clearCoatRoughness);
        var Vc = V_Kelemen(LoH) * NoL;
        var Fc = F_Schlick( vec3<f32>(F0) , 1.0, NoV) * materialUniform.clearcoatFactor;
        var Frc = (Dc * Vc) * Fc;
        // base layer attenuation for energy compensation
        let oneMinusFc  = 1.0 - Fc;
        let brdfSpecular = ((Fd + Fr * oneMinusFc) * oneMinusFc + Frc)  * att ; 
        var iblSpecular = vec3<f32>(brdfSpecular);
        iblSpecular += approximateSpecularIBL(vec3<f32>(1.0),clearCoatRoughness,R, NoV) * Fc ;
        return vec3<f32>(mix(baseColor,iblSpecular,materialUniform.clearcoatWeight));
    }
    #endif
`,Jn=`
    #include "Common_vert"
    #include "Common_frag"
    #include "BxDF_frag"

    fn vert(inputData:VertexAttributes) -> VertexOutput {
        ORI_Vert(inputData) ;
        return ORI_VertexOut ;
    }

    fn frag(){
        ORI_ShadingInput.BaseColor = materialUniform.baseColor ;
        ORI_ShadingInput.Roughness = materialUniform.roughness  ;
        ORI_ShadingInput.Metallic = materialUniform.metallic ;
        ORI_ShadingInput.Specular = 0.5 ;
        ORI_ShadingInput.AmbientOcclusion = materialUniform.ao ;
        ORI_ShadingInput.EmissiveColor = vec4<f32>(0.0);

        ORI_ShadingInput.Normal = ORI_VertexVarying.vWorldNormal.rgb ;

        BxDFShading();
    }
`,Zn=`
    #include "Common_vert"
    #include "Common_frag"
    #include "BxDF_frag"

    @group(1) @binding(auto)
    var baseMapSampler: sampler;
    @group(1) @binding(auto)
    var baseMap: texture_2d<f32>;

    @group(1) @binding(auto)
    var normalMapSampler: sampler;
    @group(1) @binding(auto)
    var normalMap: texture_2d<f32>;

    #if USE_ARMC
        @group(1) @binding(auto)
        var maskMapSampler: sampler;
        @group(1) @binding(auto)
        var maskMap: texture_2d<f32>;
    #endif

    #if USE_MR
        @group(1) @binding(auto)
        var maskMapSampler: sampler;
        @group(1) @binding(auto)
        var maskMap: texture_2d<f32>;
    #endif

    #if USE_AOTEX
        @group(1) @binding(auto)
        var aoMapSampler: sampler;
        @group(1) @binding(auto)
        var aomapMap: texture_2d<f32>;
    #endif

    @group(1) @binding(auto)
    var emissiveMapSampler: sampler;
    @group(1) @binding(auto)
    var emissiveMap: texture_2d<f32>;

    fn vert(inputData:VertexAttributes) -> VertexOutput {
        ORI_Vert(inputData) ;
        return ORI_VertexOut ;
    }

    fn frag(){
        var transformUV1 = materialUniform.transformUV1;
        var transformUV2 = materialUniform.transformUV2;

        var uv = transformUV1.zw * ORI_VertexVarying.fragUV0 + transformUV1.xy; 

        ORI_ShadingInput.BaseColor = textureSample(baseMap, baseMapSampler, uv ) ;
        ORI_ShadingInput.BaseColor = vec4<f32>(gammaToLiner(ORI_ShadingInput.BaseColor.rgb*ORI_ShadingInput.BaseColor.w ) * materialUniform.baseColor.rgb,ORI_ShadingInput.BaseColor.w*materialUniform.baseColor.a)  ;
        #if USE_ALPHACUT
            if( (ORI_ShadingInput.BaseColor.a - materialUniform.alphaCutoff) <= 0.0 ){
                ORI_FragmentOutput.color = vec4<f32>(0.0,0.0,0.0,1.0);
                ORI_FragmentOutput.worldPos = vec4<f32>(0.0,0.0,0.0,1.0);
                ORI_FragmentOutput.worldNormal = vec4<f32>(0.0,0.0,0.0,1.0);
                ORI_FragmentOutput.material = vec4<f32>(0.0,0.0,0.0,1.0);
                discard;
            }
        #endif

        #if USE_SHADOWMAPING
            useShadow();
        #endif

        #if USE_ARMC
            var maskTex = textureSample(maskMap, maskMapSampler, uv ) ;

            ORI_ShadingInput.AmbientOcclusion = maskTex.r * materialUniform.ao ; 

            #if USE_AOTEX
                var aoMap = textureSample(aomapMap, aoMapSampler, uv );
                ORI_ShadingInput.AmbientOcclusion = mix(0.0,aoMap.r,materialUniform.ao) ;
            #endif

            ORI_ShadingInput.Roughness = maskTex.g * materialUniform.roughness ;
            ORI_ShadingInput.Metallic =  maskTex.b * materialUniform.metallic ;

        #elseif USE_MR
            var maskTex = textureSample(maskMap, maskMapSampler, uv ) ;
            #if USE_AOTEX
                var aoMap = textureSample(aomapMap, aoMapSampler, uv );
                ORI_ShadingInput.AmbientOcclusion = mix(0.0,aoMap.r,materialUniform.ao) ;
            #else
                ORI_ShadingInput.AmbientOcclusion = materialUniform.ao ; 
            #endif

            ORI_ShadingInput.Roughness = maskTex.g * materialUniform.roughness ;
            ORI_ShadingInput.Metallic =  maskTex.b * materialUniform.metallic;
        #else
            ORI_ShadingInput.Roughness = materialUniform.roughness ;
            ORI_ShadingInput.Metallic = materialUniform.metallic ;
            ORI_ShadingInput.AmbientOcclusion =  materialUniform.ao ;
            #if USE_AOTEX
                var aoMap = textureSample(aomapMap, aoMapSampler, uv );
                ORI_ShadingInput.AmbientOcclusion = mix(0.0,aoMap.r,materialUniform.ao) ;
            #endif
        #endif

        ORI_ShadingInput.Roughness = clamp(ORI_ShadingInput.Roughness,0.084,1.0);
        ORI_ShadingInput.Specular = 0.5 ;

        var emissiveColor = textureSample(emissiveMap, emissiveMapSampler , ORI_VertexVarying.fragUV0.xy) ;
        emissiveColor = vec4<f32>(gammaToLiner(emissiveColor.rgb),emissiveColor.w);
        ORI_ShadingInput.EmissiveColor = vec4<f32>(materialUniform.emissiveColor.rgb * emissiveColor.rgb * materialUniform.emissiveIntensity,1.0);

        var Normal = textureSample(normalMap,normalMapSampler,uv).rgb ;
        // Normal.y = 1.0 - Normal.y ;
        // let normal = unPackNormal(Normal,1.0,materialUniform.normalScale) ;
        let normal = unPackNormal(Normal,materialUniform.normalScale) ;  
        ORI_ShadingInput.Normal = normal ;

        BxDFShading();
    }
`,$n=`
#include "ClusterDebug_frag" 

        fn debugPosition(){
            ORI_FragmentOutput.color = vec4<f32>(ORI_VertexVarying.vWorldPos.xyz,1.0);
        }

        fn debugMeshID(){
            let meshIDColor = u32(ORI_VertexVarying.vWorldPos.w ) ;
            let color = colorSet[ meshIDColor % 9u] ;
            ORI_FragmentOutput.color = vec4<f32>(vec3<f32>(color.rgb),1.0);
        }

        fn debugNormal(){
            ORI_FragmentOutput.color = vec4<f32>(ORI_ShadingInput.Normal.xyz,1.0);
        }

        fn debugUV(){
            ORI_FragmentOutput.color = vec4<f32>(ORI_VertexVarying.fragUV0.xy,0.0,1.0);
        }

        fn debugColor(){
            ORI_FragmentOutput.color = vec4<f32>(fragData.Albedo.rgb,1.0);
        }

        fn debugDiffuse(){
            ORI_FragmentOutput.color = vec4<f32>( fragData.LightChannel.rgb,1.0);
            // ORI_FragmentOutput.color = vec4<f32>(0.2,0.2,0.2,1.0);
        }

        fn debugAmbient(){
            ORI_FragmentOutput.color = vec4<f32>(fragData.Irradiance * fragData.Albedo.rgb,1.0);
        }
        
        fn debugEmissive(){
            ORI_FragmentOutput.color = vec4<f32>(fragData.Emissive.rgb,1.0);
        }

        fn debugEnvment(){
            ORI_FragmentOutput.color = vec4<f32>(fragData.EnvColor.rgb,1.0);
        }

        fn debugAo(){
            ORI_FragmentOutput.color = vec4<f32>(vec3<f32>(fragData.Ao),1.0);
        }

        fn debugRoughness(){
            ORI_FragmentOutput.color = vec4<f32>(vec3<f32>(fragData.Roughness),1.0);
        }

        fn debugMetallic(){
            ORI_FragmentOutput.color = vec4<f32>(vec3<f32>(fragData.Metallic),1.0);
        }

        fn debugIrradiance(){
            ORI_FragmentOutput.color = vec4<f32>(vec3<f32>(fragData.Irradiance),1.0);
        }

        fn debugTangent(){
            ORI_FragmentOutput.color = vec4<f32>(vec3<f32>(fragData.TangentChannel),1.0);
        }

        fn debugFragmentOut(){
            if(ORI_VertexVarying.fragCoord.x > globalUniform.renderState_split) {
                switch (globalUniform.renderState_right)
                {
                  case 0: {
                    debugPosition();
                  }
                  case 1: {
                    debugColor();
                  }
                  case 2: {
                    debugNormal();
                  }
                  case 3: {
                    debugIrradiance();
                  }
                  case 4: {
                    debugTangent();
                  }
                  case 5: {
                    // debugTangent();
                  }
                  case 6: {
                    debugEmissive();
                  }
                  case 7: {
                    debugEnvment();
                  }
                  case 8: {
                    debugAo();
                  }
                  case 9: {
                    debugRoughness();
                  }
                  case 10: {
                    debugMetallic();
                  }
                  case 11: {
                    debugDiffuse();
                  }
                  case 12: {
                    debugAmbient();
                  }
                  case 13: {
                    debugMeshID();
                  }
                  case 14: {
                    #if DEBUG_CLUSTER
                      debugCluster( ORI_VertexVarying.fragCoord );
                    #endif
                  }
                  case 15: {
                    #if DEBUG_CLUSTER
                      debugClusterBox( ORI_VertexVarying.fragCoord );
                    #endif
                  }
                  case 16: {
                    #if DEBUG_CLUSTER
                      debugClusterLightCount( vec4<f32>(ORI_VertexVarying.fragCoord.xyz,0.0));
                      #endif
                  }
                  default: {
                  }
                }
              } else {
                switch (globalUniform.renderState_left)
                {
                  case 0: {
                    debugPosition();
                  }
                  case 1: {
                    debugColor();
                  }
                  case 2: {
                    debugNormal();
                  }
                  case 3: {
                    debugIrradiance();
                  }
                  case 4: {
                    debugTangent();
                  }
                  case 5: {
                    // debugTangent();
                  }
                  case 6: {
                    debugEmissive();
                  }
                  case 7: {
                    debugEnvment();
                  }
                  case 8: {
                    debugAo();
                  }
                  case 9: {
                    debugRoughness();
                  }
                  case 10: {
                    debugMetallic();
                  }
                  case 11: {
                    debugDiffuse();
                  }
                  case 12: {
                    debugAmbient();
                  }
                  case 13: {
                    debugMeshID();
                  }
                  case 14: {
                    #if DEBUG_CLUSTER
                      debugCluster( ORI_VertexVarying.fragCoord );
                    #endif
                  }
                  case 15: {
                    #if DEBUG_CLUSTER
                      debugClusterBox( ORI_VertexVarying.fragCoord );
                    #endif
                  }
                  case 16: {
                    #if DEBUG_CLUSTER
                      debugClusterLightCount( vec4<f32>(ORI_VertexVarying.fragCoord.xyz,0.0));
                      #endif
                  }
                  default: {
                  }
                }
              }
        }
`,el=`
    #include "WorldMatrixUniform"
    #include "GlobalUniform"

    struct MaterialUniform {
    x:f32,
    y:f32,
    width:f32,
    height:f32,
    };

    struct VertexOutput {
        @location(0) fragUV: vec2<f32>,
        @builtin(position) position: vec4<f32>
    };

    @vertex
    fn main(@builtin(vertex_index) vertexIndex : u32, @builtin(instance_index) index : u32 ) -> VertexOutput {
        const pos = array(
        vec2(-1.0, -1.0), vec2(1.0, -1.0), vec2(-1.0, 1.0),
        vec2(-1.0, 1.0), vec2(1.0, -1.0), vec2(1.0, 1.0),
        );
        const uv = array(
        vec2(1.0, 0.0), vec2(1.0, 1.0), vec2(0.0, 1.0), 
        vec2(1.0, 0.0), vec2(0.0, 1.0), vec2(0.0, 0.0),
        );
        let id = u32(index) ;
        var output : VertexOutput;
        output.fragUV = uv[vertexIndex] ;
        output.position = vec4<f32>(pos[vertexIndex] , 0.0, 1.0) ;
        return output ;
    }
`,tl=`
#include "WorldMatrixUniform"
      #include "GlobalUniform"
   
      struct MaterialUniform {
        x:f32,
        y:f32,
        width:f32,
        height:f32,
      };

      struct VertexOutput {
          @location(0) fragUV: vec2<f32>,
          @builtin(position) member: vec4<f32>
      };

      @vertex
      fn main(@builtin(instance_index) index : u32,@location(0) position: vec3<f32>, @location(1) TEXCOORD_1: vec2<f32>) -> VertexOutput {
          let id = u32(index) ;
          let worldMatrix = models.matrix[id];

          let windowSize = vec2<f32>(globalUniform.windowWidth,globalUniform.windowHeight) ;

        //   let pos = worldMatrix[3].xy ;

          let size = vec2<f32>(worldMatrix[0].x,worldMatrix[1].y) / windowSize ;

          let uv = vec2(((TEXCOORD_1.xy * 2.0) - vec2<f32>(1.0)))  ;// / windowSize * size - offset ;

          return VertexOutput(TEXCOORD_1, vec4<f32>(uv, 0.0, 1.0));
      }
`,il=`
    struct FragmentOutput {
        @location(0) o_Target: vec4<f32>
    };

    var<private> fragUV1: vec2<f32>;
    var<private> o_Target: vec4<f32>;
    @group(1) @binding(0)
    var baseMapSampler: sampler;
    @group(1) @binding(1)
    var baseMap: texture_2d<f32>;

    @fragment
    fn main(@location(0) fragUV: vec2<f32>) -> FragmentOutput {
        var uv = fragUV ;
        uv.y = 1.0 - uv.y ;
        var color: vec4<f32> = textureSample(baseMap, baseMapSampler, uv );

        return FragmentOutput(color);
    }
`,rl=`
    struct FragmentOutput {
        @location(0) o_Target: vec4<f32>
    }; 

    var<private> fragUV1: vec2<f32>;
    var<private> o_Target: vec4<f32>;

    @group(1) @binding(0)
    var baseMapSampler: sampler;
    @group(1) @binding(1)
    var baseMap: texture_depth_2d ;

    fn Linear01Depth(  z : f32 ) -> f32
    {
        return 1.0 / (1.0 * z + 5000.0);
    }

    @fragment
    fn main(@location(0) fragUV: vec2<f32>) -> FragmentOutput {
        var uv = fragUV ;
        uv.y = 1.0 - uv.y ;
        var depth = textureSample(baseMap, baseMapSampler, uv , vec2<i32>(0) ) ;
        return FragmentOutput(vec4<f32>(depth,0.0,0.0,1.0));
    }
`,sl=`
    struct FragmentOutput {
        @location(0) o_Target: vec4<f32>
    };

    var<private> fragUV1: vec2<f32>;
    var<private> o_Target: vec4<f32>;

    @group(1) @binding(0)
    var baseMapSampler: sampler;
    @group(1) @binding(1)
    var baseMap: texture_depth_cube ;

    fn uvToXYZ( face : i32 ,  uv : vec2<f32> ) -> vec3<f32>
    {
        var out : vec3<f32> ;
        if(face == 0){
            out = vec3<f32>( 1.0, uv.y, -uv.x);
        }else if(face == 1){
            out = vec3<f32>( -1.0, uv.y, uv.x);
        }else if(face == 2){
            out = vec3<f32>( uv.x, -1.0, uv.y);
        }else if(face == 3){
            out = vec3<f32>( uv.x,  1.0, -uv.y);
        }else if(face == 4){
            out = vec3<f32>( uv.x, uv.y, 1.0);
        }else{	
            out = vec3<f32>( -uv.x, uv.y, -1.0);
        }
        return out ;
    }

    @fragment
    fn main(@location(0) fragUV: vec2<f32>) -> FragmentOutput {
        var uv = fragUV ;
        uv.y = 1.0 - uv.y ;
        var ii = 0.16 ;
        var ouv = vec3<f32>(0.0);
        if(uv.x < ii * 6.0){
            ouv = uvToXYZ(5,uv/ii);
        }
        if(uv.x < ii * 5.0){
            ouv = uvToXYZ(4,uv/ii);
        }
        if(uv.x < ii * 4.0){
            ouv = uvToXYZ(3,uv/ii);
        } 
        if(uv.x < ii * 3.0){
            ouv = uvToXYZ(2,uv/ii);
        }
        if(uv.x < ii * 2.0){
            ouv = uvToXYZ(1,uv/ii);
        }
        if(uv.x < ii * 1.0){
            ouv = uvToXYZ(0,uv/ii);
        }
        var depth = textureSample(baseMap, baseMapSampler, ouv ) ;
        depth = 1.0 - depth; 

        return FragmentOutput(vec4<f32>(depth,0.0,0.0,1.0));
    }
`,Xf=`
    struct FragmentOutput {
        @location(0) o_Target: vec4<f32>
    };

    var<private> fragUV1: vec2<f32>;
    var<private> o_Target: vec4<f32>;

    @group(1) @binding(0)
    var baseMapSampler: sampler;
    @group(1) @binding(1)
    var baseMap: texture_2d_array ;

    struct MaterialData{
        index:f32;
    }

    @fragment
    fn main(@location(0) fragUV: vec2<f32>) -> FragmentOutput {
        var uv = fragUV ;
        uv.y = 1.0 - uv.y ;
    
        var depth = textureSample(baseMap, baseMapSampler, ouv ) ;
        depth = 1.0 - depth; 

        return FragmentOutput(vec4<f32>(depth,0.0,0.0,1.0));
    }
`,ja=`
    fn getHDRColor(color: vec3<f32>, exposure: f32) -> vec3 < f32 > {
        // var newColor = color * (  1.0 / 255.0 ) ;
        return color * pow(2.4, exposure) ;
    }

    fn lambda2rgb(lambda : f32) -> vec3 < f32 > {
        let ultraviolet = 400.0;
        let infrared = 700.0;

        var a = (lambda - ultraviolet) / (infrared - ultraviolet);
        let c = 10.0;
        var b = vec3<f32>(a) - vec3<f32>(0.75, 0.5, 0.25);
        return max((1.0 - c * b * b), vec3<f32>(0.0));
    }

    fn CEToneMapping(color: vec3<f32>, adapted_lum: f32) -> vec3<f32>
    {
        return 1.0 - exp(-adapted_lum * color);
    }

    fn ACESToneMapping(color: vec3<f32>, adapted_lum: f32) -> vec3<f32>
    {
        let A = 2.51;
        let B = 0.03;
        let C = 2.43;
        let D = 0.59;
        let E = 0.14;

        var color2 = color * adapted_lum;
        color2 = (color2 * (A * color2 + B)) / (color2 * (C * color2 + D) + E);
        return color2;
    }

    fn gammaToLiner(color: vec3<f32>) -> vec3 < f32 > {
        let gammaCorrect = 2.4;
        var color2 = pow(color, vec3<f32>(gammaCorrect));
        return color2 ;
    }

    fn linerToGamma4(color: vec4<f32>) -> vec4 < f32 > {
        let gammaCorrect = 0.416666667;
        var color2 = pow(color, vec4<f32>(gammaCorrect));
        return color2 ;
    }

    fn linerToGamma3(color: vec3<f32>) -> vec3 < f32 > {
        let gammaCorrect = 0.416666667;
        var color2 = pow(color, vec3<f32>(gammaCorrect));
        return color2 ;
    }

    fn LinearToGammaSpace(linRGB0: vec3<f32>) -> vec3 < f32 > {
        var linRGB = max(linRGB0, vec3(0.0, 0.0, 0.0));
        linRGB.r = pow(linRGB.r, 0.416666667);
        linRGB.g = pow(linRGB.g, 0.416666667);
        linRGB.b = pow(linRGB.b, 0.416666667);
        return max(1.055 * linRGB - 0.055, vec3(0.0, 0.0, 0.0));
    }

    var<private>sRGB_2_LMS_MAT: mat3x3<f32> = mat3x3<f32>(
        17.8824, 43.5161, 4.1193,
        3.4557, 27.1554, 3.8671,
        0.02996, 0.18431, 1.4670,
    );

    var<private>LMS_2_sRGB_MAT: mat3x3<f32> = mat3x3<f32>(
        0.0809, -0.1305, 0.1167,
        -0.0102, 0.0540, -0.1136,
        -0.0003, -0.0041, 0.6935,
    );

    fn sRGB_2_LMS(RGB: vec3<f32>) -> vec3<f32>
    {
        return sRGB_2_LMS_MAT * RGB;
    }

    fn LMS_2_sRGB(LMS: vec3<f32>) -> vec3<f32>
    {
        return LMS_2_sRGB_MAT * LMS;
    }

    fn LinearToSrgbBranchless(lin: vec3<f32>) -> vec3<f32>
    {
        var lin2 = max(vec3<f32>(6.10352e-5), lin);
        return min(lin2 * 12.92, pow(max(lin2, vec3<f32>(0.00313067)), vec3<f32>(0.416666667)) * vec3<f32>(1.055) - vec3<f32>(0.055));
    }

    fn sRGBToLinear(color : vec3<f32>) -> vec3<f32>
    {
        let color2 = max(vec3<f32>(6.10352e-5), color);
        let c = 0.04045;
        if (color2.r > c && color2.g > c && color2.b > c) {
            return pow(color2 * (1.0 / 1.055) + 0.0521327, vec3<f32>(2.4));
        } else {
            return color2 * (1.0 / 12.92);
        }
    }

//     fn ReorientedBlendNormal(){
//         vec3 t = texture(baseMap,   uv).xyz * vec3( 2.0,  2.0, 2.0) + vec3(-1.0, -1.0,  0.0);
// vec3 u = texture(detailMap, uv).xyz * vec3(-2.0, -2.0, 2.0) + vec3( 1.0,  1.0, -1.0);
// vec3 r = normalize(t * dot(t, u) - u * t.z);
// return r;
//     }

//     fn UDNBlendNormal(){
    // vec3 t = texture(baseMap,   uv).xyz * 2.0 - 1.0;
    // vec3 u = texture(detailMap, uv).xyz * 2.0 - 1.0;
    // vec3 r = normalize(t.xy + u.xy, t.z);
    // return r;
//     }
`,al=`
    fn madfrac(A:f32, B:f32)-> f32 {
        return A*B-floor(A*B) ;
    }

    fn sampleRandomDir(count:u32,SAMPLE_COUNT:u32) -> vec3<f32>{
    var ray_dir = sphericalFibonacci(f32((count)), f32(SAMPLE_COUNT) );
    return normalize(ray_dir) ;
    }

    fn sphericalFibonacci( i : f32 ,  n : f32 ) -> vec3<f32>{
        const PHI = sqrt(5.0) * 0.5 + 0.5;
        let phi = 2.0 * PI * madfrac(i, PHI - 1);
        let cosTheta = 1.0 - (2.0 * i + 1.0) * (1.0 / n);
        let sinTheta = sqrt(saturate(1.0 - cosTheta*cosTheta));

        return vec3<f32>(
            cos(phi) * sinTheta,
            sin(phi) * sinTheta,
            cosTheta);

    }
`;class N{static init(){N.register("MathShader",Bs),N.register("FastMathShader",Gn),N.register("MatrixShader",Sc),N.register("GlobalUniform",Ts),N.register("WorldMatrixUniform",Xa),N.register("NormalMap_frag",Qn),N.register("LightingFunction_frag",Bn),N.register("PhysicMaterialUniform_frag",Tn),N.register("UnLitMaterialUniform_frag",Mn),N.register("VideoUniform_frag",Rn),N.register("InstanceUniform",zn),N.register("Inline_vert",Un),N.register("VertexAttributes_vert",Pn),N.register("Common_vert",Nn),N.register("Common_frag",On),N.register("FragmentVarying",Vn),N.register("ColorPassFragmentOutput",Wa),N.register("ClusterLight",_c),N.register("ShadingInput",Hn),N.register("IESProfiles_frag",Yn),N.register("ShadowMapping_frag",Xn),N.register("Irradiance_frag",Wn),N.register("IrradianceVolumeData_frag",Ln),N.register("BrdfLut_frag",Fn),N.register("EnvMap_frag",kn),N.register("ColorUtil_frag",ja),N.register("ColorUtil",ja),N.register("BRDF_frag",jn),N.register("BxDF_frag",qn),N.register("UnLit_frag",Dn),N.register("UnLit",tn),N.register("Clearcoat_frag",Kn),N.register("LitShader",Jn),N.register("PBRLItShader",Zn),N.register("ClusterDebug_frag",En),N.register("BxdfDebug_frag",$n),N.register("GenerayRandomDir",al),N.register("Quad_vert_wgsl",tl),N.register("Quad_frag_wgsl",il),N.register("Quad_depth2d_frag_wgsl",rl),N.register("Quad_depthCube_frag_wgsl",sl),N.register("sky_vs_frag_wgsl",Ur.sky_vs_frag_wgsl),N.register("sky_fs_frag_wgsl",Ur.sky_fs_frag_wgsl),N.register("Bloom_Brightness_frag_wgsl",Ci.Bloom_Brightness_frag_wgsl),N.register("Bloom_blur_frag_wgsl",Ci.Bloom_blur_frag_wgsl),N.register("Bloom_composite_frag_wgsl",Ci.Bloom_composite_frag_wgsl),N.register("LambertShader",wc),N.register("QuadGlsl_vs",xc),N.register("QuadGlsl_fs",vc),N.register("SkyGBuffer_fs",gc),N.register("gbuffer_vs",$o),N.register("gbuffer_fs",$o),N.register("castPointShadowMap_vert",cc),N.register("shadowCastMap_frag",fc),N.register("shadowCastMap_vert",uc),N.register("directionShadowCastMap_frag",dc),N.register("ZPass_shader_vs",Ac),N.register("ZPass_shader_fs",mc)}static register(e,t){N[e.toLowerCase()]||(N[e.toLowerCase()]=t)}static getShader(e){return N[e.toLowerCase()],N[e.toLowerCase()]}}const Se=class{constructor(i=0,e=0){o(this,"x",0),o(this,"y",0),this.x=i,this.y=e}static getAngle(i,e){return Math.atan2(e.y-i.y,e.x-i.x)}static slerp(i,e,t){let r=new Se,s=i.dot(e);if(s<0&&(e.x=-e.x,e.y=-e.y,s=-s),s>.9995)return r.x=i.x+t*(e.x-i.x),r.y=i.y+t*(e.y-i.y),r;let a=Math.acos(s),n=Math.sin(a),l=Math.sin((1-t)*a)/n,h=Math.sin(t*a)/n;return r.x=l*i.x+h*e.x,r.y=l*i.y+h*e.y,r}static lerp(i,e,t){return Se.HELP_0.copyFrom(i),Se.HELP_1.copyFrom(e),Se.HELP_0.scale(t),Se.HELP_1.scale(1-t),new Se(Se.HELP_0.x+Se.HELP_1.x,Se.HELP_0.y+Se.HELP_1.y)}set(i=0,e=0){return this.x=i,this.y=e,this}distance(i){return Math.sqrt(Math.pow(this.x-i.x,2)+Math.pow(this.y-i.y,2))}add(i,e){return e=e||new Se,e.x=this.x+i.x,e.y=this.y+i.y,e}sub(i,e){return e=e||new Se,e.x=this.x-i.x,e.y=this.y-i.y,e}scale(i){return this.x=this.x*i,this.y=this.y*i,this}multiply(i,e){return e=e||new Se,e.x=this.x*i,e.y=this.y*i,e}multiplyScaler(i){return this.x*=i,this.y*=i,this}divide(i,e){return e=e||new Se,e.x=this.x/i,e.y=this.y/i,e}neg(i){return i||(i=new Se),i.x=-i.x,i.y=-i.y,i}abs(){return Math.sqrt(this.x*this.x+this.y*this.y)}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}getAngle(i){return Math.atan2(i.y-this.y,i.x-this.x)}unt(i){i=i||new Se;let e=this.abs();return i.x=this.x/e,i.y=this.y/e,i}angleTo(i){let e=i.x-this.x,t=i.y-this.y;return Math.atan2(t,e)}equals(i){return Math.abs(this.x-i.x)<1e-6&&Math.abs(this.y-i.y)<1e-6}pal(i){let e=this.unt(),t=i.unt();return e.equals(t)?1:e.equals(t.neg())?-1:0}clone(){return new Se(this.x,this.y)}copyFrom(i){return this.x=i.x,this.y=i.y,this}dot(i){return this.x*i.x+this.y*i.y}normalize(){let i=this.abs();return this.x=this.x/i,this.y=this.y/i,this}addInPlace(i){return this.x+=i.x,this.y+=i.y,this}addScalar(i){return this.x+=i,this.y+=i,this}clampScalar(i,e){return this.x=Math.max(i,Math.min(e,this.x)),this.y=Math.max(i,Math.min(e,this.y)),this}};let Z=Se;o(Z,"HELP_0",new Se),o(Z,"HELP_1",new Se),o(Z,"ZERO",new Se(0,0)),o(Z,"SAFE_MAX",new Se(Number.MAX_SAFE_INTEGER,Number.MAX_SAFE_INTEGER)),o(Z,"SAFE_MIN",new Se(Number.MIN_SAFE_INTEGER,Number.MIN_SAFE_INTEGER));const Me=class{constructor(i=0,e=0,t=0,r=0){o(this,"x",0),o(this,"y",0),o(this,"z",0),o(this,"w",1),this.x=i,this.y=e,this.z=t,this.w=r}get width(){return this.z}get height(){return this.w}static crossVectors(i,e,t){t=t||new Me;var r=i.x,s=i.y,a=i.z,n=e.x,l=e.y,h=e.z;return t.x=s*h-a*l,t.y=a*n-r*h,t.z=r*l-s*n,t}static distance(i,e){let t=i.x-e.x,r=i.y-e.y,s=i.z-e.z,a=i.w-e.w;return Math.sqrt(t*t+r*r+s*s+a*a)}set(i,e,t,r){return this.x=i,this.y=e,this.z=t,this.w=r,this}multiplyScalar(i){return this.x*=i,this.y*=i,this.z*=i,this.w*=i,this}copyFrom(i){return this.x=i.x,this.y=i.y,this.z=i.z,this.w=i.w,this}clone(){return new Me(this.x,this.y,this.z,this.w)}};let j=Me;o(j,"X_AXIS",new Me(1,0,0)),o(j,"Y_AXIS",new Me(0,1,0)),o(j,"Z_AXIS",new Me(0,0,1)),o(j,"HELP_0",new Me),o(j,"HELP_1",new Me),o(j,"HELP_2",new Me),o(j,"EPSILON",1e-5),o(j,"HELP_3",new Me),o(j,"HELP_4",new Me),o(j,"HELP_5",new Me),o(j,"HELP_6",new Me),o(j,"ZERO",new Me),o(j,"ONE",new Me(1,1,1,1)),o(j,"LEFT",new Me(-1,0,0)),o(j,"RIGHT",new Me(1,0,0)),o(j,"UP",new Me(0,-1,0)),o(j,"DOWN",new Me(0,1,0)),o(j,"BACK",new Me(0,0,-1)),o(j,"FORWARD",new Me(0,0,1));var $e=(i=>(i[i.Number=0]="Number",i[i.Vector2=1]="Vector2",i[i.Vector3=2]="Vector3",i[i.Vector4=3]="Vector4",i[i.Color=4]="Color",i[i.Float32Array=5]="Float32Array",i))($e||{});class ${constructor(e){o(this,"size"),o(this,"memoryInfo"),o(this,"bindOnChange"),o(this,"_data"),o(this,"_type",$e.Number),o(this,"_x",0),o(this,"_y",0),o(this,"_z",0),o(this,"_w",0),this.data=e}get data(){return this._data}set data(e){this._data=e,this._type=$e.Number,e instanceof Z?(this.size=2,this._x=e.x,this._y=e.y,this._type=$e.Vector2):e instanceof g?(this.size=3,this._x=e.x,this._y=e.y,this._z=e.z,this._type=$e.Vector3):e instanceof j?(this.size=4,this._x=e.x,this._y=e.y,this._z=e.z,this._w=e.w,this._type=$e.Vector4):e instanceof z?(this.size=4,this._x=e.r,this._y=e.g,this._z=e.b,this._w=e.a,this._type=$e.Color):e instanceof Float32Array?(this.size=e.length,this._type=$e.Float32Array):(this.size=1,this._x=e,this._data=e,this._type=$e.Number)}getColor(e){return e?e.copyFrom(this._data):e=this._data,e}get color(){return new z(this._data.r,this._data.g,this._data.b,this._data.a)}set color(e){(this._x!=e.r||this._y!=e.g||this._z!=e.b||this._w!=e.a)&&(this._data.r=e.r,this._data.g=e.g,this._data.b=e.b,this._data.a=e.a,this._x=e.r,this._y=e.g,this._z=e.b,this._w=e.a,this.onChange())}get value(){return this._x}set value(e){this._x!=e&&(this._data=e,this._x=e,this.onChange())}get vector2(){return this._data}set vector2(e){(this._x!=e.x||this._y!=e.y)&&(this._data.x=e.x,this._data.y=e.y,this._x=e.x,this._y=e.y,this.onChange())}get vector3(){return this._data}set vector3(e){(this._x!=e.x||this._y!=e.y||this._z!=e.z)&&(this._data.x=e.x,this._data.y=e.y,this._data.z=e.z,this._x=e.x,this._y=e.y,this._z=e.z,this.onChange())}get vector4(){return this._data}set vector4(e){(this._x!=e.x||this._y!=e.y||this._z!=e.z||this._w!=e.w)&&(this._data.x=e.x,this._data.y=e.y,this._data.z=e.z,this._data.w=e.w,this._x=e.x,this._y=e.y,this._z=e.z,this._w=e.w,this.onChange())}onChange(){this.bindOnChange&&this.bindOnChange()}float32Array(e){this._data.set(e),this.onChange()}update(){switch(this._type){case $e.Number:this.memoryInfo.dataBytes.setFloat32(0*Float32Array.BYTES_PER_ELEMENT,this._data,!0);break;case $e.Vector2:this.memoryInfo.setVector2(0,this._data);break;case $e.Vector3:this.memoryInfo.setVector3(0,this._data);break;case $e.Vector4:this.memoryInfo.setVector4(0,this._data);break;case $e.Color:this.memoryInfo.setColor(0,this._data);break;case $e.Float32Array:this.memoryInfo.setFloat32Array(0,this._data);break}}}let Bt={clamp_to_edge:"clamp-to-edge",repeat:"repeat",mirror_repeat:"mirror-repeat"},Wf={zero:"zero",one:"one",src:"src",one_minus_src:"one-minus-src",src_alpha:"src-alpha",one_minus_src_alpha:"one-minus-src-alpha",dst:"dst",one_minus_dst:"one-minus-dst",dst_alpha:"dst-alpha",one_minus_dst_alpha:"one-minus-dst-alpha",src_alpha_saturated:"src-alpha-saturated",constant:"constant",one_minus_constant:"one-minus-constant"};const jf={srcFactor:"one",dstFactor:"zero",operation:"add"},qf={compare:"always",failOp:"keep",depthFailOp:"keep",passOp:"keep"};let vt={never:"never",less:"less",equal:"equal",less_equal:"less-equal",greater:"greater",not_equal:"not-equal",greater_equal:"greater-equal",always:"always"},ui={none:"none",front:"front",back:"back"},Nr={nearest:"nearest",linear:"linear"},Ms={point_list:"point-list",line_list:"line-list",line_strip:"line-strip",triangle_list:"triangle-list",triangle_strip:"triangle-strip"},G={r8unorm:"r8unorm",r8snorm:"r8snorm",r8uint:"r8uint",r8sint:"r8sint",r16uint:"r16uint",r16sint:"r16sint",r16float:"r16float",rg8unorm:"rg8unorm",rg8snorm:"rg8snorm",rg8uint:"rg8uint",rg8sint:"rg8sint",r32uint:"r32uint",r32sint:"r32sint",r32float:"r32float",rg16uint:"rg16uint",rg16sint:"rg16sint",rg16float:"rg16float",rgba8unorm:"rgba8unorm",rgba8unorm_srgb:"rgba8unorm-srgb",rgba8snorm:"rgba8snorm",rgba8uint:"rgba8uint",rgba8sint:"rgba8sint",bgra8unorm:"bgra8unorm",bgra8unorm_srgb:"bgra8unorm-srgb",rgb9e5ufloat:"rgb9e5ufloat",rgb10a2unorm:"rgb10a2unorm",rg11b10ufloat:"rg11b10ufloat",rg32uint:"rg32uint",rg32sint:"rg32sint",rg32float:"rg32float",rgba16uint:"rgba16uint",rgba16sint:"rgba16sint",rgba16float:"rgba16float",rgba32uint:"rgba32uint",rgba32sint:"rgba32sint",rgba32float:"rgba32float",stencil8:"stencil8",depth16unorm:"depth16unorm",depth24plus:"depth24plus",depth24plus_stencil8:"depth24plus-stencil8",depth32float:"depth32float",bc1_rgba_unorm:"bc1-rgba-unorm",bc1_rgba_unorm_srgb:"bc1-rgba-unorm-srgb",bc2_rgba_unorm:"bc2-rgba-unorm",bc2_rgba_unorm_srgb:"bc2-rgba-unorm-srgb",bc3_rgba_unorm:"bc3-rgba-unorm",bc3_rgba_unorm_srgb:"bc3-rgba-unorm-srgb",bc4_r_unorm:"bc4-r-unorm",bc4_r_snorm:"bc4-r-snorm",bc5_rg_unorm:"bc5-rg-unorm",bc5_rg_snorm:"bc5-rg-snorm",bc6h_rgb_ufloat:"bc6h-rgb-ufloat",bc6h_rgb_float:"bc6h-rgb-float",bc7_rgba_unorm:"bc7-rgba-unorm",bc7_rgba_unorm_srgb:"bc7-rgba-unorm-srgb",depth24unorm_stencil8:"depth24unorm-stencil8",depth32float_stencil8:"depth32float-stencil8"},Fr={uint8x2:"uint8x2",uint8x4:"uint8x4",sint8x2:"sint8x2",sint8x4:"sint8x4",unorm8x2:"unorm8x2",unorm8x4:"unorm8x4",snorm8x2:"snorm8x2",snorm8x4:"snorm8x4",uint16x2:"uint16x2",uint16x4:"uint16x4",sint16x2:"sint16x2",sint16x4:"sint16x4",unorm16x2:"unorm16x2",unorm16x4:"unorm16x4",snorm16x2:"snorm16x2",snorm16x4:"snorm16x4",float16x2:"float16x2",float16x4:"float16x4",float32:"float32",float32x2:"float32x2",float32x3:"float32x3",float32x4:"float32x4",uint32:"uint32",uint32x2:"uint32x2",uint32x3:"uint32x3",uint32x4:"uint32x4",sint32:"sint32",sint32x2:"sint32x2",sint32x3:"sint32x3",sint32x4:"sint32x4"},Kf={vertex:"vertex",instance:"instance"};class Ae{}o(Ae,"colorBufferTex_NAME","colorBufferTex"),o(Ae,"positionBufferTex_NAME","positionBufferTex"),o(Ae,"normalBufferTex_NAME","normalBufferTex"),o(Ae,"materialBufferTex_NAME","materialBufferTex"),o(Ae,"zBufferTexture_NAME","zBufferTexture"),o(Ae,"zPreDepthTexture_NAME","zPreDepthTexture"),o(Ae,"outTex_NAME","outTex");var Ue=(i=>(i[i.Default=1]="Default",i[i.IgnoreDepthPass=2]="IgnoreDepthPass",i[i.Sky=6]="Sky",i[i.Particle=10]="Particle",i[i.SkinnedMesh=16]="SkinnedMesh",i[i.MorphTarget=32]="MorphTarget",i[i.Terrain=64]="Terrain",i[i.UI=128]="UI",i))(Ue||{});class Tt{static addMask(e,t){return e|t}static removeMask(e,t){return e&~t}static hasMask(e,t){return(e&t)==t}}const kr=class{constructor(){o(this,"__refection"),o(this,"__size",0)}getValueType(){if(!this.__refection){let i=this;this.__refection=[];for(const e in i)if(!e.includes("__")){const t=i[e];let r={name:e,type:t.constructor.name};this.__refection.push(r)}}return this.__refection}static getValueSize(i){switch(i.constructor.name){case"Boolean":return 1*4;case"Number":return 1*4;case"f32":return 1*4;case"i32":return 1*4;case"u32":return 1*4;case"Float32Array":return i.byteLength*4;case"Vector2":return 2*4;case"Vector3":return 4*4;case"Vector4":return 4*4;case"Color":return 4*4;case"Array":let t=0;for(let r=0,s=i.length;r<s;r++)t+=kr.getValueSize(i[r]);return t}return 0}static Ref(i){return this.Get(i).getValueType()}static Get(i){let e=kr.__cacheStruct.get(i.prototype);return e||(e=new i,kr.__cacheStruct.set(i.prototype,e)),e}static GetSize(i){let e=this.Get(i);if(e.__size==0){for(const t in e)if(t.indexOf("__")==-1){const r=e[t];e.__size+=kr.getValueSize(r)}e.__size>4&&(e.__size=Math.ceil(e.__size/4)*4)}return e.__size}};let wi=kr;o(wi,"__cacheStruct",new Map);class ol{constructor(){o(this,"byteOffset"),o(this,"byteSize"),o(this,"offset",0),o(this,"dataBytes")}get x(){return this.dataBytes.getFloat32(0*Float32Array.BYTES_PER_ELEMENT,!0)}set x(e){this.dataBytes.setFloat32(0*Float32Array.BYTES_PER_ELEMENT,e,!0)}get y(){return this.dataBytes.getFloat32(1*Float32Array.BYTES_PER_ELEMENT,!0)}set y(e){this.dataBytes.setFloat32(1*Float32Array.BYTES_PER_ELEMENT,e,!0)}get z(){return this.dataBytes.getFloat32(2*Float32Array.BYTES_PER_ELEMENT,!0)}set z(e){this.dataBytes.setFloat32(2*Float32Array.BYTES_PER_ELEMENT,e,!0)}get w(){return this.dataBytes.getFloat32(3*Float32Array.BYTES_PER_ELEMENT,!0)}set w(e){this.dataBytes.setFloat32(3*Float32Array.BYTES_PER_ELEMENT,e,!0)}setX(e){this.x=e}setXY(e,t){this.x=e,this.y=t}setXYZ(e,t,r){this.x=e,this.y=t,this.z=r}setXYZW(e,t,r,s){this.x=e,this.y=t,this.z=r,this.w=s}setVector2Array(e){for(let t=0;t<e.length;t++){const r=e[t];this.dataBytes.setFloat32((t*2+0)*Float32Array.BYTES_PER_ELEMENT,r.x,!0),this.dataBytes.setFloat32((t*2+1)*Float32Array.BYTES_PER_ELEMENT,r.y,!0)}}setVector3Array(e){for(let t=0;t<e.length;t++){const r=e[t];this.dataBytes.setFloat32((t*3+0)*Float32Array.BYTES_PER_ELEMENT,r.x,!0),this.dataBytes.setFloat32((t*3+1)*Float32Array.BYTES_PER_ELEMENT,r.y,!0),this.dataBytes.setFloat32((t*3+2)*Float32Array.BYTES_PER_ELEMENT,r.z,!0)}}setVector4Array(e){for(let t=0;t<e.length;t++){const r=e[t];this.dataBytes.setFloat32((t*4+0)*Float32Array.BYTES_PER_ELEMENT,r.x,!0),this.dataBytes.setFloat32((t*4+1)*Float32Array.BYTES_PER_ELEMENT,r.y,!0),this.dataBytes.setFloat32((t*4+2)*Float32Array.BYTES_PER_ELEMENT,r.z,!0),this.dataBytes.setFloat32((t*4+3)*Float32Array.BYTES_PER_ELEMENT,r.w,!0)}}setColorArray(e){for(let t=0;t<e.length;t++){const r=e[t];this.dataBytes.setFloat32((t*4+0)*Float32Array.BYTES_PER_ELEMENT,r.r,!0),this.dataBytes.setFloat32((t*4+1)*Float32Array.BYTES_PER_ELEMENT,r.g,!0),this.dataBytes.setFloat32((t*4+2)*Float32Array.BYTES_PER_ELEMENT,r.b,!0),this.dataBytes.setFloat32((t*4+3)*Float32Array.BYTES_PER_ELEMENT,r.a,!0)}}setInt8(e,t=0){this.dataBytes.setInt8(t*Int8Array.BYTES_PER_ELEMENT,e)}getInt8(e=0){return this.dataBytes.getInt8(e*Int8Array.BYTES_PER_ELEMENT)}setInt16(e,t=0){this.dataBytes.setInt16(t*Int16Array.BYTES_PER_ELEMENT,e,!0)}getInt16(e=0){return this.dataBytes.getInt16(e*Int16Array.BYTES_PER_ELEMENT,!0)}setInt32(e,t=0){this.dataBytes.setInt32(t*Int32Array.BYTES_PER_ELEMENT,e,!0)}getInt32(e=0){return this.dataBytes.getInt32(e*Int32Array.BYTES_PER_ELEMENT,!0)}setFloat(e,t=0){this.dataBytes.setFloat32(t*Float32Array.BYTES_PER_ELEMENT,e,!0)}getFloat(e=0){return this.dataBytes.getFloat32(e*Float32Array.BYTES_PER_ELEMENT,!0)}setUint8(e,t=0){this.dataBytes.setUint8(t*Uint8Array.BYTES_PER_ELEMENT,e)}getUint8(e=0){return this.dataBytes.getUint8(e*Uint8Array.BYTES_PER_ELEMENT)}setUint16(e,t=0){this.dataBytes.setUint16(t*Uint16Array.BYTES_PER_ELEMENT,e,!0)}getUint16(e=0){return this.dataBytes.getUint16(e*Uint16Array.BYTES_PER_ELEMENT,!0)}setUint32(e,t=0){this.dataBytes.setUint32(t*Uint32Array.BYTES_PER_ELEMENT,e,!0)}getUint32(e=0){return this.dataBytes.getUint32(e*Uint32Array.BYTES_PER_ELEMENT,!0)}setArray(e,t){for(let r=0;r<t.length;r++){const s=t[r];this.dataBytes.setFloat32((e+r)*Float32Array.BYTES_PER_ELEMENT,s,!0)}}setFloat32Array(e,t){new Float32Array(this.dataBytes.buffer,this.dataBytes.byteOffset+e*Float32Array.BYTES_PER_ELEMENT,t.length).set(t)}setArrayBuffer(e,t){t instanceof Uint8Array?this.setUint8Array(e,t):t instanceof Uint16Array?this.setUint16Array(e,t):t instanceof Uint32Array?this.setUint32Array(e,t):t instanceof Int8Array?this.setInt8Array(e,t):t instanceof Int16Array?this.setInt16Array(e,t):t instanceof Int32Array?this.setInt32Array(e,t):t instanceof Float32Array&&this.setFloat32Array(e,t)}setInt8Array(e,t){new Int8Array(this.dataBytes.buffer,this.dataBytes.byteOffset+e*Int8Array.BYTES_PER_ELEMENT).set(t)}setInt16Array(e,t){new Int16Array(this.dataBytes.buffer,this.dataBytes.byteOffset+e*Int16Array.BYTES_PER_ELEMENT).set(t)}setInt32Array(e,t){new Int32Array(this.dataBytes.buffer,this.dataBytes.byteOffset+e*Int32Array.BYTES_PER_ELEMENT).set(t)}setUint8Array(e,t){new Uint8Array(this.dataBytes.buffer,this.dataBytes.byteOffset+e*Uint8Array.BYTES_PER_ELEMENT).set(t)}setUint16Array(e,t){new Uint16Array(this.dataBytes.buffer,this.dataBytes.byteOffset+e*Uint16Array.BYTES_PER_ELEMENT).set(t)}setUint32Array(e,t){new Uint32Array(this.dataBytes.buffer,this.dataBytes.byteOffset+e*Uint32Array.BYTES_PER_ELEMENT).set(t)}setData(e,t){this.dataBytes.setFloat32(e*Float32Array.BYTES_PER_ELEMENT,t,!0)}setVector2(e,t){this.dataBytes.setFloat32(e*Float32Array.BYTES_PER_ELEMENT,t.x,!0),this.dataBytes.setFloat32((e+1)*Float32Array.BYTES_PER_ELEMENT,t.y,!0)}setVector3(e,t){this.dataBytes.setFloat32(e*Float32Array.BYTES_PER_ELEMENT,t.x,!0),this.dataBytes.setFloat32((e+1)*Float32Array.BYTES_PER_ELEMENT,t.y,!0),this.dataBytes.setFloat32((e+2)*Float32Array.BYTES_PER_ELEMENT,t.z,!0)}setVector4(e,t){this.dataBytes.setFloat32(e*Float32Array.BYTES_PER_ELEMENT,t.x,!0),this.dataBytes.setFloat32((e+1)*Float32Array.BYTES_PER_ELEMENT,t.y,!0),this.dataBytes.setFloat32((e+2)*Float32Array.BYTES_PER_ELEMENT,t.z,!0),this.dataBytes.setFloat32((e+3)*Float32Array.BYTES_PER_ELEMENT,t.w,!0)}setColor(e,t){this.dataBytes.setFloat32(e*Float32Array.BYTES_PER_ELEMENT,t.r,!0),this.dataBytes.setFloat32((e+1)*Float32Array.BYTES_PER_ELEMENT,t.g,!0),this.dataBytes.setFloat32((e+2)*Float32Array.BYTES_PER_ELEMENT,t.b,!0),this.dataBytes.setFloat32((e+3)*Float32Array.BYTES_PER_ELEMENT,t.a,!0)}getData(e){return this.dataBytes.getFloat32(e*Float32Array.BYTES_PER_ELEMENT,!0)}writeFloat(e){this.dataBytes.setFloat32(this.offset,e,!0),this.offset+=Float32Array.BYTES_PER_ELEMENT}writeInt8(e){this.dataBytes.setInt8(this.offset,e),this.offset+=Int8Array.BYTES_PER_ELEMENT}writeInt16(e){this.dataBytes.setInt16(this.offset,e,!0),this.offset+=Int16Array.BYTES_PER_ELEMENT}writeInt32(e){this.dataBytes.setInt32(this.offset,e,!0),this.offset+=Int32Array.BYTES_PER_ELEMENT}writeUint8(e){this.dataBytes.setUint8(this.offset,e),this.offset+=Uint8Array.BYTES_PER_ELEMENT}writeUint16(e){this.dataBytes.setUint16(this.offset,e,!0),this.offset+=Uint16Array.BYTES_PER_ELEMENT}writeUint32(e){this.dataBytes.setUint32(this.offset,e,!0),this.offset+=Uint32Array.BYTES_PER_ELEMENT}writeVector2(e){this.writeFloat(e.x),this.writeFloat(e.y)}writeVector3(e){this.writeFloat(e.x),this.writeFloat(e.y),this.writeFloat(e.z)}writeVector4(e){this.writeFloat(e.x),this.writeFloat(e.y),this.writeFloat(e.z),this.writeFloat(e.w)}writeRGBColor(e){this.writeFloat(e.r),this.writeFloat(e.g),this.writeFloat(e.b)}writeArray(e){for(let t=0;t<e.length;t++){const r=e[t];this.writeFloat(r)}}writeFloat32Array(e){new Float32Array(this.dataBytes.buffer,this.dataBytes.byteOffset+this.offset).set(e),this.offset+=e.byteLength}writeInt8Array(e){new Int8Array(this.dataBytes.buffer,this.dataBytes.byteOffset+this.offset).set(e),this.offset+=e.byteLength}writeInt16Array(e){new Int16Array(this.dataBytes.buffer,this.dataBytes.byteOffset+this.offset).set(e),this.offset+=e.byteLength}writeInt32Array(e){new Int32Array(this.dataBytes.buffer,this.dataBytes.byteOffset+this.offset).set(e),this.offset+=e.byteLength}writeUint8Array(e){new Uint8Array(this.dataBytes.buffer,this.dataBytes.byteOffset+this.offset).set(e),this.offset+=e.byteLength}writeUint16Array(e){new Uint16Array(this.dataBytes.buffer,this.dataBytes.byteOffset+this.offset).set(e),this.offset+=e.byteLength}writeUint32Array(e){new Uint32Array(this.dataBytes.buffer,this.dataBytes.byteOffset+this.offset).set(e),this.offset+=e.byteLength}reset(){this.offset=0}destroy(){this.byteOffset=null,this.byteSize=null,this.offset=null,this.dataBytes=null}}class zr{constructor(){o(this,"shareDataBuffer"),o(this,"_byteOffset",0)}allocation(e){this.shareDataBuffer&&this.shareDataBuffer.byteLength<e?this._byteOffset=0:this.shareDataBuffer=new ArrayBuffer(e)}allocation_node(e){if(this._byteOffset+e>this.shareDataBuffer.byteLength)return console.error("memory not enough!",this._byteOffset,e,this.shareDataBuffer.byteLength),null;let t=new ol;return t.byteOffset=this._byteOffset,t.byteSize=e,t.dataBytes=new DataView(this.shareDataBuffer,this._byteOffset,t.byteSize),this._byteOffset+=t.byteSize,t}allocation_memory(e){return this._byteOffset+e.byteSize>this.shareDataBuffer.byteLength?(console.error("memory not enough!",this._byteOffset,e.byteSize,this.shareDataBuffer.byteLength),null):(e.byteOffset=this._byteOffset,e.dataBytes=new DataView(this.shareDataBuffer,this._byteOffset,e.byteSize),this._byteOffset+=e.byteSize,e)}reset(){this._byteOffset=0}destroy(e){this.shareDataBuffer=null,this._byteOffset=0}}class Jt{constructor(){o(this,"bufferType"),o(this,"buffer"),o(this,"memory"),o(this,"memoryNodes"),o(this,"seek"),o(this,"outFloat32Array"),o(this,"byteSize"),o(this,"usage"),o(this,"visibility",GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE),o(this,"mapAsyncBuffersOutstanding",0),o(this,"mapAsyncReady"),o(this,"_readBuffer"),o(this,"_dataView"),o(this,"_readFlag",!1),this.mapAsyncReady=[],this.memory=new zr,this.memoryNodes=new Map,this._dataView=new Float32Array(this.memory.shareDataBuffer)}debug(){}reset(e=!1,t=0,r){this.seek=0,this.memory.reset(),e&&this.createBuffer(this.usage,t,r)}setBoolean(e,t){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(1*4),this.memoryNodes.set(e,r)),r.setX(t?1:0)}setFloat(e,t){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(1*4),this.memoryNodes.set(e,r)),r.setX(t)}setInt8(e,t){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(1*1),this.memoryNodes.set(e,r)),r.setInt8(t)}setInt16(e,t){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(1*2),this.memoryNodes.set(e,r)),r.setInt16(t)}setInt32(e,t){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(1*4),this.memoryNodes.set(e,r)),r.setInt32(t)}setUint8(e,t){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(1*1),this.memoryNodes.set(e,r)),r.setUint8(t)}setUint16(e,t){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(1*2),this.memoryNodes.set(e,r)),r.setUint16(t)}setUint32(e,t){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(1*4),this.memoryNodes.set(e,r)),r.setUint32(t)}setVector2(e,t){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(2*4),this.memoryNodes.set(e,r)),r.setXY(t.x,t.y)}setVector3(e,t){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(3*4),this.memoryNodes.set(e,r)),r.setXYZ(t.x,t.y,t.z)}setVector4(e,t){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(4*4),this.memoryNodes.set(e,r)),r.setXYZW(t.x,t.y,t.z,t.w)}setVector4Array(e,t){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(4*4*t.length),this.memoryNodes.set(e,r)),r.setVector4Array(t)}setColor(e,t){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(4*4),this.memoryNodes.set(e,r)),r.setXYZW(t.r,t.g,t.b,t.a)}setColorArray(e,t){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(4*4*t.length),this.memoryNodes.set(e,r)),r.setColorArray(t)}setMatrix(e,t){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(16*4),this.memoryNodes.set(e,r)),r.setFloat32Array(0,t.rawData)}setMatrixArray(e,t){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(16*4*t.length),this.memoryNodes.set(e,r));for(let s=0;s<t.length;s++){const a=t[s];r.setFloat32Array(s*16,a.rawData)}}setArray(e,t){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(t.length*4),this.memoryNodes.set(e,r)),r.setArray(0,t)}setFloat32Array(e,t){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(t.length*4),this.memoryNodes.set(e,r)),r.setFloat32Array(0,t)}setInt32Array(e,t){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(t.length*4),this.memoryNodes.set(e,r)),r.setInt32Array(0,t)}setUint32Array(e,t){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(t.length*4),this.memoryNodes.set(e,r)),r.setUint32Array(0,t)}setStruct(e,t,r,s){let a=wi.Ref(e);wi.GetSize(e);let n=t,l=this.memoryNodes.get(n);l.reset();let h=r;s&&(h=h[s]);for(let u=0;u<a.length;u++){const c=a[u];let f=h[c.name];switch(c.type){case"Boolean":l.writeFloat(f);break;case"Number":l.writeFloat(f);break;case"Float32Array":l.writeFloat32Array(f);break;case"Vector2":l.writeVector2(f);break;case"Vector3":l.writeVector3(f);break;case"Vector4":l.writeVector4(f);break;case"Color":l.writeRGBColor(f);break;case"Array":l.writeArray(f);break}}}setStructArray(e,t,r){let s=t.length;for(let a=0;a<s;a++){const n=t[a];this.setStruct(e,a,n,r)}}clean(){this._dataView.fill(0,0,this._dataView.length)}apply(){S.device.queue.writeBuffer(this.buffer,0,this.memory.shareDataBuffer)}applyMapAsync(){this.mapAsyncWrite(new Float32Array(this.memory.shareDataBuffer),this.memory.shareDataBuffer.byteLength/4)}mapAsyncWrite(e,t){let r=S.device;if(e.length>0){let s=null;for(;this.mapAsyncReady.length&&(s=this.mapAsyncReady.shift(),s.usedSize!=e.byteLength);)s.destroy(),this.mapAsyncBuffersOutstanding--,s=null;s||(s=r.createBuffer({size:e.byteLength,usage:GPUBufferUsage.COPY_SRC|GPUBufferUsage.MAP_WRITE,mappedAtCreation:!0}),s.usedSize=e.byteLength,this.mapAsyncBuffersOutstanding++,this.mapAsyncBuffersOutstanding>10&&console.warn(` Warning: mapAsync requests from ${this.mapAsyncBuffersOutstanding} frames ago have not resolved yet.  MB of staging buffers allocated.`));let a=new Float32Array(e.buffer,e.byteOffset,t);new Float32Array(s.getMappedRange(0,t*4)).set(a),s.unmap();const l=r.createCommandEncoder();l.copyBufferToBuffer(s,0,this.buffer,0,t*4),r.queue.submit([l.finish()]),s.mapAsync(GPUMapMode.WRITE).then(()=>this.mapAsyncReady.push(s))}}destroy(e){this.memoryNodes&&this.memoryNodes.forEach(t=>{t.destroy()}),this.bufferType=null,this.seek=null,this.byteSize=null,this.usage=null,this.visibility=null,this.outFloat32Array=null,this.buffer&&this.buffer.destroy(),this.buffer=null,this.memory&&this.memory.destroy(),this.memory=null,this._readBuffer&&this._readBuffer.destroy()}createBuffer(e,t,r){let s=S.device;this.byteSize=t*4,this.usage=e,this.buffer&&this.destroy(),this.buffer=s.createBuffer({size:this.byteSize,usage:e,mappedAtCreation:!1}),this.memory.allocation(this.byteSize),r&&(this.memory.allocation_node(r.length*4).setArrayBuffer(0,r),this.apply())}createNewBuffer(e,t){let r=S.device,s=t*4,a=e;return this.buffer&&this.destroy(),r.createBuffer({size:s,usage:a,mappedAtCreation:!1})}createBufferByStruct(e,t,r){let s=wi.GetSize(t),a=s*r,n=S.device;this.buffer=n.createBuffer({size:a,usage:e,mappedAtCreation:!1}),this.memory.allocation(a);for(let l=0;l<r;l++){let h=l,u=this.memoryNodes.get(h);u||(u=this.memory.allocation_node(s),this.memoryNodes.set(h,u))}}readBuffer(){return this.outFloat32Array||(this.outFloat32Array=new Float32Array(this.memory.shareDataBuffer.byteLength/4)),this._readBuffer||(this._readBuffer=S.device.createBuffer({size:this.memory.shareDataBuffer.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ,mappedAtCreation:!1})),this._readFlag||this.read(),this.outFloat32Array}async read(){this._readFlag=!0;let e=S.device.createCommandEncoder();e.copyBufferToBuffer(this.buffer,0,this._readBuffer,0,this.memory.shareDataBuffer.byteLength),S.device.queue.submit([e.finish()]),await this._readBuffer.mapAsync(GPUMapMode.READ);const t=this._readBuffer.getMappedRange();this.outFloat32Array.set(new Float32Array(t),0),this._readBuffer.unmap(),this._readFlag=!1}}var Mt=(i=>(i[i.IndicesGPUBuffer=0]="IndicesGPUBuffer",i[i.VertexGPUBuffer=1]="VertexGPUBuffer",i[i.UniformGPUBuffer=2]="UniformGPUBuffer",i[i.StorageGPUBuffer=3]="StorageGPUBuffer",i[i.ComputeGPUBuffer=4]="ComputeGPUBuffer",i[i.MaterialDataUniformGPUBuffer=5]="MaterialDataUniformGPUBuffer",i[i.StructStorageGPUBuffer=6]="StructStorageGPUBuffer",i))(Mt||{});class ge extends Jt{constructor(e,t=0,r){super(),this.bufferType=Mt.StorageGPUBuffer,this.createBuffer(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|t,e,r)}}class Dt extends Jt{constructor(e,t){super(),this.bufferType=Mt.UniformGPUBuffer,this.createBuffer(GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC,e,t)}genUniformNodes(){}}let Pt=function(i=16,e=16){var t="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split(""),r=[],s;if(e=e||t.length,i)for(s=0;s<i;s++)r[s]=t[0|Math.random()*e];else{var a;for(r[8]=r[13]=r[18]=r[23]="-",r[14]="4",s=0;s<36;s++)r[s]||(a=0|Math.random()*16,r[s]=t[s==19?a&3|8:a])}return r.join("")},nl=1e6,qa=function(){return nl++,nl},Jf=function(i,e){let t=0,r=i.length;for(t=0;t<r;t++)if(i[t]==e)return!0;return!1},Zf=function(i,e){let t=0,r=i.length;for(t=0;t<r;t++)if(i[t]==e)return t;return-1};class Ka{constructor(){o(this,"instanceID"),o(this,"shaderVariant"),o(this,"vsEntryPoint","main"),o(this,"fsEntryPoint","main"),o(this,"bindGroups"),o(this,"shaderReflection"),o(this,"defineValue"),o(this,"constValues"),o(this,"uniforms"),o(this,"_bufferDic"),o(this,"_shaderChange",!0),o(this,"_valueChange",!1),this.instanceID=Pt(),this.defineValue={},this.constValues={},this.uniforms={},this._bufferDic=new Map}noticeShaderChange(){this._shaderChange=!0}noticeValueChange(){this._valueChange=!0}setStorageBuffer(e,t){this._bufferDic.has(e)?this._bufferDic.set(e,t):(this._bufferDic.set(e,t),this.noticeBufferChange(e))}setStructStorageBuffer(e,t){this._bufferDic.has(e)?(this._bufferDic.set(e,t),this.noticeBufferChange(e)):this._bufferDic.set(e,t)}setUniformBuffer(e,t){this._bufferDic.has(e)?(this._bufferDic.set(e,t),this.noticeBufferChange(e)):this._bufferDic.set(e,t)}setDefine(e,t){(this.defineValue[e]==null||this.defineValue[e]!=t)&&(this.defineValue[e]=t,this.noticeValueChange(),this.noticeShaderChange()),this.defineValue[e]=t}hasDefine(e){return this.defineValue[e]!=null}deleteDefine(e){delete this.defineValue[e],this.noticeShaderChange()}setUniformFloat(e,t){this.uniforms[e]?this.uniforms[e].value=t:(this.uniforms[e]=new $(t),this.noticeValueChange())}setUniformVector2(e,t){this.uniforms[e]?this.uniforms[e].vector2=t:(this.uniforms[e]=new $(t),this.noticeValueChange())}setUniformVector3(e,t){this.uniforms[e]?this.uniforms[e].vector3=t:this.uniforms[e]=new $(t)}setUniformVector4(e,t){this.uniforms[e]?this.uniforms[e].vector4=t:this.uniforms[e]=new $(t)}setUniformColor(e,t){this.uniforms[e]?this.uniforms[e].color=t:this.uniforms[e]=new $(t)}setUniformArray(e,t){this.uniforms[e]?this.uniforms[e].float32Array(t):this.uniforms[e]=new $(t)}setUniform(e,t){this.uniforms[e]?this.uniforms[e].data=t:this.uniforms[e]=new $(t)}getUniform(e){return this.uniforms[e].data}noticeBufferChange(e){}destroy(e){}}var bi=(i=>(i[i.u32=1]="u32",i[i.f32=1]="f32",i[i["vec2<f32>"]=2]="vec2<f32>",i[i["vec3<f32>"]=3]="vec3<f32>",i[i["vec4<f32>"]=4]="vec4<f32>",i[i.float32=1]="float32",i[i.float32x2=2]="float32x2",i[i.float32x3=3]="float32x3",i[i.float32x4=4]="float32x4",i))(bi||{});let ll=[null,Fr.float32,Fr.float32x2,Fr.float32x3,Fr.float32x4];class ut{static parse(e,t){return e=this.filterComment(e),e=this.parsePreprocess(new hl,e,t),e=this.parseAutoBindingForGroupX(e,1),e}static parseComputeShader(e,t){return e=this.filterComment(e),e=this.parsePreprocess(new hl,e,t),e}static parsePreprocess(e,t,r){let s=t.indexOf("#");if(s==-1)return t;let a=t.substring(0,s),n=t.indexOf(`
`,t.lastIndexOf("#")),l=t.substring(s,n),h=t.substring(n);return a+this.parsePreprocessCommand(e,l,r)+h}static parseAutoBindingForGroupX(e,t){let r=0,s="",a=new Map;for(;r<e.length;){let n=e.indexOf("@group(",r);if(n==-1){s+=e.substring(r);break}let l=e.indexOf(")",n),h=Number.parseInt(e.substring(n+7,l));if(n=e.indexOf("@binding(",l),l=e.indexOf(")",n),s+=e.substring(r,n),h==t)if(a.has(h)){let u=a.get(h)+1;s+=`@binding(${u})`,a.set(h,u)}else s+="@binding(0)",a.set(h,0);else s+=e.substring(n,l+1);r=l+1}return s}static parsePreprocessCommand(e,t,r){let s="",a=t.split(`
`),n=[!1],l=[!1];for(let h=0;h<a.length;h++){let u=a[h],c=n[n.length-1];if(u.trim().indexOf("#")!=0){c||(s+=u+`
`);continue}let f=u.trim();if(f.indexOf("#if")!=-1){if(c&&n.length>1){n.push(c);continue}let d=f.substring(3).trim();c=!this.parseCondition(d,r),n.push(c),l.push(!c);continue}else if(f.indexOf("#elseif")!=-1||f.indexOf("#else")!=-1&&f.indexOf(" if")!=-1){if(l[l.length-1]){n.pop(),c=!0,n.push(c);continue}if(n.pop(),c=n[n.length-1],c&&n.length>1){n.push(c);continue}let p=f.substring(f.indexOf("if")+2).trim();p==""&&console.error(`preprocess command error, conditions missing: ${f}`),c=!this.parseCondition(p,r),n.push(c),l.push(!c);continue}else if(f.indexOf("#else")!=-1){n.pop(),c&&n.length>1&&n[n.length-1]?n.push(c):n.push(!c);continue}else if(f.indexOf("#endif")!=-1){n.pop(),l.pop();continue}else if(f.indexOf("#include")!=-1){let d="",p=f.charAt(f.length-1);if(p==">"?d=this.extract(f,"<",">"):d=this.extract(f,p,p),!e.includeMap.has(d)){e.includeMap.set(d,!0);let m=N.getShader(d);if(!m)throw`${f} error: '${d}' not found`;m=this.filterComment(m),m=this.parsePreprocess(e,m,r),s+=m+`\r
`}continue}else if(f.indexOf("#define ")!=-1){let d=f.substring(f.indexOf("#define ")+8).trim(),p=d.indexOf(" "),m=d,_="";p!=-1&&(m=d.substring(0,p).trim(),_=d.substring(p+1).trim()),r[m]=_;continue}else throw"nonsupport: "+f}return s}static parseCondition(e,t){let r=t[e];return r==null?!1:r==!0||r!=0}static filterComment(e){let t="",r=!0,s=!0;for(let a=0;a<e.length;){let n=r?e.indexOf("//",a):-1,l=s?e.indexOf("/*",a):-1;if(n==-1&&l==-1){t+=e.substring(a);break}r=n!=-1,s=l!=-1,n!=-1&&l!=-1&&(n<l?l=-1:n=-1),n!=-1?(l=e.indexOf(`
`,n),t+=e.substring(a,n),a=l!=-1?l:e.length):l!=-1&&(n=e.indexOf("*/",l),t+=e.substring(a,l),a=n+2)}return t}static extract(e,t,r){let s=e.indexOf(t)+t.length,a=e.indexOf(r,s);return e.substring(s,a).trim()}}class hl{constructor(){o(this,"includeMap",new Map)}}const Ds=class{constructor(){o(this,"attributes",[]),o(this,"vs_variables",[]),o(this,"fs_variables",[]),o(this,"cs_variables",[]),o(this,"groups",[]),o(this,"variables",{}),o(this,"useSplit",!1)}static parser(i,e){e.shaderReflection||(e.shaderReflection=new Ds),i.indexOf("@vertex")!=-1?(e.shaderReflection.attributes=this.parserVertexOld(i),e.shaderReflection.vs_variables=this.parserVariables(i)):i.indexOf("@fragment")!=-1?e.shaderReflection.fs_variables=this.parserVariables(i):i.indexOf("@compute")!=-1&&(e.shaderReflection.cs_variables=this.parserVariables(i))}static parser2(i,e){e.shaderReflection||(e.shaderReflection=new Ds);let t=e.shaderReflection;i.indexOf("@vertex")!=-1?(t.attributes=this.parserVertex(e.vsEntryPoint,i),t.vs_variables=this.parserVariables(i)):i.indexOf("@fragment")!=-1?t.fs_variables=this.parserVariables(i):i.indexOf("@compute")!=-1&&(t.cs_variables=this.parserVariables(i)),i.indexOf("splitTexture")!=-1&&(t.useSplit=!0)}static combineShaderReflectionVarInfo(i,e){for(const t of e){i.groups[t.group]||(i.groups[t.group]=[]);let r=t;if(i.groups[t.group][t.binding]){let s=i.groups[t.group][t.binding],a=t;if(s.dataFields)for(let n=0;n<s.dataFields.length;n++)s.dataFields[n];if(a.dataFields)for(let n=0;n<a.dataFields.length;n++)a.dataFields[n]}i.groups[t.group][t.binding]=r,i.variables[t.varName]=r}}static final(i){let e=i.shaderReflection;this._shaderReflectionMap.set(i.shaderVariant,e),this.combineShaderReflectionVarInfo(e,e.vs_variables),this.combineShaderReflectionVarInfo(e,e.fs_variables)}static getShaderReflection2(i,e){if(e.shaderVariant!=null){let t=ut.parse(i,e.defineValue);Ds.parser2(t,e)}}static poolGetReflection(i){return this._shaderReflectionMap.get(i)}static genShaderVar(i){let e=`${i.vs}${i.fs}${i.compute}`;e+="|";for(const t in i.uniforms)e+=t+":";e+="|";for(const t in i.constValues)e+=t+":",e+=i.constValues[t];e+="|";for(const t in i.defines)e+=t+":",e+=i.defines[t];e+="|";for(const t in i.shaderState)e+=t+":",e+=i.shaderState[t]+";";return e}static genShaderVariant(i){let e="";for(const t in i.uniforms)e+=t+":";e+="|";for(const t in i.constValues)e+=t+":",e+=i.constValues[t];e+="|";for(const t in i.defineValue)e+=t+":",e+=i.defineValue[t];return e}static genRenderShaderVariant(i){let e=`RenderShader(${i.vsName},${i.fsName})`;e+="|",e+=this.genShaderVariant(i),e+="|";for(const t in i.shaderState)e+=t+":",e+=i.shaderState[t]+";";return e}static genComputeShaderVariant(i){let e=`ComputeShader(${i.instanceID})`;return e+="|",e+=this.genShaderVariant(i),e}combine(i){let e=i.shaderReflection,t=i.defines,r={};for(let a=0;a<this.attributes.length;a++){let n=this.attributes[a];t[n.name]&&(r[n.name]=n)}let s=e.attributes.length;for(let a=0;a<s;a++){const n=e.attributes[a];if(!r[n.name])this.attributes.push(n);else{let l=r[n.name];l.location==n.location&&l.name!=n.name&&console.log("location must same!")}}}static parserVariables(i){let e=0,t=[];for(;e<i.length;){let r=i.indexOf("@group(",e);if(r<0)break;let s=i.indexOf(";",r);e=s;let a=i.substring(r,s),n=this.extract(a,"@group(",")"),l=this.extract(a,"@binding(",")"),h="",u="var";a.indexOf("var<")!=-1?(h=this.extract(a,">",":"),u=this.extract(a,"var<",">").replace(",","-").replaceAll(" ","")):h=this.extract(a,"var",":");let c=a.substring(a.lastIndexOf(":")+1).trim(),f={group:0,binding:0,varType:"",varName:"",dataType:"",dataIsBuiltinType:!0,dataFields:null};f.group=Number.parseInt(n),f.binding=Number.parseInt(l),f.varType=u,f.varName=h,f.dataType=c,f.dataIsBuiltinType=this.isBuiltinTypes(f.dataType),f.dataIsBuiltinType||(f.dataFields=this.parserStructFields(i,f.dataType)),t.push(f)}return t}static extract(i,e,t){let r=i.indexOf(e)+e.length,s=i.indexOf(t,r);return i.substring(r,s).trim()}static isBuiltinTypes(i){switch(i){case"i32":return!0;case"u32":return!0;case"f32":return!0;default:let e=i.indexOf("<");if(e!=-1)switch(i.substring(0,e)){case"vec2":return!0;case"vec3":return!0;case"vec4":return!0;case"mat3":return!0;case"mat4":return!0;case"array":return this.isBuiltinTypes(i.substring(e+1,i.lastIndexOf(">")))}break}return!1}static parserStructFields(i,e){let t=[],r=0;for(;r<i.length;){let s=i.indexOf("struct ",r);if(s<0)break;let a=i.indexOf("{",s);if(r=a,i.substring(s+6,a).trim()===e){s=i.indexOf("{",s),a=i.indexOf("}",s);let h=i.substring(s+1,a).split(",");for(let u of h){let c=u.indexOf(":");if(c!=-1){let f={name:u.substring(0,c).trim(),type:u.substring(c+1).trim()};t.push(f)}}break}}return t}static parserVertexOld(i){let e=[],r=i.split("fn main(")[1].split("->")[0],s=r.split("@");if(s&&s.length>1)for(let n=1;n<s.length;n++){let h=s[n].replace(/\s*$/g,"");h=h.replaceAll(",",""),h=h.replaceAll(`
`,""),h=h.replaceAll("  "," "),this.parserAttribute(h,e)}else{var a=r.split(":")[1];a=a.replaceAll("  ",""),a=a.replaceAll(" ",""),a=a.replaceAll(")",""),a=i.split(`struct ${a}`)[1];let l=a.indexOf("{"),h=a.indexOf("}");a=a.slice(l,h),s=a.split("@");for(let u=1;u<s.length;u++){let f=s[u].replace(/\s*$/g,"");f=f.replaceAll(`
`,""),f=f.split(",")[0],f=f.replaceAll("  "," "),this.parserAttribute(f,e)}}return e}static parserVertex(i,e){let t=[],s=e.split(`fn ${i}(`)[1].split("->")[0],a=s.split("@");if(a&&a.length>1)for(let l=1;l<a.length;l++){let u=a[l].replace(/\s*$/g,"");u=u.replaceAll(",",""),u=u.replaceAll(`
`,""),u=u.replaceAll("  "," "),this.parserAttribute(u,t)}else{var n=s.split(":")[1];n=n.replaceAll("  ",""),n=n.replaceAll(" ",""),n=n.replaceAll(")",""),n=e.split(`struct ${n}`)[1];let h=n.indexOf("{"),u=n.indexOf("}");n=n.slice(h,u),a=n.split("@");for(let c=1;c<a.length;c++){let d=a[c].replace(/\s*$/g,"");d=d.replaceAll(`
`,""),d=d.split(",")[0],d=d.replaceAll("  "," "),this.parserAttribute(d,t)}}return t}static parserAttribute(i,e){let t={name:"",group:0,location:0,type:"",valueType:"",value:0,size:0,format:"float32"};if(i.indexOf("builtin")!=-1){t.type="builtin";var r=i.match(/\((.+?)\)/g)[0];r=i.match(/\((.+?)\)/g)[0],r=r.replace("(",""),r=r.replaceAll(")",""),t.location=parseInt(r);let s=i.split(":");t.name=s[0].split(" ")[1],t.name=t.name.replaceAll("  "," "),t.name=t.name.replaceAll(" ",""),t.valueType=s[1],t.valueType=t.valueType.replaceAll("  "," "),t.valueType=t.valueType.replaceAll(" ",""),t.valueType=t.valueType.replaceAll("\r",""),t.valueType=t.valueType.replaceAll(")",""),t.valueType=t.valueType.replaceAll(")",""),t.size=bi[t.valueType],e.push(t)}else if(i.indexOf("location")!=-1){t.type="location";var r=i.match(/\((.+?)\)/g)[0];r=i.match(/\((.+?)\)/g)[0],r=r.replace("(",""),r=r.replaceAll(")",""),t.location=parseInt(r);let a=i.split(":");t.name=a[0].split(" ")[1],t.name=t.name.replaceAll("  "," "),t.name=t.name.replaceAll(" ",""),t.valueType=a[1],t.valueType=t.valueType.replaceAll("  "," "),t.valueType=t.valueType.replaceAll(" ",""),t.valueType=t.valueType.replaceAll("\r",""),t.valueType=t.valueType.replaceAll(")",""),t.valueType=t.valueType.replaceAll(")",""),t.size=bi[t.valueType],e.push(t)}t.format=ll[bi[t.valueType]]}};let ct=Ds;o(ct,"_shaderReflectionMap",new Map);class be extends Ka{constructor(e){super(),o(this,"entryPoint","CsMain"),o(this,"workerSizeX",1),o(this,"workerSizeY",0),o(this,"workerSizeZ",0),o(this,"_computePipeline"),o(this,"_csShaderModule"),o(this,"_destCS"),o(this,"_sourceCS"),o(this,"_storageTextureDic"),o(this,"_sampleTextureDic"),o(this,"_groupsShaderReflectionVarInfos"),o(this,"_groupCache",{}),this._sourceCS=e,ct.getShaderReflection2(e,this),this._storageTextureDic=new Map,this._sampleTextureDic=new Map}setStorageTexture(e,t){this._storageTextureDic.has(e)||this._storageTextureDic.set(e,t)}setSamplerTexture(e,t){this._sampleTextureDic.set(e,t)}compute(e){this._computePipeline||this.genComputePipeline(),e.setPipeline(this._computePipeline);for(let t=0;t<this.bindGroups.length;++t)e.setBindGroup(t,this.bindGroups[t]);this.workerSizeX&&this.workerSizeY&&this.workerSizeZ?e.dispatchWorkgroups(this.workerSizeX,this.workerSizeY,this.workerSizeZ):this.workerSizeX&&this.workerSizeY?e.dispatchWorkgroups(this.workerSizeX,this.workerSizeY):e.dispatchWorkgroups(this.workerSizeX)}createBufferBindGroup(e,t,r,s){let a=this._bufferDic.get(t);if(a){let n={binding:r,resource:{buffer:a.buffer,offset:0,size:a.memory.shareDataBuffer.byteLength}};s.push(n)}else console.error(`ComputeShader(${this.instanceID})`,`buffer ${t} is missing!`)}noticeBufferChange(e){let t=this._groupCache[e];t&&this.genGroups(t.groupIndex,t.infos,!0)}genGroups(e,t,r=!1){if(!this.bindGroups[e]||r){const s=t[e];let a=[];for(let l=0;l<s.length;++l){const h=s[l];if(h)switch(h.varType){case"uniform":case"storage-read":case"storage-read_write":this.createBufferBindGroup(e,h.varName,h.binding,a),this._groupCache[h.varName]={groupIndex:e,infos:t};break;case"var":if(h.dataType=="sampler"){let u=h.varName.replace("Sampler",""),c=this._sampleTextureDic.get(u);if(c){let f={binding:h.binding,resource:c.gpuSampler};a.push(f)}else console.error(`ComputeShader(${this.instanceID})`,`texture ${h.varName} is missing! `)}else if(h.dataType=="sampler_comparison"){let u=h.varName.replace("Sampler",""),c=this._sampleTextureDic.get(u);if(c){let f={binding:h.binding,resource:c.gpuSampler_comparison};a.push(f)}else console.error(`ComputeShader(${this.instanceID})`,`texture ${h.varName} is missing! `)}else if(h.dataType.indexOf("texture_storage")!=-1){let u=this._storageTextureDic.get(h.varName);if(u){let c={binding:h.binding,resource:u.getGPUView()};a.push(c),se.getInstance().attached(u,this)}else console.error(`ComputeShader(${this.instanceID})`,`texture ${h.varName} is missing! `)}else if(h.dataType.indexOf("texture")!=-1){let u=this._sampleTextureDic.get(h.varName);if(u){let c={binding:h.binding,resource:u.getGPUView()};a.push(c),se.getInstance().attached(u,this)}else console.error(`ComputeShader(${this.instanceID})`,`texture ${h.varName} is missing! `)}break;default:console.error("unprocessed type:",h.varType);break}}let n=S.device.createBindGroup({layout:this._computePipeline.getBindGroupLayout(e),entries:a});this.bindGroups[e]=n}}genComputePipeline(){this.preCompileShader(this._sourceCS),this.genReflection(),this._computePipeline=S.device.createComputePipeline({layout:"auto",compute:{module:this.compileShader(),entryPoint:this.entryPoint}}),this._groupsShaderReflectionVarInfos=[];let e=this.shaderReflection;this.bindGroups=[];for(let t=0;t<e.groups.length;++t){let r=e.groups[t];this._groupsShaderReflectionVarInfos[t]=r,this.genGroups(t,this._groupsShaderReflectionVarInfos)}}preCompileShader(e){for(const t in this.constValues)if(Object.prototype.hasOwnProperty.call(this.constValues,t)){const r=this.constValues[t];e=e.replaceAll(`&${t}`,r.toString())}this._destCS=ut.parseComputeShader(e,this.defineValue)}compileShader(){let e=S.device.createShaderModule({label:`ComputeShader(${this.instanceID})`,code:this._destCS});return e.getCompilationInfo().then(t=>{t.messages.length>0&&console.log(this._destCS)}),this._csShaderModule=e,e}genReflection(){this.shaderVariant+=ct.genComputeShaderVariant(this);let e=ct.poolGetReflection(this.shaderVariant);e?this.shaderReflection=e:(ct.getShaderReflection2(this._destCS,this),ct.combineShaderReflectionVarInfo(this.shaderReflection,this.shaderReflection.cs_variables))}}class ft{static start(e){let t=this.profilerLabelMap.get(e);t||(t={lable:e,start:0,end:0,total:0,count:0,child:new Map},this.profilerLabelMap.set(e,t)),t.start=performance.now(),t.end=performance.now(),t.count=0,t.child.clear()}static end(e){let t=this.profilerLabelMap.get(e);t&&(t.end=performance.now(),t.total=t.end-t.start)}static countStart(e,t=""){let r=this.profilerLabelMap.get(e);if(r&&(r.count++,t!="")){let s=r.child.get(t);s||(s={lable:t,start:0,end:0,total:0,count:0}),s.start=performance.now(),s.end=performance.now(),s.count=0,r.child.set(t,s)}}static countEnd(e,t){let r=this.profilerLabelMap.get(e);if(r&&t!=""){let s=r.child.get(t);s||(s={lable:t,start:0,end:0,total:0,count:0}),s.end=performance.now(),s.total=s.end-s.start,s.count++}}static print(e){let t=this.profilerLabelMap.get(e);t&&console.log("performance",e,t.total+" ms")}}o(ft,"profilerLabelMap",new Map);const $f=`var Module=typeof Module!="undefined"?Module:{};var moduleOverrides=Object.assign({},Module);var arguments_=[];var thisProgram="./this.program";var quit_=(status,toThrow)=>{throw toThrow};var ENVIRONMENT_IS_WEB=typeof window=="object";var ENVIRONMENT_IS_WORKER=typeof importScripts=="function";var ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";var scriptDirectory="";function locateFile(path){if(Module["locateFile"]){return Module["locateFile"](path,scriptDirectory)}return scriptDirectory+path}var read_,readAsync,readBinary,setWindowTitle;if(ENVIRONMENT_IS_NODE){var fs=require("fs");var nodePath=require("path");if(ENVIRONMENT_IS_WORKER){scriptDirectory=nodePath.dirname(scriptDirectory)+"/"}else{scriptDirectory=__dirname+"/"}read_=(filename,binary)=>{filename=isFileURI(filename)?new URL(filename):nodePath.normalize(filename);return fs.readFileSync(filename,binary?undefined:"utf8")};readBinary=filename=>{var ret=read_(filename,true);if(!ret.buffer){ret=new Uint8Array(ret)}return ret};readAsync=(filename,onload,onerror,binary=true)=>{filename=isFileURI(filename)?new URL(filename):nodePath.normalize(filename);fs.readFile(filename,binary?undefined:"utf8",((err,data)=>{if(err)onerror(err);else onload(binary?data.buffer:data)}))};if(!Module["thisProgram"]&&process.argv.length>1){thisProgram=process.argv[1].replace(/\\\\/g,"/")}arguments_=process.argv.slice(2);if(typeof module!="undefined"){module["exports"]=Module}process.on("uncaughtException",(ex=>{if(ex!=="unwind"&&!(ex instanceof ExitStatus)&&!(ex.context instanceof ExitStatus)){throw ex}}));quit_=(status,toThrow)=>{process.exitCode=status;throw toThrow};Module["inspect"]=()=>"[Emscripten Module object]"}else if(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER){if(ENVIRONMENT_IS_WORKER){scriptDirectory=self.location.href}else if(typeof document!="undefined"&&document.currentScript){scriptDirectory=document.currentScript.src}if(scriptDirectory.indexOf("blob:")!==0){scriptDirectory=scriptDirectory.substr(0,scriptDirectory.replace(/[?#].*/,"").lastIndexOf("/")+1)}else{scriptDirectory=""}{read_=url=>{var xhr=new XMLHttpRequest;xhr.open("GET",url,false);xhr.send(null);return xhr.responseText};if(ENVIRONMENT_IS_WORKER){readBinary=url=>{var xhr=new XMLHttpRequest;xhr.open("GET",url,false);xhr.responseType="arraybuffer";xhr.send(null);return new Uint8Array(xhr.response)}}readAsync=(url,onload,onerror)=>{var xhr=new XMLHttpRequest;xhr.open("GET",url,true);xhr.responseType="arraybuffer";xhr.onload=()=>{if(xhr.status==200||xhr.status==0&&xhr.response){onload(xhr.response);return}onerror()};xhr.onerror=onerror;xhr.send(null)}}setWindowTitle=title=>document.title=title}else{}var out=Module["print"]||console.log.bind(console);var err=Module["printErr"]||console.error.bind(console);Object.assign(Module,moduleOverrides);moduleOverrides=null;if(Module["arguments"])arguments_=Module["arguments"];if(Module["thisProgram"])thisProgram=Module["thisProgram"];if(Module["quit"])quit_=Module["quit"];var wasmBinary;if(Module["wasmBinary"])wasmBinary=Module["wasmBinary"];var noExitRuntime=Module["noExitRuntime"]||true;if(typeof WebAssembly!="object"){abort("no native wasm support detected")}var wasmMemory;var ABORT=false;var EXITSTATUS;var HEAP8,HEAPU8,HEAP16,HEAPU16,HEAP32,HEAPU32,HEAPF32,HEAPF64;function updateMemoryViews(){var b=wasmMemory.buffer;Module["HEAP8"]=HEAP8=new Int8Array(b);Module["HEAP16"]=HEAP16=new Int16Array(b);Module["HEAP32"]=HEAP32=new Int32Array(b);Module["HEAPU8"]=HEAPU8=new Uint8Array(b);Module["HEAPU16"]=HEAPU16=new Uint16Array(b);Module["HEAPU32"]=HEAPU32=new Uint32Array(b);Module["HEAPF32"]=HEAPF32=new Float32Array(b);Module["HEAPF64"]=HEAPF64=new Float64Array(b)}var wasmTable;var __ATPRERUN__=[];var __ATINIT__=[];var __ATMAIN__=[];var __ATPOSTRUN__=[];var runtimeInitialized=false;var runtimeKeepaliveCounter=0;function keepRuntimeAlive(){return noExitRuntime||runtimeKeepaliveCounter>0}function preRun(){if(Module["preRun"]){if(typeof Module["preRun"]=="function")Module["preRun"]=[Module["preRun"]];while(Module["preRun"].length){addOnPreRun(Module["preRun"].shift())}}callRuntimeCallbacks(__ATPRERUN__)}function initRuntime(){runtimeInitialized=true;callRuntimeCallbacks(__ATINIT__)}function preMain(){callRuntimeCallbacks(__ATMAIN__)}function postRun(){if(Module["postRun"]){if(typeof Module["postRun"]=="function")Module["postRun"]=[Module["postRun"]];while(Module["postRun"].length){addOnPostRun(Module["postRun"].shift())}}callRuntimeCallbacks(__ATPOSTRUN__)}function addOnPreRun(cb){__ATPRERUN__.unshift(cb)}function addOnInit(cb){__ATINIT__.unshift(cb)}function addOnPostRun(cb){__ATPOSTRUN__.unshift(cb)}var runDependencies=0;var runDependencyWatcher=null;var dependenciesFulfilled=null;function addRunDependency(id){runDependencies++;if(Module["monitorRunDependencies"]){Module["monitorRunDependencies"](runDependencies)}}function removeRunDependency(id){runDependencies--;if(Module["monitorRunDependencies"]){Module["monitorRunDependencies"](runDependencies)}if(runDependencies==0){if(runDependencyWatcher!==null){clearInterval(runDependencyWatcher);runDependencyWatcher=null}if(dependenciesFulfilled){var callback=dependenciesFulfilled;dependenciesFulfilled=null;callback()}}}function abort(what){if(Module["onAbort"]){Module["onAbort"](what)}what="Aborted("+what+")";err(what);ABORT=true;EXITSTATUS=1;what+=". Build with -sASSERTIONS for more info.";var e=new WebAssembly.RuntimeError(what);throw e}var dataURIPrefix="data:application/octet-stream;base64,";function isDataURI(filename){return filename.startsWith(dataURIPrefix)}function isFileURI(filename){return filename.startsWith("file://")}var wasmBinaryFile;wasmBinaryFile="data:application/octet-stream;base64,AGFzbQEAAAABfBRgAX8Bf2ABfwBgA39/fwF/YAN/f38AYAAAYAV/f39/fwBgBH9/f38AYAZ/f39/f38AYAABf2ACf38Bf2AEf39/fwF/YAF8AX1gAnx/AXxgAn9/AGABfQF9YAN/f30AYAJ+fwF/YAZ/fH9/f38Bf2ACfX8Bf2ADf35/AX4CHwUBYQFhAAoBYQFiAAMBYQFjAAABYQFkAAQBYQFlAAMDSEcDBQsLAgEAEAEADAEDDQ4CAA4PBAQABAABAAYDCQAAAAkRAwAKDAACARINAQAAAQAAAAAHBwUFAQYGAgEBEwACCQ8BCAgICAQFAXABICAFBwEBgAKAgAIGCAF/AUHgtwQLBzUNAWYCAAFnABsBaAEAAWkAMAFqAEsBawBKAWwASQFtAEgBbgBHAW8ARgFwAEUBcQAxAXIANwklAQBBAQsfIh5BQDwzQ0RCJiINLS0/ODo+DTk7PQ01DTQNNh0yHQryvgFHFwAgAC0AAEEgcUUEQCABIAIgABAUGgsLbgEBfyMAQYACayIFJAACQCACIANMDQAgBEGAwARxDQAgBSABQf8BcSACIANrIgNBgAIgA0GAAkkiARsQESABRQRAA0AgACAFQYACEAUgA0GAAmsiA0H/AUsNAAsLIAAgBSADEAULIAVBgAJqJAALSwECfCAAIACiIgEgAKIiAiABIAGioiABRKdGO4yHzcY+okR058ri+QAqv6CiIAIgAUSy+26JEBGBP6JEd6zLVFVVxb+goiAAoKC2C08BAXwgACAAoiIAIAAgAKIiAaIgAERpUO7gQpP5PqJEJx4P6IfAVr+goiABREI6BeFTVaU/oiAARIFeDP3//9+/okQAAAAAAADwP6CgoLYLdAEBfyACRQRAIAAoAgQgASgCBEYPCyAAIAFGBEBBAQ8LIAEoAgQiAi0AACEBAkAgACgCBCIDLQAAIgBFDQAgACABRw0AA0AgAi0AASEBIAMtAAEiAEUNASACQQFqIQIgA0EBaiEDIAAgAUYNAAsLIAAgAUYL0gsBB38CQCAARQ0AIABBCGsiAiAAQQRrKAIAIgFBeHEiAGohBQJAIAFBAXENACABQQNxRQ0BIAIgAigCACIBayICQfgzKAIASQ0BIAAgAWohAAJAAkBB/DMoAgAgAkcEQCABQf8BTQRAIAFBA3YhBCACKAIMIgEgAigCCCIDRgRAQegzQegzKAIAQX4gBHdxNgIADAULIAMgATYCDCABIAM2AggMBAsgAigCGCEGIAIgAigCDCIBRwRAIAIoAggiAyABNgIMIAEgAzYCCAwDCyACQRRqIgQoAgAiA0UEQCACKAIQIgNFDQIgAkEQaiEECwNAIAQhByADIgFBFGoiBCgCACIDDQAgAUEQaiEEIAEoAhAiAw0ACyAHQQA2AgAMAgsgBSgCBCIBQQNxQQNHDQJB8DMgADYCACAFIAFBfnE2AgQgAiAAQQFyNgIEIAUgADYCAA8LQQAhAQsgBkUNAAJAIAIoAhwiA0ECdEGYNmoiBCgCACACRgRAIAQgATYCACABDQFB7DNB7DMoAgBBfiADd3E2AgAMAgsgBkEQQRQgBigCECACRhtqIAE2AgAgAUUNAQsgASAGNgIYIAIoAhAiAwRAIAEgAzYCECADIAE2AhgLIAIoAhQiA0UNACABIAM2AhQgAyABNgIYCyACIAVPDQAgBSgCBCIBQQFxRQ0AAkACQAJAAkAgAUECcUUEQEGANCgCACAFRgRAQYA0IAI2AgBB9DNB9DMoAgAgAGoiADYCACACIABBAXI2AgQgAkH8MygCAEcNBkHwM0EANgIAQfwzQQA2AgAPC0H8MygCACAFRgRAQfwzIAI2AgBB8DNB8DMoAgAgAGoiADYCACACIABBAXI2AgQgACACaiAANgIADwsgAUF4cSAAaiEAIAFB/wFNBEAgAUEDdiEEIAUoAgwiASAFKAIIIgNGBEBB6DNB6DMoAgBBfiAEd3E2AgAMBQsgAyABNgIMIAEgAzYCCAwECyAFKAIYIQYgBSAFKAIMIgFHBEBB+DMoAgAaIAUoAggiAyABNgIMIAEgAzYCCAwDCyAFQRRqIgQoAgAiA0UEQCAFKAIQIgNFDQIgBUEQaiEECwNAIAQhByADIgFBFGoiBCgCACIDDQAgAUEQaiEEIAEoAhAiAw0ACyAHQQA2AgAMAgsgBSABQX5xNgIEIAIgAEEBcjYCBCAAIAJqIAA2AgAMAwtBACEBCyAGRQ0AAkAgBSgCHCIDQQJ0QZg2aiIEKAIAIAVGBEAgBCABNgIAIAENAUHsM0HsMygCAEF+IAN3cTYCAAwCCyAGQRBBFCAGKAIQIAVGG2ogATYCACABRQ0BCyABIAY2AhggBSgCECIDBEAgASADNgIQIAMgATYCGAsgBSgCFCIDRQ0AIAEgAzYCFCADIAE2AhgLIAIgAEEBcjYCBCAAIAJqIAA2AgAgAkH8MygCAEcNAEHwMyAANgIADwsgAEH/AU0EQCAAQXhxQZA0aiEBAn9B6DMoAgAiA0EBIABBA3Z0IgBxRQRAQegzIAAgA3I2AgAgAQwBCyABKAIICyEAIAEgAjYCCCAAIAI2AgwgAiABNgIMIAIgADYCCA8LQR8hAyAAQf///wdNBEAgAEEmIABBCHZnIgFrdkEBcSABQQF0a0E+aiEDCyACIAM2AhwgAkIANwIQIANBAnRBmDZqIQECQAJAAkBB7DMoAgAiBEEBIAN0IgdxRQRAQewzIAQgB3I2AgAgASACNgIAIAIgATYCGAwBCyAAQRkgA0EBdmtBACADQR9HG3QhAyABKAIAIQEDQCABIgQoAgRBeHEgAEYNAiADQR12IQEgA0EBdCEDIAQgAUEEcWoiB0EQaigCACIBDQALIAcgAjYCECACIAQ2AhgLIAIgAjYCDCACIAI2AggMAQsgBCgCCCIAIAI2AgwgBCACNgIIIAJBADYCGCACIAQ2AgwgAiAANgIIC0GINEGINCgCAEEBayIAQX8gABs2AgALC08BAn9B2CkoAgAiASAAQQdqQXhxIgJqIQACQCACQQAgACABTRsNACAAPwBBEHRLBEAgABACRQ0BC0HYKSAANgIAIAEPC0GoMkEwNgIAQX8LgwECA38BfgJAIABCgICAgBBUBEAgACEFDAELA0AgAUEBayIBIAAgAEIKgCIFQgp+fadBMHI6AAAgAEL/////nwFWIQIgBSEAIAINAAsLIAWnIgIEQANAIAFBAWsiASACIAJBCm4iA0EKbGtBMHI6AAAgAkEJSyEEIAMhAiAEDQALCyABCwYAIAAQCgs1AQF/QQEgACAAQQFNGyEAAkADQCAAECQiAQ0BQdg3KAIAIgEEQCABEQQADAELCxADAAsgAQuoAQACQCABQYAITgRAIABEAAAAAAAA4H+iIQAgAUH/D0kEQCABQf8HayEBDAILIABEAAAAAAAA4H+iIQBB/RcgASABQf0XThtB/g9rIQEMAQsgAUGBeEoNACAARAAAAAAAAGADoiEAIAFBuHBLBEAgAUHJB2ohAQwBCyAARAAAAAAAAGADoiEAQfBoIAEgAUHwaEwbQZIPaiEBCyAAIAFB/wdqrUI0hr+iCwYAIAAQCgvwAgICfwF+AkAgAkUNACAAIAE6AAAgACACaiIDQQFrIAE6AAAgAkEDSQ0AIAAgAToAAiAAIAE6AAEgA0EDayABOgAAIANBAmsgAToAACACQQdJDQAgACABOgADIANBBGsgAToAACACQQlJDQAgAEEAIABrQQNxIgRqIgMgAUH/AXFBgYKECGwiADYCACADIAIgBGtBfHEiAmoiAUEEayAANgIAIAJBCUkNACADIAA2AgggAyAANgIEIAFBCGsgADYCACABQQxrIAA2AgAgAkEZSQ0AIAMgADYCGCADIAA2AhQgAyAANgIQIAMgADYCDCABQRBrIAA2AgAgAUEUayAANgIAIAFBGGsgADYCACABQRxrIAA2AgAgAiADQQRxQRhyIgFrIgJBIEkNACAArUKBgICAEH4hBSABIANqIQEDQCABIAU3AxggASAFNwMQIAEgBTcDCCABIAU3AwAgAUEgaiEBIAJBIGsiAkEfSw0ACwsLMgAgACABKgIAIAAqAgCSOAIAIAAgASoCBCAAKgIEkjgCBCAAIAEqAgggACoCCJI4AggL/gICA38BfCMAQRBrIgEkAAJAIAC8IgNB/////wdxIgJB2p+k+gNNBEAgAkGAgIDMA0kNASAAuxAHIQAMAQsgAkHRp+2DBE0EQCAAuyEEIAJB45fbgARNBEAgA0EASARAIAREGC1EVPsh+T+gEAiMIQAMAwsgBEQYLURU+yH5v6AQCCEADAILRBgtRFT7IQnARBgtRFT7IQlAIANBAE4bIASgmhAHIQAMAQsgAkHV44iHBE0EQCACQd/bv4UETQRAIAC7IQQgA0EASARAIARE0iEzf3zZEkCgEAghAAwDCyAERNIhM3982RLAoBAIjCEADAILRBgtRFT7IRlARBgtRFT7IRnAIANBAEgbIAC7oBAHIQAMAQsgAkGAgID8B08EQCAAIACTIQAMAQsCQAJAAkACQCAAIAFBCGoQLkEDcQ4DAAECAwsgASsDCBAHIQAMAwsgASsDCBAIIQAMAgsgASsDCJoQByEADAELIAErAwgQCIwhAAsgAUEQaiQAIAALwAEBA38CQCABIAIoAhAiAwR/IAMFIAIQFQ0BIAIoAhALIAIoAhQiBWtLBEAgAiAAIAEgAigCJBECAA8LAkAgAigCUEEASARAQQAhAwwBCyABIQQDQCAEIgNFBEBBACEDDAILIAAgA0EBayIEai0AAEEKRw0ACyACIAAgAyACKAIkEQIAIgQgA0kNASAAIANqIQAgASADayEBIAIoAhQhBQsgBSAAIAEQLBogAiACKAIUIAFqNgIUIAEgA2ohBAsgBAtZAQF/IAAgACgCSCIBQQFrIAFyNgJIIAAoAgAiAUEIcQRAIAAgAUEgcjYCAEF/DwsgAEIANwIEIAAgACgCLCIBNgIcIAAgATYCFCAAIAEgACgCMGo2AhBBAAvoAgIDfwF8IwBBEGsiASQAAn0gALwiA0H/////B3EiAkHan6T6A00EQEMAAIA/IAJBgICAzANJDQEaIAC7EAgMAQsgAkHRp+2DBE0EQCACQeSX24AETwRARBgtRFT7IQlARBgtRFT7IQnAIANBAEgbIAC7oBAIjAwCCyAAuyEEIANBAEgEQCAERBgtRFT7Ifk/oBAHDAILRBgtRFT7Ifk/IAShEAcMAQsgAkHV44iHBE0EQCACQeDbv4UETwRARBgtRFT7IRlARBgtRFT7IRnAIANBAEgbIAC7oBAIDAILIANBAEgEQETSITN/fNkSwCAAu6EQBwwCCyAAu0TSITN/fNkSwKAQBwwBCyAAIACTIAJBgICA/AdPDQAaAkACQAJAAkAgACABQQhqEC5BA3EOAwABAgMLIAErAwgQCAwDCyABKwMImhAHDAILIAErAwgQCIwMAQsgASsDCBAHCyEAIAFBEGokACAACzMBAn0gASoCACAClCEDIAEqAgQgApQhBCAAIAEqAgggApQ4AgggACAEOAIEIAAgAzgCAAsqAQF/QQQQIyIAQeQmNgIAIABBvCY2AgAgAEHQJjYCACAAQcAnQQEQAQALXwEDf0EIECMiAEHkJjYCACAAQdQnNgIAQZ0IECsiAUENahAOIgJBADYCCCACIAE2AgQgAiABNgIAIAAgAkEMakGdCCABQQFqECw2AgQgAEGEKDYCACAAQaQoQQIQAQALfwAgAP0MAAAAAAAAAAAAAAAAAAAAAP0LAiQgAP0MAAAAAAAAAAAAAAAAAAAAAP0LAhQgAP0MAAAAAAAAAAAAAAAAAAAAAP0LAgQgAEGAgID8AzYCPCAAQYCAgPwDNgIAIABCADcCNCAAQYCAgPwDNgIoIABBgICA/AM2AhQgAAtTAEHsKUEANgIAQeQpQgA3AgBB+ClBADYCAEHwKUIANwIAQYQqQQA2AgBB/ClCADcCAEGQKkEANgIAQYgqQgA3AgBBxDNBzDI2AgBB/DJBKjYCAAv8BwMIfw59EHsjAEFAaiICJABB5CkoAgAgAEEGdGohAUH8KSgCACAAQQR0aiIFKAIABEAgBSgCBCEDIwBBEGsiBiQAIABBJGwiBEHwKSgCAGoiAEEYaiEHIABBDGohCCADBEAgBkEEaiIDQYgqKAIAIARqIgRB4CkqAgAQFyAAIAMQEiADIARBDGpB4CkqAgAQFyAIIAMQEiADIARBGGpB4CkqAgAQFyAHIAMQEgsgACoCFCEJIAAqAhAhCiAAKgIAIRIgACoCBCETIAAqAgghECAIKgIAIQwgAUEANgIsIAFBADYCHCABQQA2AgwgDEM1+o48lEMAAAA/lCIMEBMhDiAKQzX6jjyUQwAAAD+UIgoQEyERIAlDNfqOPJRDAAAAP5QiDRATIQkgDBAWIQsgChAWIQ8gASAQIAsgEZQiFCANEBYiCpQgCSAOIA+UIg2UkiIMIAkgCyAPlCILlCAKIA4gEZQiD5STIhEgEZIiDpQiFSALIAqUIA8gCZSSIgsgDSAKlCAJIBSUkyIJIAmSIg+UIg2TlDgCJCABIBAgCSAOlCIUIAsgDCAMkiIKlCIWkpQ4AiAgASATIBUgDZKUOAIYIAEgEyAJIAqUIg0gCyAOlCILk5Q4AhAgASASIBQgFpOUOAIIIAEgEiANIAuSlDgCBCABIBBDAACAPyAJIA+UIgkgDCAKlCIQkpOUOAIoIAEgE0MAAIA/IAkgESAOlCIJkpOUOAIUIAEgEkMAAIA/IBAgCZKTlDgCACABIAcqAgA4AjAgASAAKgIcOAI0IAAqAiAhCSABQYCAgPwDNgI8IAEgCTgCOCAGQRBqJAAgBSgCCCIAQX9HBEAgABAcIQAgAhAaGiAB/QkCDCEbIAH9CQIIIRwgAf0JAgAhHSAB/QkCBCEeIAH9CQIcIR8gAf0JAhghICAB/QkCECEhIAH9CQIUISIgAf0JAiwhIyAB/QkCKCEkIAH9CQIgISUgAf0JAiQhJiACIAD9AAIwIhcgAf0JAjz95gEgAP0AAiAiGCAB/QkCOP3mASAA/QACACIZIAH9CQIw/eYBIAD9AAIQIhogAf0JAjT95gH95AH95AH95AH9CwIwIAIgFyAj/eYBIBggJP3mASAZICX95gEgGiAm/eYB/eQB/eQB/eQB/QsCICACIBcgH/3mASAYICD95gEgGSAh/eYBIBogIv3mAf3kAf3kAf3kAf0LAhAgAiAXIBv95gEgGCAc/eYBIBkgHf3mASAeIBr95gH95AH95AH95AH9CwIAIAEgAv0AAjD9CwIwIAEgAv0AAiD9CwIgIAEgAv0AAhD9CwIQIAEgAv0AAgD9CwIACyAFQQA2AgALIAJBQGskACABCwsAIAAQHhogABAKCzEBAn8gAEHUJzYCACAAKAIEQQxrIgEgASgCCEEBayICNgIIIAJBAEgEQCABEBALIAALmgEAIABBAToANQJAIAAoAgQgAkcNACAAQQE6ADQCQCAAKAIQIgJFBEAgAEEBNgIkIAAgAzYCGCAAIAE2AhAgA0EBRw0CIAAoAjBBAUYNAQwCCyABIAJGBEAgACgCGCICQQJGBEAgACADNgIYIAMhAgsgACgCMEEBRw0CIAJBAUYNAQwCCyAAIAAoAiRBAWo2AiQLIABBAToANgsLXQEBfyAAKAIQIgNFBEAgAEEBNgIkIAAgAjYCGCAAIAE2AhAPCwJAIAEgA0YEQCAAKAIYQQJHDQEgACACNgIYDwsgAEEBOgA2IABBAjYCGCAAIAAoAiRBAWo2AiQLC7kCAQN/IwBBQGoiAiQAIAAoAgAiA0EEaygCACEEIANBCGsoAgAhAyACQgA3AiAgAkIANwIoIAJCADcCMCACQgA3ADcgAkIANwIYIAJBADYCFCACQZQkNgIQIAIgADYCDCACIAE2AgggACADaiEAQQAhAwJAIAQgAUEAEAkEQCACQQE2AjggBCACQQhqIAAgAEEBQQAgBCgCACgCFBEHACAAQQAgAigCIEEBRhshAwwBCyAEIAJBCGogAEEBQQAgBCgCACgCGBEFAAJAAkAgAigCLA4CAAECCyACKAIcQQAgAigCKEEBRhtBACACKAIkQQFGG0EAIAIoAjBBAUYbIQMMAQsgAigCIEEBRwRAIAIoAjANASACKAIkQQFHDQEgAigCKEEBRw0BCyACKAIYIQMLIAJBQGskACADCwQAIAALDgAgAEHQAGoQJEHQAGoLnCgBC38jAEEQayILJAACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABB9AFNBEBB6DMoAgAiBkEQIABBC2pBeHEgAEELSRsiBUEDdiIAdiIBQQNxBEACQCABQX9zQQFxIABqIgJBA3QiAUGQNGoiACABQZg0aigCACIBKAIIIgRGBEBB6DMgBkF+IAJ3cTYCAAwBCyAEIAA2AgwgACAENgIICyABQQhqIQAgASACQQN0IgJBA3I2AgQgASACaiIBIAEoAgRBAXI2AgQMDwsgBUHwMygCACIHTQ0BIAEEQAJAQQIgAHQiAkEAIAJrciABIAB0cSIAQQAgAGtxaCIBQQN0IgBBkDRqIgIgAEGYNGooAgAiACgCCCIERgRAQegzIAZBfiABd3EiBjYCAAwBCyAEIAI2AgwgAiAENgIICyAAIAVBA3I2AgQgACAFaiIIIAFBA3QiASAFayIEQQFyNgIEIAAgAWogBDYCACAHBEAgB0F4cUGQNGohAUH8MygCACECAn8gBkEBIAdBA3Z0IgNxRQRAQegzIAMgBnI2AgAgAQwBCyABKAIICyEDIAEgAjYCCCADIAI2AgwgAiABNgIMIAIgAzYCCAsgAEEIaiEAQfwzIAg2AgBB8DMgBDYCAAwPC0HsMygCACIKRQ0BIApBACAKa3FoQQJ0QZg2aigCACICKAIEQXhxIAVrIQMgAiEBA0ACQCABKAIQIgBFBEAgASgCFCIARQ0BCyAAKAIEQXhxIAVrIgEgAyABIANJIgEbIQMgACACIAEbIQIgACEBDAELCyACKAIYIQkgAiACKAIMIgRHBEBB+DMoAgAaIAIoAggiACAENgIMIAQgADYCCAwOCyACQRRqIgEoAgAiAEUEQCACKAIQIgBFDQMgAkEQaiEBCwNAIAEhCCAAIgRBFGoiASgCACIADQAgBEEQaiEBIAQoAhAiAA0ACyAIQQA2AgAMDQtBfyEFIABBv39LDQAgAEELaiIAQXhxIQVB7DMoAgAiCEUNAEEAIAVrIQMCQAJAAkACf0EAIAVBgAJJDQAaQR8gBUH///8HSw0AGiAFQSYgAEEIdmciAGt2QQFxIABBAXRrQT5qCyIHQQJ0QZg2aigCACIBRQRAQQAhAAwBC0EAIQAgBUEZIAdBAXZrQQAgB0EfRxt0IQIDQAJAIAEoAgRBeHEgBWsiBiADTw0AIAEhBCAGIgMNAEEAIQMgASEADAMLIAAgASgCFCIGIAYgASACQR12QQRxaigCECIBRhsgACAGGyEAIAJBAXQhAiABDQALCyAAIARyRQRAQQAhBEECIAd0IgBBACAAa3IgCHEiAEUNAyAAQQAgAGtxaEECdEGYNmooAgAhAAsgAEUNAQsDQCAAKAIEQXhxIAVrIgIgA0khASACIAMgARshAyAAIAQgARshBCAAKAIQIgEEfyABBSAAKAIUCyIADQALCyAERQ0AIANB8DMoAgAgBWtPDQAgBCgCGCEHIAQgBCgCDCICRwRAQfgzKAIAGiAEKAIIIgAgAjYCDCACIAA2AggMDAsgBEEUaiIBKAIAIgBFBEAgBCgCECIARQ0DIARBEGohAQsDQCABIQYgACICQRRqIgEoAgAiAA0AIAJBEGohASACKAIQIgANAAsgBkEANgIADAsLIAVB8DMoAgAiBE0EQEH8MygCACEAAkAgBCAFayIBQRBPBEAgACAFaiICIAFBAXI2AgQgACAEaiABNgIAIAAgBUEDcjYCBAwBCyAAIARBA3I2AgQgACAEaiIBIAEoAgRBAXI2AgRBACECQQAhAQtB8DMgATYCAEH8MyACNgIAIABBCGohAAwNCyAFQfQzKAIAIgJJBEBB9DMgAiAFayIBNgIAQYA0QYA0KAIAIgAgBWoiAjYCACACIAFBAXI2AgQgACAFQQNyNgIEIABBCGohAAwNC0EAIQAgBUEvaiIDAn9BwDcoAgAEQEHINygCAAwBC0HMN0J/NwIAQcQ3QoCggICAgAQ3AgBBwDcgC0EMakFwcUHYqtWqBXM2AgBB1DdBADYCAEGkN0EANgIAQYAgCyIBaiIGQQAgAWsiCHEiASAFTQ0MQaA3KAIAIgQEQEGYNygCACIHIAFqIgkgB00NDSAEIAlJDQ0LAkBBpDctAABBBHFFBEACQAJAAkACQEGANCgCACIEBEBBqDchAANAIAQgACgCACIHTwRAIAcgACgCBGogBEsNAwsgACgCCCIADQALC0EAEAsiAkF/Rg0DIAEhBkHENygCACIAQQFrIgQgAnEEQCABIAJrIAIgBGpBACAAa3FqIQYLIAUgBk8NA0GgNygCACIABEBBmDcoAgAiBCAGaiIIIARNDQQgACAISQ0ECyAGEAsiACACRw0BDAULIAYgAmsgCHEiBhALIgIgACgCACAAKAIEakYNASACIQALIABBf0YNASAFQTBqIAZNBEAgACECDAQLQcg3KAIAIgIgAyAGa2pBACACa3EiAhALQX9GDQEgAiAGaiEGIAAhAgwDCyACQX9HDQILQaQ3QaQ3KAIAQQRyNgIACyABEAshAkEAEAshACACQX9GDQUgAEF/Rg0FIAAgAk0NBSAAIAJrIgYgBUEoak0NBQtBmDdBmDcoAgAgBmoiADYCAEGcNygCACAASQRAQZw3IAA2AgALAkBBgDQoAgAiAwRAQag3IQADQCACIAAoAgAiASAAKAIEIgRqRg0CIAAoAggiAA0ACwwEC0H4MygCACIAQQAgACACTRtFBEBB+DMgAjYCAAtBACEAQaw3IAY2AgBBqDcgAjYCAEGINEF/NgIAQYw0QcA3KAIANgIAQbQ3QQA2AgADQCAAQQN0IgFBmDRqIAFBkDRqIgQ2AgAgAUGcNGogBDYCACAAQQFqIgBBIEcNAAtB9DMgBkEoayIAQXggAmtBB3FBACACQQhqQQdxGyIBayIENgIAQYA0IAEgAmoiATYCACABIARBAXI2AgQgACACakEoNgIEQYQ0QdA3KAIANgIADAQLIAIgA00NAiABIANLDQIgACgCDEEIcQ0CIAAgBCAGajYCBEGANCADQXggA2tBB3FBACADQQhqQQdxGyIAaiIBNgIAQfQzQfQzKAIAIAZqIgIgAGsiADYCACABIABBAXI2AgQgAiADakEoNgIEQYQ0QdA3KAIANgIADAMLQQAhBAwKC0EAIQIMCAtB+DMoAgAgAksEQEH4MyACNgIACyACIAZqIQFBqDchAAJAAkACQANAIAEgACgCAEcEQCAAKAIIIgANAQwCCwsgAC0ADEEIcUUNAQtBqDchAANAIAMgACgCACIBTwRAIAEgACgCBGoiBCADSw0DCyAAKAIIIQAMAAsACyAAIAI2AgAgACAAKAIEIAZqNgIEIAJBeCACa0EHcUEAIAJBCGpBB3EbaiIHIAVBA3I2AgQgAUF4IAFrQQdxQQAgAUEIakEHcRtqIgYgBSAHaiIFayEAIAMgBkYEQEGANCAFNgIAQfQzQfQzKAIAIABqIgA2AgAgBSAAQQFyNgIEDAgLQfwzKAIAIAZGBEBB/DMgBTYCAEHwM0HwMygCACAAaiIANgIAIAUgAEEBcjYCBCAAIAVqIAA2AgAMCAsgBigCBCIDQQNxQQFHDQYgA0F4cSEJIANB/wFNBEAgBigCDCIBIAYoAggiAkYEQEHoM0HoMygCAEF+IANBA3Z3cTYCAAwHCyACIAE2AgwgASACNgIIDAYLIAYoAhghCCAGIAYoAgwiAkcEQCAGKAIIIgEgAjYCDCACIAE2AggMBQsgBkEUaiIBKAIAIgNFBEAgBigCECIDRQ0EIAZBEGohAQsDQCABIQQgAyICQRRqIgEoAgAiAw0AIAJBEGohASACKAIQIgMNAAsgBEEANgIADAQLQfQzIAZBKGsiAEF4IAJrQQdxQQAgAkEIakEHcRsiAWsiCDYCAEGANCABIAJqIgE2AgAgASAIQQFyNgIEIAAgAmpBKDYCBEGENEHQNygCADYCACADIARBJyAEa0EHcUEAIARBJ2tBB3EbakEvayIAIAAgA0EQakkbIgFBGzYCBCABQbA3KQIANwIQIAFBqDcpAgA3AghBsDcgAUEIajYCAEGsNyAGNgIAQag3IAI2AgBBtDdBADYCACABQRhqIQADQCAAQQc2AgQgAEEIaiECIABBBGohACACIARJDQALIAEgA0YNACABIAEoAgRBfnE2AgQgAyABIANrIgJBAXI2AgQgASACNgIAIAJB/wFNBEAgAkF4cUGQNGohAAJ/QegzKAIAIgFBASACQQN2dCICcUUEQEHoMyABIAJyNgIAIAAMAQsgACgCCAshASAAIAM2AgggASADNgIMIAMgADYCDCADIAE2AggMAQtBHyEAIAJB////B00EQCACQSYgAkEIdmciAGt2QQFxIABBAXRrQT5qIQALIAMgADYCHCADQgA3AhAgAEECdEGYNmohAQJAAkBB7DMoAgAiBEEBIAB0IgZxRQRAQewzIAQgBnI2AgAgASADNgIADAELIAJBGSAAQQF2a0EAIABBH0cbdCEAIAEoAgAhBANAIAQiASgCBEF4cSACRg0CIABBHXYhBCAAQQF0IQAgASAEQQRxaiIGKAIQIgQNAAsgBiADNgIQCyADIAE2AhggAyADNgIMIAMgAzYCCAwBCyABKAIIIgAgAzYCDCABIAM2AgggA0EANgIYIAMgATYCDCADIAA2AggLQfQzKAIAIgAgBU0NAEH0MyAAIAVrIgE2AgBBgDRBgDQoAgAiACAFaiICNgIAIAIgAUEBcjYCBCAAIAVBA3I2AgQgAEEIaiEADAgLQagyQTA2AgBBACEADAcLQQAhAgsgCEUNAAJAIAYoAhwiAUECdEGYNmoiBCgCACAGRgRAIAQgAjYCACACDQFB7DNB7DMoAgBBfiABd3E2AgAMAgsgCEEQQRQgCCgCECAGRhtqIAI2AgAgAkUNAQsgAiAINgIYIAYoAhAiAQRAIAIgATYCECABIAI2AhgLIAYoAhQiAUUNACACIAE2AhQgASACNgIYCyAAIAlqIQAgBiAJaiIGKAIEIQMLIAYgA0F+cTYCBCAFIABBAXI2AgQgACAFaiAANgIAIABB/wFNBEAgAEF4cUGQNGohAQJ/QegzKAIAIgJBASAAQQN2dCIAcUUEQEHoMyAAIAJyNgIAIAEMAQsgASgCCAshACABIAU2AgggACAFNgIMIAUgATYCDCAFIAA2AggMAQtBHyEDIABB////B00EQCAAQSYgAEEIdmciAWt2QQFxIAFBAXRrQT5qIQMLIAUgAzYCHCAFQgA3AhAgA0ECdEGYNmohAQJAAkBB7DMoAgAiAkEBIAN0IgRxRQRAQewzIAIgBHI2AgAgASAFNgIADAELIABBGSADQQF2a0EAIANBH0cbdCEDIAEoAgAhAgNAIAIiASgCBEF4cSAARg0CIANBHXYhAiADQQF0IQMgASACQQRxaiIEKAIQIgINAAsgBCAFNgIQCyAFIAE2AhggBSAFNgIMIAUgBTYCCAwBCyABKAIIIgAgBTYCDCABIAU2AgggBUEANgIYIAUgATYCDCAFIAA2AggLIAdBCGohAAwCCwJAIAdFDQACQCAEKAIcIgBBAnRBmDZqIgEoAgAgBEYEQCABIAI2AgAgAg0BQewzIAhBfiAAd3EiCDYCAAwCCyAHQRBBFCAHKAIQIARGG2ogAjYCACACRQ0BCyACIAc2AhggBCgCECIABEAgAiAANgIQIAAgAjYCGAsgBCgCFCIARQ0AIAIgADYCFCAAIAI2AhgLAkAgA0EPTQRAIAQgAyAFaiIAQQNyNgIEIAAgBGoiACAAKAIEQQFyNgIEDAELIAQgBUEDcjYCBCAEIAVqIgIgA0EBcjYCBCACIANqIAM2AgAgA0H/AU0EQCADQXhxQZA0aiEAAn9B6DMoAgAiAUEBIANBA3Z0IgNxRQRAQegzIAEgA3I2AgAgAAwBCyAAKAIICyEBIAAgAjYCCCABIAI2AgwgAiAANgIMIAIgATYCCAwBC0EfIQAgA0H///8HTQRAIANBJiADQQh2ZyIAa3ZBAXEgAEEBdGtBPmohAAsgAiAANgIcIAJCADcCECAAQQJ0QZg2aiEBAkACQCAIQQEgAHQiBnFFBEBB7DMgBiAIcjYCACABIAI2AgAMAQsgA0EZIABBAXZrQQAgAEEfRxt0IQAgASgCACEFA0AgBSIBKAIEQXhxIANGDQIgAEEddiEGIABBAXQhACABIAZBBHFqIgYoAhAiBQ0ACyAGIAI2AhALIAIgATYCGCACIAI2AgwgAiACNgIIDAELIAEoAggiACACNgIMIAEgAjYCCCACQQA2AhggAiABNgIMIAIgADYCCAsgBEEIaiEADAELAkAgCUUNAAJAIAIoAhwiAEECdEGYNmoiASgCACACRgRAIAEgBDYCACAEDQFB7DMgCkF+IAB3cTYCAAwCCyAJQRBBFCAJKAIQIAJGG2ogBDYCACAERQ0BCyAEIAk2AhggAigCECIABEAgBCAANgIQIAAgBDYCGAsgAigCFCIARQ0AIAQgADYCFCAAIAQ2AhgLAkAgA0EPTQRAIAIgAyAFaiIAQQNyNgIEIAAgAmoiACAAKAIEQQFyNgIEDAELIAIgBUEDcjYCBCACIAVqIgQgA0EBcjYCBCADIARqIAM2AgAgBwRAIAdBeHFBkDRqIQBB/DMoAgAhAQJ/QQEgB0EDdnQiBSAGcUUEQEHoMyAFIAZyNgIAIAAMAQsgACgCCAshBiAAIAE2AgggBiABNgIMIAEgADYCDCABIAY2AggLQfwzIAQ2AgBB8DMgAzYCAAsgAkEIaiEACyALQRBqJAAgAAuXAgAgAEUEQEEADwsCfwJAIAAEfyABQf8ATQ0BAkBBxDMoAgAoAgBFBEAgAUGAf3FBgL8DRg0DDAELIAFB/w9NBEAgACABQT9xQYABcjoAASAAIAFBBnZBwAFyOgAAQQIMBAsgAUGAQHFBgMADRyABQYCwA09xRQRAIAAgAUE/cUGAAXI6AAIgACABQQx2QeABcjoAACAAIAFBBnZBP3FBgAFyOgABQQMMBAsgAUGAgARrQf//P00EQCAAIAFBP3FBgAFyOgADIAAgAUESdkHwAXI6AAAgACABQQZ2QT9xQYABcjoAAiAAIAFBDHZBP3FBgAFyOgABQQQMBAsLQagyQRk2AgBBfwVBAQsMAQsgACABOgAAQQELC5YYAxJ/AXwCfiMAQbAEayIMJAAgDEEANgIsAkAgAb0iGUIAUwRAQQEhEEGKCCETIAGaIgG9IRkMAQsgBEGAEHEEQEEBIRBBjQghEwwBC0GQCEGLCCAEQQFxIhAbIRMgEEUhFQsCQCAZQoCAgICAgID4/wCDQoCAgICAgID4/wBRBEAgAEEgIAIgEEEDaiIDIARB//97cRAGIAAgEyAQEAUgAEGzCEH2CCAFQSBxIgUbQcwIQfoIIAUbIAEgAWIbQQMQBSAAQSAgAiADIARBgMAAcxAGIAMgAiACIANIGyEJDAELIAxBEGohEQJAAn8CQCABIAxBLGoQKiIBIAGgIgFEAAAAAAAAAABiBEAgDCAMKAIsIgZBAWs2AiwgBUEgciIOQeEARw0BDAMLIAVBIHIiDkHhAEYNAiAMKAIsIQpBBiADIANBAEgbDAELIAwgBkEdayIKNgIsIAFEAAAAAAAAsEGiIQFBBiADIANBAEgbCyELIAxBMGpBoAJBACAKQQBOG2oiDSEHA0AgBwJ/IAFEAAAAAAAA8EFjIAFEAAAAAAAAAABmcQRAIAGrDAELQQALIgM2AgAgB0EEaiEHIAEgA7ihRAAAAABlzc1BoiIBRAAAAAAAAAAAYg0ACwJAIApBAEwEQCAKIQMgByEGIA0hCAwBCyANIQggCiEDA0BBHSADIANBHU4bIQMCQCAHQQRrIgYgCEkNACADrSEaQgAhGQNAIAYgGUL/////D4MgBjUCACAahnwiGSAZQoCU69wDgCIZQoCU69wDfn0+AgAgBkEEayIGIAhPDQALIBmnIgZFDQAgCEEEayIIIAY2AgALA0AgCCAHIgZJBEAgBkEEayIHKAIARQ0BCwsgDCAMKAIsIANrIgM2AiwgBiEHIANBAEoNAAsLIANBAEgEQCALQRlqQQluQQFqIQ8gDkHmAEYhEgNAQQlBACADayIDIANBCU4bIQkCQCAGIAhNBEAgCCgCACEHDAELQYCU69wDIAl2IRRBfyAJdEF/cyEWQQAhAyAIIQcDQCAHIAMgBygCACIXIAl2ajYCACAWIBdxIBRsIQMgB0EEaiIHIAZJDQALIAgoAgAhByADRQ0AIAYgAzYCACAGQQRqIQYLIAwgDCgCLCAJaiIDNgIsIA0gCCAHRUECdGoiCCASGyIHIA9BAnRqIAYgBiAHa0ECdSAPShshBiADQQBIDQALC0EAIQMCQCAGIAhNDQAgDSAIa0ECdUEJbCEDQQohByAIKAIAIglBCkkNAANAIANBAWohAyAJIAdBCmwiB08NAAsLIAsgA0EAIA5B5gBHG2sgDkHnAEYgC0EAR3FrIgcgBiANa0ECdUEJbEEJa0gEQEEEQaQCIApBAEgbIAxqIAdBgMgAaiIJQQltIg9BAnRqQdAfayEKQQohByAJIA9BCWxrIglBB0wEQANAIAdBCmwhByAJQQFqIglBCEcNAAsLAkAgCigCACISIBIgB24iDyAHbGsiCUUgCkEEaiIUIAZGcQ0AAkAgD0EBcUUEQEQAAAAAAABAQyEBIAdBgJTr3ANHDQEgCCAKTw0BIApBBGstAABBAXFFDQELRAEAAAAAAEBDIQELRAAAAAAAAOA/RAAAAAAAAPA/RAAAAAAAAPg/IAYgFEYbRAAAAAAAAPg/IAkgB0EBdiIURhsgCSAUSRshGAJAIBUNACATLQAAQS1HDQAgGJohGCABmiEBCyAKIBIgCWsiCTYCACABIBigIAFhDQAgCiAHIAlqIgM2AgAgA0GAlOvcA08EQANAIApBADYCACAIIApBBGsiCksEQCAIQQRrIghBADYCAAsgCiAKKAIAQQFqIgM2AgAgA0H/k+vcA0sNAAsLIA0gCGtBAnVBCWwhA0EKIQcgCCgCACIJQQpJDQADQCADQQFqIQMgCSAHQQpsIgdPDQALCyAKQQRqIgcgBiAGIAdLGyEGCwNAIAYiByAITSIJRQRAIAdBBGsiBigCAEUNAQsLAkAgDkHnAEcEQCAEQQhxIQoMAQsgA0F/c0F/IAtBASALGyIGIANKIANBe0pxIgobIAZqIQtBf0F+IAobIAVqIQUgBEEIcSIKDQBBdyEGAkAgCQ0AIAdBBGsoAgAiDkUNAEEKIQlBACEGIA5BCnANAANAIAYiCkEBaiEGIA4gCUEKbCIJcEUNAAsgCkF/cyEGCyAHIA1rQQJ1QQlsIQkgBUFfcUHGAEYEQEEAIQogCyAGIAlqQQlrIgZBACAGQQBKGyIGIAYgC0obIQsMAQtBACEKIAsgAyAJaiAGakEJayIGQQAgBkEAShsiBiAGIAtKGyELC0F/IQkgC0H9////B0H+////ByAKIAtyIhIbSg0BIAsgEkEAR2pBAWohDgJAIAVBX3EiFUHGAEYEQCADIA5B/////wdzSg0DIANBACADQQBKGyEGDAELIBEgAyADQR91IgZzIAZrrSAREAwiBmtBAUwEQANAIAZBAWsiBkEwOgAAIBEgBmtBAkgNAAsLIAZBAmsiDyAFOgAAIAZBAWtBLUErIANBAEgbOgAAIBEgD2siBiAOQf////8Hc0oNAgsgBiAOaiIDIBBB/////wdzSg0BIABBICACIAMgEGoiBSAEEAYgACATIBAQBSAAQTAgAiAFIARBgIAEcxAGAkACQAJAIBVBxgBGBEAgDEEQaiIGQQhyIQMgBkEJciEKIA0gCCAIIA1LGyIJIQgDQCAINQIAIAoQDCEGAkAgCCAJRwRAIAYgDEEQak0NAQNAIAZBAWsiBkEwOgAAIAYgDEEQaksNAAsMAQsgBiAKRw0AIAxBMDoAGCADIQYLIAAgBiAKIAZrEAUgCEEEaiIIIA1NDQALIBIEQCAAQf4IQQEQBQsgByAITQ0BIAtBAEwNAQNAIAg1AgAgChAMIgYgDEEQaksEQANAIAZBAWsiBkEwOgAAIAYgDEEQaksNAAsLIAAgBkEJIAsgC0EJThsQBSALQQlrIQYgCEEEaiIIIAdPDQMgC0EJSiEDIAYhCyADDQALDAILAkAgC0EASA0AIAcgCEEEaiAHIAhLGyEJIAxBEGoiBkEIciEDIAZBCXIhDSAIIQcDQCANIAc1AgAgDRAMIgZGBEAgDEEwOgAYIAMhBgsCQCAHIAhHBEAgBiAMQRBqTQ0BA0AgBkEBayIGQTA6AAAgBiAMQRBqSw0ACwwBCyAAIAZBARAFIAZBAWohBiAKIAtyRQ0AIABB/ghBARAFCyAAIAYgDSAGayIGIAsgBiALSBsQBSALIAZrIQsgB0EEaiIHIAlPDQEgC0EATg0ACwsgAEEwIAtBEmpBEkEAEAYgACAPIBEgD2sQBQwCCyALIQYLIABBMCAGQQlqQQlBABAGCyAAQSAgAiAFIARBgMAAcxAGIAUgAiACIAVIGyEJDAELIBMgBUEadEEfdUEJcWohCAJAIANBC0sNAEEMIANrIQZEAAAAAAAAMEAhGANAIBhEAAAAAAAAMECiIRggBkEBayIGDQALIAgtAABBLUYEQCAYIAGaIBihoJohAQwBCyABIBigIBihIQELIBEgDCgCLCIGIAZBH3UiBnMgBmutIBEQDCIGRgRAIAxBMDoADyAMQQ9qIQYLIBBBAnIhCyAFQSBxIQ0gDCgCLCEHIAZBAmsiCiAFQQ9qOgAAIAZBAWtBLUErIAdBAEgbOgAAIARBCHEhBiAMQRBqIQcDQCAHIgUCfyABmUQAAAAAAADgQWMEQCABqgwBC0GAgICAeAsiB0HgI2otAAAgDXI6AAAgASAHt6FEAAAAAAAAMECiIQECQCAFQQFqIgcgDEEQamtBAUcNAAJAIAYNACADQQBKDQAgAUQAAAAAAAAAAGENAQsgBUEuOgABIAVBAmohBwsgAUQAAAAAAAAAAGINAAtBfyEJQf3///8HIAsgESAKayIGaiINayADSA0AIABBICACIA0gA0ECaiAHIAxBEGoiB2siBSAFQQJrIANIGyAFIAMbIglqIgMgBBAGIAAgCCALEAUgAEEwIAIgAyAEQYCABHMQBiAAIAcgBRAFIABBMCAJIAVrQQBBABAGIAAgCiAGEAUgAEEgIAIgAyAEQYDAAHMQBiADIAIgAiADSBshCQsgDEGwBGokACAJC7QCAAJAAkACQAJAAkACQAJAAkACQAJAAkAgAUEJaw4SAAgJCggJAQIDBAoJCgoICQUGBwsgAiACKAIAIgFBBGo2AgAgACABKAIANgIADwsgAiACKAIAIgFBBGo2AgAgACABMgEANwMADwsgAiACKAIAIgFBBGo2AgAgACABMwEANwMADwsgAiACKAIAIgFBBGo2AgAgACABMAAANwMADwsgAiACKAIAIgFBBGo2AgAgACABMQAANwMADwsgAiACKAIAQQdqQXhxIgFBCGo2AgAgACABKwMAOQMADwsACw8LIAIgAigCACIBQQRqNgIAIAAgATQCADcDAA8LIAIgAigCACIBQQRqNgIAIAAgATUCADcDAA8LIAIgAigCAEEHakF4cSIBQQhqNgIAIAAgASkDADcDAAtyAQN/IAAoAgAsAABBMGtBCk8EQEEADwsDQCAAKAIAIQNBfyEBIAJBzJmz5gBNBEBBfyADLAAAQTBrIgEgAkEKbCICaiABIAJB/////wdzShshAQsgACADQQFqNgIAIAEhAiADLAABQTBrQQpJDQALIAILkRQCE38BfkGHCSELIwBB0ABrIgUkACAFQYcJNgJMIAVBN2ohFSAFQThqIRACQAJAAkACQANAIAshCiAEIAxB/////wdzSg0BIAQgDGohDAJAAkACQCAKIgQtAAAiBgRAA0ACQAJAIAZB/wFxIgtFBEAgBCELDAELIAtBJUcNASAEIQYDQCAGLQABQSVHBEAgBiELDAILIARBAWohBCAGLQACIQcgBkECaiILIQYgB0ElRg0ACwsgBCAKayIEIAxB/////wdzIhZKDQcgAARAIAAgCiAEEAULIAQNBiAFIAs2AkwgC0EBaiEEQX8hDQJAIAssAAFBMGtBCk8NACALLQACQSRHDQAgC0EDaiEEIAssAAFBMGshDUEBIRELIAUgBDYCTEEAIQgCQCAELAAAIgZBIGsiC0EfSwRAIAQhBwwBCyAEIQdBASALdCILQYnRBHFFDQADQCAFIARBAWoiBzYCTCAIIAtyIQggBCwAASIGQSBrIgtBIE8NASAHIQRBASALdCILQYnRBHENAAsLAkAgBkEqRgRAAn8CQCAHLAABQTBrQQpPDQAgBy0AAkEkRw0AIAcsAAFBAnQgA2pBwAFrQQo2AgAgB0EDaiEGQQEhESAHLAABQQN0IAJqQYADaygCAAwBCyARDQYgB0EBaiEGIABFBEAgBSAGNgJMQQAhEUEAIQ4MAwsgASABKAIAIgRBBGo2AgBBACERIAQoAgALIQ4gBSAGNgJMIA5BAE4NAUEAIA5rIQ4gCEGAwAByIQgMAQsgBUHMAGoQKCIOQQBIDQggBSgCTCEGC0EAIQRBfyEJAn8gBi0AAEEuRwRAIAYhC0EADAELIAYtAAFBKkYEQAJ/AkAgBiwAAkEwa0EKTw0AIAYtAANBJEcNACAGLAACQQJ0IANqQcABa0EKNgIAIAZBBGohCyAGLAACQQN0IAJqQYADaygCAAwBCyARDQYgBkECaiELQQAgAEUNABogASABKAIAIgdBBGo2AgAgBygCAAshCSAFIAs2AkwgCUF/c0EfdgwBCyAFIAZBAWo2AkwgBUHMAGoQKCEJIAUoAkwhC0EBCyESA0AgBCEPQRwhByALIhQsAAAiBEH7AGtBRkkNCSAUQQFqIQsgBCAPQTpsakHPH2otAAAiBEEBa0EISQ0ACyAFIAs2AkwCQAJAIARBG0cEQCAERQ0LIA1BAE4EQCADIA1BAnRqIAQ2AgAgBSACIA1BA3RqKQMANwNADAILIABFDQggBUFAayAEIAEQJwwCCyANQQBODQoLQQAhBCAARQ0HCyAIQf//e3EiBiAIIAhBgMAAcRshCEEAIQ1BgAghEyAQIQcCQAJAAkACfwJAAkACQAJAAn8CQAJAAkACQAJAAkACQCAULAAAIgRBX3EgBCAEQQ9xQQNGGyAEIA8bIgRB2ABrDiEEFBQUFBQUFBQOFA8GDg4OFAYUFBQUAgUDFBQJFAEUFAQACwJAIARBwQBrDgcOFAsUDg4OAAsgBEHTAEYNCQwTCyAFKQNAIRdBgAgMBQtBACEEAkACQAJAAkACQAJAAkAgD0H/AXEOCAABAgMEGgUGGgsgBSgCQCAMNgIADBkLIAUoAkAgDDYCAAwYCyAFKAJAIAysNwMADBcLIAUoAkAgDDsBAAwWCyAFKAJAIAw6AAAMFQsgBSgCQCAMNgIADBQLIAUoAkAgDKw3AwAMEwtBCCAJIAlBCE0bIQkgCEEIciEIQfgAIQQLIBAhCiAFKQNAIhdCAFIEQCAEQSBxIQYDQCAKQQFrIgogF6dBD3FB4CNqLQAAIAZyOgAAIBdCD1YhDyAXQgSIIRcgDw0ACwsgBSkDQFANAyAIQQhxRQ0DIARBBHZBgAhqIRNBAiENDAMLIBAhBCAFKQNAIhdCAFIEQANAIARBAWsiBCAXp0EHcUEwcjoAACAXQgdWIQogF0IDiCEXIAoNAAsLIAQhCiAIQQhxRQ0CIAkgECAKayIEQQFqIAQgCUgbIQkMAgsgBSkDQCIXQgBTBEAgBUIAIBd9Ihc3A0BBASENQYAIDAELIAhBgBBxBEBBASENQYEIDAELQYIIQYAIIAhBAXEiDRsLIRMgFyAQEAwhCgsgEkEAIAlBAEgbDQ4gCEH//3txIAggEhshCAJAIAUpA0AiF0IAUg0AIAkNACAQIQpBACEJDAwLIAkgF1AgECAKa2oiBCAEIAlIGyEJDAsLAn9B/////wcgCSAJQf////8HTxsiDyIHQQBHIQgCQAJAAkAgBSgCQCIEQYAJIAQbIgoiBEEDcUUNACAHRQ0AA0AgBC0AAEUNAiAHQQFrIgdBAEchCCAEQQFqIgRBA3FFDQEgBw0ACwsgCEUNAQJAIAQtAABFDQAgB0EESQ0AA0AgBCgCACIIQX9zIAhBgYKECGtxQYCBgoR4cQ0CIARBBGohBCAHQQRrIgdBA0sNAAsLIAdFDQELA0AgBCAELQAARQ0CGiAEQQFqIQQgB0EBayIHDQALC0EACyIEIAprIA8gBBsiBCAKaiEHIAlBAE4EQCAGIQggBCEJDAsLIAYhCCAEIQkgBy0AAA0NDAoLIAkEQCAFKAJADAILQQAhBCAAQSAgDkEAIAgQBgwCCyAFQQA2AgwgBSAFKQNAPgIIIAUgBUEIaiIENgJAQX8hCSAECyEGQQAhBAJAA0AgBigCACIKRQ0BAkAgBUEEaiAKECUiCkEASCIHDQAgCiAJIARrSw0AIAZBBGohBiAEIApqIgQgCUkNAQwCCwsgBw0NC0E9IQcgBEEASA0LIABBICAOIAQgCBAGIARFBEBBACEEDAELQQAhByAFKAJAIQYDQCAGKAIAIgpFDQEgBUEEaiAKECUiCiAHaiIHIARLDQEgACAFQQRqIAoQBSAGQQRqIQYgBCAHSw0ACwsgAEEgIA4gBCAIQYDAAHMQBiAOIAQgBCAOSBshBAwICyASQQAgCUEASBsNCEE9IQcgACAFKwNAIA4gCSAIIAQQJiIEQQBODQcMCQsgBSAFKQNAPAA3QQEhCSAVIQogBiEIDAQLIAQtAAEhBiAEQQFqIQQMAAsACyAADQcgEUUNAkEBIQQDQCADIARBAnRqKAIAIgAEQCACIARBA3RqIAAgARAnQQEhDCAEQQFqIgRBCkcNAQwJCwtBASEMIARBCk8NBwNAIAMgBEECdGooAgANASAEQQFqIgRBCkcNAAsMBwtBHCEHDAQLIAkgByAKayIPIAkgD0obIgkgDUH/////B3NKDQJBPSEHIA4gCSANaiIGIAYgDkgbIgQgFkoNAyAAQSAgBCAGIAgQBiAAIBMgDRAFIABBMCAEIAYgCEGAgARzEAYgAEEwIAkgD0EAEAYgACAKIA8QBSAAQSAgBCAGIAhBgMAAcxAGDAELC0EAIQwMAwtBPSEHC0GoMiAHNgIAC0F/IQwLIAVB0ABqJAAgDAt+AgF/AX4gAL0iA0I0iKdB/w9xIgJB/w9HBHwgAkUEQCABIABEAAAAAAAAAABhBH9BAAUgAEQAAAAAAADwQ6IgARAqIQAgASgCAEFAags2AgAgAA8LIAEgAkH+B2s2AgAgA0L/////////h4B/g0KAgICAgICA8D+EvwUgAAsLegEDfwJAAkAgACIBQQNxRQ0AIAAtAABFBEBBAA8LA0AgAUEBaiIBQQNxRQ0BIAEtAAANAAsMAQsDQCABIgJBBGohASACKAIAIgNBf3MgA0GBgoQIa3FBgIGChHhxRQ0ACwNAIAIiAUEBaiECIAEtAAANAAsLIAEgAGsLgAQBA38gAkGABE8EQCAAIAEgAhAEIAAPCyAAIAJqIQMCQCAAIAFzQQNxRQRAAkAgAEEDcUUEQCAAIQIMAQsgAkUEQCAAIQIMAQsgACECA0AgAiABLQAAOgAAIAFBAWohASACQQFqIgJBA3FFDQEgAiADSQ0ACwsCQCADQXxxIgRBwABJDQAgAiAEQUBqIgVLDQADQCACIAEoAgA2AgAgAiABKAIENgIEIAIgASgCCDYCCCACIAEoAgw2AgwgAiABKAIQNgIQIAIgASgCFDYCFCACIAEoAhg2AhggAiABKAIcNgIcIAIgASgCIDYCICACIAEoAiQ2AiQgAiABKAIoNgIoIAIgASgCLDYCLCACIAEoAjA2AjAgAiABKAI0NgI0IAIgASgCODYCOCACIAEoAjw2AjwgAUFAayEBIAJBQGsiAiAFTQ0ACwsgAiAETw0BA0AgAiABKAIANgIAIAFBBGohASACQQRqIgIgBEkNAAsMAQsgA0EESQRAIAAhAgwBCyAAIANBBGsiBEsEQCAAIQIMAQsgACECA0AgAiABLQAAOgAAIAIgAS0AAToAASACIAEtAAI6AAIgAiABLQADOgADIAFBBGohASACQQRqIgIgBE0NAAsLIAIgA0kEQANAIAIgAS0AADoAACABQQFqIQEgAkEBaiICIANHDQALCyAACwMAAQv4DwIUfwN8IwBBEGsiCyQAAkAgALwiEUH/////B3EiA0Han6TuBE0EQCABIAC7IhcgF0SDyMltMF/kP6JEAAAAAAAAOEOgRAAAAAAAADjDoCIWRAAAAFD7Ifm/oqAgFkRjYhphtBBRvqKgIhg5AwAgGEQAAABg+yHpv2MhAgJ/IBaZRAAAAAAAAOBBYwRAIBaqDAELQYCAgIB4CyEDIAIEQCABIBcgFkQAAAAAAADwv6AiFkQAAABQ+yH5v6KgIBZEY2IaYbQQUb6ioDkDACADQQFrIQMMAgsgGEQAAABg+yHpP2RFDQEgASAXIBZEAAAAAAAA8D+gIhZEAAAAUPsh+b+ioCAWRGNiGmG0EFG+oqA5AwAgA0EBaiEDDAELIANBgICA/AdPBEAgASAAIACTuzkDAEEAIQMMAQsgCyADIANBF3ZBlgFrIgNBF3Rrvrs5AwggC0EIaiEOIwBBsARrIgUkACADIANBA2tBGG0iAkEAIAJBAEobIg1BaGxqIQZB8AkoAgAiB0EATgRAIAdBAWohAyANIQIDQCAFQcACaiAEQQN0aiACQQBIBHxEAAAAAAAAAAAFIAJBAnRBgApqKAIAtws5AwAgAkEBaiECIARBAWoiBCADRw0ACwsgBkEYayEIQQAhAyAHQQAgB0EAShshBANAQQAhAkQAAAAAAAAAACEWA0AgDiACQQN0aisDACAFQcACaiADIAJrQQN0aisDAKIgFqAhFiACQQFqIgJBAUcNAAsgBSADQQN0aiAWOQMAIAMgBEYhAiADQQFqIQMgAkUNAAtBLyAGayESQTAgBmshDyAGQRlrIRMgByEDAkADQCAFIANBA3RqKwMAIRZBACECIAMhBCADQQBMIglFBEADQCAFQeADaiACQQJ0agJ/An8gFkQAAAAAAABwPqIiF5lEAAAAAAAA4EFjBEAgF6oMAQtBgICAgHgLtyIXRAAAAAAAAHDBoiAWoCIWmUQAAAAAAADgQWMEQCAWqgwBC0GAgICAeAs2AgAgBSAEQQFrIgRBA3RqKwMAIBegIRYgAkEBaiICIANHDQALCwJ/IBYgCBAPIhYgFkQAAAAAAADAP6KcRAAAAAAAACDAoqAiFplEAAAAAAAA4EFjBEAgFqoMAQtBgICAgHgLIQogFiAKt6EhFgJAAkACQAJ/IAhBAEwiFEUEQCADQQJ0IAVqIgIgAigC3AMiAiACIA91IgIgD3RrIgQ2AtwDIAIgCmohCiAEIBJ1DAELIAgNASADQQJ0IAVqKALcA0EXdQsiDEEATA0CDAELQQIhDCAWRAAAAAAAAOA/Zg0AQQAhDAwBC0EAIQJBACEEIAlFBEADQCAFQeADaiACQQJ0aiIVKAIAIQlB////ByEQAn8CQCAEDQBBgICACCEQIAkNAEEADAELIBUgECAJazYCAEEBCyEEIAJBAWoiAiADRw0ACwsCQCAUDQBB////AyECAkACQCATDgIBAAILQf///wEhAgsgA0ECdCAFaiIJIAkoAtwDIAJxNgLcAwsgCkEBaiEKIAxBAkcNAEQAAAAAAADwPyAWoSEWQQIhDCAERQ0AIBZEAAAAAAAA8D8gCBAPoSEWCyAWRAAAAAAAAAAAYQRAQQAhBAJAIAcgAyICTg0AA0AgBUHgA2ogAkEBayICQQJ0aigCACAEciEEIAIgB0oNAAsgBEUNACAIIQYDQCAGQRhrIQYgBUHgA2ogA0EBayIDQQJ0aigCAEUNAAsMAwtBASECA0AgAiIEQQFqIQIgBUHgA2ogByAEa0ECdGooAgBFDQALIAMgBGohBANAIAVBwAJqIANBAWoiA0EDdGogAyANakECdEGACmooAgC3OQMAQQAhAkQAAAAAAAAAACEWA0AgDiACQQN0aisDACAFQcACaiADIAJrQQN0aisDAKIgFqAhFiACQQFqIgJBAUcNAAsgBSADQQN0aiAWOQMAIAMgBEgNAAsgBCEDDAELCwJAIBZBGCAGaxAPIhZEAAAAAAAAcEFmBEAgBUHgA2ogA0ECdGoCfwJ/IBZEAAAAAAAAcD6iIheZRAAAAAAAAOBBYwRAIBeqDAELQYCAgIB4CyICt0QAAAAAAABwwaIgFqAiFplEAAAAAAAA4EFjBEAgFqoMAQtBgICAgHgLNgIAIANBAWohAwwBCwJ/IBaZRAAAAAAAAOBBYwRAIBaqDAELQYCAgIB4CyECIAghBgsgBUHgA2ogA0ECdGogAjYCAAtEAAAAAAAA8D8gBhAPIRYCQCADQQBIDQAgAyECA0AgBSACIgRBA3RqIBYgBUHgA2ogAkECdGooAgC3ojkDACACQQFrIQIgFkQAAAAAAABwPqIhFiAEDQALIANBAEgNACADIQQDQEQAAAAAAAAAACEWQQAhAiAHIAMgBGsiBiAGIAdKGyIIQQBOBEADQCACQQN0QdAfaisDACAFIAIgBGpBA3RqKwMAoiAWoCEWIAIgCEchDSACQQFqIQIgDQ0ACwsgBUGgAWogBkEDdGogFjkDACAEQQBKIQIgBEEBayEEIAINAAsLRAAAAAAAAAAAIRYgA0EATgRAA0AgAyICQQFrIQMgFiAFQaABaiACQQN0aisDAKAhFiACDQALCyALIBaaIBYgDBs5AwAgBUGwBGokACAKQQdxIQMgCysDACEWIBFBAEgEQCABIBaaOQMAQQAgA2shAwwBCyABIBY5AwALIAtBEGokACADC/YEAQh/IAEgACgCCCIEIAAoAgQiAmtBJG1NBEAgACABBH8gAiABQSRsaiEAA0AgAv0MAAAAAAAAAAAAAAAAAAAAAP0LAgAgAkEANgIgIAL9DAAAAAAAAAAAAAAAAAAAAAD9CwIQIAJBADYCCCACQgA3AgAgAkEMaiIBQQA2AgggAUIANwIAIAJBGGoiAUEANgIIIAFCADcCACACQSRqIgIgAEcNAAsgAAUgAgs2AgQPCwJAIAIgACgCACICa0EkbSIGIAFqIgNByOPxOEkEQEHH4/E4IAQgAmtBJG0iAkEBdCIEIAMgAyAESRsgAkHj8bgcTxsiBARAIARByOPxOE8NAiAEQSRsEA4hBQsgBSAGQSRsaiIDIAFBJGxqIQYgAyECA0AgAv0MAAAAAAAAAAAAAAAAAAAAAP0LAgAgAkEANgIgIAL9DAAAAAAAAAAAAAAAAAAAAAD9CwIQIAJBADYCCCACQgA3AgAgAkEMaiIBQQA2AgggAUIANwIAIAJBGGoiAUEANgIIIAFCADcCACACQSRqIgIgBkcNAAsgBSAEQSRsaiEIAkAgACgCBCICIAAoAgAiCUYEQCADIQUMAQsDQCADQSRrIgUgAkEkayIBKgIAOAIAIAUgASoCBDgCBCAFIAEqAgg4AgggA0EYayIEIAJBGGsiByoCADgCACAEIAcqAgQ4AgQgBCAHKgIIOAIIIANBDGsiAyACQQxrIgIqAgA4AgAgAyACKgIEOAIEIAMgAioCCDgCCCAFIQMgASICIAlHDQALIAAoAgAhAgsgACAINgIIIAAgBjYCBCAAIAU2AgAgAgRAIAIQCgsPCxAZAAsQGAALrgoBCH8CQEHoKSgCAEHkKSgCACICa0EGdSIBIABJBEAgACABayIDQewpKAIAIgRB6CkoAgAiAWtBBnVNBEBB6CkgAwR/IAEgA0EGdGohAgNAIAEQGkFAayIBIAJHDQALIAIFIAELNgIADAILAkAgAUHkKSgCACICa0EGdSIGIANqIgVBgICAIEkEQEH///8fIAQgAmsiAUEFdSICIAUgAiAFSxsgAUHA////B08bIgcEfyAHQYCAgCBPDQIgB0EGdBAOBUEACyIEIAZBBnRqIgIgA0EGdGohBSACIQEDQCABEBpBQGsiASAFRw0AC0HoKSgCACIBQeQpKAIAIgZHBEADQCACQUBqIgMgAUFAaiIBIgL9AAIA/QsCACADIAL9AAIw/QsCMCADIAL9AAIg/QsCICADIAL9AAIQ/QsCECADIQIgASAGRw0AC0HkKSgCACEBC0HsKSAEIAdBBnRqNgIAQegpIAU2AgBB5CkgAjYCACABBEAgARAQCwwDCxAZAAsQGAALIAAgAU8NAEHoKSACIABBBnRqNgIACwJAQfQpKAIAQfApKAIAIgJrQSRtIgEgAEkEQEHwKSAAIAFrEC8MAQsgACABTw0AQfQpIAIgAEEkbGo2AgALAkBBgCooAgBB/CkoAgAiAmtBBHUiASAASQRAQQAhBEEAIQcgACABayIDQYQqKAIAIgZBgCooAgAiAmtBBHVNBEACQCADRQ0AIAIhASADQQdxIggEQANAIAFC/////w83AgggAUIANwIAIAFBEGohASAEQQFqIgQgCEcNAAsLIANBBHQgAmohAiADQQFrQf////8AcUEHSQ0AA0AgAUIANwJwIAFCADcCYCABQgA3AlAgAUIANwJAIAFCADcCMCABQgA3AiAgAUIANwIQIAFC/////w83AgggAUIANwIAIAFC/////w83AnggAUL/////DzcCaCABQv////8PNwJYIAFC/////w83AkggAUL/////DzcCOCABQv////8PNwIoIAFC/////w83AhggAUGAAWoiASACRw0ACwtBgCogAjYCAAwCCwJAIAJB/CkoAgAiAWtBBHUiBCADaiIFQYCAgIABSQRAQf////8AIAYgAWsiBkEDdSIBIAUgASAFSxsgBkHw////B08bIgUEQCAFQYCAgIABTw0CIAVBBHQQDiEHCyAHIARBBHRqIgQhASADQQdxIgYEQANAIAFC/////w83AgggAUIANwIAIAFBEGohASAIQQFqIgggBkcNAAsLIANBBHQgBGohCCADQQFrQf////8AcUEHTwRAA0AgAUIANwJwIAFCADcCYCABQgA3AlAgAUIANwJAIAFCADcCMCABQgA3AiAgAUIANwIQIAFC/////w83AgggAUIANwIAIAFC/////w83AnggAUL/////DzcCaCABQv////8PNwJYIAFC/////w83AkggAUL/////DzcCOCABQv////8PNwIoIAFC/////w83AhggAUGAAWoiASAIRw0ACwtB/CkoAgAiASACRwRAA0AgBEEQayIEIAJBEGsiAv0AAgD9CwIAIAEgAkcNAAtB/CkoAgAhAgtBhCogByAFQQR0ajYCAEGAKiAINgIAQfwpIAQ2AgAgAgRAIAIQEAsMAwsQGQALEBgACyAAIAFPDQBBgCogAiAAQQR0ajYCAAtBjCooAgBBiCooAgAiAmtBJG0iASAASQRAQYgqIAAgAWsQLw8LIAAgAUkEQEGMKiACIABBJGxqNgIACwsQACMAIABrQXBxIgAkACAACwcAIAAoAgQLGQBBiCooAgAiAARAQYwqIAA2AgAgABAKCwsFAEG3CAsFAEHnCAsFAEGkCAsVACAARQRAQQAPCyAAQaQlECFBAEcLGgAgACABKAIIIAUQCQRAIAEgAiADIAQQHwsLNwAgACABKAIIIAUQCQRAIAEgAiADIAQQHw8LIAAoAggiACABIAIgAyAEIAUgACgCACgCFBEHAAunAQAgACABKAIIIAQQCQRAAkAgASgCBCACRw0AIAEoAhxBAUYNACABIAM2AhwLDwsCQCAAIAEoAgAgBBAJRQ0AAkAgAiABKAIQRwRAIAEoAhQgAkcNAQsgA0EBRw0BIAFBATYCIA8LIAEgAjYCFCABIAM2AiAgASABKAIoQQFqNgIoAkAgASgCJEEBRw0AIAEoAhhBAkcNACABQQE6ADYLIAFBBDYCLAsLiAIAIAAgASgCCCAEEAkEQAJAIAEoAgQgAkcNACABKAIcQQFGDQAgASADNgIcCw8LAkAgACABKAIAIAQQCQRAAkAgAiABKAIQRwRAIAEoAhQgAkcNAQsgA0EBRw0CIAFBATYCIA8LIAEgAzYCIAJAIAEoAixBBEYNACABQQA7ATQgACgCCCIAIAEgAiACQQEgBCAAKAIAKAIUEQcAIAEtADUEQCABQQM2AiwgAS0ANEUNAQwDCyABQQQ2AiwLIAEgAjYCFCABIAEoAihBAWo2AiggASgCJEEBRw0BIAEoAhhBAkcNASABQQE6ADYPCyAAKAIIIgAgASACIAMgBCAAKAIAKAIYEQUACwsZAEH8KSgCACIABEBBgCogADYCACAAEAoLCzEAIAAgASgCCEEAEAkEQCABIAIgAxAgDwsgACgCCCIAIAEgAiADIAAoAgAoAhwRBgALGAAgACABKAIIQQAQCQRAIAEgAiADECALC5sBAQF/IwBBQGoiAyQAAn9BASAAIAFBABAJDQAaQQAgAUUNABpBACABQcQkECEiAUUNABogA0EMakEAQTQQESADQQE2AjggA0F/NgIUIAMgADYCECADIAE2AgggASADQQhqIAIoAgBBASABKAIAKAIcEQYAIAMoAiAiAEEBRgRAIAIgAygCGDYCAAsgAEEBRgshACADQUBrJAAgAAsZAEHwKSgCACIABEBB9CkgADYCACAAEAoLCxkAQeQpKAIAIgAEQEHoKSAANgIAIAAQCgsLBABCAAsEAEEAC/QCAQd/IwBBIGsiAyQAIAMgACgCHCIENgIQIAAoAhQhBSADIAI2AhwgAyABNgIYIAMgBSAEayIBNgIUIAEgAmohBUECIQcCfwJAAkACQCAAKAI8IANBEGoiAUECIANBDGoQACIEBH9BqDIgBDYCAEF/BUEACwRAIAEhBAwBCwNAIAUgAygCDCIGRg0CIAZBAEgEQCABIQQMBAsgASAGIAEoAgQiCEsiCUEDdGoiBCAGIAhBACAJG2siCCAEKAIAajYCACABQQxBBCAJG2oiASABKAIAIAhrNgIAIAUgBmshBSAAKAI8IAQiASAHIAlrIgcgA0EMahAAIgYEf0GoMiAGNgIAQX8FQQALRQ0ACwsgBUF/Rw0BCyAAIAAoAiwiATYCHCAAIAE2AhQgACABIAAoAjBqNgIQIAIMAQsgAEEANgIcIABCADcDECAAIAAoAgBBIHI2AgBBACAHQQJGDQAaIAIgBCgCBGsLIQAgA0EgaiQAIAALhwIAQZQpKAIAGgJAQX9BAAJ/QdAIECsiAAJ/QZQpKAIAQQBIBEBB0AggAEHIKBAUDAELQdAIIABByCgQFAsiASAARg0AGiABCyAARxtBAEgNAAJAQZgpKAIAQQpGDQBB3CgoAgAiAEHYKCgCAEYNAEHcKCAAQQFqNgIAIABBCjoAAAwBCyMAQRBrIgAkACAAQQo6AA8CQAJAQdgoKAIAIgEEfyABBUHIKBAVDQJB2CgoAgALQdwoKAIAIgFGDQBBmCkoAgBBCkYNAEHcKCABQQFqNgIAIAFBCjoAAAwBC0HIKCAAQQ9qQQFB7CgoAgARAgBBAUcNACAALQAPGgsgAEEQaiQAC0EACyYAQeApIAI4AgAgACABSARAA0AgABAcGiAAQQFqIgAgAUcNAAsLC+UEAgZ/D30jAEGAAWsiASQAQeQpKAIAIABBBnRqIgAqAgAhByAAKgIEIQggACoCCCEJIAAqAgwhCiAAKgIQIQsgACoCFCEMIAAqAhghDSAAKgIcIQ4gACoCICEPIAAqAiQhECAAKgIoIREgACoCLCESIAAqAjAhEyAAKgI0IRQgACoCOCEVIAEgACoCPLs5A3ggASAVuzkDcCABIBS7OQNoIAEgE7s5A2AgASASuzkDWCABIBG7OQNQIAEgELs5A0ggAUFAayAPuzkDACABIA67OQM4IAEgDbs5AzAgASAMuzkDKCABIAu7OQMgIAEgCrs5AxggASAJuzkDECABIAi7OQMIIAEgB7s5AwAjAEEQayIEJAAgBCABNgIMIwBB0AFrIgAkACAAIAE2AswBIABBoAFqIgJBAEEoEBEgACAAKALMATYCyAECQEEAIABByAFqIABB0ABqIAIQKUEASA0AQZQpKAIAQQBOIQVByCgoAgAhAkGQKSgCAEEATARAQcgoIAJBX3E2AgALAn8CQAJAQfgoKAIARQRAQfgoQdAANgIAQeQoQQA2AgBB2ChCADcDAEH0KCgCACEDQfQoIAA2AgAMAQtB2CgoAgANAQtBf0HIKBAVDQEaC0HIKCAAQcgBaiAAQdAAaiAAQaABahApCyEGIAMEf0HIKEEAQQBB7CgoAgARAgAaQfgoQQA2AgBB9CggAzYCAEHkKEEANgIAQdwoKAIAGkHYKEIANwMAQQAFIAYLGkHIKEHIKCgCACACQSBxcjYCACAFRQ0ACyAAQdABaiQAIARBEGokACABQYABaiQACwgAQYgqKAIACwgAQfwpKAIACwgAQfApKAIACwgAQeQpKAIACwvnHxQAQYAIC8cXLSsgICAwWDB4AC0wWCswWCAwWC0weCsweCAweAB2ZWN0b3IAc3RkOjpleGNlcHRpb24AbmFuAGJhZF9hcnJheV9uZXdfbGVuZ3RoAGluZgBlbXNjcmlwdGVuIGhhdmUgbG9hZGVkAHN0ZDo6YmFkX2FsbG9jAE5BTgBJTkYALgAobnVsbCkAWyUuMmYsICUuMmYsICUuMmYsICUuMmZdDQpbJS4yZiwgJS4yZiwgJS4yZiwgJS4yZl0NClslLjJmLCAlLjJmLCAlLjJmLCAlLjJmXQ0KWyUuMmYsICUuMmYsICUuMmYsICUuMmZdDQoAAwAAAAQAAAAEAAAABgAAAIP5ogBETm4A/CkVANFXJwDdNPUAYtvAADyZlQBBkEMAY1H+ALveqwC3YcUAOm4kANJNQgBJBuAACeouAByS0QDrHf4AKbEcAOg+pwD1NYIARLsuAJzphAC0JnAAQX5fANaROQBTgzkAnPQ5AItfhAAo+b0A+B87AN7/lwAPmAUAES/vAApaiwBtH20Az342AAnLJwBGT7cAnmY/AC3qXwC6J3UA5evHAD178QD3OQcAklKKAPtr6gAfsV8ACF2NADADVgB7/EYA8KtrACC8zwA29JoA46kdAF5hkQAIG+YAhZllAKAUXwCNQGgAgNj/ACdzTQAGBjEAylYVAMmocwB74mAAa4zAABnERwDNZ8MACejcAFmDKgCLdsQAphyWAESv3QAZV9EApT4FAAUH/wAzfj8AwjLoAJhP3gC7fTIAJj3DAB5r7wCf+F4ANR86AH/yygDxhx0AfJAhAGokfADVbvoAMC13ABU7QwC1FMYAwxmdAK3EwgAsTUEADABdAIZ9RgDjcS0Am8aaADNiAAC00nwAtKeXADdV1QDXPvYAoxAYAE12/ABknSoAcNerAGN8+AB6sFcAFxXnAMBJVgA71tkAp4Q4ACQjywDWincAWlQjAAAfuQDxChsAGc7fAJ8x/wBmHmoAmVdhAKz7RwB+f9gAImW3ADLoiQDmv2AA78TNAGw2CQBdP9QAFt7XAFg73gDem5IA0iIoACiG6ADiWE0AxsoyAAjjFgDgfcsAF8BQAPMdpwAY4FsALhM0AIMSYgCDSAEA9Y5bAK2wfwAe6fIASEpDABBn0wCq3dgArl9CAGphzgAKKKQA05m0AAam8gBcd38Ao8KDAGE8iACKc3gAr4xaAG/XvQAtpmMA9L/LAI2B7wAmwWcAVcpFAMrZNgAoqNIAwmGNABLJdwAEJhQAEkabAMRZxADIxUQATbKRAAAX8wDUQ60AKUnlAP3VEAAAvvwAHpTMAHDO7gATPvUA7PGAALPnwwDH+CgAkwWUAMFxPgAuCbMAC0XzAIgSnACrIHsALrWfAEeSwgB7Mi8ADFVtAHKnkABr5x8AMcuWAHkWSgBBeeIA9N+JAOiUlwDi5oQAmTGXAIjtawBfXzYAu/0OAEiatABnpGwAcXJCAI1dMgCfFbgAvOUJAI0xJQD3dDkAMAUcAA0MAQBLCGgALO5YAEeqkAB05wIAvdYkAPd9pgBuSHIAnxbvAI6UpgC0kfYA0VNRAM8K8gAgmDMA9Ut+ALJjaADdPl8AQF0DAIWJfwBVUikAN2TAAG3YEAAySDIAW0x1AE5x1ABFVG4ACwnBACr1aQAUZtUAJwedAF0EUAC0O9sA6nbFAIf5FwBJa30AHSe6AJZpKQDGzKwArRRUAJDiagCI2YkALHJQAASkvgB3B5QA8zBwAAD8JwDqcagAZsJJAGTgPQCX3YMAoz+XAEOU/QANhowAMUHeAJI5nQDdcIwAF7fnAAjfOwAVNysAXICgAFqAkwAQEZIAD+jYAGyArwDb/0sAOJAPAFkYdgBipRUAYcu7AMeJuQAQQL0A0vIEAEl1JwDrtvYA2yK7AAoUqgCJJi8AZIN2AAk7MwAOlBoAUTqqAB2jwgCv7a4AXCYSAG3CTQAtepwAwFaXAAM/gwAJ8PYAK0CMAG0xmQA5tAcADCAVANjDWwD1ksQAxq1LAE7KpQCnN80A5qk2AKuSlADdQmgAGWPeAHaM7wBoi1IA/Ns3AK6hqwDfFTEAAK6hAAz72gBkTWYA7QW3ACllMABXVr8AR/86AGr5uQB1vvMAKJPfAKuAMABmjPYABMsVAPoiBgDZ5B0APbOkAFcbjwA2zQkATkLpABO+pAAzI7UA8KoaAE9lqADSwaUACz8PAFt4zQAj+XYAe4sEAIkXcgDGplMAb27iAO/rAACbSlgAxNq3AKpmugB2z88A0QIdALHxLQCMmcEAw613AIZI2gD3XaAAxoD0AKzwLwDd7JoAP1y8ANDebQCQxx8AKtu2AKMlOgAAr5oArVOTALZXBAApLbQAS4B+ANoHpwB2qg4Ae1mhABYSKgDcty0A+uX9AInb/gCJvv0A5HZsAAap/AA+gHAAhW4VAP2H/wAoPgcAYWczACoYhgBNveoAs+evAI9tbgCVZzkAMb9bAITXSAAw3xYAxy1DACVhNQDJcM4AMMu4AL9s/QCkAKIABWzkAFrdoAAhb0cAYhLSALlchABwYUkAa1bgAJlSAQBQVTcAHtW3ADPxxAATbl8AXTDkAIUuqQAdssMAoTI2AAi3pADqsdQAFvchAI9p5AAn/3cADAOAAI1ALQBPzaAAIKWZALOi0wAvXQoAtPlCABHaywB9vtAAm9vBAKsXvQDKooEACGpcAC5VFwAnAFUAfxTwAOEHhgAUC2QAlkGNAIe+3gDa/SoAayW2AHuJNAAF8/4Aub+eAGhqTwBKKqgAT8RaAC34vADXWpgA9MeVAA1NjQAgOqYApFdfABQ/sQCAOJUAzCABAHHdhgDJ3rYAv2D1AE1lEQABB2sAjLCsALLA0ABRVUgAHvsOAJVywwCjBjsAwEA1AAbcewDgRcwATin6ANbKyADo80EAfGTeAJtk2ADZvjEApJfDAHdY1ABp48UA8NoTALo6PABGGEYAVXVfANK99QBuksYArC5dAA5E7QAcPkIAYcSHACn96QDn1vMAInzKAG+RNQAI4MUA/9eNAG5q4gCw/cYAkwjBAHxddABrrbIAzW6dAD5yewDGEWoA98+pAClz3wC1yboAtwBRAOKyDQB0uiQA5X1gAHTYigANFSwAgRgMAH5mlAABKRYAn3p2AP39vgBWRe8A2X42AOzZEwCLurkAxJf8ADGoJwDxbsMAlMU2ANioVgC0qLUAz8wOABKJLQBvVzQALFaJAJnO4wDWILkAa16qAD4qnAARX8wA/QtKAOH0+wCOO20A4oYsAOnUhAD8tKkA7+7RAC41yQAvOWEAOCFEABvZyACB/AoA+0pqAC8c2ABTtIQATpmMAFQizAAqVdwAwMbWAAsZlgAacLgAaZVkACZaYAA/Uu4AfxEPAPS1EQD8y/UANLwtADS87gDoXcwA3V5gAGeOmwCSM+8AyRe4AGFYmwDhV7wAUYPGANg+EADdcUgALRzdAK8YoQAhLEYAWfPXANl6mACeVMAAT4b6AFYG/ADlea4AiSI2ADitIgBnk9wAVeiqAIImOADK55sAUQ2kAJkzsQCp1w4AaQVIAGWy8AB/iKcAiEyXAPnRNgAhkrMAe4JKAJjPIQBAn9wA3EdVAOF0OgBn60IA/p3fAF7UXwB7Z6QAuqx6AFX2ogAriCMAQbpVAFluCAAhKoYAOUeDAInj5gDlntQASftAAP9W6QAcD8oAxVmKAJT6KwDTwcUAD8XPANtargBHxYYAhUNiACGGOwAseZQAEGGHACpMewCALBoAQ78SAIgmkAB4PIkAqMTkAOXbewDEOsIAJvTqAPdnigANkr8AZaMrAD2TsQC9fAsApFHcACfdYwBp4d0AmpQZAKgplQBozigACe20AESfIABOmMoAcIJjAH58IwAPuTIAp/WOABRW5wAh8QgAtZ0qAG9+TQClGVEAtfmrAILf1gCW3WEAFjYCAMQ6nwCDoqEAcu1tADmNegCCuKkAazJcAEYnWwAANO0A0gB3APz0VQABWU0A4HGAAEHTHwt+QPsh+T8AAAAALUR0PgAAAICYRvg8AAAAYFHMeDsAAACAgxvwOQAAAEAgJXo4AAAAgCKC4zYAAAAAHfNpNRkACgAZGRkAAAAABQAAAAAAAAkAAAAACwAAAAAAAAAAGQARChkZGQMKBwABAAkLGAAACQYLAAALAAYZAAAAGRkZAEHhIAshDgAAAAAAAAAAGQAKDRkZGQANAAACAAkOAAAACQAOAAAOAEGbIQsBDABBpyELFRMAAAAAEwAAAAAJDAAAAAAADAAADABB1SELARAAQeEhCxUPAAAABA8AAAAACRAAAAAAABAAABAAQY8iCwESAEGbIgseEQAAAAARAAAAAAkSAAAAAAASAAASAAAaAAAAGhoaAEHSIgsOGgAAABoaGgAAAAAAAAkAQYMjCwEUAEGPIwsVFwAAAAAXAAAAAAkUAAAAAAAUAAAUAEG9IwsBFgBBySML/QQVAAAAABUAAAAACRYAAAAAABYAABYAADAxMjM0NTY3ODlBQkNERUZOMTBfX2N4eGFiaXYxMTZfX3NoaW1fdHlwZV9pbmZvRQAAAADgEgAA8BEAAEAUAABOMTBfX2N4eGFiaXYxMTdfX2NsYXNzX3R5cGVfaW5mb0UAAADgEgAAIBIAABQSAABOMTBfX2N4eGFiaXYxMTdfX3BiYXNlX3R5cGVfaW5mb0UAAADgEgAAUBIAABQSAABOMTBfX2N4eGFiaXYxMTlfX3BvaW50ZXJfdHlwZV9pbmZvRQDgEgAAgBIAAHQSAAAAAAAARBIAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABEAAAASAAAAAAAAACgTAAALAAAAEwAAAA0AAAAOAAAADwAAABQAAAAVAAAAFgAAAE4xMF9fY3h4YWJpdjEyMF9fc2lfY2xhc3NfdHlwZV9pbmZvRQAAAADgEgAAABMAAEQSAAAAAAAAmBMAAAEAAAAXAAAAGAAAAAAAAADAEwAAAQAAABkAAAAaAAAAAAAAAIATAAABAAAAGwAAABwAAABTdDlleGNlcHRpb24AAAAAuBIAAHATAABTdDliYWRfYWxsb2MAAAAA4BIAAIgTAACAEwAAU3QyMGJhZF9hcnJheV9uZXdfbGVuZ3RoAAAAAOASAACkEwAAmBMAAAAAAADwEwAAAgAAAB0AAAAeAAAAU3QxMWxvZ2ljX2Vycm9yAOASAADgEwAAgBMAAAAAAAAkFAAAAgAAAB8AAAAeAAAAU3QxMmxlbmd0aF9lcnJvcgAAAADgEgAAEBQAAPATAABTdDl0eXBlX2luZm8AAAAAuBIAADAUAEHIKAsBBQBB1CgLAQcAQewoCw4IAAAACQAAACgVAAAABABBhCkLAQEAQZQpCwX/////CgBB2CkLA+AbAQ==";if(!isDataURI(wasmBinaryFile)){wasmBinaryFile=locateFile(wasmBinaryFile)}function getBinarySync(file){if(file==wasmBinaryFile&&wasmBinary){return new Uint8Array(wasmBinary)}if(readBinary){return readBinary(file)}throw"both async and sync fetching of the wasm failed"}function getBinaryPromise(binaryFile){if(!wasmBinary&&(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER)){if(typeof fetch=="function"&&!isFileURI(binaryFile)){return fetch(binaryFile,{credentials:"same-origin"}).then((response=>{if(!response["ok"]){throw"failed to load wasm binary file at '"+binaryFile+"'"}return response["arrayBuffer"]()})).catch((()=>getBinarySync(binaryFile)))}else if(readAsync){return new Promise(((resolve,reject)=>{readAsync(binaryFile,(response=>resolve(new Uint8Array(response))),reject)}))}}return Promise.resolve().then((()=>getBinarySync(binaryFile)))}function instantiateArrayBuffer(binaryFile,imports,receiver){return getBinaryPromise(binaryFile).then((binary=>WebAssembly.instantiate(binary,imports))).then((instance=>instance)).then(receiver,(reason=>{err("failed to asynchronously prepare wasm: "+reason);abort(reason)}))}function instantiateAsync(binary,binaryFile,imports,callback){if(!binary&&typeof WebAssembly.instantiateStreaming=="function"&&!isDataURI(binaryFile)&&!isFileURI(binaryFile)&&!ENVIRONMENT_IS_NODE&&typeof fetch=="function"){return fetch(binaryFile,{credentials:"same-origin"}).then((response=>{var result=WebAssembly.instantiateStreaming(response,imports);return result.then(callback,(function(reason){err("wasm streaming compile failed: "+reason);err("falling back to ArrayBuffer instantiation");return instantiateArrayBuffer(binaryFile,imports,callback)}))}))}return instantiateArrayBuffer(binaryFile,imports,callback)}function createWasm(){var info={"a":wasmImports};function receiveInstance(instance,module){var exports=instance.exports;Module["asm"]=exports;wasmMemory=Module["asm"]["f"];updateMemoryViews();wasmTable=Module["asm"]["h"];addOnInit(Module["asm"]["g"]);removeRunDependency("wasm-instantiate");return exports}addRunDependency("wasm-instantiate");function receiveInstantiationResult(result){receiveInstance(result["instance"])}if(Module["instantiateWasm"]){try{return Module["instantiateWasm"](info,receiveInstance)}catch(e){err("Module.instantiateWasm callback failed with error: "+e);return false}}instantiateAsync(wasmBinary,wasmBinaryFile,info,receiveInstantiationResult);return{}}function ExitStatus(status){this.name="ExitStatus";this.message=\`Program terminated with exit(\${status})\`;this.status=status}var callRuntimeCallbacks=callbacks=>{while(callbacks.length>0){callbacks.shift()(Module)}};function ExceptionInfo(excPtr){this.excPtr=excPtr;this.ptr=excPtr-24;this.set_type=function(type){HEAPU32[this.ptr+4>>2]=type};this.get_type=function(){return HEAPU32[this.ptr+4>>2]};this.set_destructor=function(destructor){HEAPU32[this.ptr+8>>2]=destructor};this.get_destructor=function(){return HEAPU32[this.ptr+8>>2]};this.set_caught=function(caught){caught=caught?1:0;HEAP8[this.ptr+12>>0]=caught};this.get_caught=function(){return HEAP8[this.ptr+12>>0]!=0};this.set_rethrown=function(rethrown){rethrown=rethrown?1:0;HEAP8[this.ptr+13>>0]=rethrown};this.get_rethrown=function(){return HEAP8[this.ptr+13>>0]!=0};this.init=function(type,destructor){this.set_adjusted_ptr(0);this.set_type(type);this.set_destructor(destructor)};this.set_adjusted_ptr=function(adjustedPtr){HEAPU32[this.ptr+16>>2]=adjustedPtr};this.get_adjusted_ptr=function(){return HEAPU32[this.ptr+16>>2]};this.get_exception_ptr=function(){var isPointer=___cxa_is_pointer_type(this.get_type());if(isPointer){return HEAPU32[this.excPtr>>2]}var adjusted=this.get_adjusted_ptr();if(adjusted!==0)return adjusted;return this.excPtr}}var exceptionLast=0;var uncaughtExceptionCount=0;function ___cxa_throw(ptr,type,destructor){var info=new ExceptionInfo(ptr);info.init(type,destructor);exceptionLast=ptr;uncaughtExceptionCount++;throw exceptionLast}var _abort=()=>{abort("")};var _emscripten_memcpy_big=(dest,src,num)=>HEAPU8.copyWithin(dest,src,src+num);var getHeapMax=()=>2147483648;var growMemory=size=>{var b=wasmMemory.buffer;var pages=size-b.byteLength+65535>>>16;try{wasmMemory.grow(pages);updateMemoryViews();return 1}catch(e){}};var _emscripten_resize_heap=requestedSize=>{var oldSize=HEAPU8.length;requestedSize>>>=0;var maxHeapSize=getHeapMax();if(requestedSize>maxHeapSize){return false}var alignUp=(x,multiple)=>x+(multiple-x%multiple)%multiple;for(var cutDown=1;cutDown<=4;cutDown*=2){var overGrownHeapSize=oldSize*(1+.2/cutDown);overGrownHeapSize=Math.min(overGrownHeapSize,requestedSize+100663296);var newSize=Math.min(maxHeapSize,alignUp(Math.max(requestedSize,overGrownHeapSize),65536));var replacement=growMemory(newSize);if(replacement){return true}}return false};var printCharBuffers=[null,[],[]];var UTF8Decoder=typeof TextDecoder!="undefined"?new TextDecoder("utf8"):undefined;var UTF8ArrayToString=(heapOrArray,idx,maxBytesToRead)=>{var endIdx=idx+maxBytesToRead;var endPtr=idx;while(heapOrArray[endPtr]&&!(endPtr>=endIdx))++endPtr;if(endPtr-idx>16&&heapOrArray.buffer&&UTF8Decoder){return UTF8Decoder.decode(heapOrArray.subarray(idx,endPtr))}var str="";while(idx<endPtr){var u0=heapOrArray[idx++];if(!(u0&128)){str+=String.fromCharCode(u0);continue}var u1=heapOrArray[idx++]&63;if((u0&224)==192){str+=String.fromCharCode((u0&31)<<6|u1);continue}var u2=heapOrArray[idx++]&63;if((u0&240)==224){u0=(u0&15)<<12|u1<<6|u2}else{u0=(u0&7)<<18|u1<<12|u2<<6|heapOrArray[idx++]&63}if(u0<65536){str+=String.fromCharCode(u0)}else{var ch=u0-65536;str+=String.fromCharCode(55296|ch>>10,56320|ch&1023)}}return str};var printChar=(stream,curr)=>{var buffer=printCharBuffers[stream];if(curr===0||curr===10){(stream===1?out:err)(UTF8ArrayToString(buffer,0));buffer.length=0}else{buffer.push(curr)}};var UTF8ToString=(ptr,maxBytesToRead)=>ptr?UTF8ArrayToString(HEAPU8,ptr,maxBytesToRead):"";var SYSCALLS={varargs:undefined,get(){SYSCALLS.varargs+=4;var ret=HEAP32[SYSCALLS.varargs-4>>2];return ret},getStr(ptr){var ret=UTF8ToString(ptr);return ret}};var _fd_write=(fd,iov,iovcnt,pnum)=>{var num=0;for(var i=0;i<iovcnt;i++){var ptr=HEAPU32[iov>>2];var len=HEAPU32[iov+4>>2];iov+=8;for(var j=0;j<len;j++){printChar(fd,HEAPU8[ptr+j])}num+=len}HEAPU32[pnum>>2]=num;return 0};var _proc_exit=code=>{EXITSTATUS=code;if(!keepRuntimeAlive()){if(Module["onExit"])Module["onExit"](code);ABORT=true}quit_(code,new ExitStatus(code))};var exitJS=(status,implicit)=>{EXITSTATUS=status;_proc_exit(status)};var handleException=e=>{if(e instanceof ExitStatus||e=="unwind"){return EXITSTATUS}quit_(1,e)};var lengthBytesUTF8=str=>{var len=0;for(var i=0;i<str.length;++i){var c=str.charCodeAt(i);if(c<=127){len++}else if(c<=2047){len+=2}else if(c>=55296&&c<=57343){len+=4;++i}else{len+=3}}return len};var stringToUTF8Array=(str,heap,outIdx,maxBytesToWrite)=>{if(!(maxBytesToWrite>0))return 0;var startIdx=outIdx;var endIdx=outIdx+maxBytesToWrite-1;for(var i=0;i<str.length;++i){var u=str.charCodeAt(i);if(u>=55296&&u<=57343){var u1=str.charCodeAt(++i);u=65536+((u&1023)<<10)|u1&1023}if(u<=127){if(outIdx>=endIdx)break;heap[outIdx++]=u}else if(u<=2047){if(outIdx+1>=endIdx)break;heap[outIdx++]=192|u>>6;heap[outIdx++]=128|u&63}else if(u<=65535){if(outIdx+2>=endIdx)break;heap[outIdx++]=224|u>>12;heap[outIdx++]=128|u>>6&63;heap[outIdx++]=128|u&63}else{if(outIdx+3>=endIdx)break;heap[outIdx++]=240|u>>18;heap[outIdx++]=128|u>>12&63;heap[outIdx++]=128|u>>6&63;heap[outIdx++]=128|u&63}}heap[outIdx]=0;return outIdx-startIdx};var stringToUTF8=(str,outPtr,maxBytesToWrite)=>stringToUTF8Array(str,HEAPU8,outPtr,maxBytesToWrite);var stringToUTF8OnStack=str=>{var size=lengthBytesUTF8(str)+1;var ret=stackAlloc(size);stringToUTF8(str,ret,size);return ret};var wasmImports={b:___cxa_throw,d:_abort,e:_emscripten_memcpy_big,c:_emscripten_resize_heap,a:_fd_write};var asm=createWasm();var ___wasm_call_ctors=function(){return(___wasm_call_ctors=Module["asm"]["g"]).apply(null,arguments)};var _allocation=Module["_allocation"]=function(){return(_allocation=Module["_allocation"]=Module["asm"]["i"]).apply(null,arguments)};var _getMatrixBufferPtr=Module["_getMatrixBufferPtr"]=function(){return(_getMatrixBufferPtr=Module["_getMatrixBufferPtr"]=Module["asm"]["j"]).apply(null,arguments)};var _getSRTPtr=Module["_getSRTPtr"]=function(){return(_getSRTPtr=Module["_getSRTPtr"]=Module["asm"]["k"]).apply(null,arguments)};var _getInfoPtr=Module["_getInfoPtr"]=function(){return(_getInfoPtr=Module["_getInfoPtr"]=Module["asm"]["l"]).apply(null,arguments)};var _getContinuedSRTPtr=Module["_getContinuedSRTPtr"]=function(){return(_getContinuedSRTPtr=Module["_getContinuedSRTPtr"]=Module["asm"]["m"]).apply(null,arguments)};var _printMatrix=Module["_printMatrix"]=function(){return(_printMatrix=Module["_printMatrix"]=Module["asm"]["n"]).apply(null,arguments)};var _updateAllMatrixContinueTransform=Module["_updateAllMatrixContinueTransform"]=function(){return(_updateAllMatrixContinueTransform=Module["_updateAllMatrixContinueTransform"]=Module["asm"]["o"]).apply(null,arguments)};var _main=Module["_main"]=function(){return(_main=Module["_main"]=Module["asm"]["p"]).apply(null,arguments)};var ___errno_location=function(){return(___errno_location=Module["asm"]["__errno_location"]).apply(null,arguments)};var stackAlloc=function(){return(stackAlloc=Module["asm"]["q"]).apply(null,arguments)};var ___cxa_is_pointer_type=function(){return(___cxa_is_pointer_type=Module["asm"]["r"]).apply(null,arguments)};var calledRun;dependenciesFulfilled=function runCaller(){if(!calledRun)run();if(!calledRun)dependenciesFulfilled=runCaller};function callMain(args=[]){var entryFunction=_main;args.unshift(thisProgram);var argc=args.length;var argv=stackAlloc((argc+1)*4);var argv_ptr=argv>>2;args.forEach((arg=>{HEAP32[argv_ptr++]=stringToUTF8OnStack(arg)}));HEAP32[argv_ptr]=0;try{var ret=entryFunction(argc,argv);exitJS(ret,true);return ret}catch(e){return handleException(e)}}function run(args=arguments_){if(runDependencies>0){return}preRun();if(runDependencies>0){return}function doRun(){if(calledRun)return;calledRun=true;Module["calledRun"]=true;if(ABORT)return;initRuntime();preMain();if(Module["onRuntimeInitialized"])Module["onRuntimeInitialized"]();if(shouldRunNow)callMain(args);postRun()}if(Module["setStatus"]){Module["setStatus"]("Running...");setTimeout((function(){setTimeout((function(){Module["setStatus"]("")}),1);doRun()}),1)}else{doRun()}}if(Module["preInit"]){if(typeof Module["preInit"]=="function")Module["preInit"]=[Module["preInit"]];while(Module["preInit"].length>0){Module["preInit"].pop()()}}var shouldRunNow=true;if(Module["noInitialRun"])shouldRunNow=false;run();

if (!Module['ENVIRONMENT_IS_PTHREAD']) {
    // console.log("is main");
    window['wasmMatrix'] = Module;
}
        `,Si=class{static async init(i){await new Promise(e=>{const t=document.createElement("script");t.async=!0,t.type="text/javascript",t.src=URL.createObjectURL(new Blob([$f])),document.head.appendChild(t),t.onload=()=>{let r=()=>{this.wasm=window.wasmMatrix,this.wasm&&this.wasm.calledRun?e(!0):setTimeout(r,20)};r()}}),this.allocMatrix(i)}static allocMatrix(i){i>V.maxCount&&console.error(`The maximum allocation size is exceeded! current:${i}, limit:${V.maxCount}`),this.wasm._allocation(i),this.matrixBufferPtr=this.wasm._getMatrixBufferPtr(),this.matrixSRTBufferPtr=this.wasm._getSRTPtr(),this.matrixStateBufferPtr=this.wasm._getInfoPtr(),this.matrixContinuedSRTBufferPtr=this.wasm._getContinuedSRTPtr(),this.matrixBuffer=new Float32Array(this.wasm.HEAPF32.buffer,this.matrixBufferPtr,16*i),this.matrixSRTBuffer=new Float32Array(this.wasm.HEAPF32.buffer,this.matrixSRTBufferPtr,3*3*i),this.matrixContinuedSRTBuffer=new Float32Array(this.wasm.HEAPF32.buffer,this.matrixContinuedSRTBufferPtr,3*3*i),this.matrixStateBuffer=new Int32Array(this.wasm.HEAP32.buffer,this.matrixStateBufferPtr,Si.stateStruct*i),V.allocMatrix(i)}static updateAllContinueTransform(i,e,t){this.wasm._updateAllMatrixContinueTransform(i,e,t)}static setParent(i,e,t){this.matrixStateBuffer[i*Si.stateStruct+2]=e>=0?e:-1,this.matrixStateBuffer[i*Si.stateStruct+3]=t}static setTranslate(i,e,t,r){this.matrixSRTBuffer[i*9+6]=e,this.matrixSRTBuffer[i*9+7]=t,this.matrixSRTBuffer[i*9+8]=r}static setRotation(i,e,t,r){this.matrixSRTBuffer[i*9+3]=e%360,this.matrixSRTBuffer[i*9+4]=t%360,this.matrixSRTBuffer[i*9+5]=r%360}static setScale(i,e,t,r){this.matrixSRTBuffer[i*9+0]=e,this.matrixSRTBuffer[i*9+1]=t,this.matrixSRTBuffer[i*9+2]=r}static setContinueTranslate(i,e,t,r){(e!=0||t!=0||r!=0)&&(this.matrixContinuedSRTBuffer[i*9+6]=e,this.matrixContinuedSRTBuffer[i*9+7]=t,this.matrixContinuedSRTBuffer[i*9+8]=r,this.matrixStateBuffer[i*Si.stateStruct+1]=1)}static setContinueRotation(i,e,t,r){(e!=0||t!=0||r!=0)&&(this.matrixContinuedSRTBuffer[i*9+3]=e,this.matrixContinuedSRTBuffer[i*9+4]=t,this.matrixContinuedSRTBuffer[i*9+5]=r,this.matrixStateBuffer[i*Si.stateStruct+1]=1)}static setContinueScale(i,e,t,r){(e!=0||t!=0||r!=0)&&(this.matrixContinuedSRTBuffer[i*9+0]=e,this.matrixContinuedSRTBuffer[i*9+1]=t,this.matrixContinuedSRTBuffer[i*9+2]=r,this.matrixStateBuffer[i*Si.stateStruct+1]=1)}};let ee=Si;o(ee,"matrixBuffer"),o(ee,"matrixSRTBuffer"),o(ee,"matrixContinuedSRTBuffer"),o(ee,"matrixStateBuffer"),o(ee,"matrixBufferPtr"),o(ee,"matrixSRTBufferPtr"),o(ee,"matrixContinuedSRTBufferPtr"),o(ee,"matrixStateBufferPtr"),o(ee,"wasm"),o(ee,"stateStruct",4);class yt{}o(yt,"AXIS_ANGLE","axisAngle"),o(yt,"EULER_ANGLES","eulerAngles"),o(yt,"QUATERNION","quaternion");const dt=class{constructor(i=0,e=0,t=0,r=1){o(this,"x",0),o(this,"y",0),o(this,"z",0),o(this,"w",1),this.x=i,this.y=e,this.z=t,this.w=r}static identity(){return dt._zero}static quaternionToMatrix(i,e){let t=i.x*2,r=i.y*2,s=i.z*2,a=i.x*t,n=i.y*r,l=i.z*s,h=i.x*r,u=i.x*s,c=i.y*s,f=i.w*t,d=i.w*r,p=i.w*s;e.rawData[0]=1-(n+l),e.rawData[1]=h+p,e.rawData[2]=u-d,e.rawData[3]=0,e.rawData[4]=h-p,e.rawData[5]=1-(a+l),e.rawData[6]=c+f,e.rawData[7]=0,e.rawData[8]=u+d,e.rawData[9]=c-f,e.rawData[10]=1-(a+n),e.rawData[11]=0,e.rawData[12]=0,e.rawData[13]=0,e.rawData[14]=0,e.rawData[15]=1}get magnitude(){return Math.sqrt(this.w*this.w+this.x*this.x+this.y*this.y+this.z*this.z)}set(i=0,e=0,t=0,r=1){this.x=i,this.y=e,this.z=t,this.w=r}divide(i){return i instanceof dt?new dt(this.x/i.x,this.y/i.y,this.z/i.z):(this.x=this.x/i,this.y=this.y/i,this.z=this.z/i,this)}setFromArray(i){return this.x=i[0],this.y=i[1],this.z=i[2],this.w=i[3],this}multiply(i,e){var t=i.w,r=i.x,s=i.y,a=i.z,n=e.w,l=e.x,h=e.y,u=e.z;this.w=t*n-r*l-s*h-a*u,this.x=t*l+r*n+s*u-a*h,this.y=t*h-r*u+s*n+a*l,this.z=t*u+r*h-s*l+a*n}multiplyVector(i,e=null){e||(e=new dt);var t=i.x,r=i.y,s=i.z;return e.w=-this.x*t-this.y*r-this.z*s,e.x=this.w*t+this.y*s-this.z*r,e.y=this.w*r-this.x*s+this.z*t,e.z=this.w*s+this.x*r-this.y*t,e}fromAxisAngle(i,e){e*=Math.PI/180;var t=e*.5,r=Math.sin(t);this.w=Math.cos(t),this.x=i.x*r,this.y=i.y*r,this.z=i.z*r,this.normalize()}toAxisAngle(i){var e=this.x*this.x+this.y*this.y+this.z*this.z,t=0;return e>0?(t=2*Math.acos(this.w),e=1/Math.sqrt(e),i.x=this.x*e,i.y=this.y*e,i.z=this.z*e):(t=0,i.x=1,i.y=0,i.z=0),t}slerp(i,e,t){var r=i.w,s=i.x,a=i.y,n=i.z,l=e.w,h=e.x,u=e.y,c=e.z,f=r*l+s*h+a*u+n*c;if(f<0&&(f=-f,l=-l,h=-h,u=-u,c=-c),f<.95){var d=Math.acos(f),p=1/Math.sin(d),m=Math.sin(d*(1-t))*p,_=Math.sin(d*t)*p;this.w=r*m+l*_,this.x=s*m+h*_,this.y=a*m+u*_,this.z=n*m+c*_}else{this.w=r+t*(l-r),this.x=s+t*(h-s),this.y=a+t*(u-a),this.z=n+t*(c-n);var v=1/Math.sqrt(this.w*this.w+this.x*this.x+this.y*this.y+this.z*this.z);this.w*=v,this.x*=v,this.y*=v,this.z*=v}}lerp(i,e,t){var r=i.w,s=i.x,a=i.y,n=i.z,l=e.w,h=e.x,u=e.y,c=e.z,f;r*l+s*h+a*u+n*c<0&&(l=-l,h=-h,u=-u,c=-c),this.w=r+t*(l-r),this.x=s+t*(h-s),this.y=a+t*(u-a),this.z=n+t*(c-n),f=1/Math.sqrt(this.w*this.w+this.x*this.x+this.y*this.y+this.z*this.z),this.w*=f,this.x*=f,this.y*=f,this.z*=f}fromEulerAngles(i,e,t){i*=_e,e*=_e,t*=_e;var r=i*.5,s=e*.5,a=t*.5,n=Math.cos(r),l=Math.sin(r),h=Math.cos(s),u=Math.sin(s),c=Math.cos(a),f=Math.sin(a);return this.w=n*h*c+l*u*f,this.x=l*h*c-n*u*f,this.y=n*u*c+l*h*f,this.z=n*h*f-l*u*c,this}setFromRotationMatrix(i){const e=i.rawData,t=e[0],r=e[4],s=e[8],a=e[1],n=e[5],l=e[9],h=e[2],u=e[6],c=e[10],f=t+n+c;if(f>0){const d=.5/Math.sqrt(f+1);this.w=.25/d,this.x=(u-l)*d,this.y=(s-h)*d,this.z=(a-r)*d}else if(t>n&&t>c){const d=2*Math.sqrt(1+t-n-c);this.w=(u-l)/d,this.x=.25*d,this.y=(r+a)/d,this.z=(s+h)/d}else if(n>c){const d=2*Math.sqrt(1+n-t-c);this.w=(s-h)/d,this.x=(r+a)/d,this.y=.25*d,this.z=(l+u)/d}else{const d=2*Math.sqrt(1+c-t-n);this.w=(a-r)/d,this.x=(s+h)/d,this.y=(l+u)/d,this.z=.25*d}return this}getEulerAngles(i){var e,t,r,s,a,n,l,h;return i||(i=new g),s=this.x,a=this.y,n=this.z,l=this.w,h=2*(l*a-s*n),h<=-.99999?(e=2*Math.atan2(s,l),t=-Math.PI/2,r=0):h>=.99999?(e=2*Math.atan2(s,l),t=Math.PI/2,r=0):(e=Math.atan2(2*(l*s+a*n),1-2*(s*s+a*a)),t=Math.asin(h),r=Math.atan2(2*(l*n+s*a),1-2*(a*a+n*n))),i.set(e,t,r).scaleBy(qi)}normalize(i=1){var e=i/Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w);this.x*=e,this.y*=e,this.z*=e,this.w*=e}toString(){return"{x:"+this.x+" y:"+this.y+" z:"+this.z+" w:"+this.w+"}"}fromMatrix(i){var e=i.decompose(yt.QUATERNION)[1];this.x=e.x,this.y=e.y,this.z=e.z,this.w=e.w}inverse(i=null){i||(i=new dt);var e=this.w*this.w+this.x*this.x+this.y*this.y+this.z*this.z;if(e>0){var t=1/e;i.w=this.w*t,i.x=-this.x*t,i.y=-this.y*t,i.z=-this.z*t}return i}clone(){return new dt(this.x,this.y,this.z,this.w)}transformVector(i,e=null){var t,r,s,a,n=i.x,l=i.y,h=i.z;return e||(e=new g),a=-this.x*n-this.y*l-this.z*h,t=this.w*n+this.y*h-this.z*l,r=this.w*l-this.x*h+this.z*n,s=this.w*h+this.x*l-this.y*n,e.x=-a*this.x+t*this.w-r*this.z+s*this.y,e.y=-a*this.y+t*this.z+r*this.w-s*this.x,e.z=-a*this.z-t*this.y+r*this.x+s*this.w,e}copyFrom(i){var e=this;return e.x=i.x,e.y=i.y,e.z=i.z,e.w=i.w,this}mul(i,e,t){let r=t||new dt;return r.x=i.w*e.x+i.x*e.w+i.y*e.z-i.z*e.y,r.y=i.w*e.y+i.y*e.w+i.z*e.x-i.x*e.z,r.z=i.w*e.z+i.z*e.w+i.x*e.y-i.y*e.x,r.w=i.w*e.w-i.x*e.x-i.y*e.y-i.z*e.z,r}clampf(i,e,t){if(e>t){var r=e;e=t,t=r}return i<e?e:i<t?i:t}};let q=dt;o(q,"HELP_0",new dt(0,0,0,1)),o(q,"HELP_1",new dt(0,0,0,1)),o(q,"HELP_2",new dt(0,0,0,1)),o(q,"_zero",new dt(0,0,0,1)),o(q,"CALCULATION_QUATERNION",new dt);function ed(i,e,t){let r=i.x*2,s=i.y*2,a=i.z*2,n=i.x*r,l=i.y*s,h=i.z*a,u=i.x*s,c=i.x*a,f=i.y*a,d=i.w*r,p=i.w*s,m=i.w*a,_=t||new g;return _.x=(1-(l+h))*e.x+(u-m)*e.y+(c+p)*e.z,_.y=(u+m)*e.x+(1-(n+h))*e.y+(f-d)*e.z,_.z=(c-p)*e.x+(f+d)*e.y+(1-(n+l))*e.z,_}class As{constructor(e=0){o(this,"_x",0),o(this,"_y",0),o(this,"_z",0),o(this,"_w",0),this.seed=e}get seed(){return this._x}set seed(e){this._x=e,this._y=this._x*1812433253+1,this._z=this._y*1812433253+1,this._w=this._z*1812433253+1}static getFloatFromInt(e){return Math.floor((e&8388607)*(1/8388607))}static getByteFromInt(e){return e>>23-8}clone(){let e=new As;return e._x=this._x,e._y=this._y,e._z=this._z,e._w=this._w,e}get(){let e=this._x^this._x<<11;return this._x=this._y,this._y=this._z,this._z=this._w,this._w=this._w^this._w>>19^(e^e>>8)}getFloat(){return fl(this.get())}getSignedFloat(){return this.getFloat()*2-1}}let qi=180/Math.PI,_e=Math.PI/180,td=2147483647,id=-2147483647;function K(i,e,t){return Math.max(e,Math.min(t,i))}class st{static gaussFunction(e,t,r,s){let a=Math.pow(e-r,2),n=2*Math.pow(s,2),l=-1*(a/n),h=Math.pow(Math.E,l);return Math.round(h*t)}static computeGaussian(e,t){return 1/Math.sqrt(2*Math.PI*t)*Math.exp(-(e*e)/(2*t*t))}static gaussCoef(e){e<.5&&(e=.5);let t=Math.exp(.726*.726)/e,r=Math.exp(-t),s=Math.exp(-2*t),a=(1-r)*(1-r)/(1+2*t*r-s),n=a,l=a*(t-1)*r,h=a*(t+1)*r,u=-a*s,c=2*r,f=-s,d=(n+l)/(1-c-f),p=(h+u)/(1-c-f);return new Float32Array([n,l,h,u,c,f,d,p])}static clampf(e,t,r){if(t>r){let s=t;t=r,r=s}return e<t?t:e<r?e:r}static normalizeAngle(e){for(;e>180;)e-=360;for(;e<-180;)e+=360;return e}static fract(e){return e-Math.floor(e)}static getRandDirXZ(e){let t=e*Math.random(),r=360*Math.random()*_e,s=Math.cos(r)*t,a=Math.sin(r)*t;return{x:s,z:a}}static getRandDirXYZ(e){let t=e*Math.random(),r=360*Math.random()*_e,s=Math.cos(r)*t,a=Math.tan(r)*t,n=Math.sin(r)*t;return new g(s,a,n)}static getCycleXYZ(e){let t=e*Math.random(),r=360*Math.random()*_e,s=Math.cos(r)*t,a=e*Math.random()-e*.5,n=Math.sin(r)*t;return new g(s,a,n)}static angle(e,t){let r=Z.HELP_0,s=Z.HELP_1;return r.set(e.x,e.z),s.set(t.x,t.z),Math.acos((r.x*s.x+r.y*s.y)/(r.abs()*s.abs()))}static angle_360(e,t){let r=g.HELP_0;return e.crossProduct(t,r),r.z>0?st.angle(e,t):360-st.angle(e,t)}getRotationY(e){return st.normalizeAngle(Math.atan2(e.z,e.x)*qi)}static fromToRotation(e,t,r=null){r||(r=new q);let s=V.help_matrix_2;return V.fromToRotation(e,t,s),r.fromMatrix(s),r}static getEularDir_yUp(e){let t=q.HELP_0;return t.fromEulerAngles(0,e,0),t.transformVector(g.Z_AXIS,g.HELP_5),g.HELP_5}static transformVector(e,t,r=null){r||(r=new g);let s=e.rawData,a=s[0],n=s[1],l=s[2],h=s[3],u=s[4],c=s[5],f=s[6],d=s[7],p=s[8],m=s[9],_=s[10],v=s[11],y=s[12],C=s[13],B=s[14],T=s[15],M=t.x,D=t.y,P=t.z;return r.x=a*M+u*D+p*P+y,r.y=n*M+c*D+m*P+C,r.z=l*M+f*D+_*P+B,r.w=h*M+d*D+v*P+T,r}}let Ii=function(i,e,t){return i*(1-t)+e*t};function rd(i,e,t){let r=new g,s=i.x,a=i.y,n=i.z,l=i.w,h=e.x,u=e.y,c=e.z,f=e.w;return r.x=(h-s)*t+s,r.y=(u-a)*t+a,r.z=(c-n)*t+n,r.w=(f-l)*t+l,r}function sd(i,e,t){let r=new z;return r.r=(1-t)*i.r+t*e.r,r.g=(1-t)*i.g+t*e.g,r.b=(1-t)*i.b+t*e.b,r.a=(1-t)*i.a+t*e.a,r}function ad(i,e,t){return i+((e-i)*t>>8)&255}let Ja=function(i,e,t){let r=t-e;return Math.floor(i/r)%2==0?i%r+e:t-i%r+e},Za=function(i,e,t){let r=t-e;return i%r+e},od=function(i,e){let t=0;for(let r in i)r==e&&t++;return t};class nd{constructor(){o(this,"x",0),o(this,"y",0),o(this,"z",0),o(this,"w",0),o(this,"randSeedList"),this.randSeedList=[]}reset(){this.x=Math.random()*1,this.y=Math.random()*1,this.z=Math.random()*1,this.w=Math.random()*1,this.randSeedList.length=0;for(let e=0;e<20;e++)this.randSeedList.push(Math.random()*1)}}function et(i,e){return i instanceof g&&e instanceof g||i instanceof q&&e instanceof q?i.x*e.x+i.y*e.y+i.z*e.z:i.x*e.x+i.y*e.y}function $a(i,e){return new g(i.x*e.x,i.y*e.y,i.z*e.z)}function ul(i){return Math.sqrt(i)}function eo(i){return ul(et(i,i))}function cl(i,e){if(eo(i)>g.EPSILON)return i.divide(eo(i));if(i instanceof Z)return new Z;if(i instanceof g)return new g;if(i instanceof q)return new q}function fl(i){return(i&8388607)*(1/8388607)}function Ki(i){return i.getFloat()}function qe(i,e,t){let r=i.getFloat();return r=e*r+(1-r)*t,r}function ld(i,e,t){let r;if(e<t){r=t-e;let s=i.get()%r;return s+=e,s}else if(e>t){r=e-t;let s=i.get()%r;return s=e-s,s}else return e}function Ps(i){let e=qe(i,-1,1),t=qe(i,0,2*Math.PI),r=Math.sqrt(1-e*e),s=r*Math.cos(t),a=r*Math.sin(t);return new g(s,a,e)}function dl(i){let e=qe(i,0,2*Math.PI),t=Math.cos(e),r=Math.sin(e);return new Z(t,r)}function hd(i){let e=new q;return e.x=qe(i,-1,1),e.y=qe(i,-1,1),e.z=qe(i,-1,1),e.w=qe(i,-1,1),e=cl(e),et(e,q.identity())<0?-e:e}function ud(i){const e=2*Math.PI;let t=qe(i,0,1),r=qe(i,0,e),s=qe(i,0,e),a=Math.sqrt(1-t),n=Math.sqrt(t),l=new q(a*Math.sin(r),a*Math.cos(r),n*Math.sin(s),n*Math.cos(s));return et(l,q.identity())<0?-l:l}function cd(i,e){return new g(qe(i,-e.x,e.x),qe(i,-e.y,e.y),qe(i,-e.z,e.z))}function gl(i){let e=Ps(i);return e.scaleBy(Math.pow(Ki(i),1/3)),e}function fd(i,e){return $a(gl(i),e)}function dd(i,e,t){let r=Ps(i),s=Math.pow(qe(i,0,1),1/3);return r.scaleBy(e+(t-e)*s),r}function gd(i){let e=dl(i);return e.multiply(Math.pow(qe(i,0,1),1/2),e),e}function pd(i,e,t){let r=$a(Ps(i),e),s=Math.pow(qe(i,t,1),1/3);return r.scaleBy(s),r}function md(i){let e=i.getFloat(),t=i.getFloat();e+t>1&&(e=1-e,t=1-t);let r=1-e-t;return new g(e,t,r)}function Ad(i){return i/360*2*Math.PI}function _d(i){return 180*i/Math.PI}function xd(i){return Math.sin(i)}function vd(i){return Math.cos(i)}let pl=4919;function yd(){return++pl}function Cd(i,e,t){let r=i[e],s=i[t];i[e]=s,i[t]=r}function ml(i){return Math.floor(i)}function to(i){return ml(i+.5)}function wd(i){return i=Math.max(i,0),i=Math.min(i,1),to(i*65535)}function bd(i){return i=Math.max(i,0),i=Math.min(i,1),to(i*255)}function Al(i){return Math.abs(i)==0?i:1/Math.sqrt(i)}function Sd(i){let e=io(i);return i.scaleBy(Al(e))}function Id(i,e){return i.crossProduct(e)}function io(i){return et(i,i)}function Ed(i){let e=new As(i);return Ki(e)}function Bd(i,e){let t=new As(e);i.x=Ki(t),i.y=Ki(t),i.z=Ki(t)}function Td(i,e,t){return i<e?t:i>t?e:i}function ro(i,e){return i-Math.floor(i/e)*e}const Md=1e-6,F=class{constructor(i=!1){if(o(this,"index",0),o(this,"offset",0),o(this,"rawData"),o(this,"_position"),F.useCount>=F.allocCount){let e=F.allocCount+F.allocOnceCount;ee.allocMatrix(e)}this.index=F.useCount,this.offset=F.wasmMatrixPtr+this.index*F.blockBytes,F.dynamicGlobalMatrixRef[this.index]=this,F.useCount++,this.rawData=new Float32Array(F.dynamicMatrixBytes.buffer,this.offset,16),this._position=new g,this.identity()}static allocMatrix(i){this.allocCount=i,F.dynamicMatrixBytes=ee.matrixBuffer,F.buffer=F.dynamicMatrixBytes.buffer,F.wasmMatrixPtr=ee.matrixBufferPtr,this.dynamicGlobalMatrixRef||(this.dynamicGlobalMatrixRef=[]),this.dynamicGlobalMatrixRef.forEach(e=>{e.offset=F.wasmMatrixPtr+e.index*F.blockBytes,e.rawData=new Float32Array(F.dynamicMatrixBytes.buffer,e.offset,16)}),F.help_matrix_0||(F.help_matrix_0=new F),F.help_matrix_1||(F.help_matrix_1=new F),F.help_matrix_2||(F.help_matrix_2=new F),F.helpMatrix||(F.helpMatrix=new F),F.helpMatrix2||(F.helpMatrix2=new F),F._getEulerMatrix||(F._getEulerMatrix=new F),F._getEulerMatrix.identity()}static fromToRotation(i,e,t){return t||(t=new F),t.transformDir(i,e),t}static getAxisRotation(i,e,t,r){let s=new F,a=r*(Math.PI/180),n=Math.cos(a),l=Math.sin(a),h=1-n,u,c;return s.rawData[0]=n+i*i*h,s.rawData[5]=n+e*e*h,s.rawData[10]=n+t*t*h,u=i*e*h,c=t*l,s.rawData[1]=u+c,s.rawData[4]=u-c,u=i*t*h,c=e*l,s.rawData[8]=u+c,s.rawData[2]=u-c,u=e*t*h,c=i*l,s.rawData[9]=u-c,s.rawData[6]=u+c,s}static sanitizeEuler(i){F.makePositive(i)}static makePositive(i){let e=-1e-4,t=Math.PI*2-1e-4;i.x<e?i.x+=2*Math.PI:i.x>t&&(i.x-=2*Math.PI),i.y<e?i.y+=2*Math.PI:i.y>t&&(i.y-=2*Math.PI),i.z<e?i.z+=2*Math.PI:i.z>t&&(i.z-=2*Math.PI)}static matrixToEuler(i,e){return i.get(1,2)<.999?i.get(1,2)>-.999?(e.x=Math.asin(-i.get(1,2)),e.y=Math.atan2(i.get(0,2),i.get(2,2)),e.z=Math.atan2(i.get(1,0),i.get(1,1)),F.sanitizeEuler(e),!0):(e.x=Math.PI*.5,e.y=Math.atan2(i.get(0,1),i.get(0,0)),e.z=0,F.sanitizeEuler(e),!1):(e.x=-Math.PI*.5,e.y=Math.atan2(-i.get(0,1),i.get(0,0)),e.z=0,F.sanitizeEuler(e),!1)}static matrixMultiply(i,e,t){F.wasm.Matrix_Multiply(i.index,e.index,t.index)}static matrixAppend(i,e,t){F.wasm.Matrix_Append(i.index,e.index,t.index)}static matrixRotateY(i,e){F.wasm.Matrix_Append(i,e.index)}static matrixRotate(i,e,t){F.wasm.Matrix_Rotate(i,e,t.index)}lookAt(i,e,t=g.Y_AXIS){let r=this.rawData,s=e.subtract(i,g.HELP_0);s.length<1e-4&&(s.z=1),s.normalize();let a=t.crossProduct(s,g.HELP_1);a.length<1e-4&&(Math.abs(t.z)>.9999?s.x+=1e-4:s.z+=1e-4,s.normalize()),a=t.crossProduct(s,a).normalize();let n=s.crossProduct(a,g.HELP_2).normalize();r[0]=a.x,r[1]=n.x,r[2]=s.x,r[3]=0,r[4]=a.y,r[5]=n.y,r[6]=s.y,r[7]=0,r[8]=a.z,r[9]=n.z,r[10]=s.z,r[11]=0,r[12]=-a.dotProduct(i),r[13]=-n.dotProduct(i),r[14]=-s.dotProduct(i),r[15]=1}multiply(i){let e=this.rawData,t=i.rawData,r=F.float32Array;r[0]=e[0]*t[0]+e[1]*t[4]+e[2]*t[8]+e[3]*t[12],r[1]=e[0]*t[1]+e[1]*t[5]+e[2]*t[9]+e[3]*t[13],r[2]=e[0]*t[2]+e[1]*t[6]+e[2]*t[10]+e[3]*t[14],r[3]=e[0]*t[3]+e[1]*t[7]+e[2]*t[11]+e[3]*t[15],r[4]=e[4]*t[0]+e[5]*t[4]+e[6]*t[8]+e[7]*t[12],r[5]=e[4]*t[1]+e[5]*t[5]+e[6]*t[9]+e[7]*t[13],r[6]=e[4]*t[2]+e[5]*t[6]+e[6]*t[10]+e[7]*t[14],r[7]=e[4]*t[3]+e[5]*t[7]+e[6]*t[11]+e[7]*t[15],r[8]=e[8]*t[0]+e[9]*t[4]+e[10]*t[8]+e[11]*t[12],r[9]=e[8]*t[1]+e[9]*t[5]+e[10]*t[9]+e[11]*t[13],r[10]=e[8]*t[2]+e[9]*t[6]+e[10]*t[10]+e[11]*t[14],r[11]=e[8]*t[3]+e[9]*t[7]+e[10]*t[11]+e[11]*t[15],r[12]=e[12]*t[0]+e[13]*t[4]+e[14]*t[8]+e[15]*t[12],r[13]=e[12]*t[1]+e[13]*t[5]+e[14]*t[9]+e[15]*t[13],r[14]=e[12]*t[2]+e[13]*t[6]+e[14]*t[10]+e[15]*t[14],r[15]=e[12]*t[3]+e[13]*t[7]+e[14]*t[11]+e[15]*t[15],e[0]=r[0],e[1]=r[1],e[2]=r[2],e[3]=r[3],e[4]=r[4],e[5]=r[5],e[6]=r[6],e[7]=r[7],e[8]=r[8],e[9]=r[9],e[10]=r[10],e[11]=r[11],e[12]=r[12],e[13]=r[13],e[14]=r[14],e[15]=r[15]}multiplyMatrices(i,e){const t=i.rawData,r=e.rawData,s=this.rawData,a=t[0],n=t[4],l=t[8],h=t[12],u=t[1],c=t[5],f=t[9],d=t[13],p=t[2],m=t[6],_=t[10],v=t[14],y=t[3],C=t[7],B=t[11],T=t[15],M=r[0],D=r[4],P=r[8],L=r[12],I=r[1],O=r[5],k=r[9],H=r[13],W=r[2],ne=r[6],fe=r[10],we=r[14],ze=r[3],Re=r[7],ue=r[11],de=r[15];return s[0]=a*M+n*I+l*W+h*ze,s[4]=a*D+n*O+l*ne+h*Re,s[8]=a*P+n*k+l*fe+h*ue,s[12]=a*L+n*H+l*we+h*de,s[1]=u*M+c*I+f*W+d*ze,s[5]=u*D+c*O+f*ne+d*Re,s[9]=u*P+c*k+f*fe+d*ue,s[13]=u*L+c*H+f*we+d*de,s[2]=p*M+m*I+_*W+v*ze,s[6]=p*D+m*O+_*ne+v*Re,s[10]=p*P+m*k+_*fe+v*ue,s[14]=p*L+m*H+_*we+v*de,s[3]=y*M+C*I+B*W+T*ze,s[7]=y*D+C*O+B*ne+T*Re,s[11]=y*P+C*k+B*fe+T*ue,s[15]=y*L+C*H+B*we+T*de,this}multiplyPoint3(i,e){e||(e=new g);let t=this.rawData;return e.x=t[0]*i.x+t[4]*i.y+t[8]*i.z+t[12],e.y=t[1]*i.x+t[5]*i.y+t[9]*i.z+t[13],e.z=t[2]*i.x+t[6]*i.y+t[10]*i.z+t[14],e}multiplyVector4(i,e){e||(e=new g);let t=this.rawData,r=i.x,s=i.y,a=i.z,n=t[3]*r+t[7]*s+t[11]*a+t[15];return n=n||1,e.x=(t[0]*r+t[4]*s+t[8]*a+t[12])/n,e.y=(t[1]*r+t[5]*s+t[9]*a+t[13])/n,e.z=(t[2]*r+t[6]*s+t[10]*a+t[14])/n,e.w=1,e}transformVector4(i,e){let t=this.rawData;e||(e=new g);let r=i.x,s=i.y,a=i.z,n=i.w;return e.x=r*t[0]+s*t[4]+a*t[8]+n*t[12],e.y=r*t[1]+s*t[5]+a*t[9]+n*t[13],e.z=r*t[2]+s*t[6]+a*t[10]+n*t[14],e.w=r*t[3]+s*t[7]+a*t[11]+n*t[15],e}perspectiveMultiplyPoint3(i,e){let t=g.HELP_2,r,s=this.rawData;if(t.x=s[0]*i.x+s[4]*i.y+s[8]*i.z+s[12],t.y=s[1]*i.x+s[5]*i.y+s[9]*i.z+s[13],t.z=s[2]*i.x+s[6]*i.y+s[10]*i.z+s[14],r=s[3]*i.x+s[7]*i.y+s[11]*i.z+s[15],Math.abs(r)>1e-7){let a=1/r;return e.x=t.x*a,e.y=t.y*a,e.z=t.z*a,!0}else return e.x=0,e.y=0,e.z=0,!1}perspective(i,e,t,r){let s=this.rawData,a=i*_e/2,n=Math.cos(a)/Math.sin(a);s[0]=-n/e,s[1]=0,s[2]=0,s[3]=0,s[4]=0,s[5]=n,s[6]=0,s[7]=0,s[8]=0,s[9]=0,s[10]=r/(r-t),s[11]=1,s[12]=0,s[13]=0,s[14]=-t*r/(r-t),s[15]=0}perspective3(i,e,t,r){var s=Math.tan(i*Math.PI/360)*t,a=s*e;this.frustum(-a,a,-s,s,t,r)}frustum(i,e,t,r,s,a){var n=this.rawData;n[0]=-2*s/(e-i),n[1]=0,n[2]=0,n[3]=0,n[4]=0,n[5]=2*s/(r-t),n[6]=0,n[7]=0,n[8]=(e+i)/(e-i),n[9]=(r+t)/(r-t),n[10]=a/(a-s),n[11]=1,n[12]=0,n[13]=0,n[14]=-a*s/(a-s),n[15]=0}ortho(i,e,t,r){let s=this.rawData;return s[0]=2/i,s[1]=0,s[2]=0,s[3]=0,s[4]=0,s[5]=2/e,s[6]=0,s[7]=0,s[8]=0,s[9]=0,s[10]=1/(r-t),s[11]=0,s[12]=0,s[13]=0,s[14]=t/(t-r),s[15]=1,this}orthoZO(i,e,t,r,s,a){let n=this.rawData,l=1/(i-e),h=1/(t-r),u=1/(s-a);return n[0]=-2*l,n[1]=0,n[2]=0,n[3]=0,n[4]=0,n[5]=-2*h,n[6]=0,n[7]=0,n[8]=0,n[9]=0,n[10]=u,n[11]=0,n[12]=(i+e)*l,n[13]=(r+t)*h,n[14]=s*u,n[15]=1,this}orthoOffCenter(i,e,t,r,s,a){let n=this.rawData;n[0]=2/(e-i),n[1]=0,n[2]=0,n[3]=0,n[4]=0,n[5]=2/(r-t),n[6]=0,n[7]=0,n[8]=0,n[9]=0,n[10]=1/(a-s),n[11]=0,n[12]=(i+e)/(i-e),n[13]=(r+t)/(t-r),n[14]=s/(s-a),n[15]=1}transformDir(i,e){let t=this.rawData,r=1e-6,s=g.ZERO;e.crossProduct(i,s);let a=e.dotProduct(i);if(a>1-r)this.identity();else{let n,l,h,u,c,f=s.dotProduct(s),d=(1-a)/f;n=d*s.x,l=d*s.z,h=n*s.y,u=n*s.z,c=l*s.y,t[0]=a+n*s.x,t[1]=h-s.z,t[2]=u+s.y,t[4]=h+s.z,t[5]=a+d*s.y*s.y,t[6]=c-s.x,t[8]=u-s.y,t[9]=c+s.x,t[10]=a+l*s.z,t[3]=0,t[7]=0,t[11]=0,t[15]=1}}append(i){let e=this.rawData,t=e[0],r=e[4],s=e[8],a=e[12],n=e[1],l=e[5],h=e[9],u=e[13],c=e[2],f=e[6],d=e[10],p=e[14],m=e[3],_=e[7],v=e[11],y=e[15];e[0]=t*i.rawData[0]+n*i.rawData[4]+c*i.rawData[8]+m*i.rawData[12],e[1]=t*i.rawData[1]+n*i.rawData[5]+c*i.rawData[9]+m*i.rawData[13],e[2]=t*i.rawData[2]+n*i.rawData[6]+c*i.rawData[10]+m*i.rawData[14],e[3]=t*i.rawData[3]+n*i.rawData[7]+c*i.rawData[11]+m*i.rawData[15],e[4]=r*i.rawData[0]+l*i.rawData[4]+f*i.rawData[8]+_*i.rawData[12],e[5]=r*i.rawData[1]+l*i.rawData[5]+f*i.rawData[9]+_*i.rawData[13],e[6]=r*i.rawData[2]+l*i.rawData[6]+f*i.rawData[10]+_*i.rawData[14],e[7]=r*i.rawData[3]+l*i.rawData[7]+f*i.rawData[11]+_*i.rawData[15],e[8]=s*i.rawData[0]+h*i.rawData[4]+d*i.rawData[8]+v*i.rawData[12],e[9]=s*i.rawData[1]+h*i.rawData[5]+d*i.rawData[9]+v*i.rawData[13],e[10]=s*i.rawData[2]+h*i.rawData[6]+d*i.rawData[10]+v*i.rawData[14],e[11]=s*i.rawData[3]+h*i.rawData[7]+d*i.rawData[11]+v*i.rawData[15],e[12]=a*i.rawData[0]+u*i.rawData[4]+p*i.rawData[8]+y*i.rawData[12],e[13]=a*i.rawData[1]+u*i.rawData[5]+p*i.rawData[9]+y*i.rawData[13],e[14]=a*i.rawData[2]+u*i.rawData[6]+p*i.rawData[10]+y*i.rawData[14],e[15]=a*i.rawData[3]+u*i.rawData[7]+p*i.rawData[11]+y*i.rawData[15]}add(i){let e=this.rawData,t=e[0],r=e[4],s=e[8],a=e[12],n=e[1],l=e[5],h=e[9],u=e[13],c=e[2],f=e[6],d=e[10],p=e[14],m=e[3],_=e[7],v=e[11],y=e[15],C=i.rawData[0],B=i.rawData[4],T=i.rawData[8],M=i.rawData[12],D=i.rawData[1],P=i.rawData[5],L=i.rawData[9],I=i.rawData[13],O=i.rawData[2],k=i.rawData[6],H=i.rawData[10],W=i.rawData[14],ne=i.rawData[3],fe=i.rawData[7],we=i.rawData[11],ze=i.rawData[15];return e[0]=t+C,e[1]=n+D,e[2]=c+O,e[3]=m+ne,e[4]=r+B,e[5]=l+P,e[6]=f+k,e[7]=_+fe,e[8]=s+T,e[9]=h+L,e[10]=d+H,e[11]=v+we,e[12]=a+M,e[13]=u+I,e[14]=p+W,e[15]=y+ze,this}sub(i){let e=this.rawData,t=e[0],r=e[4],s=e[8],a=e[12],n=e[1],l=e[5],h=e[9],u=e[13],c=e[2],f=e[6],d=e[10],p=e[14],m=e[3],_=e[7],v=e[11],y=e[15],C=i.rawData[0],B=i.rawData[4],T=i.rawData[8],M=i.rawData[12],D=i.rawData[1],P=i.rawData[5],L=i.rawData[9],I=i.rawData[13],O=i.rawData[2],k=i.rawData[6],H=i.rawData[10],W=i.rawData[14],ne=i.rawData[3],fe=i.rawData[7],we=i.rawData[11],ze=i.rawData[15];return e[0]=t-C,e[1]=n-D,e[2]=c-O,e[3]=m-ne,e[4]=r-B,e[5]=l-P,e[6]=f-k,e[7]=_-fe,e[8]=s-T,e[9]=h-L,e[10]=d-H,e[11]=v-we,e[12]=a-M,e[13]=u-I,e[14]=p-W,e[15]=y-ze,this}mult(i){let e=this.rawData;return e[0]*=i,e[1]*=i,e[2]*=i,e[3]*=i,e[4]*=i,e[5]*=i,e[6]*=i,e[7]*=i,e[8]*=i,e[9]*=i,e[10]*=i,e[11]*=i,e[12]*=i,e[13]*=i,e[14]*=i,e[15]*=i,this}appendRotation(i,e){let t=F.getAxisRotation(e.x,e.y,e.z,i);this.append(t)}createByRotation(i,e){let t=F.helpMatrix,r,s,a=i*_e;r=Math.sin(a),s=Math.cos(a),e.x==1&&(t.rawData[0]=1,t.rawData[1]=0,t.rawData[2]=0,t.rawData[3]=0,t.rawData[4]=0,t.rawData[5]=s,t.rawData[6]=r,t.rawData[7]=0,t.rawData[8]=0,t.rawData[9]=-r,t.rawData[10]=s,t.rawData[11]=0,t.rawData[12]=0,t.rawData[13]=0,t.rawData[14]=0,t.rawData[15]=1),e.y==1&&(t.rawData[0]=s,t.rawData[1]=0,t.rawData[2]=-r,t.rawData[3]=0,t.rawData[4]=0,t.rawData[5]=1,t.rawData[6]=0,t.rawData[7]=0,t.rawData[8]=r,t.rawData[9]=0,t.rawData[10]=s,t.rawData[11]=0,t.rawData[12]=0,t.rawData[13]=0,t.rawData[14]=0,t.rawData[15]=1),e.z==1&&(t.rawData[0]=s,t.rawData[1]=r,t.rawData[2]=0,t.rawData[3]=0,t.rawData[4]=-r,t.rawData[5]=s,t.rawData[6]=0,t.rawData[7]=0,t.rawData[8]=0,t.rawData[9]=0,t.rawData[10]=1,t.rawData[11]=0,t.rawData[12]=0,t.rawData[13]=0,t.rawData[14]=0,t.rawData[15]=1),this.append(t)}appendScale(i,e,t){F.helpMatrix.createByScale(i,e,t),this.append(F.helpMatrix)}createByScale(i,e,t){let r=this.rawData;r[0]=i,r[1]=0,r[2]=0,r[3]=0,r[4]=0,r[5]=e,r[6]=0,r[7]=0,r[8]=0,r[9]=0,r[10]=t,r[11]=0,r[12]=0,r[13]=0,r[14]=0,r[15]=1}appendTranslation(i,e,t){let r=this.rawData;r[12]+=i,r[13]+=e,r[14]+=t}clone(){let i=new F;return i.copyFrom(this),i}copyRowFrom(i,e){let t=this.rawData;switch(i){case 0:t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w;break;case 1:t[4]=e.x,t[5]=e.y,t[6]=e.z,t[7]=e.w;break;case 2:t[8]=e.x,t[9]=e.y,t[10]=e.z,t[11]=e.w;break;case 3:t[12]=e.x,t[13]=e.y,t[14]=e.z,t[15]=e.w;break}}copyRowTo(i,e){let t=this.rawData;switch(i){case 0:e.x=t[0],e.y=t[1],e.z=t[2],e.w=t[3];break;case 1:e.x=t[4],e.y=t[5],e.z=t[6],e.w=t[7];break;case 2:e.x=t[8],e.y=t[9],e.z=t[10],e.w=t[11];break;case 3:e.x=t[12],e.y=t[13],e.z=t[14],e.w=t[15];break}}copyFrom(i){let e=this.rawData;return e[0]=i.rawData[0],e[1]=i.rawData[1],e[2]=i.rawData[2],e[3]=i.rawData[3],e[4]=i.rawData[4],e[5]=i.rawData[5],e[6]=i.rawData[6],e[7]=i.rawData[7],e[8]=i.rawData[8],e[9]=i.rawData[9],e[10]=i.rawData[10],e[11]=i.rawData[11],e[12]=i.rawData[12],e[13]=i.rawData[13],e[14]=i.rawData[14],e[15]=i.rawData[15],this}copyRawDataTo(i,e=0,t=!1){let r=this.rawData;i[0+e]=r[0],i[1+e]=r[1],i[2+e]=r[2],i[3+e]=r[3],i[4+e]=r[4],i[5+e]=r[5],i[6+e]=r[6],i[7+e]=r[7],i[8+e]=r[8],i[9+e]=r[9],i[10+e]=r[10],i[11+e]=r[11],i[12+e]=r[12],i[13+e]=r[13],i[14+e]=r[14],i[15+e]=r[15]}copyColFrom(i,e){let t=this.rawData;switch(i){case 0:t[0]=e.x,t[4]=e.y,t[8]=e.z,t[12]=e.w;break;case 1:t[1]=e.x,t[5]=e.y,t[9]=e.z,t[13]=e.w;break;case 2:t[2]=e.x,t[6]=e.y,t[10]=e.z,t[14]=e.w;break;case 3:t[3]=e.x,t[7]=e.y,t[11]=e.z,t[15]=e.w;break}}copyColTo(i,e){let t=this.rawData;switch(i){case 0:e.x=t[0],e.y=t[4],e.z=t[8],e.w=t[12];break;case 1:e.x=t[1],e.y=t[5],e.z=t[9],e.w=t[13];break;case 2:e.x=t[2],e.y=t[6],e.z=t[10],e.w=t[14];break;case 3:e.x=t[3],e.y=t[7],e.z=t[11],e.w=t[15];break}}copyToMatrix3D(i){i.rawData=this.rawData.slice(0)}makeRotationFromQuaternion(i){return this.compose(F._zero,i,F._one),this}decompose(i="eulerAngles",e){let t=q.CALCULATION_QUATERNION,r=e||F._prs;this.copyRawDataTo(F.decomposeRawData);let s=F.decomposeRawData,a=r[0];a.x=s[12],a.y=s[13],a.z=s[14],s[12]=0,s[13]=0,s[14]=0;let n=r[2];n.x=Math.sqrt(s[0]*s[0]+s[1]*s[1]+s[2]*s[2]),n.y=Math.sqrt(s[4]*s[4]+s[5]*s[5]+s[6]*s[6]),n.z=Math.sqrt(s[8]*s[8]+s[9]*s[9]+s[10]*s[10]),s[0]*(s[5]*s[10]-s[6]*s[9])-s[1]*(s[4]*s[10]-s[6]*s[8])+s[2]*(s[4]*s[9]-s[5]*s[8])<0&&(n.z=-n.z),s[0]/=n.x,s[1]/=n.x,s[2]/=n.x,s[4]/=n.y,s[5]/=n.y,s[6]/=n.y,s[8]/=n.z,s[9]/=n.z,s[10]/=n.z;let l=r[1],h;switch(i){case yt.AXIS_ANGLE:l.w=Math.acos((s[0]+s[5]+s[10]-1)/2);let u=Math.sqrt((s[6]-s[9])*(s[6]-s[9])+(s[8]-s[2])*(s[8]-s[2])+(s[1]-s[4])*(s[1]-s[4]));l.x=(s[6]-s[9])/u,l.y=(s[8]-s[2])/u,l.z=(s[1]-s[4])/u;break;case yt.QUATERNION:h=s[0]+s[5]+s[10],h>0?(l.w=Math.sqrt(1+h)/2,l.x=(s[6]-s[9])/(4*l.w),l.y=(s[8]-s[2])/(4*l.w),l.z=(s[1]-s[4])/(4*l.w)):s[0]>s[5]&&s[0]>s[10]?(l.x=Math.sqrt(1+s[0]-s[5]-s[10])/2,l.w=(s[6]-s[9])/(4*l.x),l.y=(s[1]+s[4])/(4*l.x),l.z=(s[8]+s[2])/(4*l.x)):s[5]>s[10]?(l.y=Math.sqrt(1+s[5]-s[0]-s[10])/2,l.x=(s[1]+s[4])/(4*l.y),l.w=(s[8]-s[2])/(4*l.y),l.z=(s[6]+s[9])/(4*l.y)):(l.z=Math.sqrt(1+s[10]-s[0]-s[5])/2,l.x=(s[8]+s[2])/(4*l.z),l.y=(s[6]+s[9])/(4*l.z),l.w=(s[1]-s[4])/(4*l.z));break;case yt.EULER_ANGLES:h=s[0]+s[5]+s[10],h>0?(t.w=Math.sqrt(1+h)/2,t.x=(s[6]-s[9])/(4*t.w),t.y=(s[8]-s[2])/(4*t.w),t.z=(s[1]-s[4])/(4*t.w)):s[0]>s[5]&&s[0]>s[10]?(t.x=Math.sqrt(1+s[0]-s[5]-s[10])/2,t.w=(s[6]-s[9])/(4*t.x),t.y=(s[1]+s[4])/(4*t.x),t.z=(s[8]+s[2])/(4*t.x)):s[5]>s[10]?(l.y=Math.sqrt(1+s[5]-s[0]-s[10])/2,t.x=(s[1]+s[4])/(4*t.y),t.w=(s[8]-s[2])/(4*t.y),t.z=(s[6]+s[9])/(4*t.y)):(t.z=Math.sqrt(1+s[10]-s[0]-s[5])/2,t.x=(s[8]+s[2])/(4*t.z),t.y=(s[6]+s[9])/(4*t.z),t.w=(s[1]-s[4])/(4*t.z)),t.getEulerAngles(l);break}return r[0]=a,r[1]=l,r[2]=n,r}static getEuler(i,e,t=!0,r){return i||(i=new g),F._getEulerMatrix.makeRotationFromQuaternion(e).makeEuler(i,t,r),i}compose(i,e,t){const r=this.rawData,s=e.x,a=e.y,n=e.z,l=e.w,h=s+s,u=a+a,c=n+n,f=s*h,d=s*u,p=s*c,m=a*u,_=a*c,v=n*c,y=l*h,C=l*u,B=l*c,T=t.x,M=t.y,D=t.z;return r[0]=(1-(m+v))*T,r[1]=(d+B)*T,r[2]=(p-C)*T,r[3]=0,r[4]=(d-B)*M,r[5]=(1-(f+v))*M,r[6]=(_+y)*M,r[7]=0,r[8]=(p+C)*D,r[9]=(_-y)*D,r[10]=(1-(f+m))*D,r[11]=0,r[12]=i.x,r[13]=i.y,r[14]=i.z,r[15]=1,this}deltaTransformVector(i,e){e||(e=new g);let t=this.rawData,r=i.x,s=i.y,a=i.z;return e.x=r*t[0]+s*t[4]+a*t[8],e.y=r*t[1]+s*t[5]+a*t[9],e.z=r*t[2]+s*t[6]+a*t[10],e.w=r*t[3]+s*t[7]+a*t[11],e}identity(){let i=this.rawData;return i[0]=1,i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=1,i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[10]=1,i[11]=0,i[12]=0,i[13]=0,i[14]=0,i[15]=1,this}fill(i){let e=this.rawData;e[1]=i,e[2]=i,e[3]=i,e[4]=i,e[6]=i,e[7]=i,e[8]=i,e[9]=i,e[11]=i,e[12]=i,e[13]=i,e[14]=i,e[0]=i,e[5]=i,e[10]=i,e[15]=i}invers33(){let i=this.rawData,e=i[5]*i[10]-i[9]*i[6],t=i[8]*i[6]-i[4]*i[10],r=i[4]*i[9]-i[8]*i[5],s=i[9]*i[2]-i[1]*i[10],a=i[0]*i[10]-i[8]*i[2],n=i[8]*i[1]-i[0]*i[9],l=i[1]*i[6]-i[5]*i[2],h=i[4]*i[2]-i[0]*i[6],u=i[0]*i[5]-i[4]*i[1],c=i[0]*e+i[4]*s+i[8]*l;if(Math.abs(c)>1e-11){let f=1/c;i[0]=f*e,i[4]=f*t,i[8]=f*r,i[1]=f*s,i[5]=f*a,i[9]=f*n,i[2]=f*l,i[6]=f*h,i[10]=f*u}}invert(){let i=this.determinant,e=Math.abs(i)>1e-11,t=this.rawData;if(e){i=1/i;let r=t[0],s=t[4],a=t[8],n=t[12],l=t[1],h=t[5],u=t[9],c=t[13],f=t[2],d=t[6],p=t[10],m=t[14],_=t[3],v=t[7],y=t[11],C=t[15];t[0]=i*(h*(p*C-m*y)-u*(d*C-m*v)+c*(d*y-p*v)),t[1]=-i*(l*(p*C-m*y)-u*(f*C-m*_)+c*(f*y-p*_)),t[2]=i*(l*(d*C-m*v)-h*(f*C-m*_)+c*(f*v-d*_)),t[3]=-i*(l*(d*y-p*v)-h*(f*y-p*_)+u*(f*v-d*_)),t[4]=-i*(s*(p*C-m*y)-a*(d*C-m*v)+n*(d*y-p*v)),t[5]=i*(r*(p*C-m*y)-a*(f*C-m*_)+n*(f*y-p*_)),t[6]=-i*(r*(d*C-m*v)-s*(f*C-m*_)+n*(f*v-d*_)),t[7]=i*(r*(d*y-p*v)-s*(f*y-p*_)+a*(f*v-d*_)),t[8]=i*(s*(u*C-c*y)-a*(h*C-c*v)+n*(h*y-u*v)),t[9]=-i*(r*(u*C-c*y)-a*(l*C-c*_)+n*(l*y-u*_)),t[10]=i*(r*(h*C-c*v)-s*(l*C-c*_)+n*(l*v-h*_)),t[11]=-i*(r*(h*y-u*v)-s*(l*y-u*_)+a*(l*v-h*_)),t[12]=-i*(s*(u*m-c*p)-a*(h*m-c*d)+n*(h*p-u*d)),t[13]=i*(r*(u*m-c*p)-a*(l*m-c*f)+n*(l*p-u*f)),t[14]=-i*(r*(h*m-c*d)-s*(l*m-c*f)+n*(l*d-h*f)),t[15]=i*(r*(h*p-u*d)-s*(l*p-u*f)+a*(l*d-h*f))}return e}transformPoint(i,e){let t=this.rawData;e||(e=new g);let r=i.x,s=i.y,a=i.z;return e.x=r*t[0]+s*t[4]+a*t[8]+t[12],e.y=r*t[1]+s*t[5]+a*t[9]+t[13],e.z=r*t[2]+s*t[6]+a*t[10]+t[14],e}transformVector(i,e){let t=this.rawData;e||(e=new g);let r=i.x,s=i.y,a=i.z;return e.x=r*t[0]+s*t[4]+a*t[8],e.y=r*t[1]+s*t[5]+a*t[9],e.z=r*t[2]+s*t[6]+a*t[10],e}transpose(){let i=this.rawData;for(let e=0;e<F.helpMatrix.rawData.length;e++)F.helpMatrix.rawData[e]=i[e];i[1]=F.helpMatrix.rawData[4],i[2]=F.helpMatrix.rawData[8],i[3]=F.helpMatrix.rawData[12],i[4]=F.helpMatrix.rawData[1],i[6]=F.helpMatrix.rawData[9],i[7]=F.helpMatrix.rawData[13],i[8]=F.helpMatrix.rawData[2],i[9]=F.helpMatrix.rawData[6],i[11]=F.helpMatrix.rawData[14],i[12]=F.helpMatrix.rawData[3],i[13]=F.helpMatrix.rawData[7],i[14]=F.helpMatrix.rawData[11]}get determinant(){let i=this.rawData;return(i[0]*i[5]-i[4]*i[1])*(i[10]*i[15]-i[14]*i[11])-(i[0]*i[9]-i[8]*i[1])*(i[6]*i[15]-i[14]*i[7])+(i[0]*i[13]-i[12]*i[1])*(i[6]*i[11]-i[10]*i[7])+(i[4]*i[9]-i[8]*i[5])*(i[2]*i[15]-i[14]*i[3])-(i[4]*i[13]-i[12]*i[5])*(i[2]*i[11]-i[10]*i[3])+(i[8]*i[13]-i[12]*i[9])*(i[2]*i[7]-i[6]*i[3])}getPosition(i){i||(i=new g);let e=this.rawData;return i.x=e[12],i.y=e[13],i.z=e[14],i}get position(){return this._position.set(this.rawData[12],this.rawData[13],this.rawData[14]),this._position}set position(i){let e=this.rawData;e[12]=i.x,e[13]=i.y,e[14]=i.z}get scale(){let i=this.rawData;return new g(i[0],i[5],i[10])}set scale(i){let e=this.rawData;e[0]=i.x,e[5]=i.y,e[10]=i.z}toString(){let i=this.rawData;return"matrix3d("+Math.round(i[0]*1e3)/1e3+","+Math.round(i[1]*1e3)/1e3+","+Math.round(i[2]*1e3)/1e3+","+Math.round(i[3]*1e3)/1e3+","+Math.round(i[4]*1e3)/1e3+","+Math.round(i[5]*1e3)/1e3+","+Math.round(i[6]*1e3)/1e3+","+Math.round(i[7]*1e3)/1e3+","+Math.round(i[8]*1e3)/1e3+","+Math.round(i[9]*1e3)/1e3+","+Math.round(i[10]*1e3)/1e3+","+Math.round(i[11]*1e3)/1e3+","+Math.round(i[12]*1e3)/1e3+","+Math.round(i[13]*1e3)/1e3+","+Math.round(i[14]*1e3)/1e3+","+Math.round(i[15]*1e3)/1e3+")"}lerp(i,e,t){this.copyFrom(e).sub(i).mult(t).add(i)}get(i,e){return this.rawData[i+e*4]}set(i,e,t){this.rawData[i+e*4]=t}getMaxScaleOnAxis(){let i=this.rawData,e=i[0]*i[0]+i[1]*i[1]+i[2]*i[2],t=i[4]*i[4]+i[5]*i[5]+i[6]*i[6],r=i[8]*i[8]+i[9]*i[9]+i[10]*i[10];return Math.sqrt(Math.max(e,t,r))}translate(i){let e=this.get(0,0)*i.x+this.get(0,1)*i.y+this.get(0,2)*i.z+this.get(0,3),t=this.get(1,0)*i.x+this.get(1,1)*i.y+this.get(1,2)*i.z+this.get(1,3),r=this.get(2,0)*i.x+this.get(2,1)*i.y+this.get(2,2)*i.z+this.get(2,3),s=this.get(3,0)*i.x+this.get(3,1)*i.y+this.get(3,2)*i.z+this.get(3,3);return this.set(0,3,e),this.set(1,3,t),this.set(2,3,r),this.set(3,3,s),this}setTRInverse(i,e){e=e.inverse(),q.quaternionToMatrix(e,this),this.translate(new g(-i.x,-i.y,-i.z))}setScale(i){return this.set(0,0,i.x),this.set(0,1,0),this.set(0,2,0),this.set(0,3,0),this.set(1,0,0),this.set(1,1,i.y),this.set(1,2,0),this.set(1,3,0),this.set(2,0,0),this.set(2,1,0),this.set(2,2,i.z),this.set(2,3,0),this.set(3,0,0),this.set(3,1,0),this.set(3,2,0),this.set(3,3,1),this}makeBasis(i,e,t){return this.setElements(i.x,e.x,t.x,0,i.y,e.y,t.y,0,i.z,e.z,t.z,0,0,0,0,1),this}makeRotationAxis(i,e){const t=Math.cos(e),r=Math.sin(e),s=1-t,a=i.x,n=i.y,l=i.z,h=s*a,u=s*n;return this.setElements(h*a+t,h*n-r*l,h*l+r*n,0,h*n+r*l,u*n+t,u*l-r*a,0,h*l-r*n,u*l+r*a,s*l*l+t,0,0,0,0,1),this}static transpose(i,e){e||(e=new F);let t=i.rawData,r=e.rawData;return r[0]=t[0],r[1]=t[4],r[2]=t[8],r[3]=t[12],r[4]=t[1],r[5]=t[5],r[6]=t[9],r[7]=t[13],r[8]=t[2],r[9]=t[6],r[10]=t[10],r[11]=t[14],r[12]=t[3],r[13]=t[7],r[14]=t[11],r[15]=t[15],e}static inverse(i,e){e||(e=new F);let t=i.rawData,r=e.rawData;r[0]=t[5]*t[10]*t[15]-t[5]*t[14]*t[11]-t[6]*t[9]*t[15]+t[6]*t[13]*t[11]+t[7]*t[9]*t[14]-t[7]*t[13]*t[10],r[1]=-t[1]*t[10]*t[15]+t[1]*t[14]*t[11]+t[2]*t[9]*t[15]-t[2]*t[13]*t[11]-t[3]*t[9]*t[14]+t[3]*t[13]*t[10],r[2]=t[1]*t[6]*t[15]-t[1]*t[14]*t[7]-t[2]*t[5]*t[15]+t[2]*t[13]*t[7]+t[3]*t[5]*t[14]-t[3]*t[13]*t[6],r[3]=-t[1]*t[6]*t[11]+t[1]*t[10]*t[7]+t[2]*t[5]*t[11]-t[2]*t[9]*t[7]-t[3]*t[5]*t[10]+t[3]*t[9]*t[6],r[4]=-t[4]*t[10]*t[15]+t[4]*t[14]*t[11]+t[6]*t[8]*t[15]-t[6]*t[12]*t[11]-t[7]*t[8]*t[14]+t[7]*t[12]*t[10],r[5]=t[0]*t[10]*t[15]-t[0]*t[14]*t[11]-t[2]*t[8]*t[15]+t[2]*t[12]*t[11]+t[3]*t[8]*t[14]-t[3]*t[12]*t[10],r[6]=-t[0]*t[6]*t[15]+t[0]*t[14]*t[7]+t[2]*t[4]*t[15]-t[2]*t[12]*t[7]-t[3]*t[4]*t[14]+t[3]*t[12]*t[6],r[7]=t[0]*t[6]*t[11]-t[0]*t[10]*t[7]-t[2]*t[4]*t[11]+t[2]*t[8]*t[7]+t[3]*t[4]*t[10]-t[3]*t[8]*t[6],r[8]=t[4]*t[9]*t[15]-t[4]*t[13]*t[11]-t[5]*t[8]*t[15]+t[5]*t[12]*t[11]+t[7]*t[8]*t[13]-t[7]*t[12]*t[9],r[9]=-t[0]*t[9]*t[15]+t[0]*t[13]*t[11]+t[1]*t[8]*t[15]-t[1]*t[12]*t[11]-t[3]*t[8]*t[13]+t[3]*t[12]*t[9],r[10]=t[0]*t[5]*t[15]-t[0]*t[13]*t[7]-t[1]*t[4]*t[15]+t[1]*t[12]*t[7]+t[3]*t[4]*t[13]-t[3]*t[12]*t[5],r[11]=-t[0]*t[5]*t[11]+t[0]*t[9]*t[7]+t[1]*t[4]*t[11]-t[1]*t[8]*t[7]-t[3]*t[4]*t[9]+t[3]*t[8]*t[5],r[12]=-t[4]*t[9]*t[14]+t[4]*t[13]*t[10]+t[5]*t[8]*t[14]-t[5]*t[12]*t[10]-t[6]*t[8]*t[13]+t[6]*t[12]*t[9],r[13]=t[0]*t[9]*t[14]-t[0]*t[13]*t[10]-t[1]*t[8]*t[14]+t[1]*t[12]*t[10]+t[2]*t[8]*t[13]-t[2]*t[12]*t[9],r[14]=-t[0]*t[5]*t[14]+t[0]*t[13]*t[6]+t[1]*t[4]*t[14]-t[1]*t[12]*t[6]-t[2]*t[4]*t[13]+t[2]*t[12]*t[5],r[15]=t[0]*t[5]*t[10]-t[0]*t[9]*t[6]-t[1]*t[4]*t[10]+t[1]*t[8]*t[6]+t[2]*t[4]*t[9]-t[2]*t[8]*t[5];let s=t[0]*r[0]+t[1]*r[4]+t[2]*r[8]+t[3]*r[12];for(let a=0;a<16;a++)r[a]/=s;return e}makeEuler(i,e,t="XYZ"){const r=this.rawData,s=r[0],a=r[4],n=r[8],l=r[1],h=r[5],u=r[9],c=r[2],f=r[6],d=r[10];switch(t){case"XYZ":i.y=Math.asin(K(n,-1,1)),Math.abs(n)<.9999999?(i.x=Math.atan2(-u,d),i.z=Math.atan2(-a,s)):(i.x=Math.atan2(f,h),i.z=0);break;case"YXZ":i.x=Math.asin(-K(u,-1,1)),Math.abs(u)<.9999999?(i.y=Math.atan2(n,d),i.z=Math.atan2(l,h)):(i.y=Math.atan2(-c,s),i.z=0);break;case"ZXY":i.x=Math.asin(K(f,-1,1)),Math.abs(f)<.9999999?(i.y=Math.atan2(-c,d),i.z=Math.atan2(-a,h)):(i.y=0,i.z=Math.atan2(l,s));break;case"ZYX":i.y=Math.asin(-K(c,-1,1)),Math.abs(c)<.9999999?(i.x=Math.atan2(f,d),i.z=Math.atan2(l,s)):(i.x=0,i.z=Math.atan2(-a,h));break;case"YZX":i.z=Math.asin(K(l,-1,1)),Math.abs(l)<.9999999?(i.x=Math.atan2(-u,h),i.y=Math.atan2(-c,s)):(i.x=0,i.y=Math.atan2(n,d));break;case"XZY":i.z=Math.asin(-K(a,-1,1)),Math.abs(a)<.9999999?(i.x=Math.atan2(f,h),i.y=Math.atan2(n,s)):(i.x=Math.atan2(-u,d),i.y=0);break}return e&&i.multiplyScalar(qi),i}setElements(i,e,t,r,s,a,n,l,h,u,c,f,d,p,m,_){const v=this.rawData;return v[0]=i,v[4]=e,v[8]=t,v[12]=r,v[1]=s,v[5]=a,v[9]=n,v[13]=l,v[2]=h,v[6]=u,v[10]=c,v[14]=f,v[3]=d,v[7]=p,v[11]=m,v[15]=_,this}makeMatrix44ByQuaternion(i,e,t){this.identity(),q.quaternionToMatrix(t,this),this.appendTranslation(i.x,i.y,i.z),this.appendScale(e.x,e.y,e.z)}};let V=F;o(V,"blockBytes",16*4),o(V,"block",16),o(V,"allocCount",1e3),o(V,"allocOnceCount",1e3),o(V,"maxCount",50*1e4),o(V,"useCount",0),o(V,"buffer"),o(V,"wasmMatrixPtr",0),o(V,"dynamicMatrixBytes"),o(V,"dynamicGlobalMatrixRef"),o(V,"wasm"),o(V,"help_matrix_0"),o(V,"help_matrix_1"),o(V,"help_matrix_2"),o(V,"helpMatrix"),o(V,"helpMatrix2"),o(V,"_getEulerMatrix"),o(V,"_zero",new g(0,0,0)),o(V,"_one",new g(1,1,1)),o(V,"_prs",[new g,new g,new g]),o(V,"float32Array",new Float32Array(16).fill(0)),o(V,"decomposeRawData",new Float32Array(16).fill(0));function _l(i,e,t){for(let r=0;r<4;r++)t.rawData[r]=i.rawData[r]*e.rawData[0]+i.rawData[r+4]*e.rawData[1]+i.rawData[r+8]*e.rawData[2]+i.rawData[r+12]*e.rawData[3],t.rawData[r+4]=i.rawData[r]*e.rawData[4]+i.rawData[r+4]*e.rawData[5]+i.rawData[r+8]*e.rawData[6]+i.rawData[r+12]*e.rawData[7],t.rawData[r+8]=i.rawData[r]*e.rawData[8]+i.rawData[r+4]*e.rawData[9]+i.rawData[r+8]*e.rawData[10]+i.rawData[r+12]*e.rawData[11],t.rawData[r+12]=i.rawData[r]*e.rawData[12]+i.rawData[r+4]*e.rawData[13]+i.rawData[r+8]*e.rawData[14]+i.rawData[r+12]*e.rawData[15]}function Rs(i,e,t,r){let s=r.rawData,a=i.x*_e,n=i.y*_e,l=i.z*_e,h=0,u=a*.5,c=n*.5,f=l*.5,d=Math.cos(u),p=Math.sin(u),m=Math.cos(c),_=Math.sin(c),v=Math.cos(f),y=Math.sin(f);h=d*m*v+p*_*y,a=p*m*v-d*_*y,n=d*_*v+p*m*y,l=d*m*y-p*_*v;let C=a+a,B=n+n,T=l+l,M=a*C,D=a*B,P=a*T,L=n*B,I=n*T,O=l*T,k=h*C,H=h*B,W=h*T,ne=t.x,fe=t.y,we=t.z;s[0]=(1-(L+O))*ne,s[1]=(D+W)*ne,s[2]=(P-H)*ne,s[3]=0,s[4]=(D-W)*fe,s[5]=(1-(M+O))*fe,s[6]=(I+k)*fe,s[7]=0,s[8]=(P+H)*we,s[9]=(I-k)*we,s[10]=(1-(M+L))*we,s[11]=0,s[12]=e.x,s[13]=e.y,s[14]=e.z,s[15]=1}function xl(i,e,t){let r=i.rawData,s=t.rawData,a=r[0],n=r[4],l=r[8],h=r[12],u=r[1],c=r[5],f=r[9],d=r[13],p=r[2],m=r[6],_=r[10],v=r[14],y=r[3],C=r[7],B=r[11],T=r[15];s[0]=a*e.rawData[0]+u*e.rawData[4]+p*e.rawData[8]+y*e.rawData[12],s[1]=a*e.rawData[1]+u*e.rawData[5]+p*e.rawData[9]+y*e.rawData[13],s[2]=a*e.rawData[2]+u*e.rawData[6]+p*e.rawData[10]+y*e.rawData[14],s[3]=a*e.rawData[3]+u*e.rawData[7]+p*e.rawData[11]+y*e.rawData[15],s[4]=n*e.rawData[0]+c*e.rawData[4]+m*e.rawData[8]+C*e.rawData[12],s[5]=n*e.rawData[1]+c*e.rawData[5]+m*e.rawData[9]+C*e.rawData[13],s[6]=n*e.rawData[2]+c*e.rawData[6]+m*e.rawData[10]+C*e.rawData[14],s[7]=n*e.rawData[3]+c*e.rawData[7]+m*e.rawData[11]+C*e.rawData[15],s[8]=l*e.rawData[0]+f*e.rawData[4]+_*e.rawData[8]+B*e.rawData[12],s[9]=l*e.rawData[1]+f*e.rawData[5]+_*e.rawData[9]+B*e.rawData[13],s[10]=l*e.rawData[2]+f*e.rawData[6]+_*e.rawData[10]+B*e.rawData[14],s[11]=l*e.rawData[3]+f*e.rawData[7]+_*e.rawData[11]+B*e.rawData[15],s[12]=h*e.rawData[0]+d*e.rawData[4]+v*e.rawData[8]+T*e.rawData[12],s[13]=h*e.rawData[1]+d*e.rawData[5]+v*e.rawData[9]+T*e.rawData[13],s[14]=h*e.rawData[2]+d*e.rawData[6]+v*e.rawData[10]+T*e.rawData[14],s[15]=h*e.rawData[3]+d*e.rawData[7]+v*e.rawData[11]+T*e.rawData[15]}function Dd(i,e){let t=e.x,r=e.y,s=e.z,a=e.w,n=i.rawData,l=2*t*r,h=2*t*s,u=2*t*a,c=2*r*s,f=2*r*a,d=2*s*a,p=t*t,m=r*r,_=s*s,v=a*a;return n[0]=p-m-_+v,n[4]=l-d,n[8]=h+f,n[12]=0,n[1]=l+d,n[5]=-p+m-_+v,n[9]=c-u,n[13]=0,n[2]=h-f,n[6]=c+u,n[10]=-p-m+_+v,n[14]=0,n[3]=0,n[7]=0,n[11]=0,n[15]=1,i}function Pd(i,e){let t=e.rawData,r=Math.sin(i),s=Math.cos(i);return t[0]=s,t[1]=0,t[2]=-r,t[3]=0,t[8]=r,t[9]=0,t[10]=s,t[11]=0,t}function Rd(i,e,t){let r=e.x,s=e.y,a=e.z,n=Math.hypot(r,s,a),l,h,u,c,f,d,p,m,_,v,y,C;if(n<Md)return null;n=1/n,r*=n,s*=n,a*=n,l=Math.sin(i),h=Math.cos(i),u=1-h,c=r*r*u+h,f=s*r*u+a*l,d=a*r*u-s*l,p=r*s*u-a*l,m=s*s*u+h,_=a*s*u+r*l,v=r*a*u+s*l,y=s*a*u-r*l,C=a*a*u+h;let B=t.rawData;return B[0]=c,B[1]=f,B[2]=d,B[3]=0,B[4]=p,B[5]=m,B[6]=_,B[7]=0,B[8]=v,B[9]=y,B[10]=C,B[11]=0,B[12]=0,B[13]=0,B[14]=0,B[15]=1,B}function so(i,e,t){let r=i.rawData,s=r[0],a=r[1],n=r[2],l=r[3],h=r[4],u=r[5],c=r[6],f=r[7],d=r[8],p=r[9],m=r[10],_=r[11],v=r[12],y=r[13],C=r[14],B=r[15],T=e.rawData,M=t.rawData,D=T[0],P=T[1],L=T[2],I=T[3];return M[0]=D*s+P*h+L*d+I*v,M[1]=D*a+P*u+L*p+I*y,M[2]=D*n+P*c+L*m+I*C,M[3]=D*l+P*f+L*_+I*B,D=T[4],P=T[5],L=T[6],I=T[7],M[4]=D*s+P*h+L*d+I*v,M[5]=D*a+P*u+L*p+I*y,M[6]=D*n+P*c+L*m+I*C,M[7]=D*l+P*f+L*_+I*B,D=T[8],P=T[9],L=T[10],I=T[11],M[8]=D*s+P*h+L*d+I*v,M[9]=D*a+P*u+L*p+I*y,M[10]=D*n+P*c+L*m+I*C,M[11]=D*l+P*f+L*_+I*B,D=T[12],P=T[13],L=T[14],I=T[15],M[12]=D*s+P*h+L*d+I*v,M[13]=D*a+P*u+L*p+I*y,M[14]=D*n+P*c+L*m+I*C,M[15]=D*l+P*f+L*_+I*B,M}var Qe=(i=>(i[i.None=0]="None",i[i.PointLight=1]="PointLight",i[i.DirectionLight=2]="DirectionLight",i[i.SpotLight=3]="SpotLight",i[i.SkyLight=4]="SkyLight",i))(Qe||{});class Gr extends wi{constructor(){super(...arguments),o(this,"index",-1),o(this,"lightType",-1),o(this,"radius",.5),o(this,"linear",1),o(this,"lightPosition",new g),o(this,"lightMatrixIndex",-1),o(this,"direction",new g),o(this,"quadratic",.032),o(this,"lightColor",new z(1,1,1,1)),o(this,"intensity",1),o(this,"innerAngle",0),o(this,"outerAngle",1),o(this,"range",100),o(this,"castShadowIndex",-1),o(this,"lightTangent",g.FORWARD),o(this,"iesIndex",-1)}}o(Gr,"lightSize",24);const vl=class{static init(){this._init||(this._init=!0,this.componentsUpdateList=new Map,this.componentsLateUpdateList=new Map,this.componentsBeforeUpdateList=new Map,this.componentsComputeList=new Map,this.componentsEnablePickerList=new Map,this.graphicComponent=new Map,this.waitStartComponent=new Map)}static bindUpdate(i,e,t){this.init();let r=this.componentsUpdateList.get(i);r||(r=new Map,this.componentsUpdateList.set(i,r)),r.set(e,t)}static unBindUpdate(i,e){this.init();let t=this.componentsUpdateList.get(i);t&&t.delete(e)}static bindLateUpdate(i,e,t){this.init();let r=this.componentsLateUpdateList.get(i);r||(r=new Map,this.componentsLateUpdateList.set(i,r)),r.set(e,t)}static unBindLateUpdate(i,e){this.init();let t=this.componentsLateUpdateList.get(i);t&&t.delete(e)}static bindBeforeUpdate(i,e,t){this.init();let r=this.componentsBeforeUpdateList.get(i);r||(r=new Map,this.componentsBeforeUpdateList.set(i,r)),r.set(e,t)}static unBindBeforeUpdate(i,e){this.init();let t=this.componentsBeforeUpdateList.get(i);t&&t.delete(e)}static bindCompute(i,e,t){this.init();let r=this.componentsComputeList.get(i);r||(r=new Map,this.componentsComputeList.set(i,r)),r.set(e,t)}static unBindCompute(i,e){this.init();let t=this.componentsComputeList.get(i);t&&t.delete(e)}static bindGraphic(i,e,t){this.init();let r=this.graphicComponent.get(i);r||(r=new Map,this.graphicComponent.set(i,r)),r.set(e,t)}static unBindGraphic(i,e){this.init();let t=this.graphicComponent.get(i);t&&t.delete(e)}static appendWaitStart(i){this.init();let e=this.waitStartComponent.get(i.object3D);e?e.indexOf(i)==-1&&e.push(i):this.waitStartComponent.set(i.object3D,[i])}static removeWaitStart(i,e){this.init();let t=vl.waitStartComponent.get(i);if(t){let r=t.indexOf(e);r!=-1&&t.splice(r)}}static bindEnablePick(i,e,t){this.init();let r=this.componentsEnablePickerList.get(i);r||(r=new Map,this.componentsEnablePickerList.set(i,r)),r.set(e,t)}static unBindEnablePick(i,e){this.init();let t=this.componentsEnablePickerList.get(i);t&&t.delete(e)}};let ae=vl;o(ae,"componentsUpdateList"),o(ae,"componentsLateUpdateList"),o(ae,"componentsBeforeUpdateList"),o(ae,"componentsComputeList"),o(ae,"componentsEnablePickerList"),o(ae,"graphicComponent"),o(ae,"waitStartComponent"),o(ae,"_init",!1);class Ee{constructor(){o(this,"object3D",null),o(this,"_eventDispatcher"),o(this,"_enable",!0),o(this,"__isStart",!1),o(this,"isDestroyed")}get eventDispatcher(){return this._eventDispatcher||(this._eventDispatcher=new hi),this._eventDispatcher}set eventDispatcher(e){console.error("The eventDispatcher should not be set externally!")}get isStart(){return this.__isStart}get transform(){return this.object3D.transform}set enable(e){var t,r;this._enable!=e&&(this._enable=e,this._enable?(t=this.onEnable)==null||t.call(this,this.transform.view3D):(r=this.onDisable)==null||r.call(this,this.transform.view3D))}get enable(){return this._enable}__init(e){this.init(e)}__start(){var e,t;this.transform&&this.transform.scene3D&&this._enable&&((e=this.onEnable)==null||e.call(this,this.transform.view3D)),this.transform&&this.transform.scene3D&&this.__isStart==!1&&((t=this.start)==null||t.call(this),this.__isStart=!0),this.onUpdate&&this._onUpdate(this.onUpdate.bind(this)),this.onLateUpdate&&this._onLateUpdate(this.onLateUpdate.bind(this)),this.onBeforeUpdate&&this._onBeforeUpdate(this.onBeforeUpdate.bind(this)),this.onCompute&&this._onCompute(this.onCompute.bind(this)),this.onGraphic&&this._onGraphic(this.onGraphic.bind(this))}__stop(){var e;this.transform&&this.transform.scene3D&&((e=this.onDisable)==null||e.call(this,this.transform.view3D)),this._onUpdate(null),this._onLateUpdate(null),this._onBeforeUpdate(null),this._onCompute(null),this._onGraphic(null)}init(e){}start(){}stop(){}cloneTo(e){}copyComponent(e){return this}_onUpdate(e){e!=null?ae.bindUpdate(this.transform.view3D,this,e):ae.unBindUpdate(this.transform.view3D,this)}_onLateUpdate(e){e!=null?ae.bindLateUpdate(this.transform.view3D,this,e):ae.unBindLateUpdate(this.transform.view3D,this)}_onBeforeUpdate(e){e!=null?ae.bindBeforeUpdate(this.transform.view3D,this,e):ae.unBindBeforeUpdate(this.transform.view3D,this)}_onCompute(e){e!=null?ae.bindCompute(this.transform.view3D,this,e):ae.unBindCompute(this.transform.view3D,this)}_onGraphic(e){e!=null?ae.bindGraphic(this.transform.view3D,this,e):ae.unBindGraphic(this.transform.view3D,this)}beforeDestroy(e){ae.removeWaitStart(this.object3D,this)}destroy(e){this.isDestroyed||(this.isDestroyed=!0,this.enable=!1,this.stop(),this._onBeforeUpdate(null),this._onUpdate(null),this._onLateUpdate(null),this.onEnable=null,this.onDisable=null,this.onUpdate=null,this.onLateUpdate=null,this.onBeforeUpdate=null,this.onCompute=null,this.onGraphic=null)}}class Ls{constructor(){o(this,"value",0),o(this,"inv_base",0)}static get(e,t){let r=0,s=1/t;for(;e>0;)r+=e%t*s,e/=t,s/=t;return r}getBase(e,t){let r=this.inv_base=1/t;for(;e>0;)this.value+=r*(e%t),e/=t,r*=this.inv_base}next(){let e=1-this.value-1e-7;if(this.inv_base<e)this.value+=this.inv_base;else{let t=this.inv_base,r;do r=t,t*=this.inv_base;while(t>=e);this.value+=r+t-1}}get(){return this.value}}const Ji=class{constructor(i,e){o(this,"origin",new g),o(this,"length",Number.MAX_VALUE),o(this,"_vector",new g),o(this,"_dir",new g),o(this,"_v0",new g),o(this,"_v1",new g),o(this,"_v2",new g),o(this,"_E1",new g),o(this,"_E2",new g),o(this,"_P",new g),o(this,"_T",new g),o(this,"_Q",new g),this.origin.copyFrom(i||new g),this._dir.copyFrom(e||new g),this._dir.normalize()}get direction(){return this._dir}set direction(i){this._dir.copyFrom(i),this._dir.normalize()}clone(){return new Ji(this.origin,this.direction)}intersectBox(i,e){let t=this.direction,r=this.origin,s,a,n,l,h,u;const c=1/t.x,f=1/t.y,d=1/t.z,p=i.min,m=i.max;return s=((c>=0?p.x:m.x)-r.x)*c,a=((c>=0?m.x:p.x)-r.x)*c,n=((f>=0?p.y:m.y)-r.y)*f,l=((f>=0?m.y:p.y)-r.y)*f,s>l||n>a||(n>s&&(s=n),l<a&&(a=l),h=((d>=0?p.z:m.z)-r.z)*d,u=((d>=0?m.z:p.z)-r.z)*d,s>u||h>a)||(h>s&&(s=h),u<a&&(a=u),a<0)?null:(e||(e=new g),this.pointAt(s>=0?s:a,e))}pointAt(i,e){return e||(e=new g),e.copy(this.direction),e.multiplyScalar(i),e.add(this.origin,e),e}copy(i){return this.origin.copy(i.origin),this.direction.copy(i.direction),this._dir.copy(i._dir),this.length=i.length,this}setApproxDirection(i){this._dir=i.normalize()}setOrigin(i){this.origin.copyFrom(i)}getOrigin(){return this.origin}getPoint(i){return this._dir.scaleBy(i),this.origin.add(this._dir)}sqrDistToPoint(i){let e=this._dir,t=i.subtract(this.origin),r=et(t,e),s=et(e,e),a=r/s,n=this.getPoint(a);return io(i.subtract(n))}applyMatrix(i){this.origin=i.transformPoint(this.origin),this._dir=i.transformVector(this._dir)}pointInTriangle(i,e,t,r){let s=this._v0,a=this._v1,n=this._v2;r.subtract(e,s),t.subtract(e,a),i.subtract(e,n);let l=g.dot(s,s),h=g.dot(s,a),u=g.dot(s,n),c=g.dot(a,a),f=g.dot(a,n),d=1/(l*c-h*h),p=(c*u-h*f)*d,m=(l*f-h*u)*d;return p>=0&&m>=0&&p+m<1}intersectTriangle(i,e,t){let r=t.v1,s=t.v2,a=t.v3;s.subtract(r,this._E1),a.subtract(r,this._E2),e.crossProduct(this._E2,this._P);let n=this._E1.dotProduct(this._P);if(n>0?i.subtract(r,this._T):(r.subtract(i,this._T),n=-n),n<1e-4||(t.u=this._T.dotProduct(this._P),t.u<0||t.u>n)||(this._T.crossProduct(this._E1,this._Q),t.v=e.dotProduct(this._Q),t.v<0||t.u+t.v>n))return null;let l=new g;t.t0=t.t=this._E2.dotProduct(this._Q);let h=1/n;return t.t*=h,t.u*=h,t.v*=h,l.x=i.x+t.t*e.x,l.y=i.y+t.t*e.y,l.z=i.z+t.t*e.z,l}intersectSphere(i,e,t,r){let s=i.subtract(t),a=g.dot(e,e),n=2*g.dot(s,e),l=g.dot(s,s)-r*r,h=n*n-4*a*l,u=g.HELP_3;if(h<0)return null;{let c=(-n-Math.sqrt(h))/(a*2);return c<0?null:(u.x=i.x+c*e.x,u.y=i.y+c*e.y,u.z=i.z+c*e.z,u)}}intersectionSegment(i,e,t){const r=this.origin,s=g.HELP_0,a=g.HELP_1,n=g.HELP_2,l=g.HELP_3;e.subtract(i,s),this._dir.scaleToRef(Ji._rayl,n),r.add(n,a),i.subtract(r,l);var h=g.dot(s,s),u=g.dot(s,n),c=g.dot(n,n),f=g.dot(s,l),d=g.dot(n,l),p=h*c-u*u,m,_,v=p,y,C,B=p;p<Ji._smallnum?(_=0,v=1,C=d,B=c):(_=u*d-c*f,C=h*d-u*f,_<0?(_=0,C=d,B=c):_>v&&(_=v,C=d+u,B=c)),C<0?(C=0,-f<0?_=0:-f>h?_=v:(_=-f,v=h)):C>B&&(C=B,-f+u<0?_=0:-f+u>h?_=v:(_=-f+u,v=h)),m=Math.abs(_)<Ji._smallnum?0:_/v,y=Math.abs(C)<Ji._smallnum?0:C/B;const T=g.HELP_4;n.scaleToRef(y,T);const M=g.HELP_5;s.scaleToRef(m,M),M.add(l,M);const D=g.HELP_6;M.subtract(T,D);var P=y>0&&y<=this._dir.length&&D.lengthSquared<t*t;if(P){let L=new g;return L.copyFrom(e.subtract(i)),L.scaleBy(m),L.add(i,L),{out:L,length:M.length}}return{out:null,length:-1}}get_vec(i,e){let t=g.HELP_1;return t.x=i.x-e.x,t.y=i.y-e.y,t.z=i.z-e.z,t}};let ci=Ji;o(ci,"_rayl",1e9),o(ci,"_smallnum",1e-8);class bs{constructor(e=0,t=0,r=0,s=0){o(this,"x"),o(this,"y"),o(this,"w"),o(this,"h"),this.x=e,this.y=t,this.w=r,this.h=s}get width(){return this.w}set width(e){this.w=e}get height(){return this.h}set height(e){this.h=e}static pointInRect(e,t,r,s,a,n){return!(e<r||e>a||t<s||t>n)}clone(){return new bs(this.x,this.y,this.w,this.h)}copyFrom(e){this.x=e.x,this.y=e.y,this.w=e.w,this.h=e.h}copyTo(e){e.copyFrom(this)}inner(e,t){return!(e<this.x||e>this.x+this.width||t<this.y||t>this.y+this.height)}equal(e){return!(this.x!=e.x||this.y!=e.y||this.width!=e.width||this.height!=e.height)}equalArea(e,t,r,s){return!(this.x!=e||this.y!=t||this.width!=r||this.height!=s)}equalInnerArea(e){var t=this.x,r=this.y,s=this.x+this.width,a=this.y+this.height,n=e.x,l=e.y,h=e.x+e.width,u=e.y+e.height;return Math.max(t,n)<=Math.min(s,h)&&Math.max(r,l)<=Math.min(a,u)}innerArea(e,t){t=t||new bs;var r=this.x,s=this.y,a=this.x+this.width,n=this.y+this.height,l=e.x,h=e.y,u=e.x+e.width,c=e.y+e.height,f=Math.max(s,h),d=Math.min(n,c),p=Math.max(r,l),m=Math.min(u,a);return f>=0&&d>=0&&d-f>=0&&m-p>0?(t.x=p,t.y=f,t.width=m-p,t.height=d-f):(t.x=0,t.y=0,t.width=0,t.height=0),t}setTo(e,t,r,s){this.x=e,this.y=t,this.width=r,this.height=s}}const Qr=class{constructor(i,e){o(this,"center"),o(this,"extents"),o(this,"max"),o(this,"min"),o(this,"size"),i||(i=g.ZERO.clone()),e||(e=g.ZERO.clone()),this.setFromCenterAndSize(i,e)}makeEmpty(){return this.setFromMinMax(Qr.maxVector3,Qr.minVector3),this}setFromMinMax(i,e){return this.init(),e.subtract(i,this.size),i.add(e,this.center).multiplyScalar(.5),this.extents.copyFrom(this.size).multiplyScalar(.5),this.min.copyFrom(i),this.max.copyFrom(e),this}init(){return this.min||(this.min=new g),this.max||(this.max=new g),this.size||(this.size=new g),this.center||(this.center=new g),this.extents||(this.extents=new g),this}setFromCenterAndSize(i,e){return this.size=e,this.center=i,this.init(),this.extents.copy(e).multiplyScalar(.5),this.center.subtract(this.extents,this.min),this.center.add(this.extents,this.max),this}inFrustum(i,e){return e.containsBox(i.bound)}merge(i){i.min.x<this.min.x&&(this.min.x=i.min.x),i.min.y<this.min.y&&(this.min.y=i.min.y),i.min.z<this.min.z&&(this.min.z=i.min.z),i.max.x>this.max.x&&(this.max.x=i.max.x),i.max.y>this.max.y&&(this.max.y=i.max.y),i.max.z>this.max.z&&(this.max.z=i.max.z),this.size.x=i.max.x-i.min.x,this.size.y=i.max.y-i.min.y,this.size.z=i.max.z-i.min.z,this.extents.x=this.size.x*.5,this.extents.y=this.size.y*.5,this.extents.z=this.size.z*.5,this.center.x=this.extents.x+i.min.x,this.center.y=this.extents.y+i.min.y,this.center.z=this.extents.z+i.min.z}intersects(i){return this.min.x<=i.max.x&&this.max.x>=i.min.x&&this.min.y<=i.max.y&&this.max.y>=i.min.y&&this.min.z<=i.max.z&&this.max.z>=i.min.z}intersectsSphere(i){return this.min.x<=i.max.x&&this.max.x>=i.min.x&&this.min.y<=i.max.y&&this.max.y>=i.min.y&&this.min.z<=i.max.z&&this.max.z>=i.min.z}intersectsBox(i){return this.min.x<=i.max.x&&this.max.x>=i.min.x&&this.min.y<=i.max.y&&this.max.y>=i.min.y&&this.min.z<=i.max.z&&this.max.z>=i.min.z}equals(i){return this.center.equals(i.center)&&this.extents.equals(i.extents)}expandByPoint(i){i.x<this.min.x&&(this.min.x=i.x),i.x>this.max.x&&(this.max.x=i.x),i.y<this.min.y&&(this.min.y=i.y),i.y>this.max.y&&(this.max.y=i.y),i.z<this.min.z&&(this.min.z=i.z),i.z>this.max.z&&(this.max.z=i.z)}static fromPoints(i){for(var e=new Qr(new g,new g),t=0;t<i.length;t++)e.expandByPoint(i[t]);return e}calculateTransform(i){}clone(){var i=new Qr(this.center.clone(),this.size.clone());return i}intersectsRay(i,e){throw new Error("Method not implemented.")}containsPoint(i){return this.min.x<=i.x&&this.max.x>=i.x&&this.min.y<=i.y&&this.max.y>=i.y&&this.min.z<=i.z&&this.max.z>=i.z}containsBox(i){let e=this.min,t=this.max;return e.x<=i.min.x&&e.y<=i.min.y&&e.z<=i.min.z&&t.x>=i.max.x&&t.y>=i.max.y&&t.z>=i.max.z}updateBound(){}destroy(i){this.center=null,this.extents=null,this.min=null,this.max=null,this.size=null}};let Be=Qr;o(Be,"maxVector3",new g(1,1,1).multiplyScalar(Number.MAX_VALUE*.1)),o(Be,"minVector3",new g(1,1,1).multiplyScalar(-Number.MAX_VALUE*.1));class yl{constructor(){o(this,"planes"),o(this,"corners"),o(this,"boundingBox",new Be),this.planes=[],this.corners=[];for(var e=0;e<6;e++)this.planes[e]=new g;for(var e=0;e<2*2*2;e++)this.corners[e]=new g}updateBoundBox(e){this.boundingBox.makeEmpty();let t=this.boundingBox.min,r=this.boundingBox.max,s=0;for(let a=0;a<2;++a)for(let n=0;n<2;++n)for(let l=0;l<2;++l){let h=this.corners[s];s++,h.set(2*a-1,2*n-1,l,1),e.transformVector4(h,h),h.div(h.w,h),t.x=Math.min(h.x,t.x),t.y=Math.min(h.y,t.y),t.z=Math.min(h.z,t.z),r.x=Math.max(h.x,r.x),r.y=Math.max(h.y,r.y),r.z=Math.max(h.z,r.z)}return this.boundingBox.setFromMinMax(t,r),this}setFrustumCorners(e){let t=0;for(let r=0;r<2;++r)for(let s=0;s<2;++s)for(let a=0;a<2;++a){let n=this.corners[t];n.set(2*r-1,2*s-1,a,1),e.transformVector4(n,n),n.div(n.w,n),t++}}update(e){var t=e.rawData;this.planes[0].x=t[3]-t[0],this.planes[0].y=t[7]-t[4],this.planes[0].z=t[11]-t[8],this.planes[0].w=t[15]-t[12];var r=Math.sqrt(this.planes[0].x*this.planes[0].x+this.planes[0].y*this.planes[0].y+this.planes[0].z*this.planes[0].z);this.planes[0].x/=r,this.planes[0].y/=r,this.planes[0].z/=r,this.planes[0].w/=r,this.planes[1].x=t[3]+t[0],this.planes[1].y=t[7]+t[4],this.planes[1].z=t[11]+t[8],this.planes[1].w=t[15]+t[12],r=Math.sqrt(this.planes[1].x*this.planes[1].x+this.planes[1].y*this.planes[1].y+this.planes[1].z*this.planes[1].z),this.planes[1].x/=r,this.planes[1].y/=r,this.planes[1].z/=r,this.planes[1].w/=r,this.planes[2].x=t[3]+t[1],this.planes[2].y=t[7]+t[5],this.planes[2].z=t[11]+t[9],this.planes[2].w=t[15]+t[13],r=Math.sqrt(this.planes[2].x*this.planes[2].x+this.planes[2].y*this.planes[2].y+this.planes[2].z*this.planes[2].z),this.planes[2].x/=r,this.planes[2].y/=r,this.planes[2].z/=r,this.planes[2].w/=r,this.planes[3].x=t[3]-t[1],this.planes[3].y=t[7]-t[5],this.planes[3].z=t[11]-t[9],this.planes[3].w=t[15]-t[13],r=Math.sqrt(this.planes[3].x*this.planes[3].x+this.planes[3].y*this.planes[3].y+this.planes[3].z*this.planes[3].z),this.planes[3].x/=r,this.planes[3].y/=r,this.planes[3].z/=r,this.planes[3].w/=r,this.planes[4].x=t[3]-t[2],this.planes[4].y=t[7]-t[6],this.planes[4].z=t[11]-t[10],this.planes[4].w=t[15]-t[14],r=Math.sqrt(this.planes[4].x*this.planes[4].x+this.planes[4].y*this.planes[4].y+this.planes[4].z*this.planes[4].z),this.planes[4].x/=r,this.planes[4].y/=r,this.planes[4].z/=r,this.planes[4].w/=r,this.planes[5].x=t[3]+t[2],this.planes[5].y=t[7]+t[6],this.planes[5].z=t[11]+t[10],this.planes[5].w=t[15]+t[14],r=Math.sqrt(this.planes[5].x*this.planes[5].x+this.planes[5].y*this.planes[5].y+this.planes[5].z*this.planes[5].z),this.planes[5].x/=r,this.planes[5].y/=r,this.planes[5].z/=r,this.planes[5].w/=r}containsPoint(e){for(var t=0;t<6;t++)if(this.planes[t].x*e.x+this.planes[t].y*e.y+this.planes[t].z*e.z+this.planes[t].w<=0)return!1;return!0}containsSphere(e){let t=e.bound,r=0,s,a=e.transform.worldPosition,n=t.radius,l=t.center.x+a.x,h=t.center.y+a.y,u=t.center.z+a.z;for(let c of this.planes){if(s=c.x*l+c.y*h+c.z*u+c.w,s<=-n)return 0;s>n&&r++}return r===6?2:1}containsBox(e){let t=0,r,a=Math.max(e.size.x,e.size.y,e.size.z)*2,n=e.center.x,l=e.center.y,h=e.center.z;for(let u of this.planes){if(r=u.x*n+u.y*l+u.z*h+u.w,r<=-a)return 0;r>a&&t++}return t===6?2:1}containsBox2(e){let t=0,r,s=1.74*Math.max(e.extents.x,e.extents.y,e.extents.z);for(let a of this.planes){if(r=a.x*e.center.x+a.y*e.center.y+a.z*e.center.z+a.w,r<=-s)return 0;r>s&&t++}return t===6?2:1}}var Ie=(i=>(i[i.ortho=0]="ortho",i[i.perspective=1]="perspective",i[i.shadow=2]="shadow",i))(Ie||{});class Ld{constructor(e){o(this,"corners"),o(this,"index"),this.index=e,this.corners=[];for(let t=0;t<4;t++)this.corners.push(new g)}}class Ud{constructor(e,t,r){o(this,"bound"),o(this,"twoSections"),o(this,"name"),o(this,"color"),o(this,"shadowCamera"),o(this,"index"),this.bound=new Be,this.shadowCamera=Ne.createCamera3DObject(null,"csmShadowCamera_"+r),this.shadowCamera.isShadowCamera=!0,this.shadowCamera.orthoOffCenter(100,-100,100,-100,1,1e4),this.twoSections=[e,t],this.index=r,r==0?this.color=new z(1,0,0,1):r==1?this.color=new z(0,1,0,1):r==2?this.color=new z(0,0,1,1):r==3&&(this.color=new z(0,1,1,1)),this.name="child_"+r}updateBound(){this.bound.makeEmpty();let e=this.bound.min,t=this.bound.max;for(let r of this.twoSections)for(let s of r.corners)e.x=Math.min(s.x,e.x),e.y=Math.min(s.y,e.y),e.z=Math.min(s.z,e.z),t.x=Math.max(s.x,t.x),t.y=Math.max(s.y,t.y),t.z=Math.max(s.z,t.z);return this.bound.setFromMinMax(e,t),this}}class Cl{constructor(e){o(this,"sections"),o(this,"children"),o(this,"name"),this.sections=[];let t=e+1;for(let r=0;r<t;r++)this.sections.push(new Ld(r));this.children=[];for(let r=0;r<e;r++)this.children.push(new Ud(this.sections[r],this.sections[r+1],r))}update(e,t,r,s,a){let n=this.sections.length-1;for(let l=0;l<=n;++l){let h=this.sections[l],u=0,c=this.logSplit(r,s,l,this.sections.length);{let d=(c-r)/s;d=d**a.csmScatteringExp,c=(s-r)*d+r}c*=a.csmAreaScale;let f=(e.rawData[10]*c+e.rawData[14])/c;for(let d=0;d<2;++d)for(let p=0;p<2;++p){let m=h.corners[u];u++,m.set(2*d-1,2*p-1,f,1),t.transformVector4(m,m),m.div(m.w,m)}}for(let l of this.children)l.updateBound();return this}squareSplit(e,t,r,s){return(r/(s-1))**4*(t-e)+e}uniformSplit(e,t,r,s){return r/(s-1)*(t-e)+e}logSplit(e,t,r,s){return e*(t/e)**(r/(s-1))}}class Zi extends Ee{constructor(){super(),o(this,"fov",1),o(this,"name"),o(this,"aspect",1),o(this,"near",1),o(this,"far",5e3),o(this,"viewPort",new bs),o(this,"frustum"),o(this,"isShadowCamera",!1),o(this,"_projectionMatrixInv",new V),o(this,"_projectionMatrix",new V),o(this,"_viewMatrix",new V),o(this,"_unprojection",new V),o(this,"_pvMatrixInv",new V),o(this,"_pvMatrix",new V),o(this,"_halfw"),o(this,"_halfh"),o(this,"_ray"),o(this,"_enableCSM",!1),o(this,"lookTarget"),o(this,"type",Ie.perspective),o(this,"csm"),o(this,"cubeShadowCameras",[]),o(this,"_haltonSeq"),o(this,"_jitterOffsetList"),o(this,"_useJitterProjection",!1),o(this,"_jitterFrameIndex",0),o(this,"_sampleIndex",0),o(this,"_jitterX",0),o(this,"_jitterY",0)}get projectionMatrix(){return this._projectionMatrix}get enableCSM(){return this._enableCSM}set enableCSM(e){e&&!this.csm&&(this.csm=new Cl(lt.Cascades)),this._enableCSM=e}init(){super.init(),this._ray=new ci,this.frustum=new yl,this.viewPort.x=0,this.viewPort.y=0,this.viewPort.w=S.presentationSize[0],this.viewPort.h=S.presentationSize[1],this.lookTarget=new g(0,0,0)}getShadowBias(e){let t=2*this.getShadowWorldExtents()/e,r=this.far-this.near;return t/r}getShadowWorldExtents(){let e=A.setting.shadow.shadowBound;return e?e*=.5:e=Math.round(.05*this.frustum.boundingBox.extents.length),e}getCSMShadowBias(e,t){let r=2*this.getCSMShadowWorldExtents(e)/t,s=this.far-this.near;return r/s}getCSMShadowWorldExtents(e){return Math.round(this.csm.children[e].bound.extents.length)}perspective(e,t,r,s){this.fov=e,this.aspect=t,this.near=r,this.far=s,this._projectionMatrix.perspective(e,t,r,s),this.type=Ie.perspective}resetPerspective(e){this.type==Ie.perspective&&this._projectionMatrix.perspective(this.fov,e,this.near,this.far)}ortho(e,t,r,s){this.near=Math.max(r,.1),this.far=s,this._projectionMatrix.ortho(e,t,r,s),this.type=Ie.ortho}orthoOffCenter(e,t,r,s,a,n){this.near=Math.max(a,.01),this.far=n,this._projectionMatrix.orthoOffCenter(e,t,r,s,a,n),this.type=Ie.ortho}orthoZo(e,t,r,s,a,n){this.near=Math.max(a,.01),this.far=n,this._projectionMatrix.orthoZO(e,t,r,s,a,n),this.type=Ie.ortho}get viewMatrix(){return this._viewMatrix.copyFrom(this.transform.worldMatrix),this._viewMatrix.invert(),this._viewMatrix}get shadowViewMatrix(){return this._viewMatrix.copyFrom(this.transform.worldMatrix),this._viewMatrix.appendScale(1,1,1),this._viewMatrix.invert(),this._viewMatrix}object3DToScreenRay(e,t=null){return t||(t=new g(0,0,0,1)),this._halfw=this.viewPort.width*.5,this._halfh=this.viewPort.height*.5,st.transformVector(this.viewMatrix,e,t),this.project(t,t),t.x=this._halfw+t.x*this._halfw,t.y=this.viewPort.height-(this._halfh-t.y*this._halfh),t}screenRayToObject3D(e,t=null){t||(t=new g),this._halfw=this.viewPort.width*.5,this._halfh=this.viewPort.height*.5;let r=e.x,s=e.y;return t.x=r/this.viewPort.width-.25,t.y=s/this.viewPort.height-.25,this.unProject(t.x,t.y,e.z,t),t}get pvMatrix(){return so(this._projectionMatrix,this.viewMatrix,this._pvMatrix),this._pvMatrix}get pvMatrix2(){so(this._projectionMatrix,this.transform.worldMatrix,this._pvMatrix);let e=this._pvMatrixInv.copyFrom(this.pvMatrix);return e.invert(),e}get pvMatrixInv(){let e=this._pvMatrixInv.copyFrom(this.pvMatrix);return e.invert(),e}get projectionMatrixInv(){return this._projectionMatrixInv.copyFrom(this._projectionMatrix),this._projectionMatrixInv.invert(),this._projectionMatrixInv}unProject(e,t,r,s){return s||(s=new g),s.x=e,s.y=-t,s.z=r,s.w=1,s.x*=r,s.y*=r,this._unprojection.copyFrom(this._projectionMatrix),this._unprojection.invert(),st.transformVector(this._unprojection,s,s),s.z=r,s}project(e,t){return this._projectionMatrix.perspectiveMultiplyPoint3(e,t),t.x=t.x/t.w,t.y=-t.y/t.w,t.z=e.z,t}screenPointToRay(e,t){let r=this._ray,s=Ne.UnProjection(e,t,.01,this),a=Ne.UnProjection(e,t,1,this);return a=a.subtract(s).normalize(),r.origin.copyFrom(s),r.direction=a,r}screenPointToWorld(e,t,r){return Ne.UnProjection(e,t,r,this)}worldToScreenPoint(e,t){return Ne.Projection(e,this,t)}lookAt(e,t,r=g.Y_AXIS){this.transform.lookAt(e,t,r),t&&this.lookTarget.copyFrom(t)}resetProjectMatrix(){this.perspective(this.fov,this.aspect,this.near,this.far)}onUpdate(){var e;this.type==Ie.perspective&&(this.aspect=S.aspect,this.resetProjectMatrix()),this._useJitterProjection&&this.getJitteredProjectionMatrix(),this.frustum.update(this.pvMatrix),this.frustum.updateBoundBox(this.pvMatrixInv);let t=A.setting.shadow;this.enableCSM&&((e=this.csm)==null||e.update(this._projectionMatrix,this._pvMatrixInv,this.near,this.far,t))}get jitterFrameIndex(){return this._jitterFrameIndex}get jitterX(){return this._jitterX}get jitterY(){return this._jitterY}enableJitterProjection(e){this._jitterFrameIndex=0,this._useJitterProjection=e,this._haltonSeq||(this._haltonSeq=new Ls),this._jitterOffsetList=[];for(let t=0;t<8;t++){let r=this.generateRandomOffset();this._jitterOffsetList.push(r)}this._jitterOffsetList.reverse()}generateRandomOffset(){let e=new Z(Ls.get((this._sampleIndex&1023)+1,2)-.5,Ls.get((this._sampleIndex&1023)+1,3)-.5);const t=8;return++this._sampleIndex>=t&&(this._sampleIndex=0),e}getJitteredProjectionMatrix(){let e=A.setting.render.postProcessing.taa,t=this._projectionMatrix,r=e.temporalJitterScale,s=this._jitterFrameIndex%e.jitterSeedCount,a=this._jitterOffsetList[s].x*r,n=this._jitterOffsetList[s].y*r,l=t.get(0,2),h=t.get(1,2);this._jitterX=a/this.viewPort.width,this._jitterY=n/this.viewPort.height,l+=this._jitterX,h+=this._jitterY,t.set(0,2,l),t.set(1,2,h),this._jitterFrameIndex++}getWorldDirection(e){e||(e=new g);const t=this.transform._worldMatrix.rawData;return e.set(-t[8],-t[9],-t[10]).normalize()}}const Vr=class extends Ee{constructor(){super(),o(this,"eventPositionChange",new je(Vr.POSITION_ONCHANGE)),o(this,"eventRotationChange",new je(Vr.ROTATION_ONCHANGE)),o(this,"eventScaleChange",new je(Vr.SCALE_ONCHANGE)),o(this,"eventLocalChange",new je(Vr.LOCAL_ONCHANGE)),o(this,"onPositionChange"),o(this,"onRotationChange"),o(this,"onScaleChange"),o(this,"_scene3d"),o(this,"_parent"),o(this,"_localPos"),o(this,"_localRot"),o(this,"_localRotQuat"),o(this,"_localScale"),o(this,"_localDetailPos"),o(this,"_localDetailRot"),o(this,"_localDetailScale"),o(this,"index"),o(this,"index2"),o(this,"_forward",new g),o(this,"_back",new g),o(this,"_right",new g),o(this,"_left",new g),o(this,"_up",new g),o(this,"_down",new g),o(this,"_worldMatrix"),o(this,"_targetPos"),o(this,"static",!1),o(this,"depthOrder",0),this._worldMatrix=new V(!0),this.index=this._worldMatrix.index,this.index2=this._worldMatrix.index*ee.stateStruct,this._localPos=new g,this._localRot=new g,this._localRotQuat=new q,this._localScale=new g(1,1,1),ee.setScale(this.index,this._localScale.x,this._localScale.y,this._localScale.z),ee.setRotation(this.index,this._localRot.x,this._localRot.y,this._localRot.z),ee.setTranslate(this.index,this._localPos.x,this._localPos.y,this._localPos.z)}get localChange(){return ee.matrixStateBuffer[this.index2]!=0}set localChange(i){ee.matrixStateBuffer[this.index2]=i?1:0}get targetPos(){return this._targetPos}set targetPos(i){this._targetPos=i}get parent(){return this._parent}set parent(i){var e;let t=(e=this._parent)==null?void 0:e.object3D;if(this._parent=i,this.depthOrder=i?i.depthOrder+1:0,ee.setParent(this.index,i?i.worldMatrix.index:-1,this.depthOrder),this.localChange=!0,this.object3D){let r=i?i.scene3D:null;r?(this._scene3d=r,this.object3D.components.forEach(s=>{ae.appendWaitStart(s)})):this.object3D.components.forEach(s=>{s.__stop()});for(let s of this.object3D.entityChildren)s.transform.parent=i?this:null;this.object3D.components.forEach(s=>{var a,n;(n=s.onParentChange)==null||n.call(s,t,(a=this._parent)==null?void 0:a.object3D)})}this.notifyLocalChange()}set enable(i){this.transform._scene3d&&i?super.enable=!0:super.enable=!1;for(let e of this.object3D.entityChildren)e.transform.enable=i}get enable(){return this._enable}get scene3D(){return this._scene3d}set scene3D(i){this._scene3d=i}get view3D(){return this._scene3d&&this._scene3d.view?this._scene3d.view:null}awake(){}start(){}stop(){}notifyLocalChange(){if(this.localChange=!0,this.object3D){let i=this.object3D.entityChildren,e=0,t=i.length;for(e=0;e<t;e++)i[e].transform.notifyLocalChange()}this.eventDispatcher.dispatchEvent(this.eventLocalChange)}get up(){return this.worldMatrix.transformVector(g.UP,this._up),this._up}set up(i){this._up.copyFrom(i),st.fromToRotation(g.UP,this._up,q.HELP_0),this.transform.localRotQuat=q.HELP_0}get down(){return this.worldMatrix.transformVector(g.DOWN,this._down),this._down}set down(i){var e;this._down.copyFrom(i),st.fromToRotation(g.DOWN,this._down,q.HELP_0),this.transform.localRotQuat=q.HELP_0,this.notifyLocalChange(),(e=this.onRotationChange)==null||e.call(this),this.eventRotationChange&&this.eventDispatcher.dispatchEvent(this.eventRotationChange)}get forward(){return this.worldMatrix.transformVector(g.FORWARD,this._forward),this._forward}set forward(i){var e;this._forward.copyFrom(i),st.fromToRotation(g.FORWARD,this._forward,q.HELP_0),this.transform.localRotQuat=q.HELP_0,this.notifyLocalChange(),(e=this.onRotationChange)==null||e.call(this),this.eventRotationChange&&this.eventDispatcher.dispatchEvent(this.eventRotationChange)}get back(){return this.worldMatrix.transformVector(g.BACK,this._back),this._back}set back(i){this._back.copyFrom(i),st.fromToRotation(g.BACK,this._back,q.HELP_0),this.transform.localRotQuat=q.HELP_0}get left(){return this.worldMatrix.transformVector(g.neg_X_AXIS,this._left),this._left}set left(i){this._left.copyFrom(i),st.fromToRotation(g.LEFT,this._left,q.HELP_0),this.transform.localRotQuat=q.HELP_0}get right(){return this.worldMatrix.transformVector(g.X_AXIS,this._right),this._right}set right(i){var e;this._right.copyFrom(i),st.fromToRotation(g.RIGHT,this._right,q.HELP_0),this.transform.localRotQuat=q.HELP_0,this.notifyLocalChange(),(e=this.onRotationChange)==null||e.call(this),this.eventRotationChange&&this.eventDispatcher.dispatchEvent(this.eventRotationChange)}get localRotQuat(){return this._localRotQuat}set localRotQuat(i){var e;(i.x!=this._localRotQuat.x||i.y!=this._localRotQuat.y||i.z!=this._localRotQuat.z||i.w!=this._localRotQuat.w)&&(this._localRotQuat.copyFrom(i),this._localRotQuat.getEulerAngles(this._localRot),ee.setRotation(this.index,this._localRot.x,this._localRot.y,this._localRot.z),this.notifyLocalChange(),(e=this.onRotationChange)==null||e.call(this),this.eventRotationChange&&this.eventDispatcher.dispatchEvent(this.eventRotationChange))}notifyChange(){var i,e,t;this.notifyLocalChange(),(i=this.onRotationChange)==null||i.call(this),(e=this.onScaleChange)==null||e.call(this),(t=this.onPositionChange)==null||t.call(this),this.eventRotationChange&&this.eventDispatcher.dispatchEvent(this.eventRotationChange),this.eventPositionChange&&this.eventDispatcher.dispatchEvent(this.eventPositionChange),this.eventScaleChange&&this.eventDispatcher.dispatchEvent(this.eventScaleChange)}get worldMatrix(){return this.updateWorldMatrix(),this._worldMatrix}updateWorldMatrix(i=!1){(this.localChange||i)&&(this.parent?(Rs(this._localRot,this._localPos,this._localScale,this._worldMatrix),xl(this._worldMatrix,this.parent.worldMatrix,this._worldMatrix)):Rs(this._localRot,this._localPos,this._localScale,this._worldMatrix),this.localChange=!1)}updateChildTransform(){let i=this;if(i.localChange&&i.updateWorldMatrix(),i.object3D.numChildren>0)for(const e of i.object3D.entityChildren)e.transform.updateChildTransform()}lookTarget(i,e=g.UP){this.lookAt(this.transform.worldPosition,i,e)}lookAt(i,e,t=g.UP){this._targetPos||(this._targetPos=new g),this._targetPos.copyFrom(e),this.localPosition=i,V.helpMatrix.lookAt(i,e,t),V.helpMatrix.invert();var r=V.helpMatrix.decompose(yt.QUATERNION);this.localRotQuat=q.CALCULATION_QUATERNION.copyFrom(r[1])}decomposeFromMatrix(i,e="eulerAngles"){let t=i.decompose(e),r=this.transform;return r.localRotQuat.copyFrom(t[1]),r.localRotQuat=r.localRotQuat,r.localPosition.copyFrom(t[0]),r.localPosition=r.localPosition,r.localScale.copyFrom(t[2]),r.localScale=r.localScale,this}cloneTo(i){i.transform.localPosition=this.localPosition,i.transform.localRotation=this.localRotation,i.transform.localScale=this.localScale}set x(i){var e;this._localPos.x!=i&&(this._localPos.x=i,ee.setTranslate(this.index,this._localPos.x,this._localPos.y,this._localPos.z),this.notifyLocalChange(),(e=this.onPositionChange)==null||e.call(this),this.eventPositionChange&&this.eventDispatcher.dispatchEvent(this.eventPositionChange))}get x(){return this._localPos.x}set y(i){var e;this._localPos.y!=i&&(this._localPos.y=i,ee.setTranslate(this.index,this._localPos.x,this._localPos.y,this._localPos.z),this.notifyLocalChange(),(e=this.onPositionChange)==null||e.call(this),this.eventPositionChange&&this.eventDispatcher.dispatchEvent(this.eventPositionChange))}get y(){return this._localPos.y}set z(i){var e;this._localPos.z!=i&&(this._localPos.z=i,ee.setTranslate(this.index,this._localPos.x,this._localPos.y,this._localPos.z),this.notifyLocalChange(),(e=this.onPositionChange)==null||e.call(this),this.eventPositionChange&&this.eventDispatcher.dispatchEvent(this.eventPositionChange))}get z(){return this._localPos.z}set scaleX(i){var e;this._localScale.x!=i&&(this._localScale.x=i,ee.setScale(this.index,this._localScale.x,this._localScale.y,this._localScale.z),this.notifyLocalChange(),(e=this.onScaleChange)==null||e.call(this),this.eventScaleChange&&this.eventDispatcher.dispatchEvent(this.eventScaleChange))}get scaleX(){return this._localScale.x}set scaleY(i){var e;this._localScale.y!=i&&(this._localScale.y=i,ee.setScale(this.index,this._localScale.x,this._localScale.y,this._localScale.z),this.notifyLocalChange(),(e=this.onScaleChange)==null||e.call(this),this.eventScaleChange&&this.eventDispatcher.dispatchEvent(this.eventScaleChange))}get scaleY(){return this._localScale.y}set scaleZ(i){var e;this._localScale.z!=i&&(this._localScale.z=i,ee.setScale(this.index,this._localScale.x,this._localScale.y,this._localScale.z),this.notifyLocalChange(),(e=this.onScaleChange)==null||e.call(this),this.eventScaleChange&&this.eventDispatcher.dispatchEvent(this.eventScaleChange))}get scaleZ(){return this._localScale.z}set rotationX(i){var e;this._localRot.x!=i&&(this._localRot.x=i,ee.setRotation(this.index,this._localRot.x,this._localRot.y,this._localRot.z),this.notifyLocalChange(),(e=this.onRotationChange)==null||e.call(this),this.eventRotationChange&&this.eventDispatcher.dispatchEvent(this.eventRotationChange))}get rotationX(){return this._localRot.x}set rotationY(i){var e;this._localRot.y!=i&&(this._localRot.y=i,ee.setRotation(this.index,this._localRot.x,this._localRot.y,this._localRot.z),this.notifyLocalChange(),(e=this.onRotationChange)==null||e.call(this),this.eventRotationChange&&this.eventDispatcher.dispatchEvent(this.eventRotationChange))}get rotationY(){return this._localRot.y}set rotationZ(i){var e;this._localRot.z!=i&&(this._localRot.z=i,ee.setRotation(this.index,this._localRot.x,this._localRot.y,this._localRot.z),this.notifyLocalChange(),(e=this.onRotationChange)==null||e.call(this),this.eventRotationChange&&this.eventDispatcher.dispatchEvent(this.eventRotationChange))}get rotationZ(){return this._localRot.z}get worldPosition(){return this.localChange&&this.updateWorldMatrix(),this._worldMatrix.position}set localPosition(i){var e;this._localPos.copyFrom(i),ee.setTranslate(this.index,i.x,i.y,i.z),this.notifyLocalChange(),(e=this.onPositionChange)==null||e.call(this),this.eventPositionChange&&this.eventDispatcher.dispatchEvent(this.eventPositionChange)}get localPosition(){return this._localPos}set localRotation(i){var e;ee.setRotation(this.index,i.x,i.y,i.z),this._localRot.copyFrom(i),this.notifyLocalChange(),(e=this.onRotationChange)==null||e.call(this),this.eventRotationChange&&this.eventDispatcher.dispatchEvent(this.eventRotationChange)}get localRotation(){return this._localRot}set localScale(i){var e;ee.setScale(this.index,i.x,i.y,i.z),this._localScale.copyFrom(i),this.notifyLocalChange(),(e=this.onScaleChange)==null||e.call(this),this.eventScaleChange&&this.eventDispatcher.dispatchEvent(this.eventScaleChange)}get localScale(){return this._localScale}get localDetailScale(){return this._localDetailScale}set localDetailScale(i){this._localDetailScale=i,ee.setContinueScale(this.index,i.x,i.y,i.z)}get localDetailRot(){return this._localDetailRot}set localDetailRot(i){this._localDetailRot=i,ee.setContinueRotation(this.index,i.x,i.y,i.z)}get localDetailPos(){return this._localDetailPos}set localDetailPos(i){this._localDetailPos=i,ee.setContinueTranslate(this.index,i.x,i.y,i.z)}beforeDestroy(i){this.parent&&this.parent.object3D&&this.parent.object3D.removeChild(this.object3D),super.beforeDestroy(i)}destroy(){super.destroy(),this.scene3D=null,this.eventPositionChange=null,this.eventRotationChange=null,this.eventScaleChange=null,this.onPositionChange=null,this.onRotationChange=null,this.onScaleChange=null,this._scene3d=null,this._parent=null,this._localPos=null,this._localRot=null,this._localRotQuat=null,this._localScale=null,this._forward=null,this._back=null,this._right=null,this._left=null,this._up=null,this._down=null,this.localChange=null,this._targetPos=null}};let Oe=Vr;o(Oe,"LIMIT",1),o(Oe,"COMPONENT_NAME","UUTransform"),o(Oe,"COMPONENT_TYPE","Transform"),o(Oe,"POSITION_ONCHANGE","POSITION_ONCHANGE"),o(Oe,"ROTATION_ONCHANGE","ROTATION_ONCHANGE"),o(Oe,"SCALE_ONCHANGE","SCALE_ONCHANGE"),o(Oe,"PARENT_ONCHANGE","PARENT_ONCHANGE"),o(Oe,"CHILDREN_ONCHANGE","CHILDREN_ONCHANGE"),o(Oe,"ADD_ONCHANGE","ADD_ONCHANGE"),o(Oe,"LOCAL_ONCHANGE","LOCAL_ONCHANGE");const wl=class{static genMeshBounds(i,e){let t=this.genMeshMinVector,r=this.genMeshMaxVector,s=this.genMeshVectorList8;e||(e=new Be(g.ZERO,g.ZERO)),e.setFromMinMax(this.maxVector,this.minVector);let a=i.getComponents(ce);for(const n of a)if(n&&n.geometry){let l=n.object3D.transform.worldMatrix;t.copy(n.geometry.bounds.min),r.copy(n.geometry.bounds.max),s[0].set(t.x,t.y,t.z),s[1].set(t.x,t.y,r.z),s[2].set(t.x,r.y,t.z),s[3].set(t.x,r.y,r.z),s[4].set(r.x,t.y,t.z),s[5].set(r.x,t.y,r.z),s[6].set(r.x,r.y,t.z),s[7].set(r.x,r.y,r.z);for(const h of s)l.transformPoint(h,h),e.expandByPoint(h)}return r.copyFrom(e.max),t.copyFrom(e.min),e.setFromMinMax(t,r),e}static transformBound(i,e,t){let r=this.genMeshMinVector.copyFrom(e.min),s=this.genMeshMaxVector.copyFrom(e.max),a=this.genMeshVectorList8;t||(t=new Be(g.ZERO,g.ZERO)),t.setFromMinMax(this.maxVector,this.minVector),a[0].set(r.x,r.y,r.z),a[1].set(r.x,r.y,s.z),a[2].set(r.x,s.y,r.z),a[3].set(r.x,s.y,s.z),a[4].set(s.x,r.y,r.z),a[5].set(s.x,r.y,s.z),a[6].set(s.x,s.y,r.z),a[7].set(s.x,s.y,s.z);for(const n of a)i.transformPoint(n,n),t.expandByPoint(n);return s.copyFrom(t.max),r.copyFrom(t.min),t.setFromMinMax(r,s),t}};let Zt=wl;o(Zt,"maxVector",new g(Number.MAX_VALUE*.1,Number.MAX_VALUE*.1,Number.MAX_VALUE*.1)),o(Zt,"minVector",wl.maxVector.clone().multiplyScalar(-1)),o(Zt,"genMeshMaxVector",g.ZERO.clone()),o(Zt,"genMeshMinVector",g.ZERO.clone()),o(Zt,"genMeshVectorList8",[new g,new g,new g,new g,new g,new g,new g,new g]);class bl extends hi{constructor(){super(),o(this,"name",""),o(this,"_instanceID",""),o(this,"_numChildren"),o(this,"transform"),o(this,"renderNode"),o(this,"entityChildren"),o(this,"components"),o(this,"waitDisposeComponents"),o(this,"_bound"),o(this,"_boundWorld"),o(this,"_isBoundChange",!0),o(this,"_dispose",!1),this.entityChildren=[],this.components=new Map,this._instanceID=qa().toString(),this.waitDisposeComponents=[]}get instanceID(){return this._instanceID}getObjectByName(e){if(e.indexOf("/")>=0){let r=e.split("/"),s=this;for(;r.length>0&&s;){let a=r.shift();if(s=s.getChildByName(a,!1),!s)return null}return s}else return this.getChildByName(e,!1)}get numChildren(){return this._numChildren}addChild(e){return e==null?new console.error("child is null!"):e===this?new console.error("child is self!"):this.entityChildren.indexOf(e)==-1?(e.removeFromParent(),e.transform.parent=this.transform,this.entityChildren.push(e),this._numChildren=this.entityChildren.length,e):null}removeChild(e){if(e===null)return new console.error("remove child is null!");if(e===this)return new console.error("add child is self!");let t=this.entityChildren.indexOf(e);t!=-1&&(this.entityChildren.splice(t,1),e.transform.parent=null,this._numChildren=this.entityChildren.length)}removeAllChild(){for(;this.numChildren>0;)this.removeChild(this.entityChildren[0])}removeSelf(){return this.removeFromParent()}removeChildByIndex(e){e>=0&&e<this.entityChildren.length?this.removeChild(this.entityChildren[e]):console.error("remove child by index , index out of range")}hasChild(e){return this.entityChildren.indexOf(e)!=-1}removeFromParent(){let e=this.transform.parent;return e&&e.object3D&&e.object3D.removeChild(this),this}getChildByIndex(e){let t=null;return e<this.entityChildren.length&&(t=this.entityChildren[e]),t}getChildByName(e,t=!0){let r=null;for(const s of this.entityChildren){if(s.name==e)return r=s,r;if(t&&(r=s.getChildByName(e,t),r))return r}return r}update(){}instantiate(){return null}onTransformLocalChange(e){this._isBoundChange=!0}get bound(){return(this._isBoundChange||!this._bound)&&this.updateBound(),this._boundWorld}set bound(e){this._bound=e,this._boundWorld=this._bound.clone(),this._isBoundChange=!0}updateBound(){return this._bound||(this._bound=new Be,this._boundWorld=this._bound.clone(),this._isBoundChange=!0),this._isBoundChange&&(Zt.transformBound(this.transform.worldMatrix,this._bound,this._boundWorld),this._isBoundChange=!1),this._boundWorld}waitUpdate(){this._dispose?(this.transform.parent&&this.transform.parent.object3D.removeChild(this),this.components.forEach((e,t)=>{e.enable=!1,e.destroy()}),this.components.clear()):ae.waitStartComponent.forEach((e,t)=>{for(;e.length>0;)e.shift().__start();ae.waitStartComponent.delete(t)})}destroy(e){this._dispose||(this.components.forEach(t=>{t.beforeDestroy(e)}),this.components.forEach(t=>{t.destroy(e)}),this.components.clear(),this.entityChildren.forEach(t=>{t.destroy(e)}),this.removeAllChild(),this.transform.parent=null,this._dispose=!0,super.destroy())}}var Od=Object.defineProperty,Nd=Object.getOwnPropertyDescriptor,Fd=(i,e,t,r)=>{for(var s=r>1?void 0:r?Nd(e,t):e,a=i.length-1,n;a>=0;a--)(n=i[a])&&(s=(r?n(e,t,s):n(s))||s);return r&&s&&Od(e,t,s),s};let te=class extends bl{constructor(){super(),o(this,"_isScene3D"),o(this,"prefabRef"),o(this,"serializeTag"),this.transform=this.addComponent(Oe),this.transform.eventDispatcher.addEventListener(Oe.LOCAL_ONCHANGE,this.onTransformLocalChange,this)}get isScene3D(){return this._isScene3D}forChild(i){this.entityChildren.forEach(e=>{i(e),e.forChild(i)})}addComponent(i,e){let t=i.name;if(!this.components.has(t)){let r=new i;return r.object3D=this,this.components.set(t,r),r.__init(e),ae.appendWaitStart(r),r}return null}getOrAddComponent(i){let e=i.name,t=this.components.get(e);return t||(t=this.addComponent(i)),t}removeComponent(i){let e=i.name;if(this.components.has(e)){let t=this.components.get(e);ae.removeWaitStart(this,t),this.components.delete(e),t.__stop(),t.beforeDestroy(),t.destroy()}}hasComponent(i){let e=i.name;return this.components.has(e)}getComponent(i){let e=i.name;return this.components.get(e)}getComponentFromParent(i){if(!this.parent)return null;let e=this.parent.object3D.getComponent(i);return e||this.parent.object3D.getComponentFromParent(i)}getComponentsInChild(i){let e=[],t=i.name,r=this.components.get(t);r&&e.push(r);for(let s=0;s<this.entityChildren.length;s++){let n=this.entityChildren[s].getComponentsInChild(i);e.push(...n)}return e}getComponents(i,e,t){e||(e=[]);let r=this.getComponent(i);r&&(r.enable||t)&&e.push(r);for(let s=0,a=this.entityChildren.length;s<a;s++){let n=this.entityChildren[s];n&&n instanceof te&&n.getComponents(i,e,t)}return e}getComponentsExt(i,e,t){e||(e=[]);let r=this.components.get(i.name);if(r&&(r.enable||t))e.push(r);else for(const s of this.entityChildren)s instanceof te&&s.getComponentsExt(i,e,t);return e}getComponentsByProperty(i,e,t=!0,r,s){r||(r=[]);let a;for(const n of this.components.values())n&&(n.enable||s)&&n[i]==e&&(r.push(n),a=!0);if(!(a&&t))for(const n of this.entityChildren)n instanceof te&&n.getComponentsByProperty(i,e,t,r,s);return r}clone(){return this.instantiate()}instantiate(){let i=new te;return i.name=this.name,i.serializeTag=this.serializeTag,i.prefabRef=this.prefabRef,this.entityChildren.forEach((e,t)=>{let r=e.instantiate();i.addChild(r)}),this.components.forEach((e,t)=>{e.cloneTo(i)}),i}get localPosition(){return this.transform.localPosition}set localPosition(i){this.transform.localPosition=i}get localRotation(){return this.transform.localRotation}set localRotation(i){this.transform.localRotation=i}get localScale(){return this.transform.localScale}set localScale(i){this.transform.localScale=i}get localQuaternion(){return this.transform.localRotQuat}set localQuaternion(i){this.transform.localRotQuat=i}notifyChange(){this.transform.notifyChange()}get parent(){return this.transform.parent}get parentObject(){return this.transform.parent.object3D}set x(i){this.transform.x=i}get x(){return this.transform.x}set y(i){this.transform.y=i}get y(){return this.transform.y}set z(i){this.transform.z=i}get z(){return this.transform.z}set scaleX(i){this.transform.scaleX=i}get scaleX(){return this.transform.scaleX}set scaleY(i){this.transform.scaleY=i}get scaleY(){return this.transform.scaleY}set scaleZ(i){this.transform.scaleZ=i}get scaleZ(){return this.transform.scaleZ}set rotationX(i){this.transform.rotationX=i}get rotationX(){return this.transform.rotationX}set rotationY(i){this.transform.rotationY=i}get rotationY(){return this.transform.rotationY}set rotationZ(i){this.transform.rotationZ=i}get rotationZ(){return this.transform.rotationZ}fixedUpdate(){}lateUpdate(){}traverse(i){i(this);for(let e=0,t=this.entityChildren.length;e<t;e++){let r=this.entityChildren[e];r instanceof te&&r.traverse(i)}}destroy(i){this.transform.eventDispatcher.removeEventListener(Oe.LOCAL_ONCHANGE,this.onTransformLocalChange,this),super.destroy(i)}};te=Fd([kd],te);function kd(i,e){return class extends te{set active(t){this.transform.enable=t>0}get active(){return this.transform.enable?1:0}get materialColor(){var t;let r=this.getComponent(ce);return(t=r?.material)==null?void 0:t.defaultPass.baseColor}set materialColor(t){var r;let s=(r=this.getComponent(ce))==null?void 0:r.material;s&&(s.defaultPass.baseColor=t)}notifyMaterialColorChange(t,r){var s;let a=this.getComponent(ce).materials;(s=a?.[t])==null||s.defaultPass.uniforms[r].onChange()}}}class Ne{static createCamera3DObject(e,t){return this.createCamera3D(null,e,t)}static createCamera3D(e,t,r){return e||(e=new te),t&&t.addChild(e),r&&(e.name=r),e.getOrAddComponent(Zi)}static UnProjection(e,t,r=1,s){let a=new g(e,t,0),n=1,l=g.HELP_0,h=S.canvas.offsetLeft,u=S.canvas.offsetTop,c=S.canvas.clientWidth,f=S.canvas.clientHeight;l.x=((a.x-h)*n/c-.5)*2,l.y=-((a.y-u)*n/f-.5)*2,l.z=r;let d=new g(0,0,0),p=V.helpMatrix2;p.copyFrom(s.projectionMatrix),p.invert();let m=V.helpMatrix;return m.identity(),m.multiply(p),m.multiply(s.transform.worldMatrix),m.perspectiveMultiplyPoint3(l,d),d}static Projection(e,t,r){let s=r||new g(0,0,0),a=V.helpMatrix;a.copyFrom(t.viewMatrix),a.multiply(t.projectionMatrix),a.perspectiveMultiplyPoint3(e,s);let n=S.canvas.clientWidth/2,l=S.canvas.clientHeight/2;return s.x=s.x*n+n,s.y=l-s.y*l,s}static UnProjection2(e,t,r,s,a){let n=a||new g(0,0,0),l=V.helpMatrix;l.copyFrom(s.pvMatrixInv);let h=S.canvas.clientWidth/2,u=S.canvas.clientHeight/2;return n.x=(e-h)/h,n.y=(u-t)/u,n.z=r,l.perspectiveMultiplyPoint3(n,n),n}}const ao=class{static init(){this.directionLightList=new Map,this.pointLightList=new Map,this.shadowBuffer=new Map,this.shadowLights=new Map}static createBuffer(i){if(!this.shadowBuffer.has(i)){let e=new ge(20);e.visibility=GPUShaderStage.FRAGMENT,this.shadowBuffer.set(i,e),e.setInt32("nDirShadowStart",0),e.setInt32("nDirShadowEnd",1),e.setInt32("nPointShadowStart",0),e.setInt32("nPointShadowEnd",0);let t=new Uint32Array(16);this.shadowLights.set(i,t),e.setUint32Array("shadowLights",t),e.apply()}}static getShadowLightList(i){if(!i.transform.view3D)return null;if(i.lightData.lightType==Qe.DirectionLight){let e=this.directionLightList.get(i.transform.view3D.scene);return e||(e=[],this.directionLightList.set(i.transform.view3D.scene,e)),e}else if(i.lightData.lightType==Qe.PointLight){let e=this.pointLightList.get(i.transform.view3D.scene);return e||(e=[],this.pointLightList.set(i.transform.view3D.scene,e)),e}else if(i.lightData.lightType==Qe.SpotLight){let e=this.pointLightList.get(i.transform.view3D.scene);return e||(e=[],this.pointLightList.set(i.transform.view3D.scene,e)),e}}static getShadowLightWhichScene(i,e){if(e==Qe.DirectionLight){let t=this.directionLightList.get(i);return t||(t=[],this.directionLightList.set(i,t)),t}else if(e==Qe.PointLight){let t=this.pointLightList.get(i);return t||(t=[],this.pointLightList.set(i,t)),t}}static getDirectShadowLightWhichScene(i){let e=this.directionLightList.get(i);return e||(e=[],this.directionLightList.set(i,e)),e}static getPointShadowLightWhichScene(i){let e=this.pointLightList.get(i);return e||(e=[],this.pointLightList.set(i,e)),e}static addShadowLight(i){if(!i.transform.view3D)return null;let e=i.transform.view3D.scene;if(i.lightData.lightType==Qe.DirectionLight){let t=this.directionLightList.get(e);if(t||(t=[],this.directionLightList.set(e,t)),!i.shadowCamera){i.shadowCamera=Ne.createCamera3DObject(null,"shadowCamera"),i.shadowCamera.isShadowCamera=!0;let r=-1e3;i.shadowCamera.orthoOffCenter(r,-r,r,-r,1,1e4)}return t.indexOf(i)==-1&&t.push(i),t}else if(i.lightData.lightType==Qe.PointLight||i.lightData.lightType==Qe.SpotLight){let t=this.pointLightList.get(e);return t&&t.length>=8||(t||(t=[],this.pointLightList.set(e,t)),t.indexOf(i)==-1&&t.push(i)),t}}static removeShadowLight(i){if(i.lightData.castShadowIndex=-1,!i.transform.view3D)return null;if(i.lightData.lightType==Qe.DirectionLight){let e=this.directionLightList.get(i.transform.view3D.scene);if(e){let t=e.indexOf(i);t!=-1&&e.splice(t,1)}return i.lightData.castShadowIndex=-1,e}else if(i.lightData.lightType==Qe.PointLight||i.lightData.lightType==Qe.SpotLight){let e=this.pointLightList.get(i.transform.view3D.scene);if(e){let t=e.indexOf(i);t!=-1&&e.splice(t,1)}return i.lightData.castShadowIndex=-1,e}}static update(i){let e=this.shadowBuffer.get(i),t=this.shadowLights.get(i),r=ao.directionLightList.get(i),s=ao.pointLightList.get(i),a=0,n=0,l=0,h=0;if(t.fill(0),r){let u=0;for(let c=0;c<r.length;c++){const f=r[c];t[c]=f.lightData.index,f.lightData.castShadowIndex=u++}n=r.length}if(e.setInt32("nDirShadowStart",a),e.setInt32("nDirShadowEnd",n),s){l=n;let u=0;for(let c=l;c<s.length;c++){const f=s[c];t[c]=f.lightData.index,f.lightData.castShadowIndex=u++}h=l+s.length}e.setInt32("nPointShadowStart",l),e.setInt32("nPointShadowEnd",h),e.setUint32Array("shadowLights",t),e.apply()}};let Ve=ao;o(Ve,"maxNumDirectionShadow",8),o(Ve,"maxNumPointShadow",8),o(Ve,"directionLightList"),o(Ve,"pointLightList"),o(Ve,"shadowBuffer"),o(Ve,"shadowLights");class Hr{static getGlobalDataBindGroupLayout(){if(this._globalDataBindGroupLayout)return this._globalDataBindGroupLayout;let e=[];return e.push({binding:0,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,buffer:{type:"uniform"}}),e.push({binding:1,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}}),this._globalDataBindGroupLayout=S.device.createBindGroupLayout({entries:e}),this._globalDataBindGroupLayout}}o(Hr,"_globalDataBindGroupLayout");class Sl{constructor(e){o(this,"uuid"),o(this,"usage"),o(this,"globalBindGroup"),o(this,"uniformGPUBuffer"),o(this,"matrixBindGroup"),o(this,"uniformByteLength"),o(this,"matrixesByteLength"),o(this,"shadowMatrixRaw",new Float32Array(8*16)),o(this,"csmMatrixRaw",new Float32Array(lt.Cascades*16)),o(this,"csmShadowBias",new Float32Array(4)),this.uuid=Pt(),this.usage=GPUBufferUsage.UNIFORM|GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,this.uniformGPUBuffer=new Dt(32*4*4+3*4*4+8*16+lt.Cascades*16+4+4),this.uniformGPUBuffer.visibility=GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,this.matrixBindGroup=e,this.createBindGroup()}createBindGroup(){this.uniformByteLength=this.uniformGPUBuffer.memory.shareDataBuffer.byteLength,this.matrixesByteLength=V.blockBytes*V.maxCount,this.globalBindGroup=S.device.createBindGroup({label:"global_bindGroupLayout",layout:Hr.getGlobalDataBindGroupLayout(),entries:[{binding:0,resource:{buffer:this.uniformGPUBuffer.buffer,offset:0,size:this.uniformByteLength}},{binding:1,resource:{buffer:this.matrixBindGroup.matrixBufferDst.buffer,offset:0,size:this.matrixesByteLength}}]})}setCamera(e){this.uniformGPUBuffer.setMatrix("_projectionMatrix",e.projectionMatrix),this.uniformGPUBuffer.setMatrix("_viewMatrix",e.viewMatrix),this.uniformGPUBuffer.setMatrix("_cameraWorldMatrix",e.transform.worldMatrix),this.uniformGPUBuffer.setMatrix("pvMatrixInv",e.projectionMatrixInv);let t=Ve.getDirectShadowLightWhichScene(e.transform.scene3D);this.csmShadowBias.fill(1e-4),this.shadowMatrixRaw.fill(0),this.csmMatrixRaw.fill(0);for(let n=0;n<8;n++)if(n<t.length){let l=t[n].shadowCamera;this.shadowMatrixRaw.set(l.pvMatrix.rawData,n*16)}else this.shadowMatrixRaw.set(e.transform.worldMatrix.rawData,n*16);this.uniformGPUBuffer.setFloat32Array("shadowMatrix",this.shadowMatrixRaw);let r=A.setting.shadow.shadowSize;if(lt.Cascades>1&&e.enableCSM&&t[0])for(let n=0;n<lt.Cascades;n++){let l=e.csm.children[n].shadowCamera;this.csmMatrixRaw.set(l.pvMatrix.rawData,n*16),this.csmShadowBias[n]=e.getCSMShadowBias(n,r)}this.uniformGPUBuffer.setFloat32Array("csmShadowBias",this.csmShadowBias),this.uniformGPUBuffer.setFloat32Array("csmMatrix",this.csmMatrixRaw),this.uniformGPUBuffer.setVector3("CameraPos",e.transform.worldPosition),this.uniformGPUBuffer.setFloat("frame",he.frame),this.uniformGPUBuffer.setFloat("time",he.frame),this.uniformGPUBuffer.setFloat("delta",he.delta),this.uniformGPUBuffer.setFloat("shadowBias",e.getShadowBias(r)),this.uniformGPUBuffer.setFloat("skyExposure",A.setting.sky.skyExposure),this.uniformGPUBuffer.setFloat("renderPassState",A.setting.render.renderPassState),this.uniformGPUBuffer.setFloat("quadScale",A.setting.render.quadScale),this.uniformGPUBuffer.setFloat("hdrExposure",A.setting.render.hdrExposure),this.uniformGPUBuffer.setInt32("renderState_left",A.setting.render.renderState_left),this.uniformGPUBuffer.setInt32("renderState_right",A.setting.render.renderState_right),this.uniformGPUBuffer.setFloat("renderState_split",A.setting.render.renderState_split);let s=A.inputSystem.mouseX*S.pixelRatio,a=A.inputSystem.mouseY*S.pixelRatio;this.uniformGPUBuffer.setFloat("mouseX",s),this.uniformGPUBuffer.setFloat("mouseY",a),this.uniformGPUBuffer.setFloat("windowWidth",S.windowWidth),this.uniformGPUBuffer.setFloat("windowHeight",S.windowHeight),this.uniformGPUBuffer.setFloat("near",e.near),this.uniformGPUBuffer.setFloat("far",e.far),this.uniformGPUBuffer.setFloat("pointShadowBias",A.setting.shadow.pointShadowBias),this.uniformGPUBuffer.setFloat("shadowMapSize",r),this.uniformGPUBuffer.setFloat("shadowSoft",A.setting.shadow.shadowSoft),this.uniformGPUBuffer.setFloat("enableCSM",e.enableCSM?1:0),this.uniformGPUBuffer.setFloat("csmMargin",A.setting.shadow.csmMargin),this.uniformGPUBuffer.apply()}setShadowCamera(e){this.uniformGPUBuffer.setMatrix("_projectionMatrix",e.projectionMatrix),this.uniformGPUBuffer.setMatrix("_viewMatrix",e.viewMatrix),this.uniformGPUBuffer.setMatrix("_pvMatrix",e.pvMatrix),this.uniformGPUBuffer.setMatrix("pvMatrixInv",e.projectionMatrixInv),this.csmShadowBias.fill(1e-4),this.shadowMatrixRaw.fill(0),this.csmMatrixRaw.fill(0),this.uniformGPUBuffer.setFloat32Array("shadowCamera",this.shadowMatrixRaw),this.uniformGPUBuffer.setFloat32Array("csmShadowBias",this.csmShadowBias),this.uniformGPUBuffer.setFloat32Array("csmMatrix",this.csmMatrixRaw),this.uniformGPUBuffer.setVector3("CameraPos",e.transform.worldPosition),this.uniformGPUBuffer.setFloat("frame",he.frame),this.uniformGPUBuffer.setFloat("time",he.frame),this.uniformGPUBuffer.setFloat("delta",he.delta),this.uniformGPUBuffer.setFloat("shadowBias",1e-4),this.uniformGPUBuffer.setFloat("skyExposure",A.setting.sky.skyExposure),this.uniformGPUBuffer.setFloat("renderPassState",A.setting.render.renderPassState),this.uniformGPUBuffer.setFloat("quadScale",A.setting.render.quadScale),this.uniformGPUBuffer.setFloat("hdrExposure",A.setting.render.hdrExposure),this.uniformGPUBuffer.setInt32("renderState_left",A.setting.render.renderState_left),this.uniformGPUBuffer.setInt32("renderState_right",A.setting.render.renderState_right),this.uniformGPUBuffer.setFloat("renderState_split",A.setting.render.renderState_split);let t=A.inputSystem.mouseX*S.pixelRatio,r=A.inputSystem.mouseY*S.pixelRatio;this.uniformGPUBuffer.setFloat("mouseX",t),this.uniformGPUBuffer.setFloat("mouseY",r),this.uniformGPUBuffer.setFloat("windowWidth",S.windowWidth),this.uniformGPUBuffer.setFloat("windowHeight",S.windowHeight),this.uniformGPUBuffer.setFloat("near",e.near),this.uniformGPUBuffer.setFloat("far",e.far),this.uniformGPUBuffer.setFloat("pointShadowBias",A.setting.shadow.pointShadowBias),this.uniformGPUBuffer.setFloat("shadowMapSize",A.setting.shadow.shadowSize),this.uniformGPUBuffer.setFloat("shadowSoft",A.setting.shadow.shadowSoft),this.uniformGPUBuffer.setFloat("enableCSM",0),this.uniformGPUBuffer.setFloat("csmMargin",A.setting.shadow.csmMargin),this.uniformGPUBuffer.apply()}addUniformNode(){}}const $i=class{constructor(i,e=0,t=null,r=0){o(this,"entities"),o(this,"box"),o(this,"subTrees",[]),o(this,"parent"),o(this,"level"),o(this,"index"),o(this,"uuid"),o(this,"__rayCastTempVector",new g),this.parent=t,this.box=i.clone(),this.level=r,this.index=e,this.uuid=r+"_"+e,this.entities=new Map}tryInsertEntity(i){let e=i.renderer.object3D.bound;if(this.level==0||this.box.containsBox(e)){this.subTrees.length==0&&this.level<$i.maxSplitLevel&&this.splitTree();let t;if(this.subTrees.length>0){for(let r of this.subTrees)if(r.tryInsertEntity(i)){t=!0;break}}return t||i.enterNode(this),!0}return!1}splitTree(){if(this.subTrees.length==0){const i=$i._v1,e=this.box.extents.clone();let t=this.level+1,r=0;for(let s=0;s<2;s++)for(let a=0;a<2;a++)for(let n=0;n<2;n++){const l=new Be;this.box.min.add(i.set(s,a,n).multiply(e),l.min),l.min.add(e,l.max),l.setFromMinMax(l.min,l.max);let h=new $i(l,r++,this,t);this.subTrees.push(h)}}}rayCasts(i,e){if(this.level==0||i.intersectBox(this.box,this.__rayCastTempVector)){this.entities.size>0&&e.push(...this.entities.values());for(let t of this.subTrees)t.rayCasts(i,e);return!0}return!1}frustumCasts(i,e){if(this.level==0||i.containsBox2(this.box)>0){if(this.entities.size>0)for(const t of this.entities.values())(this.level>$i.autoSplitLevel||i.containsBox2(t.renderer.object3D.bound)>0)&&e.push(t);for(let t of this.subTrees)t.frustumCasts(i,e);return!0}return!1}getRenderNode(i,e){if(this.level==0||i.containsBox2(this.box)>0){if(this.entities.size>0)for(const t of this.entities.values())(this.level>$i.autoSplitLevel||i.containsBox2(t.renderer.object3D.bound)>0)&&(t.renderer.renderOrder<3e3?e.opaqueList.push(t.renderer):t.renderer.renderOrder>=3e3&&e.transparentList.push(t.renderer));for(let t of this.subTrees)t.getRenderNode(i,e);return!0}return!1}boxCasts(i,e){if(i.intersectsBox(this.box)){this.entities.size>0&&e.push(...this.entities.values());for(let t of this.subTrees)t.boxCasts(i,e);return!0}return!1}clean(){for(let i of this.entities.values())i.leaveNode();return this.entities.clear(),this}};let er=$i;o(er,"_v1",new g),o(er,"_v2",new g),o(er,"maxSplitLevel",6),o(er,"autoSplitLevel",3);class Il{constructor(){o(this,"_pool",[]),o(this,"_worldPosition",new g),o(this,"_viewPosition",new g),o(this,"_zSortList",[])}pop(){return this._pool.pop()||{}}recycle(){for(let e of this._zSortList)e.z=0,e.userData=null,e.obj3d=null,this._pool.push(e);this._zSortList.length=0}sort(e,t,r,s){this._zSortList=[];for(let a of t){let n=this.pop();n.userData=a,n.obj3d=r(a),n.z=this.worldToCameraDepth(n.obj3d,e),this._zSortList.push(n)}this._zSortList.sort((a,n)=>a.z-n.z>0?1:-1),s||(s=[]);for(let a of this._zSortList)s.push(a.userData);return this.recycle(),s}worldToCameraDepth(e,t){t||(t=e.transform.view3D.camera);let r=0;return t&&(this._worldPosition.copyFrom(e.transform.worldPosition),t.worldToScreenPoint(this._worldPosition,this._viewPosition),r=this._viewPosition.z),r}}let El=new Il;var Yr=(i=>(i[i.None=2]="None",i[i.StaticBatch=4]="StaticBatch",i[i.DynamicBatch=8]="DynamicBatch",i))(Yr||{});class oo{static addMask(e,t){return e|t}static removeMask(e,t){return e&~t}static hasMask(e,t){return(e&t)!=0}}function zd(i,e){let t=i.__NonSerialize__;t||(t=i.__NonSerialize__={},t.__NonSerialize__=!0),t[e]=!0}function Gd(i,e){let t;for(;i&&(i=i.__proto__,i&&(t=i.__NonSerialize__),!t););return t&&t[e]}function Vt(i,e,t,r,s){let a=i.__EditorInspector__;a||(a=i.__EditorInspector__=new Map);let n=a.get(i.constructor.name);n||(n=new Map,a.set(i.constructor.name,n)),n.set(e,{p1:t,p2:r,p3:s})}function Qd(i){let e,t=i,r=[];for(;t;){if(r.indexOf(t.constructor.name)!=-1){t=t.__proto__;continue}r.push(t.constructor.name),t=t.__proto__}for(r=r.reverse(),t=i;t&&(t=t.__proto__,t&&(e=t.__EditorInspector__),!e););let s=new Map;if(e)for(let a=0;a<r.length;a++){const n=r[a];let l=e.get(n);l&&l.forEach((h,u)=>{s.set(u,h)})}return s}function Vd(i,e,t,r,s){let a=window.__Component__;a||(a=window.__Component__={}),a[i.name]=i}var re=(i=>(i[i.COLOR=1]="COLOR",i[i.NORMAL=2]="NORMAL",i[i.POSITION=4]="POSITION",i[i.GRAPHIC=8]="GRAPHIC",i[i.GI=16]="GI",i[i.Cluster=32]="Cluster",i[i.SHADOW=64]="SHADOW",i[i.POINT_SHADOW=128]="POINT_SHADOW",i[i.POST=256]="POST",i[i.DEPTH=512]="DEPTH",i[i.REFLECTION=1024]="REFLECTION",i))(re||{});class le{}o(le,"GLTF_NODE_INDEX_PROPERTY"),o(le,"BASE_COLOR_UNIFORM","u_baseColorFactor"),o(le,"BASE_COLOR_TEXTURE_UNIFORM","u_baseColorSampler"),o(le,"METALROUGHNESS_UNIFORM","u_metallicRoughnessValues"),o(le,"METALROUGHNESS_TEXTURE_UNIFORM","u_metallicRoughnessSampler"),o(le,"NORMAL_TEXTURE_UNIFORM","u_normalSampler"),o(le,"NORMAL_SCALE_UNIFORM","u_normalScale"),o(le,"EMISSIVE_TEXTURE_UNIFORM","u_emissiveSampler"),o(le,"EMISSIVE_FACTOR_UNIFORM","u_emissiveFactor"),o(le,"OCCLUSION_TEXTURE_UNIFORM","u_occlusionSampler"),o(le,"OCCLUSION_FACTOR_UNIFORM","u_occlusionFactor"),o(le,"MAX_MORPH_TARGETS",8),o(le,"MORPH_POSITION_PREFIX","a_morphPositions_"),o(le,"MORPH_NORMAL_PREFIX","a_morphNormals_"),o(le,"MORPH_TANGENT_PREFIX","a_morphTangents_"),o(le,"MORPH_WEIGHT_UNIFORM","u_morphWeights"),o(le,"SCENE_ROOT_SKELETON","SCENE_ROOT"),o(le,"IDENTITY_INVERSE_BIND_MATRICES","IDENTITY_IBM"),o(le,"JOINT_MATRICES_UNIFORM","u_jointMatrix"),o(le,"ALPHA_CUTOFF_UNIFORM","u_alphaCutoff");class Xr{static createGIPass(e,t){if(Tt.hasMask(e.rendererMask,Ue.Sky)){let r=t.getPass(re.COLOR)[0],s=new Bf;s.setTexture("baseMap",r.getTexture("baseMap")),s.cullMode=r.cullMode,s.frontFace=r.frontFace,t.addPass(re.GI,s,0),s.preCompile(e.geometry)}else this.castGBufferPass(e,t)}static castGBufferPass(e,t){let r=t.getPass(re.COLOR);for(let s=0;s<r.length;s++){const a=r[s];let n=t.getPass(re.GI);if(!n||n.length<s){let l=new Ef;l.setTexture("baseMap",a.getTexture("baseMap")),l.setTexture("normalMap",a.getTexture("normalMap")),l.setTexture("emissiveMap",a.getTexture("emissiveMap")),l.setUniform("baseColor",a.getUniform("baseColor")),l.setUniform("envIntensity",a.getUniform("envIntensity")),l.setUniform("emissiveColor",a.getUniform("emissiveColor")),l.setUniform("emissiveIntensity",a.getUniform("emissiveIntensity")),l.setUniform("alphaCutoff",a.getUniform("alphaCutoff")),l.cullMode=a.cullMode,l.frontFace=a.frontFace,l.preCompile(e.geometry),t.addPass(re.GI,l)}}}static createShadowPass(e,t){let r=Tt.hasMask(e.rendererMask,Ue.SkinnedMesh),s=e.geometry.hasAttribute("TANGENT"),a=e.geometry.hasAttribute(le.MORPH_POSITION_PREFIX+"0"),n=e.geometry.hasAttribute(le.MORPH_NORMAL_PREFIX+"0"),l=t.getPass(re.COLOR);for(let h=0;h<l.length;h++){const u=l[h];let c=t.getPass(re.SHADOW);if(!c||c.length<h){let d=new Sf;d.setTexture("baseMap",u.getTexture("baseMap")),d.setUniform("alphaCutoff",u.getUniform("alphaCutoff")),s&&d.setDefine("USE_TANGENT",s),r&&d.setDefine("USE_SKELETON",r),a&&d.setDefine("USE_MORPHTARGETS",a),n&&d.setDefine("USE_MORPHNORMALS",n),u.cullMode=="none"?d.shaderState.cullMode="none":u.cullMode=="back"?d.shaderState.cullMode="front":u.cullMode=="front"&&(d.shaderState.cullMode="back"),d.preCompile(e.geometry),t.addPass(re.SHADOW,d)}if(!t.getPass(re.POINT_SHADOW)){let d=new bf;d.setTexture("baseMap",u.getTexture("baseMap")),d.setUniform("alphaCutoff",u.getUniform("alphaCutoff")),d.setDefine("USE_ALPHACUT",1);for(let p=0;p<1;p++)s&&d.setDefine("USE_TANGENT",s),r&&d.setDefine("USE_SKELETON",r),a&&d.setDefine("USE_MORPHTARGETS",a),n&&d.setDefine("USE_MORPHNORMALS",n),d.shaderState.cullMode="front",d.preCompile(e.geometry);t.addPass(re.POINT_SHADOW,d)}}}static createReflectionPass(e,t){}static createDepthPass(e,t){let r=t.getPass(re.COLOR),s=e.geometry.hasAttribute("TANGENT"),a=e.geometry.hasAttribute(le.MORPH_POSITION_PREFIX+"0"),n=e.geometry.hasAttribute(le.MORPH_NORMAL_PREFIX+"0"),l=Tt.hasMask(e.rendererMask,Ue.SkinnedMesh);for(let h=0;h<r.length;h++){const u=r[h];let c=t.getPass(re.DEPTH);if(!c&&u.shaderState.useZ&&(!c||c.length<h)){let f=new If;f.setTexture("baseMap",u.getTexture("baseMap")),s||f.setDefine("USE_TANGENT",s),l&&f.setDefine("USE_SKELETON",l),a&&f.setDefine("USE_MORPHTARGETS",a),n&&f.setDefine("USE_MORPHNORMALS",n),f.cullMode=u.cullMode,f.frontFace=u.frontFace,f.preCompile(e.geometry),t.addPass(re.DEPTH,f)}}}}const Bl=class{constructor(){o(this,"reference")}static getInstance(){return this._ins||(this._ins=new Bl),this._ins}attached(i,e){this.reference||(this.reference=new Map);let t=this.reference.get(i);t||(t=new Map),t.set(e,i),this.reference.set(i,t)}detached(i,e){let t=this.reference.get(i);t&&t.delete(e)}hasReference(i){let e=this.reference.get(i);return e?e.size>0:!1}getReferenceCount(i){let e=this.reference.get(i);return e?e.size:0}getReference(i){let e=this.reference.get(i);return e||null}};let se=Bl;o(se,"_ins");const fi=class{static getMipmapPipeline(i){let e=i.format,t=S.device,r=fi.pipelineCache[i.format],s;if(!r){s=t.createShaderModule({code:fi.mipmapShader});let a=t.createBindGroupLayout({entries:[{binding:0,visibility:i.visibility,sampler:i.samplerBindingLayout},{binding:1,visibility:i.visibility,texture:i.textureBindingLayout}]}),n=S.device.createPipelineLayout({bindGroupLayouts:[a]});r=w.createPipeline({layout:n,vertex:{module:s,entryPoint:"vertexMain"},fragment:{module:s,entryPoint:"fragmentMain",targets:[{format:e}]}}),fi.pipelineCache[e]=r}return r}static webGPUGenerateMipmap(i){let e=S.device,t=i.textureDescriptor;if(!fi.pipeline){const n=e.createShaderModule({code:`
        var<private> pos : array<vec2<f32>, 4> = array<vec2<f32>, 4>(
          vec2<f32>(-1.0, 1.0), vec2<f32>(1.0, 1.0),
          vec2<f32>(-1.0, -1.0), vec2<f32>(1.0, -1.0));

        struct VertexOutput {
          @builtin(position) position : vec4<f32>,
          @location(0) texCoord : vec2<f32>
        };

        @vertex
        fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
          var output : VertexOutput;
          output.texCoord = pos[vertexIndex] * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5);
          output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);
          return output;
        }

        @binding(0) @group(0) var imgSampler : sampler;
        @binding(1) @group(0) var img : texture_2d<f32>;

        @fragment
        fn fragmentMain(@location(0) texCoord : vec2<f32>) -> @location(0) vec4<f32> {
          var outColor: vec4<f32> = textureSample(img, imgSampler, texCoord);
          return outColor;
        }
      `});fi.pipeline=e.createRenderPipeline({layout:"auto",vertex:{module:n,entryPoint:"vertexMain"},fragment:{module:n,entryPoint:"fragmentMain",targets:[{format:t.format}]},primitive:{topology:"triangle-strip",stripIndexFormat:"uint32"}})}let r;i.format=="rgba16float"?r=e.createSampler({minFilter:"nearest",magFilter:"linear"}):r=e.createSampler({minFilter:"linear",magFilter:"linear"});let s=i.getGPUTexture().createView({baseMipLevel:0,mipLevelCount:1});const a=w.beginCommandEncoder();for(let n=1;n<t.mipLevelCount;++n){const l=i.getGPUTexture().createView({baseMipLevel:n,mipLevelCount:1}),h=a.beginRenderPass({colorAttachments:[{view:l,clearValue:[0,0,0,0],loadOp:"clear",storeOp:"store"}]}),u=e.createBindGroup({layout:fi.pipeline.getBindGroupLayout(0),entries:[{binding:0,resource:r},{binding:1,resource:s}]});h.setPipeline(fi.pipeline),h.setBindGroup(0,u),h.draw(4),h.end(),s=l}w.endCommandEncoder(a)}};let Ht=fi;o(Ht,"mipmapShader",`
    var<private> pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(
        vec2<f32>(-1.0, -1.0), vec2<f32>(-1.0, 3.0), vec2<f32>(3.0, -1.0));
      struct VertexOutput {
        @builtin(position) position : vec4<f32>;
        @location(0) texCoord : vec2<f32>;
      };
      @vertex
      fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
        var output : VertexOutput;
        output.texCoord = pos[vertexIndex] * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5);
        output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);
        return output;
      }
      @binding(0) @group(0) var imgSampler : sampler;
      @binding(1) @group(0) var img : texture_2d<f32>;
      @fragment
      fn fragmentMain(@location(0) texCoord : vec2<f32>) -> @location(0) vec4<f32> {
        var outColor: vec4<f32> = textureSample(img, imgSampler, texCoord);
        return outColor ;
      }`),o(Ht,"pipelineCache",{}),o(Ht,"pipeline");class at{constructor(e=32,t=32,r=1){o(this,"name"),o(this,"url"),o(this,"gpuTexture"),o(this,"pid"),o(this,"view"),o(this,"gpuSampler"),o(this,"gpuSampler_comparison"),o(this,"format"),o(this,"usage"),o(this,"width",4),o(this,"height",4),o(this,"depthOrArrayLayers",1),o(this,"numberLayer",1),o(this,"viewDescriptor"),o(this,"textureDescriptor"),o(this,"visibility",GPUShaderStage.COMPUTE|GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT),o(this,"textureBindingLayout",{viewDimension:"2d",multisampled:!1}),o(this,"samplerBindingLayout",{type:"filtering"}),o(this,"sampler_comparisonBindingLayout",{type:"comparison"}),o(this,"flipY"),o(this,"isVideoTexture"),o(this,"isHDRTexture"),o(this,"_useMipmap",!1),o(this,"_sourceImageData"),o(this,"_addressModeU"),o(this,"_addressModeV"),o(this,"_addressModeW"),o(this,"_magFilter"),o(this,"_minFilter"),o(this,"_mipmapFilter"),o(this,"_lodMinClamp"),o(this,"_lodMaxClamp"),o(this,"_compare"),o(this,"_maxAnisotropy"),o(this,"mipmapCount",1),o(this,"_textureChange",!1),o(this,"_stateChangeRef",new Map),this.width=e,this.height=t,this.numberLayer=r,this.minFilter="linear",this.magFilter="linear",this.mipmapFilter="linear",this.addressModeU=Bt.repeat,this.addressModeV=Bt.repeat}init(){let e=this;return e.internalCreateBindingLayoutDesc&&e.internalCreateBindingLayoutDesc(),e.internalCreateTexture&&e.internalCreateTexture(),e.internalCreateView&&e.internalCreateView(),e.internalCreateSampler&&e.internalCreateSampler(),this}createTextureDescriptor(e,t,r,s,a=GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.STORAGE_BINDING,n=1,l=0){this.width=e,this.height=t,this.format=s,this.usage=a,this.textureDescriptor={size:[e,t,n],mipLevelCount:r,format:s,usage:a,label:`${this.name+this.width+this.height+this.format}`},l>0&&(this.textureDescriptor.sampleCount=l),n>1?this.viewDescriptor={dimension:"2d-array"}:this.viewDescriptor={dimension:this.textureBindingLayout.viewDimension}}generate(e){let t=32,r=32;"width"in e&&(t=e.width,r=e.height),(t<32||r<32)&&console.log(e.name+"Size must be greater than 32!"),this.width=t,this.height=r,this.createTexture(e)}createTexture(e){this._sourceImageData=e,this.updateTextureDescription(),this.updateGPUTexture();let t=S.device;this.gpuTexture instanceof GPUTexture&&t.queue.copyExternalImageToTexture({source:this._sourceImageData},{texture:this.gpuTexture},[this.width,this.height]),this.useMipmap&&Ht.webGPUGenerateMipmap(this)}get useMipmap(){return this._useMipmap}set useMipmap(e){if(e){if(this.samplerBindingLayout.type="filtering",this._useMipmap==!1&&this._sourceImageData){this._useMipmap=!0,this.updateTextureDescription(),this.updateGPUTexture();let t=S.device;this.gpuTexture instanceof GPUTexture&&t.queue.copyExternalImageToTexture({source:this._sourceImageData},{texture:this.gpuTexture},[this.width,this.height]),Ht.webGPUGenerateMipmap(this)}}else if(this.samplerBindingLayout.type="non-filtering",this._useMipmap==!0&&this._sourceImageData){this._useMipmap=!1,this.updateTextureDescription(),this.updateGPUTexture();let t=S.device;this.gpuTexture instanceof GPUTexture&&t.queue.copyExternalImageToTexture({source:this._sourceImageData},{texture:this.gpuTexture},[this.width,this.height])}this._textureChange=!0,this._useMipmap=e,this.noticeChange()}get sourceImageData(){return this._sourceImageData}updateTextureDescription(){this.mipmapCount=Math.floor(this.useMipmap?Math.log2(Math.min(this.width,this.height)):1),this.createTextureDescriptor(this.width,this.height,this.mipmapCount,this.format)}updateGPUTexture(){this.gpuTexture&&this.gpuTexture instanceof GPUTexture&&this.gpuTexture.destroy(),this.gpuTexture=null,this.view=null,this.gpuTexture=this.getGPUTexture()}getGPUTexture(){return this.gpuTexture||(this.gpuTexture=S.device.createTexture(this.textureDescriptor)),this.gpuTexture}getGPUView(e=0){return this.view||(this.gpuTexture=this.getGPUTexture(),this.gpuTexture instanceof GPUTexture&&(this.view=this.gpuTexture.createView(this.viewDescriptor),this.view.label=this.name)),this.view}bindStateChange(e,t){this._stateChangeRef.set(t,e)}unBindStateChange(e){this._stateChangeRef.delete(e)}noticeChange(){this.gpuSampler=S.device.createSampler(this),this._stateChangeRef.forEach((e,t)=>{e()})}destroy(e){e&&this.gpuTexture instanceof GPUTexture&&(this.gpuSampler=null,this.gpuSampler_comparison=null,this.textureBindingLayout=null,this.textureDescriptor=null,this.gpuTexture.destroy(),this.gpuTexture=null),this._stateChangeRef.clear()}get addressModeU(){return this._addressModeU}set addressModeU(e){this._addressModeU!=e&&(this._addressModeU=e,this.noticeChange())}get addressModeV(){return this._addressModeV}set addressModeV(e){this._addressModeV!=e&&(this._addressModeV=e,this.noticeChange())}get addressModeW(){return this._addressModeW}set addressModeW(e){this._addressModeW!=e&&(this._addressModeW=e,this.noticeChange())}get magFilter(){return this._magFilter}set magFilter(e){this._magFilter!=e&&(this._magFilter=e,this.noticeChange())}get minFilter(){return this._minFilter}set minFilter(e){this._minFilter!=e&&(this._minFilter=e,this.noticeChange())}get mipmapFilter(){return this._mipmapFilter}set mipmapFilter(e){this._mipmapFilter!=e&&(this._mipmapFilter=e,this.noticeChange())}get lodMinClamp(){return this._lodMinClamp}set lodMinClamp(e){this._lodMinClamp!=e&&(this._lodMinClamp=e,this.noticeChange())}get lodMaxClamp(){return this._lodMaxClamp}set lodMaxClamp(e){this._lodMaxClamp!=e&&(this._lodMaxClamp=e,this.noticeChange())}get compare(){return this._compare}set compare(e){this._compare!=e&&(this._compare=e,this.noticeChange())}get maxAnisotropy(){return this._maxAnisotropy}set maxAnisotropy(e){this._maxAnisotropy!=e&&(this._maxAnisotropy=e,this.noticeChange())}}class Tl extends at{constructor(e,t,r){super(e,t,r),o(this,"_bitmapTextures"),this.format=G.rgba8unorm,this.mipmapCount=1,this._bitmapTextures=[],this.init()}setTextures(e){this._bitmapTextures.length=0;for(let t=0;t<e.length;t++){const r=e[t];this.addTexture(r)}}addTexture(e){(e.width!=this.width||e.height!=this.height)&&console.error("bitmap texture muse match bitmapTextureArray size!"),this._bitmapTextures.indexOf(e)==-1&&(e.pid=this._bitmapTextures.length,this._bitmapTextures.push(e),this.updateTexture())}removeTexture(e){let t=this._bitmapTextures.indexOf(e);if(t!=-1){this._bitmapTextures.splice(t,1);for(let r=0;r<this._bitmapTextures.length;r++){const s=this._bitmapTextures[r];s.pid=r}}}updateTexture(){let e=w.beginCommandEncoder();for(let t=0;t<this._bitmapTextures.length;t++){let r=this._bitmapTextures[t];e.copyTextureToTexture({texture:r.getGPUTexture(),mipLevel:0,origin:{x:0,y:0,z:0}},{texture:this.getGPUTexture(),mipLevel:0,origin:{x:0,y:0,z:t}},{width:this.width,height:this.height,depthOrArrayLayers:1})}w.endCommandEncoder(e)}internalCreateBindingLayoutDesc(){this.textureBindingLayout.viewDimension="2d-array",this.samplerBindingLayout.type="filtering",this.minFilter=Nr.linear,this.magFilter=Nr.linear}internalCreateTexture(){this.textureDescriptor={format:this.format,size:{width:this.width,height:this.height,depthOrArrayLayers:this.numberLayer},dimension:"2d",usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING},this.gpuTexture=S.device.createTexture(this.textureDescriptor)}internalCreateView(){this.viewDescriptor={dimension:"2d-array"},this.view=this.gpuTexture.createView(this.viewDescriptor)}internalCreateSampler(){this.gpuSampler=S.device.createSampler(this)}}const Ei=class{constructor(){o(this,"_iesTexture"),o(this,"index",0)}generateIES(i){}set IESTexture(i){this._iesTexture=i,i.addressModeU=Bt.repeat,i.addressModeV=Bt.repeat,i.addressModeW=Bt.repeat,Ei.ies_list.indexOf(this)==-1&&(this.index=Ei.ies_list.length,Ei.ies_list.push(this),Ei.iesTexture||Ei.create(i.width,i.height),Ei.iesTexture.addTexture(i))}get IESTexture(){return this._iesTexture}static create(i,e){let t=48;this.iesTexture=new Tl(i,e,t)}};let Bi=Ei;o(Bi,"use",!1),o(Bi,"iesTexture"),o(Bi,"ies_list",[]);class Ml{constructor(e){o(this,"renderer"),o(this,"owner"),o(this,"uuid"),this.renderer=e,this.uuid=e.object3D.instanceID}leaveNode(){this.owner&&(this.owner.entities.delete(this.uuid),this.owner=null)}enterNode(e){this.owner&&this.leaveNode(),this.owner=e,e.entities.set(this.uuid,this)}update(e){var t;return((t=this.owner)==null?void 0:t.tryInsertEntity(this))||(this.leaveNode(),e.tryInsertEntity(this)),this.owner}}var Hd=Object.defineProperty,Yd=Object.getOwnPropertyDescriptor,Wr=(i,e,t,r)=>{for(var s=r>1?void 0:r?Yd(e,t):e,a=i.length-1,n;a>=0;a--)(n=i[a])&&(s=(r?n(e,t,s):n(s))||s);return r&&s&&Hd(e,t,s),s};class $t extends Ee{constructor(){super(...arguments),o(this,"instanceCount",0),o(this,"lodLevel",0),o(this,"alwaysRender",!1),o(this,"instanceID"),o(this,"drawType",0),o(this,"_geometry"),o(this,"_materials",[]),o(this,"_castShadow",!0),o(this,"_castReflection",!1),o(this,"_castGI",!1),o(this,"_rendererMask",Ue.Default),o(this,"_inRenderer",!1),o(this,"_readyPipeline",!1),o(this,"_combineShaderRefection"),o(this,"_ignoreEnvMap"),o(this,"_ignorePrefilterMap"),o(this,"__renderOrder",0),o(this,"_renderOrder",0),o(this,"isRenderOrderChange"),o(this,"needSortOnCameraZ"),o(this,"_octreeBinder"),o(this,"preInit",!1),o(this,"_renderLayer",Yr.None)}init(){this.renderOrder=0,this.rendererMask=Ue.Default,this.instanceID=qa().toString()}attachSceneOctree(e){this._octreeBinder={octree:e,entity:new Ml(this)},this.transform.eventDispatcher.addEventListener(Oe.LOCAL_ONCHANGE,this.updateOctreeEntity,this)}detachSceneOctree(){var e;this._octreeBinder&&((e=this._octreeBinder.entity)==null||e.leaveNode(),this.transform.eventDispatcher.removeEventListener(Oe.LOCAL_ONCHANGE,this.updateOctreeEntity,this),this._octreeBinder=null)}updateOctreeEntity(e){var t,r;(r=(t=this._octreeBinder)==null?void 0:t.entity)==null||r.update(this._octreeBinder.octree)}copyComponent(e){return super.copyComponent(e),this.geometry=e._geometry,this.materials=e._materials.slice(),this.drawType=e.drawType,this.alwaysRender=e.alwaysRender,this.needSortOnCameraZ=e.needSortOnCameraZ,this.isRenderOrderChange=e.isRenderOrderChange,this.castShadow=e.castShadow,this.castGI=e.castGI,this.rendererMask=e.rendererMask,this}get renderLayer(){return this._renderLayer}set renderLayer(e){this._renderLayer=e}get geometry(){return this._geometry}set geometry(e){this._geometry!=e&&(this._geometry&&se.getInstance().detached(this._geometry,this),se.getInstance().attached(e,this)),this._geometry=e}addMask(e){this._rendererMask=Tt.addMask(this.rendererMask,e)}removeMask(e){this._rendererMask=Tt.removeMask(this.rendererMask,e)}hasMask(e){return Tt.hasMask(this.rendererMask,e)}get rendererMask(){return this._rendererMask}set rendererMask(e){this._rendererMask=e}get renderOrder(){return this._renderOrder}set renderOrder(e){e!=this._renderOrder&&(this.isRenderOrderChange=!0,this.__renderOrder=e),this._renderOrder=e}get materials(){return this._materials}set materials(e){this._readyPipeline=!1;for(let r=0;r<this._materials.length;r++){let s=this._materials[r];se.getInstance().detached(s,this)}for(let r=0;r<e.length;r++){let s=e[r];se.getInstance().attached(s,this)}this._materials=e;let t=0;for(let r=0;r<e.length;r++){const n=e[r].getPass(re.COLOR)[0];n.shaderState.transparent&&(t=t>n.renderOrder?t:n.renderOrder)}this.renderOrder=t,this._readyPipeline||this.initPipeline()}addRendererMask(e){this._rendererMask=Tt.addMask(this._rendererMask,e)}removeRendererMask(e){this._rendererMask=Tt.removeMask(this._rendererMask,e)}onEnable(){this._readyPipeline||this.initPipeline(),Q.instance.addRenderNode(this.transform.scene3D,this),this.updateOctreeEntity()}onDisable(){Q.instance.removeRenderNode(this.transform.scene3D,this)}selfCloneMaterials(e){let t=[];for(let r=0,s=this.materials.length;r<s;r++){const a=this.materials[r].clone();t.push(a)}return this.materials=t,this._readyPipeline=!1,this.initPipeline(),this}initPipeline(){if(this._geometry&&this._materials.length>0){for(let t=0;t<this._materials.length;t++){let s=this._materials[t].getPass(re.COLOR);for(let a=0;a<s.length;a++){const n=s[a];n.shaderReflection||n.preCompile(this._geometry),this._geometry.generate(n.shaderReflection)}this.object3D.bound=this._geometry.bounds.clone()}this._readyPipeline=!0;let e=0;for(let t=0;t<this.materials.length;t++){const a=this.materials[t].getPass(re.COLOR)[0];a.renderOrder>=3e3?e=e>a.renderOrder?e:a.renderOrder:e=Math.max(e-3e3,0),this.castNeedPass()}this.renderOrder=e,this.enable&&this.transform&&this.transform.scene3D&&Q.instance.addRenderNode(this.transform.scene3D,this)}}castNeedPass(){if(this.castGI)for(let t=0;t<this.materials.length;t++){const r=this.materials[t];Xr.createGIPass(this,r)}for(let t=0;t<this.materials.length;t++){const r=this.materials[t];r.castShadow&&Xr.createShadowPass(this,r)}if(this.castReflection)for(let t=0;t<this.materials.length;t++){const r=this.materials[t];r.castShadow&&Xr.createShadowPass(this,r)}if(!Tt.hasMask(this.rendererMask,Ue.IgnoreDepthPass)&&A.setting.render.zPrePass)for(let t=0;t<this.materials.length;t++){const r=this.materials[t];Xr.createDepthPass(this,r)}else for(let t=0;t<this.materials.length;t++)this.materials[t].removePass(re.DEPTH,0)}get castShadow(){return this._castShadow}set castShadow(e){this._castShadow=e}get castGI(){return this._castGI}set castGI(e){this._castGI=e}get castReflection(){return this._castReflection}set castReflection(e){this._castReflection=e}renderPass(e,t,r){let s=this,a=s.transform._worldMatrix;for(let n=0;n<s.materials.length;n++){const l=s.materials[n];if(!l||!l.enable)continue;let h=l.getPass(t);if(!(!h||h.length==0)){w.bindGeometryBuffer(r.encoder,s._geometry);for(let u=0;u<h.length;u++){if(!h||h.length==0)continue;const f=h[u];if(f.pipeline){f.shaderState.splitTexture&&(r.endRenderPass(),Fe.WriteSplitColorTexture(s.instanceID),r.beginRenderPass(),w.bindCamera(r.encoder,e.camera),w.bindGeometryBuffer(r.encoder,s._geometry)),w.bindPipeline(r.encoder,f);let _=s._geometry.subGeometries[n].lodLevels[s.lodLevel];s.instanceCount>0?w.drawIndexed(r.encoder,_.indexCount,s.instanceCount,_.indexStart,0,0):w.drawIndexed(r.encoder,_.indexCount,1,_.indexStart,0,a.index)}}}}}renderPass2(e,t,r,s,a,n=!1){if(!this.enable)return;let l=this,h=l.object3D.transform._worldMatrix;for(let u=0;u<this.materials.length;u++){let f=this.materials[u].getPass(t);if(!f||f.length==0)return;if(this.drawType==2)for(let d of f)d.pipeline&&(w.bindPipeline(a,d),w.draw(a,6,1,0,h.index));else{w.bindGeometryBuffer(a,l._geometry);for(let d of f)if(d.pipeline){w.bindPipeline(a,d);let v=l._geometry.subGeometries[u].lodLevels[l.lodLevel];w.drawIndexed(a,v.indexCount,1,v.indexStart,0,h.index)}}}}recordRenderPass2(e,t,r,s,a,n=!1){if(!this.enable)return;let l=this;for(let h=0;h<this.materials.length;h++){let c=this.materials[h].getPass(t);if(!c||c.length==0)return;let f=l.object3D.transform._worldMatrix;for(let d=0;d<c.length;d++){const p=c[d];w.bindPipeline(a,p);let y=l._geometry.subGeometries[h].lodLevels[l.lodLevel];w.drawIndexed(a,y.indexCount,1,y.indexStart,0,f.index)}}}noticeShaderChange(){this.enable&&(this.onEnable(),this.preInit=!1)}nodeUpdate(e,t,r,s){this.preInit=!0;let a=this,n=e.scene.envMap;for(let l=0;l<a.materials.length;l++){let u=a.materials[l].getPass(t);if(u)for(let c=0;c<u.length;c++){const d=u[c];if(d.shaderState.splitTexture){let C=Fe.CreateSplitTexture(a.instanceID);d.setTexture("splitTexture_Map",C)}if(!a._ignoreEnvMap&&d.envMap!=n&&d.setTexture("envMap",n),d.setTexture("prefilterMap",n),d.pipeline){d.apply(a._geometry,r,()=>a.noticeShaderChange());continue}let p=A.res.getTexture("BRDFLUT");d.setTexture("brdflutMap",p);let m=A.getRenderJob(e).shadowMapPassRenderer;m&&m.depth2DArrayTexture&&(d.setTexture("shadowMap",A.getRenderJob(e).shadowMapPassRenderer.depth2DArrayTexture),d.setStorageBuffer("shadowBuffer",Ve.shadowBuffer.get(e.scene)));let _=A.getRenderJob(e).pointLightShadowRenderer;_&&_.cubeArrayTexture&&d.setTexture("pointShadowMap",_.cubeArrayTexture);let v=Bi.iesTexture;v&&d.setTexture("iesTextureArrayMap",v),r.irradianceBuffer&&r.irradianceBuffer.length>0&&(d.setTexture("irradianceMap",r.irradianceBuffer[0]),d.setTexture("irradianceDepthMap",r.irradianceBuffer[1]));let y=pe.getLightEntries(e.scene);y&&(d.setStorageBuffer("lightBuffer",y.storageGPUBuffer),y.irradianceVolume&&d.setStructStorageBuffer("irradianceData",y.irradianceVolume.irradianceVolumeBuffer)),s&&(d.setStorageBuffer("clustersUniform",s.clustersUniformBuffer),d.setStorageBuffer("lightAssignBuffer",s.lightAssignBuffer),d.setStorageBuffer("assignTable",s.assignTableBuffer),d.setStorageBuffer("clusterBuffer",s.clusterBuffer)),d.apply(a._geometry,r)}}}beforeDestroy(e){se.getInstance().detached(this._geometry,this),se.getInstance().hasReference(this._geometry)||this._geometry.destroy(e);for(let t=0;t<this._materials.length;t++){const r=this._materials[t];se.getInstance().detached(r,this),se.getInstance().hasReference(r)||r.destroy(e)}super.beforeDestroy(e)}destroy(e){super.destroy(e),this._geometry=null,this._materials=null,this._combineShaderRefection=null}}Wr([Vt],$t.prototype,"materials",1),Wr([Vt],$t.prototype,"castShadow",1),Wr([Vt],$t.prototype,"castShadow",1),Wr([Vt],$t.prototype,"castGI",1),Wr([Vt],$t.prototype,"castGI",1);var xe=(i=>(i[i.NONE=0]="NONE",i[i.ABOVE=1]="ABOVE",i[i.ALPHA=2]="ALPHA",i[i.NORMAL=3]="NORMAL",i[i.ADD=4]="ADD",i[i.BELOW=5]="BELOW",i[i.ERASE=6]="ERASE",i[i.MUL=7]="MUL",i[i.SCREEN=8]="SCREEN",i[i.DIVD=9]="DIVD",i[i.SOFT_ADD=10]="SOFT_ADD",i))(xe||{}),Dl=(i=>(i[i.src_a=0]="src_a",i[i.dest_a=1]="dest_a",i))(Dl||{});class no{static getBlend(e){let t={color:{srcFactor:"src-alpha",dstFactor:"one"},alpha:{srcFactor:"one",dstFactor:"one"}};switch(e){case 0:t.color.srcFactor="one",t.color.dstFactor="zero",t.color.operation="add";break;case 1:t.color.srcFactor="one-minus-src-alpha",t.color.dstFactor="dst-alpha",t.color.operation="add";break;case 4:t.color.srcFactor="one",t.color.dstFactor="one",t.color.operation="add",t.alpha.srcFactor="one",t.alpha.dstFactor="one",t.alpha.operation="add";break;case 2:t.color.srcFactor="src-alpha",t.color.dstFactor="one-minus-src-alpha";break;case 5:t.color.srcFactor="one-minus-src-alpha",t.color.dstFactor="one",t.color.operation="add";break;case 6:t.color.srcFactor="zero",t.color.dstFactor="one-minus-src-alpha",t.color.operation="add";break;case 7:t.color.srcFactor="dst",t.color.dstFactor="one-minus-src-alpha",t.color.operation="add";break;case 3:t.color.srcFactor="one",t.color.dstFactor="one-minus-src-alpha",t.color.operation="add";break;case 10:t.color.srcFactor="one",t.color.dstFactor="one",t.color.operation="max",t.alpha.srcFactor="one",t.alpha.dstFactor="one",t.alpha.operation="add";break;case 8:t.color.srcFactor="one",t.color.dstFactor="one-minus-src",t.color.operation="add";break}return t}}let Pl=`
    #include "WorldMatrixUniform"
    #include "GlobalUniform"

    struct VertexAttributes {
        @location(0) position: vec4<f32>,
        @location(1) color: vec4<f32>,
    }

    struct VertexOutput {
        @location(0) varying_WPos: vec4<f32>,
        @location(1) varying_Color: vec4<f32>,
        @builtin(position) member: vec4<f32>
    };

    @vertex
    fn main( vertex:VertexAttributes ) -> VertexOutput {
        var worldMatrix = models.matrix[u32(vertex.position.w)];
        var worldPos = (worldMatrix * vec4<f32>(vertex.position.xyz, 1.0));
        var viewPosition = ((globalUniform.viewMat) * worldPos);
        var clipPosition = globalUniform.projMat * viewPosition;

        var ORI_VertexOut: VertexOutput; 
        ORI_VertexOut.varying_WPos = worldPos;
        ORI_VertexOut.varying_Color = vertex.color;
        ORI_VertexOut.member = clipPosition;
        return ORI_VertexOut;
    }
`,Rl=`
    struct FragmentOutput {
        @location(0) color: vec4<f32>,
        // #if USE_WORLDPOS
            @location(1) worldPos: vec4<f32>,
        // #endif
        // #if USEGBUFFER
            @location(2) worldNormal: vec4<f32>,
            @location(3) material: vec4<f32>,
        // #endif
        @builtin(frag_depth) out_depth: f32
    };

    @fragment
    fn main(  
        @location(0) vWorldPos: vec4<f32>,
        @location(1) varying_Color: vec4<f32>,
    ) -> FragmentOutput {
        var result: FragmentOutput;

        // #if USE_WORLDPOS
            result.worldPos = vWorldPos;
        // #endif

        // #if USEGBUFFER
            // result.worldNormal = vec4<f32>(0.0, 0.0, 0.0, 1.0); 
            result.material = vec4<f32>(0.0, 1.0, 0.0, 0.0);
        // #endif

        result.color = varying_Color;

        // let n = globalUniform.near ;
        // let f = globalUniform.far ;
        // let z = ORI_VertexVarying.fragCoord.z ;
        // let pt = pow((f / n),z);
        // let ratio = n * pt / (f / n);
        // result.out_depth =  ratio ;
        return result;
    }
`;class Ll{constructor(e,t){o(this,"mCount"),o(this,"mBatchSize"),o(this,"mBatchCount"),o(this,"mMinIndexCount"),o(this,"mOffset"),o(this,"mIndexBuffer"),o(this,"mDataBuffer"),o(this,"mBatchBuffers"),o(this,"mVertexShader"),o(this,"mFragmentShader"),o(this,"mRenderPipeline"),o(this,"mRenderPipelineLayout"),o(this,"mVertexBufferLayout"),o(this,"mGPUPrimitiveTopology"),this.mMinIndexCount=e,this.mGPUPrimitiveTopology=t,this.mBatchSize=Math.trunc(65536/this.mMinIndexCount),this.init()}reset(){this.mCount=0,this.mOffset=0,this.mBatchCount=0}addShapeData(e){let t=e.shapeData;for(;t.length>0;){if(this.mOffset>=this.mDataBuffer.length&&this.flush(),this.mOffset+t.length<=this.mDataBuffer.length){this.mDataBuffer.set(t,this.mOffset),this.mOffset+=t.length;break}let r=this.mDataBuffer.length-this.mOffset;this.mDataBuffer.set(t.slice(0,r),this.mOffset),this.mOffset+=r,t=t.slice(r)}}flush(){if(this.mOffset>0){let e;this.mBatchCount<this.mBatchBuffers.length?e=this.mBatchBuffers[this.mBatchCount]:(e=S.device.createBuffer({size:this.mDataBuffer.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST}),this.mBatchBuffers.push(e)),S.device.queue.writeBuffer(e,0,this.mDataBuffer,0,this.mOffset),this.mCount+=this.mOffset/8,this.mBatchCount++,this.mOffset=0}}render(e,t){const r=S.device;if(!this.mRenderPipeline){let s=e.outAttachments;if(e.outColor!=-1){let n=s[e.outColor];n.blend=no.getBlend(xe.NONE)}this.mRenderPipelineLayout=r.createPipelineLayout({bindGroupLayouts:[Hr.getGlobalDataBindGroupLayout()]});let a={label:"Graphic3DFixedRenderPipeline",layout:this.mRenderPipelineLayout,vertex:{module:this.mVertexShader,entryPoint:"main",buffers:[this.mVertexBufferLayout]},fragment:{module:this.mFragmentShader,entryPoint:"main",targets:s},primitive:{topology:this.mGPUPrimitiveTopology,cullMode:ui.back,frontFace:"ccw"}};e.depthTexture&&(a.depthStencil={depthWriteEnabled:!0,depthCompare:vt.less_equal,format:e.depthTexture.format}),this.mRenderPipeline=w.createPipeline(a)}if(this.flush(),this.mBatchCount>0){t.setPipeline(this.mRenderPipeline),t.setIndexBuffer(this.mIndexBuffer,"uint16");let s=this.mCount/this.mMinIndexCount;for(let a=Math.trunc(s/this.mBatchSize)-1;a>=0;a--)t.setVertexBuffer(0,this.mBatchBuffers[a]),t.drawIndexed(this.mMinIndexCount*this.mBatchSize,1,0,0,0);s=s%this.mBatchSize,s!=0&&(t.setVertexBuffer(0,this.mBatchBuffers[this.mBatchCount-1]),t.drawIndexed(this.mMinIndexCount*s,1,0,0,0))}}init(){const e=S.device;let t=new Uint16Array((Math.trunc(this.mMinIndexCount*this.mBatchSize/4)+1)*4);for(let r=0;r<t.length;r++)t[r]=r;this.mIndexBuffer=e.createBuffer({size:t.byteLength,usage:GPUBufferUsage.INDEX|GPUBufferUsage.COPY_DST}),e.queue.writeBuffer(this.mIndexBuffer,0,t),this.mVertexBufferLayout={arrayStride:(4+4)*4,stepMode:"vertex",attributes:[{shaderLocation:0,offset:0,format:"float32x4"},{shaderLocation:1,offset:16,format:"float32x4"}]},this.mBatchBuffers=[],this.mDataBuffer=new Float32Array((4+4)*t.length),this.mBatchBuffers.push(e.createBuffer({size:this.mDataBuffer.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST})),this.mVertexShader=this.createShaderModule("Graphic3DFixedRenderPipeline.vs",ut.parse(Pl,{})),this.mFragmentShader=this.createShaderModule("Graphic3DFixedRenderPipeline.fs",ut.parse(Rl,{})),this.reset()}createShaderModule(e,t){let r=S.device.createShaderModule({label:e,code:t});return r.getCompilationInfo().then(s=>{s.messages.length>0&&(console.log(t),console.log(s))}),r}}class ei{}o(ei,"ShapeVertexSize",8);class lo{constructor(e){o(this,"uuid"),o(this,"type"),o(this,"color"),o(this,"count",0),o(this,"shapeData"),o(this,"dirtyData",!1),o(this,"memoryDataIndex",-1),o(this,"transformIndex"),this.transformIndex=e}buildAxis(e=new g(0,0,0),t=10){this.buildLines([e,new g(e.x+t,e.y,e.z)],z.hexRGBColor(z.RED)),this.buildLines([e,new g(e.x,e.y+t,e.z)],z.hexRGBColor(z.GREEN)),this.buildLines([e,new g(e.x,e.y,e.z+t)],z.hexRGBColor(z.BLUE))}buildLines(e,t=z.COLOR_WHITE){if(!(e.length<2)){if(e.length==2){this.fillShapeData(e,t);return}var r=new Array(e.length+e.length-2);for(let s=1,a=0;s<e.length;++s)r[a++]=e[s-1],r[a++]=e[s];this.fillShapeData(r,t)}}buildArcLine(e,t,r,s,a=16,n=g.Y_AXIS,l=z.COLOR_WHITE){const h=(s-r)*_e;r*=_e;var u=[];for(let p=0;p<=a;++p){p>1&&u.push(u[u.length-1]);var c=h*(p/a)+r,f=t*Math.cos(c),d=t*Math.sin(c);switch(n){case g.X_AXIS:u.push(e.add(new g(0,f,d)));break;case g.Y_AXIS:u.push(e.add(new g(f,0,d)));break;case g.Z_AXIS:u.push(e.add(new g(f,d,0)));break;default:u.push(e.add(new g(f,d,0)));break}}this.fillShapeData(u,l)}buildCircle(e,t,r=32,s=g.Y_AXIS,a=z.COLOR_WHITE){var n=[];for(let c=0;c<=r;++c){var l=2*Math.PI*c/r,h=t*Math.cos(l),u=t*Math.sin(l);switch(s){case g.X_AXIS:n.push(e.add(new g(0,h,u)));break;case g.Y_AXIS:n.push(e.add(new g(h,0,u)));break;case g.Z_AXIS:n.push(e.add(new g(h,u,0)));break;default:n.push(e.add(new g(h,u,0)));break}c>0&&n.push(n[n.length-1])}n.push(n[0]),this.fillShapeData(n,a)}fillShapeData(e,t){if(!this.shapeData)this.shapeData=new Float32Array(ei.ShapeVertexSize*e.length);else if(this.count+ei.ShapeVertexSize*e.length>=this.shapeData.length){let s=new Float32Array(this.shapeData.length+ei.ShapeVertexSize*e.length);s.set(this.shapeData),this.shapeData=s}const r=this.shapeData;for(let s=0;s<e.length;++s){const a=e[s];if(r[this.count++]=a.x,r[this.count++]=a.y,r[this.count++]=a.z,r[this.count++]=this.transformIndex,t instanceof z)r[this.count++]=t.r,r[this.count++]=t.g,r[this.count++]=t.b,r[this.count++]=t.a;else{const n=t[s];r[this.count++]=n.r,r[this.count++]=n.g,r[this.count++]=n.b,r[this.count++]=n.a}}this.dirtyData=!0}reset(){this.count=0}}class Us extends $t{constructor(e,t){super(),o(this,"shapes"),o(this,"mDirtyData",!1),o(this,"mMinIndexCount"),o(this,"mGPUPrimitiveTopology"),o(this,"mRenderPipeline"),this.alwaysRender=!0,this.mMinIndexCount=e,this.mGPUPrimitiveTopology=t,this.shapes=new Map,this.addRendererMask(Ue.Particle)}fillShapeData(e,t,r,s){this.mDirtyData=!0;var a;this.shapes.has(e)?(a=this.shapes.get(e),a.shapeData.length<ei.ShapeVertexSize*s.length&&(a.shapeData=new Float32Array(ei.ShapeVertexSize*s.length))):(a=new lo(this.transform._worldMatrix.index),a.type=t,a.color=r,a.shapeData=new Float32Array(ei.ShapeVertexSize*s.length));const n=a.shapeData,l=this.transform._worldMatrix.index;for(let h=0,u=0;h<s.length;++h){const c=s[h];n[u++]=c.x,n[u++]=c.y,n[u++]=c.z,n[u++]=l,n[u++]=r.r,n[u++]=r.g,n[u++]=r.b,n[u++]=r.a}this.shapes.set(e,a)}init(){super.init(),this.castGI=!1,this.castShadow=!1,this.mRenderPipeline=new Ll(this.mMinIndexCount,this.mGPUPrimitiveTopology)}removeShape(e){this.shapes.has(e)&&(this.mDirtyData=!0,this.shapes.delete(e))}initPipeline(){this.object3D.bound=new Be(g.ZERO,g.MAX),this._readyPipeline=!0}nodeUpdate(e,t,r,s){this.mDirtyData&&(this.mRenderPipeline.reset(),this.shapes.forEach((a,n)=>{this.mRenderPipeline.addShapeData(a)}),this.mDirtyData=!1)}renderPass2(e,t,r,s,a,n=!1){this.mRenderPipeline.render(r,a)}allocGraphics3DShape(e,t){let r;return this.shapes.has(e)?(r=this.shapes.get(e),r.reset()):(r=new lo(t),r.uuid=e,r.type="line",r.color=z.COLOR_WHITE,this.shapes.set(r.uuid,r)),this.mDirtyData=!0,r}}class Ul{constructor(){o(this,"opaqueList",[]),o(this,"transparentList",[]),o(this,"sky")}clean(){this.opaqueList.length=0,this.transparentList.length=0}}class Ol{constructor(){o(this,"renderGroup"),this.renderGroup=new Map}collect_add(e){let t="",r="";t+=e.geometry.instanceID;for(let a=0;a<e.materials.length;a++){const n=e.materials[a];r+=n.defaultPass.shaderVariant}let s=t+r;this.renderGroup.has(s)||this.renderGroup.set(s,{bundleMap:new Map,key:s,renderNodes:[]}),this.renderGroup.get(s).renderNodes.indexOf(e)==-1&&this.renderGroup.get(s).renderNodes.push(e)}}class Nl{constructor(){o(this,"renderShaderUpdateList",new Map),o(this,"renderNodeList",new Map)}collect_add(e){let t=e.transform.view3D;t&&e.materials&&e.materials.forEach(r=>{let s=this.renderShaderUpdateList.get(t);s||(s=new Map,this.renderShaderUpdateList.set(t,s));let a=this.renderNodeList.get(t);a||(a=new Map,this.renderNodeList.set(t,a)),a.set(e.instanceID,e);let n=r.getAllPass();for(let l=0;l<n.length;l++){const h=n[l];let u=`${e.geometry.instanceID+h.instanceID}`,c=s.get(u);c||(c=new Map,s.set(u,c)),c.set(e.instanceID,e)}})}collect_remove(e){let t=e.transform.view3D;if(t&&e.materials){let r=this.renderShaderUpdateList.get(t);r&&e.materials.forEach(s=>{let a=s.getAllPass();for(let n=0;n<a.length;n++){const l=a[n];let h=`${e.geometry.instanceID+l.instanceID}`;r.delete(h)}})}}}const Fl=class{constructor(){o(this,"_sceneLights"),o(this,"_sceneGIProbes"),o(this,"_op_RenderNodes"),o(this,"_tr_RenderNodes"),o(this,"_octreeRenderNodes"),o(this,"_graphics"),o(this,"_op_renderGroup"),o(this,"_tr_renderGroup"),o(this,"_renderShaderCollect"),o(this,"state",{giLightingChange:!0}),o(this,"sky"),o(this,"_collectInfo"),o(this,"rendererOctree"),this._sceneLights=new Map,this._sceneGIProbes=new Map,this._op_RenderNodes=new Map,this._tr_RenderNodes=new Map,this._graphics=[],this._op_renderGroup=new Map,this._tr_renderGroup=new Map,this._collectInfo=new Ul,this._renderShaderCollect=new Nl,this._octreeRenderNodes=new Map}static get instance(){return this._instance||(this._instance=new Fl),this._instance}getPashList(i,e){if(e.renderOrder<3e3)return this._op_RenderNodes.get(i);if(e.renderOrder>=3e3)return this._tr_RenderNodes.get(i)}sortRenderNode(i,e){for(let t=i.length-1;t>0;t--)if(i[t].renderOrder<e.renderOrder){i.push(e);return}i.push(e)}addRenderNode(i,e){if(!i)return;let t=e.renderOrder>=3e3;if(e.hasMask(Ue.Sky))this.sky=e;else if(e instanceof Us)this._graphics.indexOf(e)==-1&&this._graphics.push(e);else if(oo.hasMask(e.renderLayer,Yr.None)){this.removeRenderNode(i,e);let r=t?this._tr_RenderNodes:this._op_RenderNodes;r.has(i)||r.set(i,[]),r.get(i).push(e),A.setting.occlusionQuery.octree&&e.attachSceneOctree(this.getOctree(i));let s=this.getPashList(i,e);s.indexOf(e)==-1&&this.sortRenderNode(s,e)}else{this.removeRenderNode(i,e);let r=t?this._tr_renderGroup:this._op_renderGroup;r.has(i)||r.set(i,new Ol),r.get(i).collect_add(e)}e.object3D.renderNode=e,this._renderShaderCollect.collect_add(e)}getOctree(i){let e,t=A.setting.occlusionQuery.octree;if(t&&(e=this._octreeRenderNodes.get(i),!e)){let r=new g(t.x,t.y,t.z),s=new g(t.width,t.height,t.depth),a=new Be(r,s);e=new er(a),this._octreeRenderNodes.set(i,e)}return e}removeRenderNode(i,e){if(e.detachSceneOctree(),e.hasMask(Ue.Sky))this.sky=null;else if(oo.hasMask(e.renderLayer,Yr.None)){let t=this.getPashList(i,e);if(t){let r=t.indexOf(e);r!=-1&&t.splice(r,1)}}this._renderShaderCollect.collect_remove(e)}addLight(i,e){if(!this._sceneLights.has(i))this._sceneLights.set(i,[e]);else{let t=this._sceneLights.get(i);if(t.length>=A.setting.light.maxLight){console.warn("Alreay meet maxmium light number:",A.setting.light.maxLight);return}t.indexOf(e)!=-1||t.push(e)}}removeLight(i,e){if(this._sceneLights.has(i)){let t=this._sceneLights.get(i),r=t.indexOf(e);r!=-1&&t.splice(r,1)}}getLights(i){let e=this._sceneLights.get(i);return e||[]}addGIProbe(i,e){this._sceneGIProbes.has(i)?this._sceneGIProbes.get(i).push(e):this._sceneGIProbes.set(i,[e])}removeGIProbe(i,e){if(this._sceneGIProbes.has(i)){let t=this._sceneGIProbes.get(i),r=t.indexOf(e);r!=-1&&t.splice(r,1)}}getProbes(i){let e=this._sceneGIProbes.get(i);return e||[]}autoSortRenderNodes(i){let e=this._tr_RenderNodes.get(i);if(!e)return;let t=!1;for(const r of e)if(r.isRenderOrderChange||r.needSortOnCameraZ){t=!0;break}if(t){for(const r of e){let s=r.renderOrder;if(r.needSortOnCameraZ){let a=El.worldToCameraDepth(r.object3D);a=1-Math.max(0,Math.min(1,a)),s+=a}r.__renderOrder=s,r.isRenderOrderChange=!1}e.sort((r,s)=>r.__renderOrder>s.__renderOrder?1:-1)}return this}getRenderNodes(i,e){if(this._collectInfo.clean(),this._collectInfo.sky=this.sky,A.setting.occlusionQuery.octree)this.rendererOctree=this.getOctree(i),this.rendererOctree.getRenderNode(e.frustum,this._collectInfo);else{let t=this._op_RenderNodes.get(i);t&&(this._collectInfo.opaqueList=t.concat());let r=this._tr_RenderNodes.get(i);r&&(this._collectInfo.transparentList=r.concat())}return this._collectInfo}getOpRenderGroup(i){return this._op_renderGroup.get(i)}getTrRenderGroup(i){return this._tr_renderGroup.get(i)}getGraphicList(){return this._graphics}getRenderShaderCollect(i){return this._renderShaderCollect.renderShaderUpdateList.get(i)||[]}};let Q=Fl;o(Q,"_instance");class kl{constructor(){o(this,"setting"),o(this,"probesBufferData"),o(this,"probesBuffer"),o(this,"isVolumeFrameChange",!0),o(this,"randomOrientation"),o(this,"startPosition",new g),o(this,"isVolumeChange",!0),o(this,"irradianceVolumeBuffer"),o(this,"directionDistance",20),o(this,"randomSeedCount",3),o(this,"useRandomIndex",0),o(this,"centerDirection",new g(0,0,this.directionDistance).normalize(1)),o(this,"arroundPositions",[]),o(this,"debugX",0),o(this,"debugY",0),o(this,"debugZ",0)}updateOrientation(){return this.useRandomIndex++,this.useRandomIndex>=this.arroundPositions.length&&(this.useRandomIndex=0),V.fromToRotation(this.centerDirection,this.arroundPositions[this.useRandomIndex],this.randomOrientation),this.randomOrientation}init(e){this.setting=e,this.randomOrientation=new V(!1),this.randomOrientation.identity(),this.irradianceVolumeBuffer=new ge(80),this.createFramesBuffer(),this.arroundPositions.push(this.centerDirection.clone());for(let t=0;t<this.randomSeedCount;t++){let r=Math.PI*2*t/this.randomSeedCount,s=new g(Math.sin(r),Math.cos(r),this.directionDistance).normalize(1);this.arroundPositions.push(s)}}setVolumeDataChange(){this.isVolumeChange=!0}updateProbes(e){let t=this.probesBufferData;for(let r of e){let s=r.index*4;t[s+3]=r.drawCallFrame}}createFramesBuffer(){if(!this.probesBufferData){let e=this.setting.probeXCount*this.setting.probeYCount*this.setting.probeZCount;this.probesBufferData=new Float32Array(e*4),this.probesBufferData.fill(-1),this.probesBuffer=new ge(e*4,GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST)}}uploadBuffer(){this.isVolumeChange&&(this.fillIrradianceData(),this.isVolumeChange=!1,this.isVolumeFrameChange=!0),this.probesBuffer.setFloat32Array("uniformFramesBuffer",this.probesBufferData)}calcPosition(e,t,r,s){let a=this.setting,n=this.setting.probeSpace;return s=s||new g,s.x=e*n-n*(a.probeXCount-1)*.5+a.offsetX,s.y=t*n-n*(a.probeYCount-1)*.5+a.offsetY,s.z=r*n-n*(a.probeZCount-1)*.5+a.offsetZ,s}fillIrradianceData(){let e=this.setting,t=this.calcPosition(0,0,0,this.startPosition);this.irradianceVolumeBuffer.setFloat("orientationIndex",this.randomOrientation.index),this.irradianceVolumeBuffer.setFloat("hysteresis",e.hysteresis),this.irradianceVolumeBuffer.setFloat("OctRTSideSize",e.octRTSideSize),this.irradianceVolumeBuffer.setFloat("OctRTMaxSize",e.octRTMaxSize),this.irradianceVolumeBuffer.setFloat("startX",t.x),this.irradianceVolumeBuffer.setFloat("startY",t.y),this.irradianceVolumeBuffer.setFloat("startZ",t.z),this.irradianceVolumeBuffer.setFloat("ProbeSpace",e.probeSpace),this.irradianceVolumeBuffer.setFloat("probeXCount",e.probeXCount),this.irradianceVolumeBuffer.setFloat("probeYCount",e.probeYCount),this.irradianceVolumeBuffer.setFloat("probeZCount",e.probeZCount),this.irradianceVolumeBuffer.setFloat("maxDistance",e.probeSpace*1.732),this.irradianceVolumeBuffer.setFloat("depthSharpness",e.depthSharpness),this.irradianceVolumeBuffer.setFloat("ProbeSourceTextureSize",e.probeSourceTextureSize),this.irradianceVolumeBuffer.setFloat("ProbeSize",e.probeSize),this.irradianceVolumeBuffer.setFloat("bounceIntensity",e.bounceIntensity),this.irradianceVolumeBuffer.setFloat("probeRoughness",e.probeRoughness),this.irradianceVolumeBuffer.setFloat("normalBias",e.normalBias),this.irradianceVolumeBuffer.setFloat("irradianceChebyshevBias",e.irradianceChebyshevBias),this.irradianceVolumeBuffer.setFloat("rayNumber",e.rayNumber),this.irradianceVolumeBuffer.setFloat("irradianceDistanceBias",e.irradianceDistanceBias),this.irradianceVolumeBuffer.setFloat("indirectIntensity",e.indirectIntensity),this.irradianceVolumeBuffer.setFloat("ddgiGamma",e.ddgiGamma),this.irradianceVolumeBuffer.setFloat("lerpHysteresis",e.lerpHysteresis),this.irradianceVolumeBuffer.setFloat("debugX",this.debugX),this.irradianceVolumeBuffer.setFloat("debugY",this.debugY),this.irradianceVolumeBuffer.setFloat("debugZ",this.debugZ),this.irradianceVolumeBuffer.apply()}}class zl{constructor(){o(this,"storageGPUBuffer"),o(this,"irradianceVolume"),o(this,"_lightList",[]),this.storageGPUBuffer=new ge(Gr.lightSize*A.setting.light.maxLight,GPUBufferUsage.COPY_SRC),this.irradianceVolume=new kl,this.irradianceVolume.init(A.setting.gi);for(let e=0;e<A.setting.light.maxLight;e++){let t=this.storageGPUBuffer.memory.allocation_node(Gr.lightSize*4);this._lightList.push(t)}this.storageGPUBuffer.visibility=GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE}update(e){this.storageGPUBuffer.clean();let t=Q.instance.getLights(e.scene);for(let r=0;r<t.length;r++){const s=t[r].lightData;s.index=r,this.writeLightBytes(s,this._lightList[r])}this.storageGPUBuffer.apply()}writeLightBytes(e,t){t.offset=0,t.writeFloat(e.index),t.writeInt32(e.lightType),t.writeFloat(e.radius),t.writeFloat(e.linear),t.writeVector3(e.lightPosition),t.writeFloat(e.lightMatrixIndex),t.writeVector3(e.direction),t.writeFloat(e.quadratic),t.writeRGBColor(e.lightColor),t.writeFloat(e.intensity),t.writeFloat(e.innerAngle),t.writeFloat(e.outerAngle),t.writeFloat(e.range),t.writeInt32(e.castShadowIndex),t.writeVector3(e.lightTangent),t.writeFloat(e.iesIndex)}}class Gl{constructor(){o(this,"gpuBuffer"),o(this,"probes"),o(this,"memoryDo"),o(this,"_probeInfoList")}initDataUniform(e){this.memoryDo=new zr,this.probes=e,this._probeInfoList=[],this.memoryDo.destroy(),this.memoryDo.allocation(e.length*17*4);for(let r=0;r<e.length;r++){var t=17;let s=this.memoryDo.allocation_node(t*4);this._probeInfoList.push(s);let a=e[r].transform.worldPosition;s.setArray(0,[a.x,a.y,a.z])}this.gpuBuffer=S.device.createBuffer({size:this.memoryDo.shareDataBuffer.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.STORAGE,label:"ProbeBuffer",mappedAtCreation:!1})}updateGPUBuffer(){const e=this.memoryDo.shareDataBuffer;let t=this.memoryDo.shareDataBuffer.byteLength,r=0;const s=5e3*64;for(;r<t;)S.device.queue.writeBuffer(this.gpuBuffer,r,e,r,Math.floor(Math.min(s,t-r))),r+=s}}class Ql extends Jt{constructor(e,t=0,r){super(),o(this,"size"),this.bufferType=Mt.StorageGPUBuffer,this.size=e,this.createBuffer(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|t,e,r)}writeBufferByHeap(e,t){let r=S.device;if(e.length>0){let s=null;for(;this.mapAsyncReady.length&&(s=this.mapAsyncReady.shift(),s.usedSize!=e.byteLength);)s.destroy(),this.mapAsyncBuffersOutstanding--,s=null;s||(s=r.createBuffer({size:e.byteLength,usage:GPUBufferUsage.COPY_SRC|GPUBufferUsage.MAP_WRITE,mappedAtCreation:!0}),s.usedSize=e.byteLength,this.mapAsyncBuffersOutstanding++,this.mapAsyncBuffersOutstanding>10&&console.warn(` Warning: mapAsync requests from ${this.mapAsyncBuffersOutstanding} frames ago have not resolved yet.  MB of staging buffers allocated.`));let a=new Float32Array(e.buffer,e.byteOffset,t);new Float32Array(s.getMappedRange(0,t*4)).set(a),s.unmap();const l=r.createCommandEncoder();l.copyBufferToBuffer(s,0,this.buffer,0,t*4),r.queue.submit([l.finish()]),s.mapAsync(GPUMapMode.WRITE).then(()=>this.mapAsyncReady.push(s))}}}class Vl{constructor(){o(this,"uuid"),o(this,"index"),o(this,"usage"),o(this,"groupBufferSize"),o(this,"matrixBufferDst"),this.uuid=Pt(),this.groupBufferSize=0,this.usage=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,this.cacheWorldMatrix()}cacheWorldMatrix(){this.groupBufferSize=V.maxCount*V.blockBytes,this.matrixBufferDst=new Ql(this.groupBufferSize/4),this.matrixBufferDst.visibility=GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,this.matrixBufferDst.buffer.label=this.groupBufferSize.toString()}writeBuffer(e){const t=V.dynamicMatrixBytes;this.matrixBufferDst.mapAsyncWrite(t,e)}}class pe{static init(){this.modelMatrixBindGroup=new Vl,this._cameraBindGroups=new Map,this._lightEntriesMap=new Map}static getCameraGroup(e){let t=this._cameraBindGroups.get(e);return t||(t=new Sl(this.modelMatrixBindGroup),this._cameraBindGroups.set(e,t)),e.isShadowCamera?t.setShadowCamera(e):t.setCamera(e),t}static getLightEntries(e){e||console.log("getLightEntries scene is null");let t=this._lightEntriesMap.get(e);return t||(t=new zl,this._lightEntriesMap.set(e,t)),this._lightEntriesMap.get(e)}static updateProbes(e){this._probeEntries||(this._probeEntries=new Gl,this._probeEntries.initDataUniform(e))}}o(pe,"_cameraBindGroups"),o(pe,"_lightEntriesMap"),o(pe,"_probeEntries"),o(pe,"modelMatrixBindGroup");const jr=class{static bindPipeline(i,e){if(jr.lastShader!=e)jr.lastShader=e;else return;jr.lastPipeline!=e.pipeline&&(jr.lastPipeline=e.pipeline,i.setPipeline(e.pipeline));for(let t=1;t<e.bindGroups.length;t++){const r=e.bindGroups[t];r&&i.setBindGroup(t,r)}}static bindCamera(i,e){let t=pe.getCameraGroup(e);i.setBindGroup(0,t.globalBindGroup)}static bindGeometryBuffer(i,e){if(this.lastGeometry!=e){this.lastGeometry=e,e.indicesBuffer&&i.setIndexBuffer(e.indicesBuffer.indicesGPUBuffer.buffer,e.indicesBuffer.indicesFormat);let t=e.vertexBuffer.vertexGPUBuffer,r=e.vertexBuffer.vertexBufferLayouts;for(let s=0;s<r.length;s++){const a=r[s];i.setVertexBuffer(s,t.buffer,a.offset,a.size)}}}static cleanCache(){this.lastGeometry=null,this.lastPipeline=null,this.lastShader=null}static createPipeline(i){return ft.countStart("GPUContext","pipeline"),S.device.createRenderPipeline(i)}static beginCommandEncoder(){return ft.countStart("GPUContext","beginCommandEncoder"),this.LastCommand&&S.device.queue.submit([this.LastCommand.finish()]),this.LastCommand=S.device.createCommandEncoder(),this.LastCommand}static endCommandEncoder(i){this.LastCommand==i&&(S.device.queue.submit([this.LastCommand.finish()]),this.LastCommand=null,ft.countStart("GPUContext","endCommandEncoder"))}static recordBundleEncoder(i){return S.device.createRenderBundleEncoder(i)}static beginRenderPass(i,e){if(this.cleanCache(),this.renderPassCount++,this.lastRenderPassState=e,e.renderTargets&&e.renderTargets.length>0){for(let t=0;t<e.renderTargets.length;++t){const r=e.renderTargets[t];let s=e.renderPassDescriptor.colorAttachments[t];e.multisample>0&&e.renderTargets.length==1?(s.view=e.multiTexture.createView(),s.resolveTarget=r.getGPUView()):s.view=r.getGPUTexture().createView()}return i.beginRenderPass(e.renderPassDescriptor)}else{let t=e.renderPassDescriptor.colorAttachments[0];return t&&(e.multisample>0?(t.view=e.multiTexture.createView(),t.resolveTarget=S.context.getCurrentTexture().createView()):t.view=S.context.getCurrentTexture().createView()),i.beginRenderPass(e.renderPassDescriptor)}}static drawIndexed(i,e,t,r,s,a){i.drawIndexed(e,t,r,s,a),this.drawCount++}static draw(i,e,t,r,s){i.draw(e,t,r,s),this.drawCount++}static endPass(i){i.insertDebugMarker("end"),i.end()}static computeCommand(i,e){let t=i.beginComputePass();for(let r=0;r<e.length;r++)e[r].compute(t);t.end()}};let w=jr;o(w,"lastGeometry"),o(w,"lastPipeline"),o(w,"lastShader"),o(w,"drawCount",0),o(w,"renderPassCount",0),o(w,"geometryCount",0),o(w,"pipelineCount",0),o(w,"matrixCount",0),o(w,"lastRenderPassState"),o(w,"LastCommand");class Hl{constructor(){o(this,"source"),o(this,"input"),o(this,"output")}reset(e){this.input&&this.input.destroy(),this.output&&this.output.destroy(),this.input=this.output=null,this.source=e}apply(e){if(this.source){if(!this.input){let t=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST;this.input=new ge(this.source.length,t,this.source),this.input.apply()}if(!this.output){let t=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC;this.output=new ge(e*3,t),this.output.apply()}}}}class Yl{constructor(){o(this,"enable"),o(this,"morphTargetsRelative"),o(this,"MaxMorphTargetCount",64),o(this,"_computeConfigArray"),o(this,"_computeConfigBuffer"),o(this,"_morphInfluenceArray"),o(this,"_morphInfluenceBuffer"),o(this,"_positionAttrDataGroup"),o(this,"_normalAttrDataGroup"),o(this,"_isInfluenceDirty"),o(this,"_morphTargetCount"),o(this,"_totalVertexCount"),o(this,"_computeShader"),o(this,"_computeShaders"),o(this,"_computeWorkGroupXY",1),o(this,"_collectMorphTargetData"),this._isInfluenceDirty=!0,this.generateGPUBuffer(),this._positionAttrDataGroup=new Hl,this._normalAttrDataGroup=new Hl}initMorphTarget(e){this._collectMorphTargetData=this.collectMorphTargetList(e),this._computeShader&&this._computeShader.destroy();let t=Le.CsMain;this._computeShader=new be(t),this._collectMorphTargetData.mergedNormal?this._computeShader.setDefine("USE_MORPHNORMALS",!0):this._computeShader.deleteDefine("USE_MORPHNORMALS"),this._computeShaders=[this._computeShader],this._isInfluenceDirty=!0,this._morphTargetCount=this._collectMorphTargetData.mtCount,this._totalVertexCount=this._collectMorphTargetData.vCount,this._morphInfluenceArray.fill(0),this._computeWorkGroupXY=this.calcWorkGroup(this._totalVertexCount),this._positionAttrDataGroup.reset(this._collectMorphTargetData.mergedPos),this._normalAttrDataGroup.reset(this._collectMorphTargetData.mergedNormal)}applyRenderShader(e){this.uploadMorphTargetBuffer(),this.uploadConfigGBuffer(),e.setUniformBuffer("morphTargetConfig",this._computeConfigBuffer),e.setStorageBuffer("morphTargetOpPositions",this._positionAttrDataGroup.output),this._collectMorphTargetData.mergedNormal&&e.setStorageBuffer("morphTargetOpNormals",this._normalAttrDataGroup.output)}computeMorphTarget(e){this.uploadConfigGBuffer(),this.uploadMorphTargetBuffer(),this._computeShader.setUniformBuffer("morphTargetConfig",this._computeConfigBuffer),this._computeShader.setStorageBuffer("morphTargetInfluence",this._morphInfluenceBuffer),this._computeShader.setStorageBuffer("morphTargetPositions",this._positionAttrDataGroup.input),this._computeShader.setStorageBuffer("morphTargetOpPositions",this._positionAttrDataGroup.output),this._collectMorphTargetData.mergedNormal&&(this._computeShader.setStorageBuffer("morphTargetNormals",this._normalAttrDataGroup.input),this._computeShader.setStorageBuffer("morphTargetOpNormals",this._normalAttrDataGroup.output)),this._computeShader.workerSizeX=this._computeWorkGroupXY,this._computeShader.workerSizeY=this._computeWorkGroupXY,this._computeShader.workerSizeZ=1,w.computeCommand(e,this._computeShaders)}updateInfluence(e,t){this._isInfluenceDirty=!0,this._morphInfluenceArray[e]=t}collectMorphTargetList(e){let t=this.collectAttribute("a_morphPositions_",e),r=t.length,s=t[0].data.length/3,a=new Float32Array(s*r*3);{let h=0;for(let u=0;u<r;u++){let c=t[u];a.set(c.data,h),h+=c.data.length}}let n=this.collectAttribute("a_morphNormals_",e),l;if(n&&n.length>0){let h=0;l=new Float32Array(s*r*3);for(let u=0;u<r;u++){let c=n[u];l.set(c.data,h),h+=c.data.length}}return{mtCount:r,vCount:s,mergedPos:a,mergedNormal:l}}collectAttribute(e,t){let r=[];for(let s=0;s<this.MaxMorphTargetCount;s++){let a=e+s,n=t.getAttribute(a);if(n)r[s]=n;else break}return r}uploadConfigGBuffer(){if(this._isInfluenceDirty){let e=0;for(let t=0;t<this._morphTargetCount;t++)e+=this._morphInfluenceArray[t];this._morphInfluenceBuffer.setFloat32Array("data",this._morphInfluenceArray),this._morphInfluenceBuffer.apply(),this._computeConfigArray[0]=this.morphTargetsRelative?1:1-e,this._computeConfigArray[1]=this._morphTargetCount,this._computeConfigArray[2]=this._totalVertexCount,this._computeConfigArray[3]=this._computeWorkGroupXY,this._computeConfigBuffer.setFloat32Array("data",this._computeConfigArray),this._computeConfigBuffer.apply(),this._isInfluenceDirty=!1}}calcWorkGroup(e){let t=Math.ceil(Math.sqrt(e)),r=Math.ceil(Math.log2(t));return t=Math.pow(2,r),t}uploadMorphTargetBuffer(){this._positionAttrDataGroup.output||this._positionAttrDataGroup.apply(this._totalVertexCount),this._normalAttrDataGroup.output||this._normalAttrDataGroup.apply(this._totalVertexCount)}generateGPUBuffer(){this._computeConfigArray=new Float32Array(4),this._computeConfigBuffer=new Dt(4),this._morphInfluenceArray=new Float32Array(this.MaxMorphTargetCount);let e=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST;this._morphInfluenceBuffer=new ge(this.MaxMorphTargetCount,e)}}var Xd=Object.defineProperty,Wd=Object.getOwnPropertyDescriptor,Os=(i,e,t,r)=>{for(var s=r>1?void 0:r?Wd(e,t):e,a=i.length-1,n;a>=0;a--)(n=i[a])&&(s=(r?n(e,t,s):n(s))||s);return r&&s&&Xd(e,t,s),s};const Xl=class extends $t{constructor(){super(),o(this,"receiveShadow"),o(this,"morphData")}onEnable(){super.onEnable()}onDisable(){super.onDisable()}cloneTo(i){i.addComponent(Xl).copyComponent(this)}copyComponent(i){return super.copyComponent(i),this.receiveShadow=i.receiveShadow,this}get geometry(){return this._geometry}set geometry(i){super.geometry=i;let e=i.morphTargetDictionary!=null;e&&(this.morphData||(this.morphData=new Yl),this.morphData.morphTargetsRelative=i.morphTargetsRelative,this.morphData.initMorphTarget(i)),this.morphData&&(this.morphData.enable=e),this.morphData&&this.morphData.enable?this.addRendererMask(Ue.MorphTarget):this.removeRendererMask(Ue.MorphTarget),this.object3D.bound=this._geometry.bounds.clone(),this._readyPipeline&&this.initPipeline()}get material(){return this._materials[0]}set material(i){this.materials=[i]}setMorphInfluence(i,e){if(this.morphData&&this.morphData.enable){let t=this._geometry.morphTargetDictionary[i];t>=0&&this.morphData.updateInfluence(t,e)}}setMorphInfluenceIndex(i,e){this.morphData&&this.morphData.enable&&i>=0&&this.morphData.updateInfluence(i,e)}onCompute(i,e){this.morphData&&this.morphData.enable&&this.morphData.computeMorphTarget(e)}nodeUpdate(i,e,t,r){if(this.morphData&&this.morphData.enable)for(let s=0;s<this.materials.length;s++){let n=this.materials[s].getPass(e);if(n)for(let l=0;l<n.length;l++)this.morphData.applyRenderShader(n[l])}super.nodeUpdate(i,e,t,r)}destroy(i){super.destroy(i)}};let ce=Xl;Os([Vt],ce.prototype,"geometry",1),Os([Vt],ce.prototype,"geometry",1),Os([Vt],ce.prototype,"material",1),Os([Vt],ce.prototype,"material",1);class Wl{constructor(){o(this,"label",""),o(this,"customSize",!1),o(this,"zPreTexture",null),o(this,"depthTexture",null),o(this,"outAttachments"),o(this,"outColor",-1),o(this,"renderTargets"),o(this,"rtTextureDescripts"),o(this,"irradianceBuffer"),o(this,"multisample",0),o(this,"multiTexture"),o(this,"depthViewIndex",0),o(this,"depthCleanValue",0),o(this,"isOutTarget",!0),o(this,"camera3D"),o(this,"rtFrame"),o(this,"renderPassDescriptor"),o(this,"renderBundleEncoderDescriptor"),o(this,"depthLoadOp")}getLastRenderTexture(){return this.renderTargets&&this.renderTargets.length>0?this.renderTargets[0]:A.res.redTexture}}const qr=class{static createRendererPassState(i,e=null){let t=new Wl;if(t.label=i.label,t.customSize=i.customSize,t.rtFrame=i,t.zPreTexture=i.zPreTexture,t.depthTexture=i.depthTexture,t.depthViewIndex=i.depthViewIndex,t.isOutTarget=i.isOutTarget,t.depthCleanValue=i.depthCleanValue,t.depthLoadOp=i.depthLoadOp,i&&i.attachments.length>0){t.renderTargets=i.attachments,t.rtTextureDescripts=i.rtDescriptors,t.renderPassDescriptor=qr.getRenderPassDescriptor(t),t.renderBundleEncoderDescriptor=qr.getRenderBundleDescriptor(t),t.outAttachments=[];for(let r=0;r<i.attachments.length;r++){const s=i.attachments[r];t.outAttachments[r]={format:s.format},s.name.indexOf(Ae.colorBufferTex_NAME)!=-1&&(t.outColor=r)}}else t.renderPassDescriptor=qr.getRenderPassDescriptor(t,e),t.renderBundleEncoderDescriptor=qr.getRenderBundleDescriptor(t),t.outAttachments=[{format:S.presentationFormat}],t.outColor=0;return t}static getRenderPassDescriptor(i,e=null){S.device,S.presentationSize;let t=[];if(i.renderTargets&&i.renderTargets.length>0){i.renderTargets[0].width,i.renderTargets[0].height;for(let s=0;s<i.renderTargets.length;s++){const a=i.renderTargets[s],n=i.rtTextureDescripts[s];t.push({view:a.getGPUView(),resolveTarget:void 0,loadOp:n.loadOp,clearValue:n.clearValue,storeOp:n.storeOp})}}else if(!i.customSize){let s=S.canvasConfig&&S.canvasConfig.alpha?[1,1,1,0]:[0,0,0,1];i.isOutTarget==!0&&t.push({view:void 0,resolveTarget:void 0,loadOp:S.canvasConfig&&S.canvasConfig.alpha||e!=null?"load":"clear",clearValue:s,storeOp:"store"})}let r=null;return i.depthTexture||i.zPreTexture?(i.zPreTexture&&(i.depthTexture=i.zPreTexture),r={label:`${i.label} renderPassDescriptor zPreTexture${i.zPreTexture?"load":"clear"}`,colorAttachments:t,depthStencilAttachment:{view:i.depthTexture.getGPUView(),depthLoadOp:i.zPreTexture?"load":i.depthLoadOp,depthClearValue:i.zPreTexture?1:i.depthCleanValue,depthStoreOp:"store"}}):r={colorAttachments:t,label:"renderPassDescriptor not writeDepth"},this.renderPassDescriptorCount++,r}static getRenderBundleDescriptor(i){S.presentationSize;let e=[];if(i.renderTargets&&i.renderTargets.length>0){i.renderTargets[0].width,i.renderTargets[0].height;for(let r=0;r<i.renderTargets.length;r++){const s=i.renderTargets[r];e.push(s.format)}}let t=null;return i.depthTexture?t={colorFormats:e,depthStencilFormat:i.depthTexture.format}:t={colorFormats:e},this.renderPassDescriptorCount++,t}};let He=qr;o(He,"bindGroupDescriptorCount",0),o(He,"bindTextureDescriptorCount",0),o(He,"renderPassDescriptorCount",0),o(He,"pipelineDescriptorCount",0);var Y=(i=>(i.position="position",i.normal="normal",i.uv="uv",i.TANGENT="TANGENT",i.TEXCOORD_1="TEXCOORD_1",i.TEXCOORD_2="TEXCOORD_2",i.color="color",i.joints0="joints0",i.joints1="joints1",i.weights0="weights0",i.weights1="weights1",i.weight="weight",i.indices="indices",i.vIndex="vIndex",i.a_morphPositions_0="a_morphPositions_0",i))(Y||{});class ho extends Jt{constructor(e){super(),o(this,"node"),this.bufferType=Mt.VertexGPUBuffer,this.createVertexBuffer(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.VERTEX,e)}createVertexBuffer(e,t){let r=S.device;this.byteSize=t*Float32Array.BYTES_PER_ELEMENT,this.usage=e,this.buffer&&this.destroy(),this.buffer=r.createBuffer({size:this.byteSize,usage:e,mappedAtCreation:!1}),this.memory.allocation(this.byteSize),this.node=this.memory.allocation_node(this.byteSize)}}var ti=(i=>(i[i.split=0]="split",i[i.compose=1]="compose",i))(ti||{});class jl{constructor(){o(this,"vertexCount",0),o(this,"vertexGPUBuffer"),o(this,"geometryType",ti.compose),o(this,"_vertexBufferLayouts"),o(this,"_attributeSlotLayouts"),o(this,"_attributeLocation"),this._vertexBufferLayouts=[],this._attributeLocation={},this._attributeSlotLayouts=[]}get vertexBufferLayouts(){return this._vertexBufferLayouts}createVertexBuffer(e,t){switch(this.geometryType){case ti.split:this.createSplitVertexBuffer(e,t);break;case ti.compose:this.createComposeVertexBuffer(e,t);break}}createSplitVertexBuffer(e,t){let r=0;for(let s=0;s<t.attributes.length;s++){const a=t.attributes[s];if(a.name=="index")continue;this._attributeLocation[a.name]=a.location;let n={name:a.name,format:a.format,offset:0,shaderLocation:a.location,stride:bi[a.format]};this._attributeSlotLayouts[a.location]=[n];let l=e.get(a.name);l||(l={attribute:a.name,data:new Float32Array(a.size*this.vertexCount)},e.set(a.name,l));let h=l.data.length/n.stride;this.vertexCount!=0&&this.vertexCount!=h&&console.error(" vertex count not match attribute count"),this.vertexCount=h,this._vertexBufferLayouts[a.location]={name:a.name,arrayStride:a.size*4,stepMode:"vertex",attributes:this._attributeSlotLayouts[a.location],offset:r*4,size:this.vertexCount*a.size*4},r+=this.vertexCount*a.size}this.vertexGPUBuffer=new ho(r)}createComposeVertexBuffer(e,t){this._attributeSlotLayouts[0]=[];let r=0;for(let s=0;s<t.attributes.length;s++){const a=t.attributes[s];if(a.name=="index"||a.type=="builtin")continue;this._attributeLocation[a.name]=a.location;let n={name:a.name,format:a.format,offset:r*4,shaderLocation:a.location,stride:bi[a.format]};this._attributeSlotLayouts[0][a.location]=n;let l=e.get(a.name);l||(l={attribute:a.name,data:new Float32Array(a.size*this.vertexCount)},e.set(a.name,l));let h=l.data.length/n.stride;this.vertexCount!=0&&this.vertexCount!=h&&console.error(" vertex count not match attribute count"),this.vertexCount=h,r+=a.size}this._vertexBufferLayouts[0]={name:"composeStruct",arrayStride:r*4,stepMode:"vertex",attributes:this._attributeSlotLayouts[0],offset:0,size:this.vertexCount*r*4},this.vertexGPUBuffer=new ho(this.vertexCount*r)}upload(e,t){var r;if(this.vertexGPUBuffer){switch(this.geometryType){case ti.split:{let s=this._attributeLocation[e],a=this._vertexBufferLayouts[s];this.vertexGPUBuffer.node.setFloat32Array(a.offset/4,t.data)}break;case ti.compose:for(let s=0;s<this.vertexCount;s++){const a=this._attributeSlotLayouts[0][this._attributeLocation[e]];for(let n=0;n<a.stride;n++){let l=t.data[s*a.stride+n],h=s*(this._vertexBufferLayouts[0].arrayStride/4)+a.offset/4+n;this.vertexGPUBuffer.node.setFloat(l,h)}}break}(r=this.vertexGPUBuffer)==null||r.apply()}}updateAttributes(e){switch(this.geometryType){case ti.split:for(let t=0;t<this._vertexBufferLayouts.length;t++){const r=this._vertexBufferLayouts[t];let s=e.get(r.name);this.vertexGPUBuffer.node.setFloat32Array(r.offset/4,s.data)}break;case ti.compose:for(let t=0;t<this.vertexCount;t++)this._attributeSlotLayouts.forEach(r=>{for(let s=0;s<r.length;s++){const a=r[s];let n=e.get(a.name);for(let l=0;l<a.stride;l++){let h=n.data[t*a.stride+l],u=t*(this._vertexBufferLayouts[0].arrayStride/4)+a.offset/4+l;this.vertexGPUBuffer.node.setFloat(h,u)}}});break}this.vertexGPUBuffer.apply()}compute(){}destroy(e){this.vertexCount=null,this.geometryType=null,this._vertexBufferLayouts=null,this._attributeSlotLayouts=null,this._attributeLocation=null,this.vertexGPUBuffer&&this.vertexGPUBuffer.destroy(e),this.vertexGPUBuffer=null}}class ql extends Jt{constructor(e){super(),o(this,"indicesNode"),this.bufferType=Mt.IndicesGPUBuffer,this.createIndicesBuffer(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.INDEX|GPUBufferUsage.INDIRECT,e)}createIndicesBuffer(e,t){let r=S.device;this.byteSize=t.length*4,this.usage=e,this.buffer&&this.destroy(),this.buffer=r.createBuffer({size:this.byteSize,usage:e,mappedAtCreation:!1}),this.memory.allocation(this.byteSize),t&&(this.indicesNode=this.memory.allocation_node(t.length*4),this.indicesNode.setArrayBuffer(0,t),this.apply())}}class Kl{constructor(){o(this,"uuid",""),o(this,"name"),o(this,"indicesGPUBuffer"),o(this,"indicesFormat","uint16"),o(this,"indicesCount",0)}createIndicesBuffer(e){e.data instanceof Uint16Array?this.indicesFormat="uint16":e.data instanceof Uint32Array&&(this.indicesFormat="uint32"),this.indicesCount=e.data.length,this.indicesGPUBuffer=new ql(e.data)}upload(e){this.indicesGPUBuffer.indicesNode.setArrayBuffer(0,e),this.indicesGPUBuffer.apply()}compute(){}destroy(){this.uuid=null,this.name=null,this.indicesFormat=null,this.indicesCount=null,this.indicesGPUBuffer.destroy(),this.indicesGPUBuffer=null}}class Jl{constructor(){o(this,"lodLevels")}}const Ti=class{constructor(){o(this,"instanceID"),o(this,"name"),o(this,"subGeometries",[]),o(this,"morphTargetsRelative"),o(this,"morphTargetDictionary"),o(this,"_bounds"),o(this,"_attributeMap"),o(this,"_attributes"),o(this,"_indicesBuffer"),o(this,"_vertexBuffer"),o(this,"_onChange",!0),this.instanceID=Pt(),this._attributeMap=new Map,this._attributes=[],this._vertexBuffer=new jl}get indicesBuffer(){return this._indicesBuffer}get vertexBuffer(){return this._vertexBuffer}get vertexAttributes(){return this._attributes}get vertexAttributeMap(){return this._attributeMap}get geometryType(){return this._vertexBuffer.geometryType}set geometryType(i){this._vertexBuffer.geometryType=i}get bounds(){if(!this._bounds){this._bounds=new Be(new g,new g(1,1,1)),this._bounds.min.x=Number.MAX_VALUE,this._bounds.min.y=Number.MAX_VALUE,this._bounds.min.z=Number.MAX_VALUE,this._bounds.max.x=-Number.MAX_VALUE,this._bounds.max.y=-Number.MAX_VALUE,this._bounds.max.z=-Number.MAX_VALUE;let i=this.getAttribute(Y.position);if(i)for(let e=0;e<i.data.length/3;e++){const t=i.data[e*3+0],r=i.data[e*3+1],s=i.data[e*3+2];this._bounds.min.x>t&&(this._bounds.min.x=t),this._bounds.min.y>r&&(this._bounds.min.y=r),this._bounds.min.z>s&&(this._bounds.min.z=s),this._bounds.max.x<t&&(this._bounds.max.x=t),this._bounds.max.y<r&&(this._bounds.max.y=r),this._bounds.max.z<s&&(this._bounds.max.z=s)}this._bounds.setFromMinMax(this._bounds.min,this._bounds.max)}return this._bounds}set bounds(i){this._bounds=i}addSubGeometry(...i){let e=new Jl;e.lodLevels=i,this.subGeometries.push(e)}generate(i){this._onChange&&(this._onChange=!1,this._indicesBuffer.upload(this.getAttribute(Y.indices).data),this._vertexBuffer.createVertexBuffer(this._attributeMap,i),this._vertexBuffer.updateAttributes(this._attributeMap))}setIndices(i){if(!this._attributeMap.has(Y.indices)){let e={attribute:Y.indices,data:i};this._attributeMap.set(Y.indices,e),this._indicesBuffer=new Kl,this._indicesBuffer.createIndicesBuffer(e)}}setAttribute(i,e){if(i==Y.indices)this.setIndices(e);else{let t={attribute:i,data:e};this._attributeMap.set(i,t),this._attributes.push(i)}}getAttribute(i){return this._attributeMap.get(i)}hasAttribute(i){return this._attributeMap.has(i)}genWireframe(){let i=this.getAttribute("position"),e=this.getAttribute("indices");if(e&&i&&e.data.length>0){let t=i.data,r=[];for(let s=0;s<e.data.length/3;s++){const a=e.data[s*3+0],n=e.data[s*3+1],l=e.data[s*3+2];let h=new g(t[a*3+0],t[a*3+1],t[a*3+2]),u=new g(t[n*3+0],t[n*3+1],t[n*3+2]),c=new g(t[l*3+0],t[l*3+1],t[l*3+2]);r.push(h,u),r.push(u,c),r.push(c,h)}return r}return null}compute(){this._indicesBuffer&&this._indicesBuffer.compute(),this._vertexBuffer&&this._vertexBuffer.compute()}computeNormals(){let i=this.getAttribute(Y.position),e=this.getAttribute(Y.normal),t=this.getAttribute(Y.indices);if(!i||!e||!t)return this;let r=t.data.length/3,s=Ti.point1,a=Ti.point2,n=Ti.point3,l=Ti.crossA,h=Ti.crossB,u=Ti.crossRet;for(let c=0;c<r;c++){let f=t.data[c*3],d=t.data[c*3+1],p=t.data[c*3+2];s.set(i.data[f*3],i.data[f*3+1],i.data[f*3+2]),a.set(i.data[d*3],i.data[d*3+1],i.data[d*3+2]),n.set(i.data[p*3],i.data[p*3+1],i.data[p*3+2]),g.sub(s,a,l).normalize(),g.sub(s,n,h).normalize();let m=l.crossProduct(h,u).normalize();e.data[f*3]=e.data[d*3]=e.data[p*3]=m.x,e.data[f*3+1]=e.data[d*3+1]=e.data[p*3+1]=m.y,e.data[f*3+2]=e.data[d*3+2]=e.data[p*3+2]=m.z}return this._vertexBuffer.upload(Y.normal,e),this}isPrimitive(){return!1}destroy(i){this.instanceID=null,this.name=null,this.subGeometries=null,this.morphTargetDictionary=null,this._bounds.destroy(),this._bounds=null,this._attributeMap=null,this._attributes=null,this._indicesBuffer.destroy(),this._vertexBuffer.destroy(),this._indicesBuffer=null,this._vertexBuffer=null}};let tt=Ti;o(tt,"crossA",g.UP.clone()),o(tt,"crossB",g.UP.clone()),o(tt,"crossRet",g.UP.clone()),o(tt,"point1",g.UP.clone()),o(tt,"point2",g.UP.clone()),o(tt,"point3",g.UP.clone());class Zl extends tt{constructor(e,t,r=1,s=1,a=g.Y_AXIS){super(),o(this,"width"),o(this,"height"),o(this,"segmentW"),o(this,"segmentH"),o(this,"up"),this.width=e,this.height=t,this.segmentW=r,this.segmentH=s,this.up=a,this.buildGeometry(this.up)}buildGeometry(e){var t,r,s,a,n=this.segmentW+1;(this.segmentH+1)*n,this.bounds=new Be(g.ZERO.clone(),new g(this.width,1,this.height)),s=this.segmentH*this.segmentW*6;let l=(this.segmentW+1)*(this.segmentH+1),h=new Float32Array(l*3),u=new Float32Array(l*3),c=new Float32Array(l*2),f;this.segmentW*this.segmentH*2*3>=Uint16Array.length?f=new Uint32Array(this.segmentW*this.segmentH*2*3):f=new Uint16Array(this.segmentW*this.segmentH*2*3),s=0;for(var p=0,m=0,_=0,v=0;v<=this.segmentH;++v)for(var y=0;y<=this.segmentW;++y){switch(t=(y/this.segmentW-.5)*this.width,r=(v/this.segmentH-.5)*this.height,e){case g.Y_AXIS:h[p++]=t,h[p++]=0,h[p++]=r,u[m++]=0,u[m++]=1,u[m++]=0;break;case g.Z_AXIS:h[p++]=t,h[p++]=-r,h[p++]=0,u[m++]=0,u[m++]=0,u[m++]=1;break;case g.X_AXIS:h[p++]=0,h[p++]=t,h[p++]=r,u[m++]=1,u[m++]=0,u[m++]=0;break;default:h[p++]=t,h[p++]=0,h[p++]=r,u[m++]=0,u[m++]=1,u[m++]=0;break}c[_++]=y/this.segmentW,c[_++]=v/this.segmentH,y!=this.segmentW&&v!=this.segmentH&&(a=y+v*n,f[s++]=a+1,f[s++]=a,f[s++]=a+n,f[s++]=a+1,f[s++]=a+n,f[s++]=a+n+1)}this.setIndices(f),this.setAttribute(Y.position,h),this.setAttribute(Y.normal,u),this.setAttribute(Y.uv,c),this.setAttribute(Y.TEXCOORD_1,c),this.addSubGeometry({indexStart:0,indexCount:f.length,vertexStart:0,index:0})}}class Ns extends te{constructor(e="QuadGlsl_vs",t="QuadGlsl_fs",r,s,a=0,n=!1){super(),o(this,"width",128),o(this,"height",128),o(this,"quadRenderer"),o(this,"material"),o(this,"uniforms"),o(this,"rendererPassState"),o(this,"pass");let l=r?r.attachments:[];this.material=new _i,this.pass=new We(e,t),this.material.addPass(re.COLOR,this.pass),this.pass.blendMode=xe.NONE;let h=this.pass.shaderState;h.frontFace="cw",h.depthWriteEnabled=!1,h.depthCompare=vt.always,h.multisample=a,this.uniforms=this.pass.uniforms=s||{color:new $(new z)},this.quadRenderer=this.addComponent(ce),this.quadRenderer.material=this.material,this.quadRenderer.castGI=!1,this.quadRenderer.castShadow=!1,this.quadRenderer.drawType=n?2:0,this.quadRenderer.geometry=new Zl(100,100,1,1),this.colorTexture=A.res.blackTexture,this.pass.setUniformFloat("x",0),this.pass.setUniformFloat("y",0),this.pass.setUniformFloat("width",100),this.pass.setUniformFloat("height",100),this.quadRenderer.material=this.material,this.quadRenderer.__start(),this.quadRenderer._enable=!0,this.quadRenderer.onEnable(),this.rendererPassState=He.createRendererPassState(r,"load"),h.multisample>0&&(this.rendererPassState.multisample=h.multisample,this.rendererPassState.multiTexture=S.device.createTexture({size:{width:S.presentationSize[0],height:S.presentationSize[1]},sampleCount:h.multisample,format:l.length>0?l[0].format:S.presentationFormat,usage:GPUTextureUsage.RENDER_ATTACHMENT}))}set colorTexture(e){this.material.getPass(re.COLOR)[0].setTexture("baseMap",e)}renderTarget(e,t,r){let s=e.camera,a=w.beginRenderPass(r,t.rendererPassState);w.bindCamera(a,s),t.quadRenderer.nodeUpdate(e,re.COLOR,t.rendererPassState,null),t.quadRenderer.renderPass2(e,re.COLOR,t.rendererPassState,null,a),w.endPass(a)}renderToViewQuad(e,t,r,s){let a=e.camera;t.colorTexture=s;let n=w.beginRenderPass(r,t.rendererPassState);w.bindCamera(n,a),t.quadRenderer.nodeUpdate(e,re.COLOR,t.rendererPassState,null),t.quadRenderer.renderPass2(e,re.COLOR,t.rendererPassState,null,n),w.endPass(n)}}class oe extends at{constructor(e,t,r=G.rgba8unorm,s=!1,a,n=1,l=0,h=!0){super(e,t,n),o(this,"resolveTarget");let u=S.device;this.name=Pt(),a!=null?this.usage=a:this.usage=GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC|GPUTextureUsage.COPY_DST,this.createTextureDescriptor(e,t,1,r,this.usage,n,l),this.useMipmap=!1,this.visibility=GPUShaderStage.COMPUTE|GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,r==G.rgba32float?(this.samplerBindingLayout.type="non-filtering",this.textureBindingLayout.sampleType="unfilterable-float",this.gpuSampler=u.createSampler({})):r==G.depth32float?(this.samplerBindingLayout.type="filtering",this.sampler_comparisonBindingLayout.type="comparison",this.textureBindingLayout.sampleType="depth",this.gpuSampler=S.device.createSampler({}),this.gpuSampler_comparison=S.device.createSampler({compare:"less",label:"sampler_comparison"})):r==G.depth24plus?(this.samplerBindingLayout={type:"filtering"},this.sampler_comparisonBindingLayout={type:"comparison"},this.textureBindingLayout.sampleType="depth",this.gpuSampler=S.device.createSampler({}),this.gpuSampler_comparison=S.device.createSampler({compare:"less",label:"sampler_comparison"})):(this.samplerBindingLayout.type="filtering",this.textureBindingLayout.sampleType="float",l>0&&(this.textureBindingLayout.multisampled=!0),this.minFilter="linear",this.magFilter="linear",this.mipmapFilter="linear",this.maxAnisotropy=16,this.addressModeU=Bt.clamp_to_edge,this.addressModeV=Bt.clamp_to_edge,this.gpuSampler=u.createSampler(this))}create(e,t,r=!0){let s=S.device;const a=e*4;let n=new Float32Array(e*t*4);const l=s.createBuffer({size:n.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC});s.queue.writeBuffer(l,0,n);const h=w.beginCommandEncoder();h.copyBufferToTexture({buffer:l,bytesPerRow:a},{texture:this.getGPUTexture()},{width:e,height:t,depthOrArrayLayers:1}),w.endCommandEncoder(h)}readTextureToImage(){let e=S.device,t=S.windowWidth,r=S.windowHeight,s=new Float32Array(t*r*4);const a=e.createBuffer({size:s.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC});return w.beginCommandEncoder().copyTextureToBuffer({texture:this.getGPUTexture()},{buffer:a},[t,r]),a.getMappedRange(0,s.byteLength)}}class Ce{constructor(){o(this,"storeOp","store"),o(this,"loadOp","clear"),o(this,"clearValue",[0,0,0,0])}}class Ze{constructor(e,t,r,s,a=!0){o(this,"label"),o(this,"customSize",!1),o(this,"attachments"),o(this,"rtDescriptors"),o(this,"zPreTexture"),o(this,"depthTexture"),o(this,"depthViewIndex",0),o(this,"depthCleanValue",1),o(this,"depthLoadOp","clear"),o(this,"isOutTarget",!0),this.attachments=e,this.rtDescriptors=t,this.depthTexture=r,this.zPreTexture=s,this.isOutTarget=a}clone2Frame(e){e.attachments.push(...this.attachments.concat());for(let t=0;t<this.rtDescriptors.length;t++){const r=this.rtDescriptors[t];let s=new Ce;s.loadOp=r.loadOp,s.storeOp=r.storeOp,s.clearValue=r.clearValue,e.rtDescriptors.push(s)}e.depthTexture=this.depthTexture,e.zPreTexture=this.zPreTexture,e.customSize=this.customSize}clone(){let e=new Ze([],[]);return this.clone2Frame(e),e}}const Fs=class{static init(){this.rtTextureMap=new Map,this.rtViewQuad=new Map}static createRTTexture(i,e,t,r,s=!1,a=0){let n=this.rtTextureMap.get(i);return n||(i==Ae.colorBufferTex_NAME?n=new oe(e,t,r,s,void 0,1,a,!1):n=new oe(e,t,r,s,void 0,1,a,!0),n.name=i,Fs.rtTextureMap.set(i,n)),n}static createRTTextureArray(i,e,t,r,s=1,a=!1,n=0){let l=this.rtTextureMap.get(i);return l||(l=new oe(e,t,r,a,void 0,s,n),l.name=i,Fs.rtTextureMap.set(i,l)),l}static createViewQuad(i,e,t,r,s,a=0){let n=new Ze([r],[new Ce]),l=new Ns(e,t,n,s,a);return Fs.rtViewQuad.set(i,l),l}static getTexture(i){return this.rtTextureMap.get(i)}static CreateSplitTexture(i){let e=this.getTexture(Ae.colorBufferTex_NAME),t=this.getTexture(i+"_split");return t||(t=this.createRTTexture(i+"_split",e.width,e.height,e.format,!1)),t}static WriteSplitColorTexture(i){let e=this.getTexture(Ae.colorBufferTex_NAME),t=this.getTexture(i+"_split");const r=w.beginCommandEncoder();r.copyTextureToTexture({texture:e.getGPUTexture(),mipLevel:0,origin:{x:0,y:0,z:0}},{texture:t.getGPUTexture(),mipLevel:0,origin:{x:0,y:0,z:0}},{width:t.width,height:t.height,depthOrArrayLayers:1}),w.endCommandEncoder(r)}};let Fe=Fs;o(Fe,"rtTextureMap"),o(Fe,"rtViewQuad");class Ct{constructor(){o(this,"enable",!0),o(this,"postRenderer"),o(this,"rtViewQuad"),o(this,"virtualTexture"),this.rtViewQuad=new Map,this.virtualTexture=new Map}createRTTexture(e,t,r,s,a=!1,n=0){let l=Fe.createRTTexture(e,t,r,s,a,n);return l.name=e,this.virtualTexture.set(e,l),se.getInstance().attached(l,this),l}createViewQuad(e,t,r,s,a=0){let n=Fe.createViewQuad(e,"Quad_vert_wgsl",t,r,s,a);return this.rtViewQuad.set(e,n),n}getOutTexture(){let e,t=w.lastRenderPassState.renderTargets;return t.length>0?e=t[0]:e=Fe.getTexture(Ae.colorBufferTex_NAME),e}autoSetColorTexture(e,t){let r=this.getOutTexture();t.setSamplerTexture(e,r)}compute(e){}onAttach(e){}onDetach(e){}render(e,t){this.compute(e),this.rtViewQuad.forEach((r,s)=>{let a=w.lastRenderPassState.getLastRenderTexture();r.renderToViewQuad(e,r,t,a)})}destroy(e){this.postRenderer=null;for(let t=0;t<this.rtViewQuad.size;t++)this.rtViewQuad.values[t].destroy(e);this.rtViewQuad.clear(),this.rtViewQuad=null;for(let t=0;t<this.virtualTexture.size;t++){const r=this.virtualTexture.values[t];se.getInstance().detached(r,this),r.destroy(e)}}}class uo extends Ct{constructor(){super();let e=S.presentationSize;Fe.createRTTexture(Ae.colorBufferTex_NAME,e[0],e[1],G.rgba16float,!1),N.register("FXAA_Shader",Ic);let t={u_texel:new $(new Z(1/e[0],1/e[1])),u_strength:new $(4)},r=this.createRTTexture("FXAAPost",e[0],e[1],G.rgba16float);this.createViewQuad("fxaa","FXAA_Shader",r,t)}onAttach(e){A.setting.render.postProcessing.fxaa.enable=!0}onDetach(e){A.setting.render.postProcessing.fxaa.enable=!1}}class $l{constructor(e){o(this,"command"),o(this,"encoder"),o(this,"rendererPassStates"),o(this,"rtFrame"),this.rtFrame=e,this.rendererPassStates=[]}clean(){this.rendererPassStates.length=0,w.cleanCache()}beginContinueRendererPassState(){if(this.rendererPassStates.length>0){let e=this.rtFrame.clone();for(const r of e.rtDescriptors)r.loadOp="load";e.depthLoadOp="load";let t=He.createRendererPassState(e);return this.rendererPassStates.push(t),t}else{let e=He.createRendererPassState(this.rtFrame);return this.rendererPassStates.push(e),e}}get rendererPassState(){return this.rendererPassStates[this.rendererPassStates.length-1]}beginRenderPass(){this.beginContinueRendererPassState(),this.begineNewCommand(),this.beginNewEncoder()}endRenderPass(){this.endEncoder(),this.endCommand()}begineNewCommand(){return this.command=w.beginCommandEncoder(),this.command}endCommand(){w.endCommandEncoder(this.command),this.command=null}beginNewEncoder(){return this.encoder=w.beginRenderPass(this.command,this.rendererPassState),this.encoder}endEncoder(){w.endPass(this.encoder),this.encoder=null}}class di extends hi{constructor(){super(),o(this,"rendererPassState"),o(this,"splitRendererPassState"),o(this,"useRenderBundle",!1),o(this,"debugViewQuads"),o(this,"debugTextures"),o(this,"renderContext"),o(this,"_rendererType"),o(this,"_rtFrame"),this.debugTextures=[],this.debugViewQuads=[]}get passType(){return this._rendererType}set passType(e){this._rendererType=e}setRenderStates(e){if(this._rtFrame=e,e){this.rendererPassState=He.createRendererPassState(e);let t=e.clone();t.depthLoadOp="load";for(const r of t.rtDescriptors)r.loadOp="load";this.splitRendererPassState=He.createRendererPassState(t)}this.renderContext=new $l(e)}setIrradiance(e,t){this.rendererPassState.irradianceBuffer=[e,t]}compute(e,t){}render(e,t,r,s=!1){w.cleanCache();let a=e.camera,n=e.scene;this.rendererPassState.camera3D=a;let l=Q.instance.getRenderNodes(n,a),h=this.renderBundleOp(e,l,t,r),u=s?[]:this.renderBundleTr(e,l,t,r);{let c=w.beginCommandEncoder(),f=w.beginRenderPass(c,this.rendererPassState);h.length>0&&f.executeBundles(h),!s&&Q.instance.sky&&(w.bindCamera(f,a),Q.instance.sky.renderPass2(e,this._rendererType,this.rendererPassState,r,f)),this.drawRenderNodes(e,f,c,l.opaqueList,t),w.endPass(f),w.endCommandEncoder(c)}{let c=w.beginCommandEncoder(),f=w.beginRenderPass(c,this.rendererPassState);u.length>0&&f.executeBundles(u),s||(w.bindCamera(f,a),this.drawRenderNodes(e,f,c,l.transparentList,t)),w.endPass(f),w.endCommandEncoder(c)}}nodeUpload(e,t,r){}occlusionRenderNodeTest(e,t,r){return r?r.occlusionRenderNodeTest(e)>0:!0}renderOp(e,t,r,s,a){}renderTr(e,t,r,s,a){}renderBundleOp(e,t,r,s){let a=Q.instance.getOpRenderGroup(e.scene);if(a){let n=[];return a.renderGroup.forEach(l=>{if(l.bundleMap.has(this._rendererType))n.push(l.bundleMap.get(this._rendererType));else{let h=w.recordBundleEncoder(this.rendererPassState.renderBundleEncoderDescriptor);this.recordRenderBundleNode(e,h,l.renderNodes,s);let u=h.finish();l.bundleMap.set(this._rendererType,u),n.push(u)}}),n}return[]}renderBundleTr(e,t,r,s){let a=Q.instance.getTrRenderGroup(e.scene);if(a){let n=[];return a.renderGroup.forEach(l=>{if(l.bundleMap.has(this._rendererType))n.push(l.bundleMap.get(this._rendererType));else{let h=w.recordBundleEncoder(this.rendererPassState.renderBundleEncoderDescriptor);this.recordRenderBundleNode(e,h,l.renderNodes,s);let u=h.finish();l.bundleMap.set(this._rendererType,u),n.push(u)}}),n}return[]}recordRenderBundleNode(e,t,r,s){w.bindCamera(t,e.camera),w.bindGeometryBuffer(t,r[0].geometry);for(let a=0;a<r.length;++a){let n=r[a];n.transform.worldMatrix.index,n.transform.enable&&n.recordRenderPass2(e,this._rendererType,this.rendererPassState,s,t)}}drawRenderNodes(e,t,r,s,a,n){w.bindCamera(t,e.camera);for(let l=A.setting.render.drawOpMin;l<Math.min(s.length,A.setting.render.drawOpMax);++l){let h=s[l];h.transform.enable&&h.enable&&h.renderPass2(e,this._rendererType,this.rendererPassState,n,t)}}setDebugTexture(e){for(let t=0;t<e.length;t++){let r=e[t],s="Quad_vert_wgsl",a="Quad_frag_wgsl";switch(r.format){case G.rgba8sint:case G.rgba8uint:case G.rgba8unorm:case G.rgba16float:case G.rgba32float:a="Quad_frag_wgsl";break;case G.depth24plus:case G.depth32float:a="Quad_depth2d_frag_wgsl",r.textureBindingLayout.viewDimension=="cube"&&(a="Quad_depthCube_frag_wgsl");break}let n=new Ns(s,a,new Ze([],[]));this.debugTextures.push(e[t]),this.debugViewQuads.push(n)}}}class eh extends di{constructor(){super(),this.passType=re.COLOR}render(e,t,r,s=!1){this.renderContext.clean();let a=e.scene,n=e.camera;this.rendererPassState.camera3D=n;let l=Q.instance.getRenderNodes(a,n),h=this.renderBundleOp(e,l,t,r),u=s?[]:this.renderBundleTr(e,l,t,r);ft.start("colorPass Renderer");{ft.start("ColorPass Draw Opaque"),this.renderContext.beginRenderPass(),this.renderContext.command;let c=this.renderContext.encoder;w.bindCamera(c,n),h.length>0&&(Q.instance.getOpRenderGroup(a),c.executeBundles(h)),!s&&Q.instance.sky&&(w.bindCamera(c,n),Q.instance.sky.preInit||Q.instance.sky.nodeUpdate(e,this._rendererType,this.rendererPassState,r),Q.instance.sky.renderPass2(e,this._rendererType,this.rendererPassState,r,c)),l.opaqueList&&(w.bindCamera(c,n),this.drawNodes(e,this.renderContext,l.opaqueList,t,r),this.renderContext.endRenderPass(),ft.end("ColorPass Draw Opaque"))}{ft.start("ColorPass Draw Transparent"),this.renderContext.beginRenderPass(),this.renderContext.command;let c=this.renderContext.encoder;u.length>0&&c.executeBundles(u),!s&&l.transparentList&&(w.bindCamera(c,n),this.drawNodes(e,this.renderContext,l.transparentList,t,r));let f=Q.instance.getGraphicList();for(let d=0;d<f.length;d++){const p=f[d];p.transform.worldMatrix.index,p.nodeUpdate(e,this._rendererType,this.splitRendererPassState,r),p.renderPass2(e,this._rendererType,this.splitRendererPassState,r,c)}this.renderContext.endRenderPass(),ft.end("ColorPass Draw Transparent")}ft.end("colorPass Renderer")}drawNodes(e,t,r,s,a){{let n=Q.instance.getRenderShaderCollect(e);for(const l of n){let h=l[1];for(const u of h){let c=u[1];if(c.preInit){c.nodeUpdate(e,this._rendererType,this.rendererPassState,a);break}}}for(let l=A.setting.render.drawOpMin;l<Math.min(r.length,A.setting.render.drawOpMax);++l){let h=r[l];h.transform.enable&&h.enable&&(h.preInit||h.nodeUpdate(e,this._rendererType,this.rendererPassState,a),h.renderPass(e,this.passType,this.renderContext))}}}occlusionRenderNodeTest(e,t,r){return r.zDepthRenderNodeTest(t)>0}}const tr=class extends Ze{constructor(){super([],[])}crateGBuffer(i,e,t){let r=this.attachments,s=this.rtDescriptors,a=Fe.createRTTexture(i+Ae.colorBufferTex_NAME,e,t,G.rgba16float,!1),n=Fe.createRTTexture(i+Ae.positionBufferTex_NAME,e,t,G.rgba16float,!1),l=Fe.createRTTexture(i+Ae.normalBufferTex_NAME,e,t,G.rgba8unorm,!1),h=Fe.createRTTexture(i+Ae.materialBufferTex_NAME,e,t,G.rgba8unorm,!1);r.push(a),r.push(n),r.push(l),r.push(h);let u=new Ce;u.loadOp="clear";let c=new oe(e,t,G.depth32float,!1);c.name="depthTexture";let f=new Ce;f.loadOp="load",this.depthTexture=c,s.push(u),s.push(new Ce),s.push(new Ce),s.push(new Ce)}getColorMap(){return this.attachments[0]}getPositionMap(){return this.attachments[1]}getNormalMap(){return this.attachments[2]}getMaterialMap(){return this.attachments[3]}static getGBufferFrame(i){let e;if(tr.gBufferMap.has(i))e=tr.gBufferMap.get(i);else{e=new tr;let t=S.presentationSize;e.crateGBuffer(i,t[0],t[1]),tr.gBufferMap.set(i,e)}return e}clone(){let i=new tr;return this.clone2Frame(i),i}};let wt=tr;o(wt,"gBufferMap",new Map);class ks{constructor(){o(this,"frustumCullingList"),o(this,"zVisibleList"),o(this,"_renderList"),this._renderList=new Map}occlusionRenderNodeTest(e){return A.setting.occlusionQuery.enable?this.frustumCullingList?this.frustumCullingList[e]:0:1}zDepthRenderNodeTest(e){return this.zVisibleList?this.zVisibleList[e]:0}update(e,t){}collect(e,t){}renderCommitTesting(e,t){return!0}}o(ks,"enable",!0);class ir extends Jt{constructor(e,t){super(),this.bufferType=Mt.ComputeGPUBuffer,this.createBuffer(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST,e,t)}}class th{constructor(e,t){o(this,"clusterBuffer"),o(this,"lightAssignBuffer"),o(this,"assignTableBuffer"),o(this,"clustersUniformBuffer"),this.clusterBuffer=new ir(e*2*4),this.clustersUniformBuffer=new Dt(10),this.clustersUniformBuffer.visibility=GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,this.lightAssignBuffer=new ir(e*t),this.lightAssignBuffer.visibility=GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,this.assignTableBuffer=new ir(e*4),this.assignTableBuffer.visibility=GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE}update(e,t,r,s,a,n,l,h,u,c){this.clustersUniformBuffer.setFloat("clusterTileX",s),this.clustersUniformBuffer.setFloat("clusterTileY",a),this.clustersUniformBuffer.setFloat("clusterTileZ",n),this.clustersUniformBuffer.setFloat("numLights",l),this.clustersUniformBuffer.setFloat("maxNumLightsPerCluster",h),this.clustersUniformBuffer.setFloat("near",u),this.clustersUniformBuffer.setFloat("far",c),this.clustersUniformBuffer.setFloat("screenWidth",e),this.clustersUniformBuffer.setFloat("screenHeight",t),this.clustersUniformBuffer.setFloat("clusterPix",r),this.clustersUniformBuffer.apply()}}class ke{}o(ke,"clusterTileX",16),o(ke,"clusterTileY",16),o(ke,"clusterTileZ",32);let ih=`
  #include "GlobalUniform"

        struct ClusterBox{
            minPoint:vec4<f32>,
            maxPoint:vec4<f32>
        }

        struct ClustersUniform{
            clusterTileX:f32,
            clusterTileY:f32,
            clusterTileZ:f32,
            numLights:f32,
            maxNumLightsPerCluster:f32,
            near:f32,
            far:f32,
            screenWidth:f32,
            screenHeight:f32,
            clusterPix:f32
        }
     
        @group(0) @binding(1) var<uniform> clustersUniform : ClustersUniform;
        @group(0) @binding(2) var<storage,read_write> clusterBuffer : array<ClusterBox>;


        var<private> clusterTileX:f32 ;
        var<private> clusterTileY:f32 ;
        var<private> clusterTileZ:f32 ;
        fn convertNDCToView( v4:vec4<f32> ) -> vec4<f32> {
            var v = globalUniform.pvMatrixInv * v4 ;
            v = v / v.w ;
            return v ;
        }

        fn gridToIndex(i:vec3<u32>) -> u32{
            return i.z * u32(clusterTileX) * u32(clusterTileY) + i.y * u32(clusterTileX) + i.x ;
        }

        fn ScreenToView(screen : vec4<f32>) -> vec4<f32> {
            let texCoord = screen.xy / vec2<f32>(clustersUniform.screenWidth, clustersUniform.screenHeight);
            let clip = vec4<f32>(vec2<f32>(texCoord.x, 1.0 - texCoord.y) * 2.0 - vec2<f32>(1.0, 1.0), screen.z, screen.w);
            return convertNDCToView(clip);
          }

        fn LineIntersectionToZPlane( eye:vec3<f32> , ndcPoint :vec3<f32> , z:f32) -> vec3<f32>
        {
            var normal = vec3<f32>(0.0, 0.0, 1.0);
            var dir = ndcPoint - eye;
            var t = (z - dot(normal, eye)) / dot(normal, dir);
            var result = eye + t * dir;
            return result;
        }

        @compute @workgroup_size(${ke.clusterTileX},${ke.clusterTileY},1)
        fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(local_invocation_id) local_invocation_id : vec3<u32> ){

            let i = local_invocation_id.x ;
            let j = local_invocation_id.y ;
            let k = workgroup_id.x ;

            clusterTileX = clustersUniform.clusterTileX;
            clusterTileY = clustersUniform.clusterTileY;
            clusterTileZ = clustersUniform.clusterTileZ;

            let clusterGrid = vec3<u32>(i,j,k);
            let tileIndex = gridToIndex(clusterGrid);
            let eyePos = vec3<f32>(0.0, 0.0, 0.0);

            let tx = clusterTileX;
            let ty = clusterTileY;
            let tz = clusterTileZ ;
            let near = clustersUniform.near ;
            let far = clustersUniform.far ;

            let titleSize = vec2<f32>( globalUniform.windowWidth / tx , globalUniform.windowHeight / ty ) ;

            var maxPointSs = vec4<f32>(vec2<f32>(f32(i) + 1.0, f32(j) + 1.0) * titleSize, 0.0, 1.0);
	        var minPointSs = vec4<f32>(vec2<f32>(f32(i) , f32(j)) * titleSize, 0.0, 1.0);

            var maxPointVs = ScreenToView(maxPointSs).xyz;
	        var minPointVs = ScreenToView(minPointSs).xyz;
 
            var tileNear = clustersUniform.near * pow(clustersUniform.far / clustersUniform.near, f32(k) / clustersUniform.clusterTileZ);
	        var tileFar = clustersUniform.near * pow(clustersUniform.far / clustersUniform.near, (f32(k) + 1.0) / clustersUniform.clusterTileZ);

            var minPointNear = LineIntersectionToZPlane(eyePos, minPointVs, tileNear);
            var minPointFar = LineIntersectionToZPlane(eyePos, minPointVs, tileFar);
            var maxPointNear = LineIntersectionToZPlane(eyePos, maxPointVs, tileNear);
            var maxPointFar = LineIntersectionToZPlane(eyePos, maxPointVs, tileFar);

            var minPointAABB = min(min(minPointNear, minPointFar), min(maxPointNear, maxPointFar));
            var maxPointAABB = max(max(minPointNear, minPointFar), max(maxPointNear, maxPointFar));

            var clusterBox : ClusterBox ;
            clusterBox.minPoint = vec4<f32>(minPointAABB,f32(tileIndex)) ;
            clusterBox.maxPoint = vec4<f32>(maxPointAABB,f32(tileIndex)) ;
            clusterBuffer[tileIndex] = clusterBox;
        }
`,rh=`
#include "GlobalUniform"

struct ClusterBox{
    min:vec4<f32>,
    max:vec4<f32>
}

struct Light {
    index:f32,
    lightType:i32,
    radius:f32,
    linear:f32,

    position:vec3<f32>,
    lightMatrixIndex:f32,

    direction:vec3<f32>,
    quadratic:f32,

    lightColor:vec3<f32>,
    intensity:f32,

    innerCutOff :f32,
    outerCutOff:f32,
    range :f32,
    castShadow:f32,

    lightTangent:vec3<f32>,
    ies:f32,
};

struct LightIndex
{
    count:f32,
    start:f32,
    empty0:f32,
    empty1:f32,
};

struct ClustersUniform{
    clusterTileX:f32,
    clusterTileY:f32,
    clusterTileZ:f32,
    numLights:f32,
    maxNumLightsPerCluster:f32,
    near:f32,
    far:f32,
    screenWidth:f32,
    screenHeight:f32,
    clusterPix:f32, 
}

var<private> clusterTileX:f32 ;
var<private> clusterTileY:f32 ;
var<private> clusterTileZ:f32 ;

// @group(0) @binding(1) var<storage, read> models : Uniforms;
@group(0) @binding(1) var<uniform> clustersUniform : ClustersUniform;
@group(0) @binding(2) var<storage,read> clusterBuffer : array<ClusterBox>;
@group(0) @binding(3) var<storage,read> lightBuffer : array<Light>; 
@group(0) @binding(4) var<storage,read_write> lightAssignBuffer : array<f32>;
@group(0) @binding(5) var<storage,read_write> assignTable : array<LightIndex>;

fn gridToIndex(i:vec3<u32>) -> u32{
    return i.z * u32(clusterTileX) * u32(clusterTileY) + i.y * u32(clusterTileX) + i.x ;
}

fn GetSqdisPointAABB( pos:vec3<f32>,  cluster:ClusterBox  ) -> f32
{
    var sqDistance = 0.0;
    for (var i = 0u; i < 3u; i+=1u)
    {
        var v = pos[i];
        if (v < cluster.min[i])
        {
            let diff = cluster.min[i] - v;
            sqDistance += diff * diff;
        }

        if (v > cluster.max[i])
        {
            let diff =  v - cluster.max[i];
            sqDistance += diff * diff;
        }
    }
    return sqDistance;
}

fn TestSphereAABB( box:ClusterBox ,light:Light ) -> bool
{
    let lightPos = light.position.xyz;
    var radius = light.range * 2.0 ;
    var spherePos = globalUniform.viewMat * vec4<f32>(lightPos.xyz, 1.0) ;
    spherePos = spherePos / spherePos.w ;
    let sqDistance = GetSqdisPointAABB(spherePos.xyz , box);
    return sqDistance <= (radius*radius);
}

@compute @workgroup_size(${ke.clusterTileX},${ke.clusterTileY},1)
fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(local_invocation_id) local_invocation_id : vec3<u32> ){
    // cluster ID 
    let i = local_invocation_id.x ;
    let j = local_invocation_id.y ;
    let k = workgroup_id.x ;

    clusterTileX = clustersUniform.clusterTileX;
    clusterTileY = clustersUniform.clusterTileY;
    clusterTileZ = clustersUniform.clusterTileZ;

    var clusterId_3D = vec3<u32>(i,j,k);
    var clusterId_1D = gridToIndex(clusterId_3D);

    var box:ClusterBox = clusterBuffer[clusterId_1D];

    var startIndex = i32(clusterId_1D) * i32(clustersUniform.maxNumLightsPerCluster) ;
    var endIndex = startIndex;

    for(var lightID = 0 ; lightID < i32(clustersUniform.numLights) ; lightID+=1)
    {
        let li:Light = lightBuffer[lightID];
        if(!TestSphereAABB(box, li)) {
            continue;
        }
        lightAssignBuffer[endIndex] = f32(lightID);
        endIndex++;
    }

    var idx: LightIndex;
    idx.count = f32(endIndex-startIndex);
    idx.start = f32(startIndex);
    idx.empty0 = f32(clusterId_1D);
    idx.empty1 = f32(clustersUniform.maxNumLightsPerCluster);
    assignTable[clusterId_1D] = idx;
}
`;function jd(i){if(i&&!(typeof window>"u")){var e=document.createElement("style");return e.setAttribute("type","text/css"),e.innerHTML=i,document.head.appendChild(e),i}}function rr(i,e){var t=i.__state.conversionName.toString(),r=Math.round(i.r),s=Math.round(i.g),a=Math.round(i.b),n=i.a,l=Math.round(i.h),h=i.s.toFixed(1),u=i.v.toFixed(1);if(e||t==="THREE_CHAR_HEX"||t==="SIX_CHAR_HEX"){for(var c=i.hex.toString(16);c.length<6;)c="0"+c;return"#"+c}else{if(t==="CSS_RGB")return"rgb("+r+","+s+","+a+")";if(t==="CSS_RGBA")return"rgba("+r+","+s+","+a+","+n+")";if(t==="HEX")return"0x"+i.hex.toString(16);if(t==="RGB_ARRAY")return"["+r+","+s+","+a+"]";if(t==="RGBA_ARRAY")return"["+r+","+s+","+a+","+n+"]";if(t==="RGB_OBJ")return"{r:"+r+",g:"+s+",b:"+a+"}";if(t==="RGBA_OBJ")return"{r:"+r+",g:"+s+",b:"+a+",a:"+n+"}";if(t==="HSV_OBJ")return"{h:"+l+",s:"+h+",v:"+u+"}";if(t==="HSVA_OBJ")return"{h:"+l+",s:"+h+",v:"+u+",a:"+n+"}"}return"unknown format"}var sh=Array.prototype.forEach,Kr=Array.prototype.slice,U={BREAK:{},extend:function(e){return this.each(Kr.call(arguments,1),function(t){var r=this.isObject(t)?Object.keys(t):[];r.forEach(function(s){this.isUndefined(t[s])||(e[s]=t[s])}.bind(this))},this),e},defaults:function(e){return this.each(Kr.call(arguments,1),function(t){var r=this.isObject(t)?Object.keys(t):[];r.forEach(function(s){this.isUndefined(e[s])&&(e[s]=t[s])}.bind(this))},this),e},compose:function(){var e=Kr.call(arguments);return function(){for(var t=Kr.call(arguments),r=e.length-1;r>=0;r--)t=[e[r].apply(this,t)];return t[0]}},each:function(e,t,r){if(e){if(sh&&e.forEach&&e.forEach===sh)e.forEach(t,r);else if(e.length===e.length+0){var s=void 0,a=void 0;for(s=0,a=e.length;s<a;s++)if(s in e&&t.call(r,e[s],s)===this.BREAK)return}else for(var n in e)if(t.call(r,e[n],n)===this.BREAK)return}},defer:function(e){setTimeout(e,0)},debounce:function(e,t,r){var s=void 0;return function(){var a=this,n=arguments;function l(){s=null,r||e.apply(a,n)}var h=r||!s;clearTimeout(s),s=setTimeout(l,t),h&&e.apply(a,n)}},toArray:function(e){return e.toArray?e.toArray():Kr.call(e)},isUndefined:function(e){return e===void 0},isNull:function(e){return e===null},isNaN:function(i){function e(t){return i.apply(this,arguments)}return e.toString=function(){return i.toString()},e}(function(i){return isNaN(i)}),isArray:Array.isArray||function(i){return i.constructor===Array},isObject:function(e){return e===Object(e)},isNumber:function(e){return e===e+0},isString:function(e){return e===e+""},isBoolean:function(e){return e===!1||e===!0},isFunction:function(e){return e instanceof Function}},qd=[{litmus:U.isString,conversions:{THREE_CHAR_HEX:{read:function(e){var t=e.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);return t===null?!1:{space:"HEX",hex:parseInt("0x"+t[1].toString()+t[1].toString()+t[2].toString()+t[2].toString()+t[3].toString()+t[3].toString(),0)}},write:rr},SIX_CHAR_HEX:{read:function(e){var t=e.match(/^#([A-F0-9]{6})$/i);return t===null?!1:{space:"HEX",hex:parseInt("0x"+t[1].toString(),0)}},write:rr},CSS_RGB:{read:function(e){var t=e.match(/^rgb\(\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*\)/);return t===null?!1:{space:"RGB",r:parseFloat(t[1]),g:parseFloat(t[2]),b:parseFloat(t[3])}},write:rr},CSS_RGBA:{read:function(e){var t=e.match(/^rgba\(\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*\)/);return t===null?!1:{space:"RGB",r:parseFloat(t[1]),g:parseFloat(t[2]),b:parseFloat(t[3]),a:parseFloat(t[4])}},write:rr}}},{litmus:U.isNumber,conversions:{HEX:{read:function(e){return{space:"HEX",hex:e,conversionName:"HEX"}},write:function(e){return e.hex}}}},{litmus:U.isArray,conversions:{RGB_ARRAY:{read:function(e){return e.length!==3?!1:{space:"RGB",r:e[0],g:e[1],b:e[2]}},write:function(e){return[e.r,e.g,e.b]}},RGBA_ARRAY:{read:function(e){return e.length!==4?!1:{space:"RGB",r:e[0],g:e[1],b:e[2],a:e[3]}},write:function(e){return[e.r,e.g,e.b,e.a]}}}},{litmus:U.isObject,conversions:{RGBA_OBJ:{read:function(e){return U.isNumber(e.r)&&U.isNumber(e.g)&&U.isNumber(e.b)&&U.isNumber(e.a)?{space:"RGB",r:e.r,g:e.g,b:e.b,a:e.a}:!1},write:function(e){return{r:e.r,g:e.g,b:e.b,a:e.a}}},RGB_OBJ:{read:function(e){return U.isNumber(e.r)&&U.isNumber(e.g)&&U.isNumber(e.b)?{space:"RGB",r:e.r,g:e.g,b:e.b}:!1},write:function(e){return{r:e.r,g:e.g,b:e.b}}},HSVA_OBJ:{read:function(e){return U.isNumber(e.h)&&U.isNumber(e.s)&&U.isNumber(e.v)&&U.isNumber(e.a)?{space:"HSV",h:e.h,s:e.s,v:e.v,a:e.a}:!1},write:function(e){return{h:e.h,s:e.s,v:e.v,a:e.a}}},HSV_OBJ:{read:function(e){return U.isNumber(e.h)&&U.isNumber(e.s)&&U.isNumber(e.v)?{space:"HSV",h:e.h,s:e.s,v:e.v}:!1},write:function(e){return{h:e.h,s:e.s,v:e.v}}}}}],Jr=void 0,zs=void 0,co=function(){zs=!1;var e=arguments.length>1?U.toArray(arguments):arguments[0];return U.each(qd,function(t){if(t.litmus(e))return U.each(t.conversions,function(r,s){if(Jr=r.read(e),zs===!1&&Jr!==!1)return zs=Jr,Jr.conversionName=s,Jr.conversion=r,U.BREAK}),U.BREAK}),zs},ah=void 0,Gs={hsv_to_rgb:function(e,t,r){var s=Math.floor(e/60)%6,a=e/60-Math.floor(e/60),n=r*(1-t),l=r*(1-a*t),h=r*(1-(1-a)*t),u=[[r,h,n],[l,r,n],[n,r,h],[n,l,r],[h,n,r],[r,n,l]][s];return{r:u[0]*255,g:u[1]*255,b:u[2]*255}},rgb_to_hsv:function(e,t,r){var s=Math.min(e,t,r),a=Math.max(e,t,r),n=a-s,l=void 0,h=void 0;if(a!==0)h=n/a;else return{h:NaN,s:0,v:0};return e===a?l=(t-r)/n:t===a?l=2+(r-e)/n:l=4+(e-t)/n,l/=6,l<0&&(l+=1),{h:l*360,s:h,v:a/255}},rgb_to_hex:function(e,t,r){var s=this.hex_with_component(0,2,e);return s=this.hex_with_component(s,1,t),s=this.hex_with_component(s,0,r),s},component_from_hex:function(e,t){return e>>t*8&255},hex_with_component:function(e,t,r){return r<<(ah=t*8)|e&~(255<<ah)}},Kd=typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?function(i){return typeof i}:function(i){return i&&typeof Symbol=="function"&&i.constructor===Symbol&&i!==Symbol.prototype?"symbol":typeof i},Rt=function(i,e){if(!(i instanceof e))throw new TypeError("Cannot call a class as a function")},Lt=function(){function i(e,t){for(var r=0;r<t.length;r++){var s=t[r];s.enumerable=s.enumerable||!1,s.configurable=!0,"value"in s&&(s.writable=!0),Object.defineProperty(e,s.key,s)}}return function(e,t,r){return t&&i(e.prototype,t),r&&i(e,r),e}}(),gi=function i(e,t,r){e===null&&(e=Function.prototype);var s=Object.getOwnPropertyDescriptor(e,t);if(s===void 0){var a=Object.getPrototypeOf(e);return a===null?void 0:i(a,t,r)}else{if("value"in s)return s.value;var n=s.get;return n===void 0?void 0:n.call(r)}},pi=function(i,e){if(typeof e!="function"&&e!==null)throw new TypeError("Super expression must either be null or a function, not "+typeof e);i.prototype=Object.create(e&&e.prototype,{constructor:{value:i,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(i,e):i.__proto__=e)},mi=function(i,e){if(!i)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e&&(typeof e=="object"||typeof e=="function")?e:i},Ye=function(){function i(){if(Rt(this,i),this.__state=co.apply(this,arguments),this.__state===!1)throw new Error("Failed to interpret color arguments");this.__state.a=this.__state.a||1}return Lt(i,[{key:"toString",value:function(){return rr(this)}},{key:"toHexString",value:function(){return rr(this,!0)}},{key:"toOriginal",value:function(){return this.__state.conversion.write(this)}}]),i}();function fo(i,e,t){Object.defineProperty(i,e,{get:function(){return this.__state.space==="RGB"?this.__state[e]:(Ye.recalculateRGB(this,e,t),this.__state[e])},set:function(s){this.__state.space!=="RGB"&&(Ye.recalculateRGB(this,e,t),this.__state.space="RGB"),this.__state[e]=s}})}function go(i,e){Object.defineProperty(i,e,{get:function(){return this.__state.space==="HSV"?this.__state[e]:(Ye.recalculateHSV(this),this.__state[e])},set:function(r){this.__state.space!=="HSV"&&(Ye.recalculateHSV(this),this.__state.space="HSV"),this.__state[e]=r}})}Ye.recalculateRGB=function(i,e,t){if(i.__state.space==="HEX")i.__state[e]=Gs.component_from_hex(i.__state.hex,t);else if(i.__state.space==="HSV")U.extend(i.__state,Gs.hsv_to_rgb(i.__state.h,i.__state.s,i.__state.v));else throw new Error("Corrupted color state")},Ye.recalculateHSV=function(i){var e=Gs.rgb_to_hsv(i.r,i.g,i.b);U.extend(i.__state,{s:e.s,v:e.v}),U.isNaN(e.h)?U.isUndefined(i.__state.h)&&(i.__state.h=0):i.__state.h=e.h},Ye.COMPONENTS=["r","g","b","h","s","v","hex","a"],fo(Ye.prototype,"r",2),fo(Ye.prototype,"g",1),fo(Ye.prototype,"b",0),go(Ye.prototype,"h"),go(Ye.prototype,"s"),go(Ye.prototype,"v"),Object.defineProperty(Ye.prototype,"a",{get:function(){return this.__state.a},set:function(e){this.__state.a=e}}),Object.defineProperty(Ye.prototype,"hex",{get:function(){return this.__state.space!=="HEX"&&(this.__state.hex=Gs.rgb_to_hex(this.r,this.g,this.b),this.__state.space="HEX"),this.__state.hex},set:function(e){this.__state.space="HEX",this.__state.hex=e}});var Mi=function(){function i(e,t){Rt(this,i),this.initialValue=e[t],this.domElement=document.createElement("div"),this.object=e,this.property=t,this.__onChange=void 0,this.__onFinishChange=void 0}return Lt(i,[{key:"onChange",value:function(t){return this.__onChange=t,this}},{key:"onFinishChange",value:function(t){return this.__onFinishChange=t,this}},{key:"setValue",value:function(t){return this.object[this.property]=t,this.__onChange&&this.__onChange.call(this,t),this.updateDisplay(),this}},{key:"getValue",value:function(){return this.object[this.property]}},{key:"updateDisplay",value:function(){return this}},{key:"isModified",value:function(){return this.initialValue!==this.getValue()}}]),i}(),Jd={HTMLEvents:["change"],MouseEvents:["click","mousemove","mousedown","mouseup","mouseover"],KeyboardEvents:["keydown"]},oh={};U.each(Jd,function(i,e){U.each(i,function(t){oh[t]=e})});var Zd=/(\d+(\.\d+)?)px/;function Yt(i){if(i==="0"||U.isUndefined(i))return 0;var e=i.match(Zd);return U.isNull(e)?0:parseFloat(e[1])}var E={makeSelectable:function(e,t){e===void 0||e.style===void 0||(e.onselectstart=t?function(){return!1}:function(){},e.style.MozUserSelect=t?"auto":"none",e.style.KhtmlUserSelect=t?"auto":"none",e.unselectable=t?"on":"off")},makeFullscreen:function(e,t,r){var s=r,a=t;U.isUndefined(a)&&(a=!0),U.isUndefined(s)&&(s=!0),e.style.position="absolute",a&&(e.style.left=0,e.style.right=0),s&&(e.style.top=0,e.style.bottom=0)},fakeEvent:function(e,t,r,s){var a=r||{},n=oh[t];if(!n)throw new Error("Event type "+t+" not supported.");var l=document.createEvent(n);switch(n){case"MouseEvents":{var h=a.x||a.clientX||0,u=a.y||a.clientY||0;l.initMouseEvent(t,a.bubbles||!1,a.cancelable||!0,window,a.clickCount||1,0,0,h,u,!1,!1,!1,!1,0,null);break}case"KeyboardEvents":{var c=l.initKeyboardEvent||l.initKeyEvent;U.defaults(a,{cancelable:!0,ctrlKey:!1,altKey:!1,shiftKey:!1,metaKey:!1,keyCode:void 0,charCode:void 0}),c(t,a.bubbles||!1,a.cancelable,window,a.ctrlKey,a.altKey,a.shiftKey,a.metaKey,a.keyCode,a.charCode);break}default:{l.initEvent(t,a.bubbles||!1,a.cancelable||!0);break}}U.defaults(l,s),e.dispatchEvent(l)},bind:function(e,t,r,s){var a=s||!1;return e.addEventListener?e.addEventListener(t,r,a):e.attachEvent&&e.attachEvent("on"+t,r),E},unbind:function(e,t,r,s){var a=s||!1;return e.removeEventListener?e.removeEventListener(t,r,a):e.detachEvent&&e.detachEvent("on"+t,r),E},addClass:function(e,t){if(e.className===void 0)e.className=t;else if(e.className!==t){var r=e.className.split(/ +/);r.indexOf(t)===-1&&(r.push(t),e.className=r.join(" ").replace(/^\s+/,"").replace(/\s+$/,""))}return E},removeClass:function(e,t){if(t)if(e.className===t)e.removeAttribute("class");else{var r=e.className.split(/ +/),s=r.indexOf(t);s!==-1&&(r.splice(s,1),e.className=r.join(" "))}else e.className=void 0;return E},hasClass:function(e,t){return new RegExp("(?:^|\\s+)"+t+"(?:\\s+|$)").test(e.className)||!1},getWidth:function(e){var t=getComputedStyle(e);return Yt(t["border-left-width"])+Yt(t["border-right-width"])+Yt(t["padding-left"])+Yt(t["padding-right"])+Yt(t.width)},getHeight:function(e){var t=getComputedStyle(e);return Yt(t["border-top-width"])+Yt(t["border-bottom-width"])+Yt(t["padding-top"])+Yt(t["padding-bottom"])+Yt(t.height)},getOffset:function(e){var t=e,r={left:0,top:0};if(t.offsetParent)do r.left+=t.offsetLeft,r.top+=t.offsetTop,t=t.offsetParent;while(t);return r},isActive:function(e){return e===document.activeElement&&(e.type||e.href)}},nh=function(i){pi(e,i);function e(t,r){Rt(this,e);var s=mi(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t,r)),a=s;s.__prev=s.getValue(),s.__checkbox=document.createElement("input"),s.__checkbox.setAttribute("type","checkbox");function n(){a.setValue(!a.__prev)}return E.bind(s.__checkbox,"change",n,!1),s.domElement.appendChild(s.__checkbox),s.updateDisplay(),s}return Lt(e,[{key:"setValue",value:function(r){var s=gi(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"setValue",this).call(this,r);return this.__onFinishChange&&this.__onFinishChange.call(this,this.getValue()),this.__prev=this.getValue(),s}},{key:"updateDisplay",value:function(){return this.getValue()===!0?(this.__checkbox.setAttribute("checked","checked"),this.__checkbox.checked=!0,this.__prev=!0):(this.__checkbox.checked=!1,this.__prev=!1),gi(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"updateDisplay",this).call(this)}}]),e}(Mi),$d=function(i){pi(e,i);function e(t,r,s){Rt(this,e);var a=mi(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t,r)),n=s,l=a;if(a.__select=document.createElement("select"),U.isArray(n)){var h={};U.each(n,function(u){h[u]=u}),n=h}return U.each(n,function(u,c){var f=document.createElement("option");f.innerHTML=c,f.setAttribute("value",u),l.__select.appendChild(f)}),a.updateDisplay(),E.bind(a.__select,"change",function(){var u=this.options[this.selectedIndex].value;l.setValue(u)}),a.domElement.appendChild(a.__select),a}return Lt(e,[{key:"setValue",value:function(r){var s=gi(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"setValue",this).call(this,r);return this.__onFinishChange&&this.__onFinishChange.call(this,this.getValue()),s}},{key:"updateDisplay",value:function(){return E.isActive(this.__select)?this:(this.__select.value=this.getValue(),gi(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"updateDisplay",this).call(this))}}]),e}(Mi),eg=function(i){pi(e,i);function e(t,r){Rt(this,e);var s=mi(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t,r)),a=s;function n(){a.setValue(a.__input.value)}function l(){a.__onFinishChange&&a.__onFinishChange.call(a,a.getValue())}return s.__input=document.createElement("input"),s.__input.setAttribute("type","text"),E.bind(s.__input,"keyup",n),E.bind(s.__input,"change",n),E.bind(s.__input,"blur",l),E.bind(s.__input,"keydown",function(h){h.keyCode===13&&this.blur()}),s.updateDisplay(),s.domElement.appendChild(s.__input),s}return Lt(e,[{key:"updateDisplay",value:function(){return E.isActive(this.__input)||(this.__input.value=this.getValue()),gi(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"updateDisplay",this).call(this)}}]),e}(Mi);function lh(i){var e=i.toString();return e.indexOf(".")>-1?e.length-e.indexOf(".")-1:0}var hh=function(i){pi(e,i);function e(t,r,s){Rt(this,e);var a=mi(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t,r)),n=s||{};return a.__min=n.min,a.__max=n.max,a.__step=n.step,U.isUndefined(a.__step)?a.initialValue===0?a.__impliedStep=1:a.__impliedStep=Math.pow(10,Math.floor(Math.log(Math.abs(a.initialValue))/Math.LN10))/10:a.__impliedStep=a.__step,a.__precision=lh(a.__impliedStep),a}return Lt(e,[{key:"setValue",value:function(r){var s=r;return this.__min!==void 0&&s<this.__min?s=this.__min:this.__max!==void 0&&s>this.__max&&(s=this.__max),this.__step!==void 0&&s%this.__step!==0&&(s=Math.round(s/this.__step)*this.__step),gi(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"setValue",this).call(this,s)}},{key:"min",value:function(r){return this.__min=r,this}},{key:"max",value:function(r){return this.__max=r,this}},{key:"step",value:function(r){return this.__step=r,this.__impliedStep=r,this.__precision=lh(r),this}}]),e}(Mi);function tg(i,e){var t=Math.pow(10,e);return Math.round(i*t)/t}var Qs=function(i){pi(e,i);function e(t,r,s){Rt(this,e);var a=mi(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t,r,s));a.__truncationSuspended=!1;var n=a,l=void 0;function h(){var m=parseFloat(n.__input.value);U.isNaN(m)||n.setValue(m)}function u(){n.__onFinishChange&&n.__onFinishChange.call(n,n.getValue())}function c(){u()}function f(m){var _=l-m.clientY;n.setValue(n.getValue()+_*n.__impliedStep),l=m.clientY}function d(){E.unbind(window,"mousemove",f),E.unbind(window,"mouseup",d),u()}function p(m){E.bind(window,"mousemove",f),E.bind(window,"mouseup",d),l=m.clientY}return a.__input=document.createElement("input"),a.__input.setAttribute("type","text"),E.bind(a.__input,"change",h),E.bind(a.__input,"blur",c),E.bind(a.__input,"mousedown",p),E.bind(a.__input,"keydown",function(m){m.keyCode===13&&(n.__truncationSuspended=!0,this.blur(),n.__truncationSuspended=!1,u())}),a.updateDisplay(),a.domElement.appendChild(a.__input),a}return Lt(e,[{key:"updateDisplay",value:function(){return this.__input.value=this.__truncationSuspended?this.getValue():tg(this.getValue(),this.__precision),gi(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"updateDisplay",this).call(this)}}]),e}(hh);function uh(i,e,t,r,s){return r+(s-r)*((i-e)/(t-e))}var po=function(i){pi(e,i);function e(t,r,s,a,n){Rt(this,e);var l=mi(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t,r,{min:s,max:a,step:n})),h=l;l.__background=document.createElement("div"),l.__foreground=document.createElement("div"),E.bind(l.__background,"mousedown",u),E.bind(l.__background,"touchstart",d),E.addClass(l.__background,"slider"),E.addClass(l.__foreground,"slider-fg");function u(_){document.activeElement.blur(),E.bind(window,"mousemove",c),E.bind(window,"mouseup",f),c(_)}function c(_){_.preventDefault();var v=h.__background.getBoundingClientRect();return h.setValue(uh(_.clientX,v.left,v.right,h.__min,h.__max)),!1}function f(){E.unbind(window,"mousemove",c),E.unbind(window,"mouseup",f),h.__onFinishChange&&h.__onFinishChange.call(h,h.getValue())}function d(_){_.touches.length===1&&(E.bind(window,"touchmove",p),E.bind(window,"touchend",m),p(_))}function p(_){var v=_.touches[0].clientX,y=h.__background.getBoundingClientRect();h.setValue(uh(v,y.left,y.right,h.__min,h.__max))}function m(){E.unbind(window,"touchmove",p),E.unbind(window,"touchend",m),h.__onFinishChange&&h.__onFinishChange.call(h,h.getValue())}return l.updateDisplay(),l.__background.appendChild(l.__foreground),l.domElement.appendChild(l.__background),l}return Lt(e,[{key:"updateDisplay",value:function(){var r=(this.getValue()-this.__min)/(this.__max-this.__min);return this.__foreground.style.width=r*100+"%",gi(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"updateDisplay",this).call(this)}}]),e}(hh),ch=function(i){pi(e,i);function e(t,r,s){Rt(this,e);var a=mi(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t,r)),n=a;return a.__button=document.createElement("div"),a.__button.innerHTML=s===void 0?"Fire":s,E.bind(a.__button,"click",function(l){return l.preventDefault(),n.fire(),!1}),E.addClass(a.__button,"button"),a.domElement.appendChild(a.__button),a}return Lt(e,[{key:"fire",value:function(){this.__onChange&&this.__onChange.call(this),this.getValue().call(this.object),this.__onFinishChange&&this.__onFinishChange.call(this,this.getValue())}}]),e}(Mi),mo=function(i){pi(e,i);function e(t,r){Rt(this,e);var s=mi(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t,r));s.__color=new Ye(s.getValue()),s.__temp=new Ye(0);var a=s;s.domElement=document.createElement("div"),E.makeSelectable(s.domElement,!1),s.__selector=document.createElement("div"),s.__selector.className="selector",s.__saturation_field=document.createElement("div"),s.__saturation_field.className="saturation-field",s.__field_knob=document.createElement("div"),s.__field_knob.className="field-knob",s.__field_knob_border="2px solid ",s.__hue_knob=document.createElement("div"),s.__hue_knob.className="hue-knob",s.__hue_field=document.createElement("div"),s.__hue_field.className="hue-field",s.__input=document.createElement("input"),s.__input.type="text",s.__input_textShadow="0 1px 1px ",E.bind(s.__input,"keydown",function(_){_.keyCode===13&&f.call(this)}),E.bind(s.__input,"blur",f),E.bind(s.__selector,"mousedown",function(){E.addClass(this,"drag").bind(window,"mouseup",function(){E.removeClass(a.__selector,"drag")})}),E.bind(s.__selector,"touchstart",function(){E.addClass(this,"drag").bind(window,"touchend",function(){E.removeClass(a.__selector,"drag")})});var n=document.createElement("div");U.extend(s.__selector.style,{width:"122px",height:"102px",padding:"3px",backgroundColor:"#222",boxShadow:"0px 1px 3px rgba(0,0,0,0.3)"}),U.extend(s.__field_knob.style,{position:"absolute",width:"12px",height:"12px",border:s.__field_knob_border+(s.__color.v<.5?"#fff":"#000"),boxShadow:"0px 1px 3px rgba(0,0,0,0.5)",borderRadius:"12px",zIndex:1}),U.extend(s.__hue_knob.style,{position:"absolute",width:"15px",height:"2px",borderRight:"4px solid #fff",zIndex:1}),U.extend(s.__saturation_field.style,{width:"100px",height:"100px",border:"1px solid #555",marginRight:"3px",display:"inline-block",cursor:"pointer"}),U.extend(n.style,{width:"100%",height:"100%",background:"none"}),fh(n,"top","rgba(0,0,0,0)","#000"),U.extend(s.__hue_field.style,{width:"15px",height:"100px",border:"1px solid #555",cursor:"ns-resize",position:"absolute",top:"3px",right:"3px"}),rg(s.__hue_field),U.extend(s.__input.style,{outline:"none",textAlign:"center",color:"#fff",border:0,fontWeight:"bold",textShadow:s.__input_textShadow+"rgba(0,0,0,0.7)"}),E.bind(s.__saturation_field,"mousedown",l),E.bind(s.__saturation_field,"touchstart",l),E.bind(s.__field_knob,"mousedown",l),E.bind(s.__field_knob,"touchstart",l),E.bind(s.__hue_field,"mousedown",h),E.bind(s.__hue_field,"touchstart",h);function l(_){p(_),E.bind(window,"mousemove",p),E.bind(window,"touchmove",p),E.bind(window,"mouseup",u),E.bind(window,"touchend",u)}function h(_){m(_),E.bind(window,"mousemove",m),E.bind(window,"touchmove",m),E.bind(window,"mouseup",c),E.bind(window,"touchend",c)}function u(){E.unbind(window,"mousemove",p),E.unbind(window,"touchmove",p),E.unbind(window,"mouseup",u),E.unbind(window,"touchend",u),d()}function c(){E.unbind(window,"mousemove",m),E.unbind(window,"touchmove",m),E.unbind(window,"mouseup",c),E.unbind(window,"touchend",c),d()}function f(){var _=co(this.value);_!==!1?(a.__color.__state=_,a.setValue(a.__color.toOriginal())):this.value=a.__color.toString()}function d(){a.__onFinishChange&&a.__onFinishChange.call(a,a.__color.toOriginal())}s.__saturation_field.appendChild(n),s.__selector.appendChild(s.__field_knob),s.__selector.appendChild(s.__saturation_field),s.__selector.appendChild(s.__hue_field),s.__hue_field.appendChild(s.__hue_knob),s.domElement.appendChild(s.__input),s.domElement.appendChild(s.__selector),s.updateDisplay();function p(_){_.type.indexOf("touch")===-1&&_.preventDefault();var v=a.__saturation_field.getBoundingClientRect(),y=_.touches&&_.touches[0]||_,C=y.clientX,B=y.clientY,T=(C-v.left)/(v.right-v.left),M=1-(B-v.top)/(v.bottom-v.top);return M>1?M=1:M<0&&(M=0),T>1?T=1:T<0&&(T=0),a.__color.v=M,a.__color.s=T,a.setValue(a.__color.toOriginal()),!1}function m(_){_.type.indexOf("touch")===-1&&_.preventDefault();var v=a.__hue_field.getBoundingClientRect(),y=_.touches&&_.touches[0]||_,C=y.clientY,B=1-(C-v.top)/(v.bottom-v.top);return B>1?B=1:B<0&&(B=0),a.__color.h=B*360,a.setValue(a.__color.toOriginal()),!1}return s}return Lt(e,[{key:"updateDisplay",value:function(){var r=co(this.getValue());if(r!==!1){var s=!1;U.each(Ye.COMPONENTS,function(l){if(!U.isUndefined(r[l])&&!U.isUndefined(this.__color.__state[l])&&r[l]!==this.__color.__state[l])return s=!0,{}},this),s&&U.extend(this.__color.__state,r)}U.extend(this.__temp.__state,this.__color.__state),this.__temp.a=1;var a=this.__color.v<.5||this.__color.s>.5?255:0,n=255-a;U.extend(this.__field_knob.style,{marginLeft:100*this.__color.s-7+"px",marginTop:100*(1-this.__color.v)-7+"px",backgroundColor:this.__temp.toHexString(),border:this.__field_knob_border+"rgb("+a+","+a+","+a+")"}),this.__hue_knob.style.marginTop=(1-this.__color.h/360)*100+"px",this.__temp.s=1,this.__temp.v=1,fh(this.__saturation_field,"left","#fff",this.__temp.toHexString()),this.__input.value=this.__color.toString(),U.extend(this.__input.style,{backgroundColor:this.__color.toHexString(),color:"rgb("+a+","+a+","+a+")",textShadow:this.__input_textShadow+"rgba("+n+","+n+","+n+",.7)"})}}]),e}(Mi),ig=["-moz-","-o-","-webkit-","-ms-",""];function fh(i,e,t,r){i.style.background="",U.each(ig,function(s){i.style.cssText+="background: "+s+"linear-gradient("+e+", "+t+" 0%, "+r+" 100%); "})}function rg(i){i.style.background="",i.style.cssText+="background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);",i.style.cssText+="background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);",i.style.cssText+="background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);",i.style.cssText+="background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);",i.style.cssText+="background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);"}var sg={load:function(e,t){var r=t||document,s=r.createElement("link");s.type="text/css",s.rel="stylesheet",s.href=e,r.getElementsByTagName("head")[0].appendChild(s)},inject:function(e,t){var r=t||document,s=document.createElement("style");s.type="text/css",s.innerHTML=e;var a=r.getElementsByTagName("head")[0];try{a.appendChild(s)}catch{}}},ag=`<div id="dg-save" class="dg dialogue">

  Here's the new load parameter for your <code>GUI</code>'s constructor:

  <textarea id="dg-new-constructor"></textarea>

  <div id="dg-save-locally">

    <input id="dg-local-storage" type="checkbox"/> Automatically save
    values to <code>localStorage</code> on exit.

    <div id="dg-local-explain">The values saved to <code>localStorage</code> will
      override those passed to <code>dat.GUI</code>'s constructor. This makes it
      easier to work incrementally, but <code>localStorage</code> is fragile,
      and your friends may not see the same values you do.

    </div>

  </div>

</div>`,og=function(e,t){var r=e[t];return U.isArray(arguments[2])||U.isObject(arguments[2])?new $d(e,t,arguments[2]):U.isNumber(r)?U.isNumber(arguments[2])&&U.isNumber(arguments[3])?U.isNumber(arguments[4])?new po(e,t,arguments[2],arguments[3],arguments[4]):new po(e,t,arguments[2],arguments[3]):U.isNumber(arguments[4])?new Qs(e,t,{min:arguments[2],max:arguments[3],step:arguments[4]}):new Qs(e,t,{min:arguments[2],max:arguments[3]}):U.isString(r)?new eg(e,t):U.isFunction(r)?new ch(e,t,""):U.isBoolean(r)?new nh(e,t):null};function ng(i){setTimeout(i,1e3/60)}var lg=window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.oRequestAnimationFrame||window.msRequestAnimationFrame||ng,hg=function(){function i(){Rt(this,i),this.backgroundElement=document.createElement("div"),U.extend(this.backgroundElement.style,{backgroundColor:"rgba(0,0,0,0.8)",top:0,left:0,display:"none",zIndex:"1000",opacity:0,WebkitTransition:"opacity 0.2s linear",transition:"opacity 0.2s linear"}),E.makeFullscreen(this.backgroundElement),this.backgroundElement.style.position="fixed",this.domElement=document.createElement("div"),U.extend(this.domElement.style,{position:"fixed",display:"none",zIndex:"1001",opacity:0,WebkitTransition:"-webkit-transform 0.2s ease-out, opacity 0.2s linear",transition:"transform 0.2s ease-out, opacity 0.2s linear"}),document.body.appendChild(this.backgroundElement),document.body.appendChild(this.domElement);var e=this;E.bind(this.backgroundElement,"click",function(){e.hide()})}return Lt(i,[{key:"show",value:function(){var t=this;this.backgroundElement.style.display="block",this.domElement.style.display="block",this.domElement.style.opacity=0,this.domElement.style.webkitTransform="scale(1.1)",this.layout(),U.defer(function(){t.backgroundElement.style.opacity=1,t.domElement.style.opacity=1,t.domElement.style.webkitTransform="scale(1)"})}},{key:"hide",value:function(){var t=this,r=function s(){t.domElement.style.display="none",t.backgroundElement.style.display="none",E.unbind(t.domElement,"webkitTransitionEnd",s),E.unbind(t.domElement,"transitionend",s),E.unbind(t.domElement,"oTransitionEnd",s)};E.bind(this.domElement,"webkitTransitionEnd",r),E.bind(this.domElement,"transitionend",r),E.bind(this.domElement,"oTransitionEnd",r),this.backgroundElement.style.opacity=0,this.domElement.style.opacity=0,this.domElement.style.webkitTransform="scale(1.1)"}},{key:"layout",value:function(){this.domElement.style.left=window.innerWidth/2-E.getWidth(this.domElement)/2+"px",this.domElement.style.top=window.innerHeight/2-E.getHeight(this.domElement)/2+"px"}}]),i}(),ug=jd(`.dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear;border:0;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button.close-top{position:relative}.dg.main .close-button.close-bottom{position:absolute}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-y:visible}.dg.a.has-save>ul.close-top{margin-top:0}.dg.a.has-save>ul.close-bottom{margin-top:27px}.dg.a.has-save>ul.closed{margin-top:0}.dg.a .save-row{top:0;z-index:1002}.dg.a .save-row.close-top{position:relative}.dg.a .save-row.close-bottom{position:fixed}.dg li{-webkit-transition:height .1s ease-out;-o-transition:height .1s ease-out;-moz-transition:height .1s ease-out;transition:height .1s ease-out;-webkit-transition:overflow .1s linear;-o-transition:overflow .1s linear;-moz-transition:overflow .1s linear;transition:overflow .1s linear}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li>*{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px;overflow:hidden}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .cr.function .property-name{width:100%}.dg .c{float:left;width:60%;position:relative}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:7px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .cr.color{overflow:visible}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.color{border-left:3px solid}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2FA1D6}.dg .cr.number input[type=text]{color:#2FA1D6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2FA1D6;max-width:100%}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}
`);sg.inject(ug);var dh="dg",gh=72,ph=20,Zr="Default",$r=function(){try{return!!window.localStorage}catch{return!1}}(),es=void 0,mh=!0,sr=void 0,Ao=!1,Ah=[],ve=function i(e){var t=this,r=e||{};this.domElement=document.createElement("div"),this.__ul=document.createElement("ul"),this.domElement.appendChild(this.__ul),E.addClass(this.domElement,dh),this.__folders={},this.__controllers=[],this.__rememberedObjects=[],this.__rememberedObjectIndecesToControllers=[],this.__listening=[],r=U.defaults(r,{closeOnTop:!1,autoPlace:!0,width:i.DEFAULT_WIDTH}),r=U.defaults(r,{resizable:r.autoPlace,hideable:r.autoPlace}),U.isUndefined(r.load)?r.load={preset:Zr}:r.preset&&(r.load.preset=r.preset),U.isUndefined(r.parent)&&r.hideable&&Ah.push(this),r.resizable=U.isUndefined(r.parent)&&r.resizable,r.autoPlace&&U.isUndefined(r.scrollable)&&(r.scrollable=!0);var s=$r&&localStorage.getItem(ar(this,"isLocal"))==="true",a=void 0,n=void 0;if(Object.defineProperties(this,{parent:{get:function(){return r.parent}},scrollable:{get:function(){return r.scrollable}},autoPlace:{get:function(){return r.autoPlace}},closeOnTop:{get:function(){return r.closeOnTop}},preset:{get:function(){return t.parent?t.getRoot().preset:r.load.preset},set:function(d){t.parent?t.getRoot().preset=d:r.load.preset=d,gg(this),t.revert()}},width:{get:function(){return r.width},set:function(d){r.width=d,yo(t,d)}},name:{get:function(){return r.name},set:function(d){r.name=d,n&&(n.innerHTML=r.name)}},closed:{get:function(){return r.closed},set:function(d){r.closed=d,r.closed?E.addClass(t.__ul,i.CLASS_CLOSED):E.removeClass(t.__ul,i.CLASS_CLOSED),this.onResize(),t.__closeButton&&(t.__closeButton.innerHTML=d?i.TEXT_OPEN:i.TEXT_CLOSED)}},load:{get:function(){return r.load}},useLocalStorage:{get:function(){return s},set:function(d){$r&&(s=d,d?E.bind(window,"unload",a):E.unbind(window,"unload",a),localStorage.setItem(ar(t,"isLocal"),d))}}}),U.isUndefined(r.parent)){if(this.closed=r.closed||!1,E.addClass(this.domElement,i.CLASS_MAIN),E.makeSelectable(this.domElement,!1),$r&&s){t.useLocalStorage=!0;var l=localStorage.getItem(ar(this,"gui"));l&&(r.load=JSON.parse(l))}this.__closeButton=document.createElement("div"),this.__closeButton.innerHTML=i.TEXT_CLOSED,E.addClass(this.__closeButton,i.CLASS_CLOSE_BUTTON),r.closeOnTop?(E.addClass(this.__closeButton,i.CLASS_CLOSE_TOP),this.domElement.insertBefore(this.__closeButton,this.domElement.childNodes[0])):(E.addClass(this.__closeButton,i.CLASS_CLOSE_BOTTOM),this.domElement.appendChild(this.__closeButton)),E.bind(this.__closeButton,"click",function(){t.closed=!t.closed})}else{r.closed===void 0&&(r.closed=!0);var h=document.createTextNode(r.name);E.addClass(h,"controller-name"),n=_o(t,h);var u=function(d){return d.preventDefault(),t.closed=!t.closed,!1};E.addClass(this.__ul,i.CLASS_CLOSED),E.addClass(n,"title"),E.bind(n,"click",u),r.closed||(this.closed=!1)}r.autoPlace&&(U.isUndefined(r.parent)&&(mh&&(sr=document.createElement("div"),E.addClass(sr,dh),E.addClass(sr,i.CLASS_AUTO_PLACE_CONTAINER),document.body.appendChild(sr),mh=!1),sr.appendChild(this.domElement),E.addClass(this.domElement,i.CLASS_AUTO_PLACE)),this.parent||yo(t,r.width)),this.__resizeHandler=function(){t.onResizeDebounced()},E.bind(window,"resize",this.__resizeHandler),E.bind(this.__ul,"webkitTransitionEnd",this.__resizeHandler),E.bind(this.__ul,"transitionend",this.__resizeHandler),E.bind(this.__ul,"oTransitionEnd",this.__resizeHandler),this.onResize(),r.resizable&&dg(this),a=function(){$r&&localStorage.getItem(ar(t,"isLocal"))==="true"&&localStorage.setItem(ar(t,"gui"),JSON.stringify(t.getSaveObject()))},this.saveToLocalStorageIfPossible=a;function c(){var f=t.getRoot();f.width+=1,U.defer(function(){f.width-=1})}r.parent||c()};ve.toggleHide=function(){Ao=!Ao,U.each(Ah,function(i){i.domElement.style.display=Ao?"none":""})},ve.CLASS_AUTO_PLACE="a",ve.CLASS_AUTO_PLACE_CONTAINER="ac",ve.CLASS_MAIN="main",ve.CLASS_CONTROLLER_ROW="cr",ve.CLASS_TOO_TALL="taller-than-window",ve.CLASS_CLOSED="closed",ve.CLASS_CLOSE_BUTTON="close-button",ve.CLASS_CLOSE_TOP="close-top",ve.CLASS_CLOSE_BOTTOM="close-bottom",ve.CLASS_DRAG="drag",ve.DEFAULT_WIDTH=245,ve.TEXT_CLOSED="Close Controls",ve.TEXT_OPEN="Open Controls",ve._keydownHandler=function(i){document.activeElement.type!=="text"&&(i.which===gh||i.keyCode===gh)&&ve.toggleHide()},E.bind(window,"keydown",ve._keydownHandler,!1),U.extend(ve.prototype,{add:function(e,t){return ts(this,e,t,{factoryArgs:Array.prototype.slice.call(arguments,2)})},addColor:function(e,t){return ts(this,e,t,{color:!0})},remove:function(e){this.__ul.removeChild(e.__li),this.__controllers.splice(this.__controllers.indexOf(e),1);var t=this;U.defer(function(){t.onResize()})},destroy:function(){if(this.parent)throw new Error("Only the root GUI should be removed with .destroy(). For subfolders, use gui.removeFolder(folder) instead.");this.autoPlace&&sr.removeChild(this.domElement);var e=this;U.each(this.__folders,function(t){e.removeFolder(t)}),E.unbind(window,"keydown",ve._keydownHandler,!1),_h(this)},addFolder:function(e){if(this.__folders[e]!==void 0)throw new Error('You already have a folder in this GUI by the name "'+e+'"');var t={name:e,parent:this};t.autoPlace=this.autoPlace,this.load&&this.load.folders&&this.load.folders[e]&&(t.closed=this.load.folders[e].closed,t.load=this.load.folders[e]);var r=new ve(t);this.__folders[e]=r;var s=_o(this,r.domElement);return E.addClass(s,"folder"),r},removeFolder:function(e){this.__ul.removeChild(e.domElement.parentElement),delete this.__folders[e.name],this.load&&this.load.folders&&this.load.folders[e.name]&&delete this.load.folders[e.name],_h(e);var t=this;U.each(e.__folders,function(r){e.removeFolder(r)}),U.defer(function(){t.onResize()})},open:function(){this.closed=!1},close:function(){this.closed=!0},hide:function(){this.domElement.style.display="none"},show:function(){this.domElement.style.display=""},onResize:function(){var e=this.getRoot();if(e.scrollable){var t=E.getOffset(e.__ul).top,r=0;U.each(e.__ul.childNodes,function(s){e.autoPlace&&s===e.__save_row||(r+=E.getHeight(s))}),window.innerHeight-t-ph<r?(E.addClass(e.domElement,ve.CLASS_TOO_TALL),e.__ul.style.height=window.innerHeight-t-ph+"px"):(E.removeClass(e.domElement,ve.CLASS_TOO_TALL),e.__ul.style.height="auto")}e.__resize_handle&&U.defer(function(){e.__resize_handle.style.height=e.__ul.offsetHeight+"px"}),e.__closeButton&&(e.__closeButton.style.width=e.width+"px")},onResizeDebounced:U.debounce(function(){this.onResize()},50),remember:function(){if(U.isUndefined(es)&&(es=new hg,es.domElement.innerHTML=ag),this.parent)throw new Error("You can only call remember on a top level GUI.");var e=this;U.each(Array.prototype.slice.call(arguments),function(t){e.__rememberedObjects.length===0&&fg(e),e.__rememberedObjects.indexOf(t)===-1&&e.__rememberedObjects.push(t)}),this.autoPlace&&yo(this,this.width)},getRoot:function(){for(var e=this;e.parent;)e=e.parent;return e},getSaveObject:function(){var e=this.load;return e.closed=this.closed,this.__rememberedObjects.length>0&&(e.preset=this.preset,e.remembered||(e.remembered={}),e.remembered[this.preset]=Vs(this)),e.folders={},U.each(this.__folders,function(t,r){e.folders[r]=t.getSaveObject()}),e},save:function(){this.load.remembered||(this.load.remembered={}),this.load.remembered[this.preset]=Vs(this),xo(this,!1),this.saveToLocalStorageIfPossible()},saveAs:function(e){this.load.remembered||(this.load.remembered={},this.load.remembered[Zr]=Vs(this,!0)),this.load.remembered[e]=Vs(this),this.preset=e,vo(this,e,!0),this.saveToLocalStorageIfPossible()},revert:function(e){U.each(this.__controllers,function(t){this.getRoot().load.remembered?xh(e||this.getRoot(),t):t.setValue(t.initialValue),t.__onFinishChange&&t.__onFinishChange.call(t,t.getValue())},this),U.each(this.__folders,function(t){t.revert(t)}),e||xo(this.getRoot(),!1)},listen:function(e){var t=this.__listening.length===0;this.__listening.push(e),t&&yh(this.__listening)},updateDisplay:function(){U.each(this.__controllers,function(e){e.updateDisplay()}),U.each(this.__folders,function(e){e.updateDisplay()})}});function _o(i,e,t){var r=document.createElement("li");return e&&r.appendChild(e),t?i.__ul.insertBefore(r,t):i.__ul.appendChild(r),i.onResize(),r}function _h(i){E.unbind(window,"resize",i.__resizeHandler),i.saveToLocalStorageIfPossible&&E.unbind(window,"unload",i.saveToLocalStorageIfPossible)}function xo(i,e){var t=i.__preset_select[i.__preset_select.selectedIndex];e?t.innerHTML=t.value+"*":t.innerHTML=t.value}function cg(i,e,t){if(t.__li=e,t.__gui=i,U.extend(t,{options:function(n){if(arguments.length>1){var l=t.__li.nextElementSibling;return t.remove(),ts(i,t.object,t.property,{before:l,factoryArgs:[U.toArray(arguments)]})}if(U.isArray(n)||U.isObject(n)){var h=t.__li.nextElementSibling;return t.remove(),ts(i,t.object,t.property,{before:h,factoryArgs:[n]})}},name:function(n){return t.__li.firstElementChild.firstElementChild.innerHTML=n,t},listen:function(){return t.__gui.listen(t),t},remove:function(){return t.__gui.remove(t),t}}),t instanceof po){var r=new Qs(t.object,t.property,{min:t.__min,max:t.__max,step:t.__step});U.each(["updateDisplay","onChange","onFinishChange","step","min","max"],function(a){var n=t[a],l=r[a];t[a]=r[a]=function(){var h=Array.prototype.slice.call(arguments);return l.apply(r,h),n.apply(t,h)}}),E.addClass(e,"has-slider"),t.domElement.insertBefore(r.domElement,t.domElement.firstElementChild)}else if(t instanceof Qs){var s=function(n){if(U.isNumber(t.__min)&&U.isNumber(t.__max)){var l=t.__li.firstElementChild.firstElementChild.innerHTML,h=t.__gui.__listening.indexOf(t)>-1;t.remove();var u=ts(i,t.object,t.property,{before:t.__li.nextElementSibling,factoryArgs:[t.__min,t.__max,t.__step]});return u.name(l),h&&u.listen(),u}return n};t.min=U.compose(s,t.min),t.max=U.compose(s,t.max)}else t instanceof nh?(E.bind(e,"click",function(){E.fakeEvent(t.__checkbox,"click")}),E.bind(t.__checkbox,"click",function(a){a.stopPropagation()})):t instanceof ch?(E.bind(e,"click",function(){E.fakeEvent(t.__button,"click")}),E.bind(e,"mouseover",function(){E.addClass(t.__button,"hover")}),E.bind(e,"mouseout",function(){E.removeClass(t.__button,"hover")})):t instanceof mo&&(E.addClass(e,"color"),t.updateDisplay=U.compose(function(a){return e.style.borderLeftColor=t.__color.toString(),a},t.updateDisplay),t.updateDisplay());t.setValue=U.compose(function(a){return i.getRoot().__preset_select&&t.isModified()&&xo(i.getRoot(),!0),a},t.setValue)}function xh(i,e){var t=i.getRoot(),r=t.__rememberedObjects.indexOf(e.object);if(r!==-1){var s=t.__rememberedObjectIndecesToControllers[r];if(s===void 0&&(s={},t.__rememberedObjectIndecesToControllers[r]=s),s[e.property]=e,t.load&&t.load.remembered){var a=t.load.remembered,n=void 0;if(a[i.preset])n=a[i.preset];else if(a[Zr])n=a[Zr];else return;if(n[r]&&n[r][e.property]!==void 0){var l=n[r][e.property];e.initialValue=l,e.setValue(l)}}}}function ts(i,e,t,r){if(e[t]===void 0)throw new Error('Object "'+e+'" has no property "'+t+'"');var s=void 0;if(r.color)s=new mo(e,t);else{var a=[e,t].concat(r.factoryArgs);s=og.apply(i,a)}r.before instanceof Mi&&(r.before=r.before.__li),xh(i,s),E.addClass(s.domElement,"c");var n=document.createElement("span");E.addClass(n,"property-name"),n.innerHTML=s.property;var l=document.createElement("div");l.appendChild(n),l.appendChild(s.domElement);var h=_o(i,l,r.before);return E.addClass(h,ve.CLASS_CONTROLLER_ROW),s instanceof mo?E.addClass(h,"color"):E.addClass(h,Kd(s.getValue())),cg(i,h,s),i.__controllers.push(s),s}function ar(i,e){return document.location.href+"."+e}function vo(i,e,t){var r=document.createElement("option");r.innerHTML=e,r.value=e,i.__preset_select.appendChild(r),t&&(i.__preset_select.selectedIndex=i.__preset_select.length-1)}function vh(i,e){e.style.display=i.useLocalStorage?"block":"none"}function fg(i){var e=i.__save_row=document.createElement("li");E.addClass(i.domElement,"has-save"),i.__ul.insertBefore(e,i.__ul.firstChild),E.addClass(e,"save-row");var t=document.createElement("span");t.innerHTML="&nbsp;",E.addClass(t,"button gears");var r=document.createElement("span");r.innerHTML="Save",E.addClass(r,"button"),E.addClass(r,"save");var s=document.createElement("span");s.innerHTML="New",E.addClass(s,"button"),E.addClass(s,"save-as");var a=document.createElement("span");a.innerHTML="Revert",E.addClass(a,"button"),E.addClass(a,"revert");var n=i.__preset_select=document.createElement("select");if(i.load&&i.load.remembered?U.each(i.load.remembered,function(f,d){vo(i,d,d===i.preset)}):vo(i,Zr,!1),E.bind(n,"change",function(){for(var f=0;f<i.__preset_select.length;f++)i.__preset_select[f].innerHTML=i.__preset_select[f].value;i.preset=this.value}),e.appendChild(n),e.appendChild(t),e.appendChild(r),e.appendChild(s),e.appendChild(a),$r){var l=document.getElementById("dg-local-explain"),h=document.getElementById("dg-local-storage"),u=document.getElementById("dg-save-locally");u.style.display="block",localStorage.getItem(ar(i,"isLocal"))==="true"&&h.setAttribute("checked","checked"),vh(i,l),E.bind(h,"change",function(){i.useLocalStorage=!i.useLocalStorage,vh(i,l)})}var c=document.getElementById("dg-new-constructor");E.bind(c,"keydown",function(f){f.metaKey&&(f.which===67||f.keyCode===67)&&es.hide()}),E.bind(t,"click",function(){c.innerHTML=JSON.stringify(i.getSaveObject(),void 0,2),es.show(),c.focus(),c.select()}),E.bind(r,"click",function(){i.save()}),E.bind(s,"click",function(){var f=prompt("Enter a new preset name.");f&&i.saveAs(f)}),E.bind(a,"click",function(){i.revert()})}function dg(i){var e=void 0;i.__resize_handle=document.createElement("div"),U.extend(i.__resize_handle.style,{width:"6px",marginLeft:"-3px",height:"200px",cursor:"ew-resize",position:"absolute"});function t(a){return a.preventDefault(),i.width+=e-a.clientX,i.onResize(),e=a.clientX,!1}function r(){E.removeClass(i.__closeButton,ve.CLASS_DRAG),E.unbind(window,"mousemove",t),E.unbind(window,"mouseup",r)}function s(a){return a.preventDefault(),e=a.clientX,E.addClass(i.__closeButton,ve.CLASS_DRAG),E.bind(window,"mousemove",t),E.bind(window,"mouseup",r),!1}E.bind(i.__resize_handle,"mousedown",s),E.bind(i.__closeButton,"mousedown",s),i.domElement.insertBefore(i.__resize_handle,i.domElement.firstElementChild)}function yo(i,e){i.domElement.style.width=e+"px",i.__save_row&&i.autoPlace&&(i.__save_row.style.width=e+"px"),i.__closeButton&&(i.__closeButton.style.width=e+"px")}function Vs(i,e){var t={};return U.each(i.__rememberedObjects,function(r,s){var a={},n=i.__rememberedObjectIndecesToControllers[s];U.each(n,function(l,h){a[h]=e?l.initialValue:l.getValue()}),t[s]=a}),t}function gg(i){for(var e=0;e<i.__preset_select.length;e++)i.__preset_select[e].value===i.preset&&(i.__preset_select.selectedIndex=e)}function yh(i){i.length!==0&&lg.call(window,function(){yh(i)}),U.each(i,function(e){e.updateDisplay()})}var Ch=ve;class pg{constructor(){o(this,"debug",!1),o(this,"data"),o(this,"gui"),o(this,"bind"),o(this,"_current"),o(this,"_nullBind",{}),o(this,"folders",{}),this.data={},this.bind={},this._nullBind={},this._nullBind.onChange=()=>{}}init(e=10){this.debug=!0,this.gui=new Ch,this.gui.domElement.style.zIndex=`${e}`,this.gui.domElement.parentElement.style.zIndex=`${e}`,this.addFolder("Orillusion")}addCustom(e,t,r,s,a,n){if(!this.debug)return this._nullBind;let l=this._current?this._current:this.gui,h={[e]:t[r]};l.add(h,e,s,a,n).onChange(u=>{t[r]=u})}add(e,t,r,s,a){return this.debug?(this._current?this._current:this.gui).add(e,t,r,s,a):this._nullBind}addLabel(e){if(!this.debug)return this._nullBind;bt.add({label:e},"label")}addInfo(e,t){if(!this.debug)return this._nullBind;let r={};r[e]=t.toString(),bt.add(r,e)}addColor(e,t){if(!this.debug)return this._nullBind;let s=(this._current?this._current:this.gui).addColor(e[t],"rgba").name(t);return s.onChange(a=>{console.log(a);let n=e[t];n.rgba=a,e[t]=n}),s}addButton(e,t){if(!this.debug)return this._nullBind;var r=new function(){this[e]=t};(this._current?this._current:this.gui).add(r,e)}open(){if(!this.debug)return this._nullBind;(this._current?this._current:this.gui).open()}close(){if(!this.debug)return this._nullBind;(this._current?this._current:this.gui).close()}addFolder(e){return this.debug?(this.folders[e]?this._current=this.folders[e]:(this._current=this.gui.addFolder(e),this.folders[e]=this._current),this._current):this._nullBind}removeFolder(e){if(!this.debug)return this._nullBind;let t=this.folders[e];t&&(this.gui.removeFolder(t),this._current=null,delete this.folders[e])}endFolder(){if(!this.debug)return this._nullBind;this._current=null}_creatPanel(){let e=new Ch;return e.domElement.style.zIndex="10",e.domElement.parentElement.style.zIndex="10",e}_add(e,t,r,s,a,n){return e.add(t,r,s,a,n)}_addLabel(e,t){bt._add(e,{label:t},"label")}_addButton(e,t,r){var s=new function(){this[t]=r};e.add(s,t)}_addColor(e,t,r){return e.addColor(t[r],"rgb").name(r)}_addFolder(e,t){e.Folder==null&&(e.Folder={});let r=e.addFolder(t);return e.Folder[t]=r,r}_removeFolder(e,t){e.Folder&&e.Folder[t]&&e.removeFolder(e.Folder[t])}}let bt=new pg;class wh extends di{constructor(e){super(),o(this,"maxNumLightsPerCluster",64),o(this,"clusterPix",1),o(this,"clusterLightingBuffer"),o(this,"_currentLightCount",0),o(this,"_clusterGenerateCompute"),o(this,"_clusterLightingCompute"),o(this,"_useCamera"),o(this,"resize",!1),this.passType=re.Cluster,this.initCompute(e)}initCompute(e){this._clusterGenerateCompute=new be(ih),this._clusterLightingCompute=new be(rh);let t=S.presentationSize,r=ke.clusterTileX*ke.clusterTileY*ke.clusterTileZ,s=e.camera,a=s.near,n=s.far;this.clusterLightingBuffer=new th(r,this.maxNumLightsPerCluster),this.clusterLightingBuffer.update(t[0],t[1],this.clusterPix,ke.clusterTileX,ke.clusterTileY,ke.clusterTileZ,0,this.maxNumLightsPerCluster,a,n),this._clusterGenerateCompute.setUniformBuffer("clustersUniform",this.clusterLightingBuffer.clustersUniformBuffer),this._clusterGenerateCompute.setStorageBuffer("clusterBuffer",this.clusterLightingBuffer.clusterBuffer);let l=pe.getLightEntries(e.scene);this._clusterLightingCompute.setStorageBuffer("models",pe.modelMatrixBindGroup.matrixBufferDst),this._clusterLightingCompute.setUniformBuffer("clustersUniform",this.clusterLightingBuffer.clustersUniformBuffer),this._clusterLightingCompute.setStorageBuffer("clusterBuffer",this.clusterLightingBuffer.clusterBuffer),this._clusterLightingCompute.setStorageBuffer("lightBuffer",l.storageGPUBuffer),this._clusterLightingCompute.setStorageBuffer("lightAssignBuffer",this.clusterLightingBuffer.lightAssignBuffer),this._clusterLightingCompute.setStorageBuffer("assignTable",this.clusterLightingBuffer.assignTableBuffer),this.resize=!0,bt.addButton("clusterBuffer",()=>{let h=this.clusterLightingBuffer.clusterBuffer.readBuffer();console.log(h);let u=2*4;for(let c=0;c<r;c++){const f=new Float32Array(h.buffer,c*u*4,u);let d=new g(f[0],f[1],f[2],f[3]),p=new g(f[4],f[5],f[6],f[7]);e.graphic3D.drawBox(c+"-box",d,p,z.random())}}),bt.addButton("assignTable",()=>{let h=this.clusterLightingBuffer.assignTableBuffer.readBuffer();for(let u=0;u<h.length/4;u++){const c=h[u*4+0],f=h[u*4+1],d=h[u*4+2],p=h[u*4+3];c>=1&&console.log(c),f+c>f+1&&console.log(c,f,d,p)}console.log(h)}),bt.addButton("clustersUniformBuffer",()=>{let h=this.clusterLightingBuffer.clustersUniformBuffer.readBuffer();console.log(h)})}render(e,t){let r=e.scene,s=Q.instance.getLights(r);if(this._useCamera!=e.camera){this._useCamera=e.camera;let l=pe.getCameraGroup(this._useCamera);this._clusterGenerateCompute.setUniformBuffer("globalUniform",l.uniformGPUBuffer),this._clusterLightingCompute.setUniformBuffer("globalUniform",l.uniformGPUBuffer)}this._currentLightCount!=s.length&&(this._currentLightCount=s.length,this.clusterLightingBuffer.clustersUniformBuffer.setFloat("numLights",s.length),this.clusterLightingBuffer.clustersUniformBuffer.apply(),this._clusterGenerateCompute.workerSizeX=ke.clusterTileZ,this._clusterLightingCompute.workerSizeX=ke.clusterTileZ);let a=S.presentationSize;this.clusterLightingBuffer.update(a[0],a[1],this.clusterPix,ke.clusterTileX,ke.clusterTileY,ke.clusterTileZ,s.length,this.maxNumLightsPerCluster,e.camera.near,e.camera.far),this.resize=!1;let n=w.beginCommandEncoder();w.computeCommand(n,[this._clusterGenerateCompute,this._clusterLightingCompute]),w.endCommandEncoder(n)}}class bh extends te{constructor(e=.001,t=1e4,r=90,s=!1){super(),o(this,"up_camera"),o(this,"down_camera"),o(this,"left_camera"),o(this,"right_camera"),o(this,"front_camera"),o(this,"back_camera"),this.initCubeCamera(e,t,r,s)}set label(e){this.up_camera.name=e+"up",this.down_camera.name=e+"down",this.left_camera.name=e+"left",this.right_camera.name=e+"right",this.front_camera.name=e+"front",this.back_camera.name=e+"back"}initCubeCamera(e,t,r=90,s=!1){this.up_camera=Ne.createCamera3DObject(this,"up"),this.down_camera=Ne.createCamera3DObject(this,"down"),this.left_camera=Ne.createCamera3DObject(this,"left"),this.right_camera=Ne.createCamera3DObject(this,"right"),this.front_camera=Ne.createCamera3DObject(this,"front"),this.back_camera=Ne.createCamera3DObject(this,"back"),this.up_camera.isShadowCamera=s,this.down_camera.isShadowCamera=s,this.left_camera.isShadowCamera=s,this.right_camera.isShadowCamera=s,this.front_camera.isShadowCamera=s,this.back_camera.isShadowCamera=s;let a=1;this.up_camera.perspective(r,a,e,t),this.up_camera.lookAt(g.ZERO,g.UP,g.DOWN),this.up_camera.object3D.scaleX=-1,this.up_camera.object3D.rotationY=180,this.down_camera.perspective(r,a,e,t),this.down_camera.lookAt(g.ZERO,g.DOWN,g.DOWN),this.down_camera.object3D.scaleX=-1,this.down_camera.object3D.rotationY=180,this.left_camera.perspective(r,a,e,t),this.left_camera.lookAt(g.ZERO,g.LEFT),this.left_camera.object3D.scaleX=-1,this.right_camera.perspective(r,a,e,t),this.right_camera.lookAt(g.ZERO,g.RIGHT),this.right_camera.object3D.scaleX=-1,this.front_camera.perspective(r,a,e,t),this.front_camera.lookAt(g.ZERO,g.FORWARD),this.front_camera.object3D.scaleX=-1,this.back_camera.perspective(r,a,e,t),this.back_camera.lookAt(g.ZERO,g.BACK),this.back_camera.object3D.scaleX=-1,this.up_camera.type=Ie.shadow,this.down_camera.type=Ie.shadow,this.left_camera.type=Ie.shadow,this.right_camera.type=Ie.shadow,this.front_camera.type=Ie.shadow,this.back_camera.type=Ie.shadow}}class Sh extends at{constructor(e,t,r){super(e,t,r),this.format=G.depth32float,this.mipmapCount=1,this.init()}internalCreateBindingLayoutDesc(){this.textureBindingLayout.sampleType="depth",this.textureBindingLayout.viewDimension="cube-array",this.samplerBindingLayout.type="filtering",this.sampler_comparisonBindingLayout.type="comparison"}internalCreateTexture(){this.textureDescriptor={format:this.format,size:{width:this.width,height:this.height,depthOrArrayLayers:6*this.numberLayer},dimension:"2d",usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING},this.gpuTexture=S.device.createTexture(this.textureDescriptor)}internalCreateView(){this.viewDescriptor={dimension:"cube-array"},this.view=this.gpuTexture.createView(this.viewDescriptor)}internalCreateSampler(){this.gpuSampler=S.device.createSampler({minFilter:Nr.linear,magFilter:Nr.linear}),this.gpuSampler_comparison=S.device.createSampler({compare:"less",label:"sampler_comparison"})}}class Ih extends di{constructor(){super(),o(this,"shadowPassCount"),o(this,"_forceUpdate",!1),o(this,"_shadowCameraDic"),o(this,"shadowCamera"),o(this,"cubeArrayTexture"),o(this,"colorTexture"),o(this,"shadowSize",1024),this.passType=re.POINT_SHADOW,this._shadowCameraDic=new Map,this.cubeArrayTexture=new Sh(this.shadowSize,this.shadowSize,8),this.colorTexture=new oe(this.shadowSize,this.shadowSize,G.bgra8unorm,!1),se.getInstance().attached(this.cubeArrayTexture,this)}getShadowCamera(e,t){let r;if(this._shadowCameraDic.has(t))r=this._shadowCameraDic.get(t);else{let s=new bh(e.camera.near,e.camera.far,90,!0);s.label=t.name;let a=[],n=[];for(let l=0;l<6;l++){let h=new oe(this.shadowSize,this.shadowSize,this.cubeArrayTexture.format,!1),u=new Ze([this.colorTexture],[new Ce]);h.name="shadowDepthTexture_"+t.name+l+"_face",u.depthTexture=h,u.label="shadowRender",u.customSize=!0;let c=He.createRendererPassState(u);n[l]=c,a[l]=h,A.getRenderJob(e).postRenderer.setDebugTexture([h]),A.getRenderJob(e).debug()}r={cubeCamera:s,depthTexture:a,rendererPassState:n},this._shadowCameraDic.set(t,r)}return r}render(e,t){if(!A.setting.shadow.enable)return;this.shadowPassCount=0,e.camera;let r=e.scene,s=Ve.getPointShadowLightWhichScene(r),a=s.length;for(let n=0;n<a;n++){let l=s[n];if(l.lightData.lightType!=Qe.DirectionLight&&l.lightData.castShadowIndex>-1&&(l.needUpdateShadow||this._forceUpdate||he.frame<5||l.realTimeShadow)){l.needUpdateShadow=!1;let h=this.getShadowCamera(e,l),u=l.transform.worldPosition;h.cubeCamera.x=u.x,h.cubeCamera.y=u.y,h.cubeCamera.z=u.z;let c;h.cubeCamera.transform.updateWorldMatrix(!0),t.update(h.cubeCamera.right_camera,r),c=Q.instance.getRenderNodes(r,h.cubeCamera.right_camera),this.renderSceneOnce(0,h,e,h.cubeCamera.right_camera,c,t),t.update(h.cubeCamera.left_camera,r),c=Q.instance.getRenderNodes(r,h.cubeCamera.left_camera),this.renderSceneOnce(1,h,e,h.cubeCamera.left_camera,c,t),t.update(h.cubeCamera.up_camera,r),c=Q.instance.getRenderNodes(r,h.cubeCamera.up_camera),this.renderSceneOnce(2,h,e,h.cubeCamera.up_camera,c,t),t.update(h.cubeCamera.down_camera,r),c=Q.instance.getRenderNodes(r,h.cubeCamera.down_camera),this.renderSceneOnce(3,h,e,h.cubeCamera.down_camera,c,t),t.update(h.cubeCamera.front_camera,r),c=Q.instance.getRenderNodes(r,h.cubeCamera.front_camera),this.renderSceneOnce(4,h,e,h.cubeCamera.front_camera,c,t),t.update(h.cubeCamera.back_camera,r),c=Q.instance.getRenderNodes(r,h.cubeCamera.back_camera),this.renderSceneOnce(5,h,e,h.cubeCamera.back_camera,c,t);let f=w.beginCommandEncoder();for(let d=0;d<6;d++)f.copyTextureToTexture({texture:h.depthTexture[d].getGPUTexture(),mipLevel:0,origin:{x:0,y:0,z:0}},{texture:this.cubeArrayTexture.getGPUTexture(),mipLevel:0,origin:{x:0,y:0,z:l.shadowIndex*6+d}},{width:this.shadowSize,height:this.shadowSize,depthOrArrayLayers:1});w.endCommandEncoder(f)}}this._forceUpdate=!1}renderSceneOnce(e,t,r,s,a,n){this.rendererPassState=t.rendererPassState[e];let l=w.beginCommandEncoder(),h=w.beginRenderPass(l,this.rendererPassState);h.setViewport(0,0,this.shadowSize,this.shadowSize,0,1),h.setScissorRect(0,0,this.shadowSize,this.shadowSize),s.onUpdate(),s.transform.updateWorldMatrix(!0);let u=Q.instance.getRenderShaderCollect(r);for(const c of u){let f=c[1];for(const d of f){let p=d[1];if(p.preInit){p.nodeUpdate(r,this._rendererType,this.rendererPassState,null);break}}}this.drawShadowRenderNodes(r,s,h,a.opaqueList,n),this.drawShadowRenderNodes(r,s,h,a.transparentList,n),w.endPass(h),w.endCommandEncoder(l)}drawShadowRenderNodes(e,t,r,s,a){if(w.bindCamera(r,t),s)for(let n=A.setting.render.drawOpMin;n<Math.min(s.length,A.setting.render.drawOpMax);++n){let l=s[n];if(l.transform.worldMatrix.index,!!l.transform.enable&&l.enable){l.preInit||l.nodeUpdate(e,this._rendererType,this.rendererPassState);for(let h of l.materials){let u=h.getPass(this._rendererType);if(!u||u.length==0)continue;w.bindGeometryBuffer(r,l.geometry);let c=l.object3D.transform._worldMatrix;for(let f of u){const d=f;if(d.pipeline){d.setUniformFloat("cameraFar",t.far),d.setUniformVector3("lightWorldPos",t.transform.worldPosition),d.materialDataUniformBuffer.apply(),w.bindPipeline(r,d);let p=l.geometry.subGeometries;for(const m of p){let v=m.lodLevels[l.lodLevel];w.drawIndexed(r,v.indexCount,1,v.indexStart,0,c.index)}}}}}}}}class Eh extends at{constructor(e,t,r=G.depth32float,s=4){super(e,t,s),this.format=r,this.mipmapCount=1,this.init()}internalCreateBindingLayoutDesc(){this.textureBindingLayout.sampleType="depth",this.textureBindingLayout.viewDimension="2d-array",this.samplerBindingLayout.type="filtering",this.sampler_comparisonBindingLayout.type="comparison"}internalCreateTexture(){this.textureDescriptor={format:this.format,size:{width:this.width,height:this.height,depthOrArrayLayers:this.numberLayer},dimension:"2d",usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING},this.gpuTexture=S.device.createTexture(this.textureDescriptor)}internalCreateView(){this.viewDescriptor={dimension:"2d-array"},this.view=this.gpuTexture.createView(this.viewDescriptor)}internalCreateSampler(){this.gpuSampler=S.device.createSampler({}),this.gpuSampler_comparison=S.device.createSampler({compare:"less",label:"sampler_comparison"})}}class Bh extends di{constructor(){super(),o(this,"shadowPassCount"),o(this,"depth2DArrayTexture"),o(this,"rendererPassStates"),o(this,"_forceUpdate",!1),o(this,"_shadowPos",new g),o(this,"_shadowCameraTarget",new g),this.setShadowMap(A.setting.shadow.shadowSize,lt.Cascades),this.passType=re.SHADOW}setShadowMap(e,t){this.rendererPassStates=[],this.depth2DArrayTexture=new Eh(e,e,G.depth32float,8),se.getInstance().attached(this.depth2DArrayTexture,this);for(let r=0;r<8;r++){let s=new Ze([],[]);const a=new oe(e,e,G.depth32float,!1);a.name=`shadowDepthTexture_${r}`,s.depthTexture=a,s.label="shadowRender",s.customSize=!0,s.depthCleanValue=1;let n=He.createRendererPassState(s);this.rendererPassStates[r]=n}}render(e,t){let r=A.setting.shadow;if(!r.enable)return;let s=e.camera,a=e.scene;if(this.shadowPassCount=0,!r.needUpdate||he.frame%r.updateFrameRate!=0)return;let n=Ve.getDirectShadowLightWhichScene(a),l=r.shadowSize;const h=lt.Cascades;for(let u of n){const c=u;let f=c.shadowIndex;this.rendererPassState=this.rendererPassStates[f];let d=Q.instance.getRenderShaderCollect(e);for(const p of d){let m=p[1];for(const _ of m){let v=_[1];if(v.preInit){v.nodeUpdate(e,this._rendererType,this.rendererPassState,null);break}}}if(c.castShadow&&c.needUpdateShadow||this._forceUpdate||c.castShadow&&r.autoUpdate)if(c.needUpdateShadow=!1,s.enableCSM&&f==0)for(let p=0;p<h;p++){this.rendererPassState=this.rendererPassStates[p];let m=s.csm.children[p],_=s.getCSMShadowWorldExtents(p);this.poseShadowCamera(s,c.direction,m.shadowCamera,_,m.bound.center),this.renderShadow(e,m.shadowCamera,t,this.rendererPassState),this.copyDepthTexture(this.rendererPassState.depthTexture,this.depth2DArrayTexture,p,l)}else{s.enableCSM&&(f+=h-1);let p=s.getShadowWorldExtents();this.rendererPassState=this.rendererPassStates[f],this.poseShadowCamera(s,c.direction,c.shadowCamera,p,s.lookTarget),this.renderShadow(e,c.shadowCamera,t,this.rendererPassState),this.copyDepthTexture(this.rendererPassState.depthTexture,this.depth2DArrayTexture,f,l)}}this._forceUpdate=!1}copyDepthTexture(e,t,r,s){let a=w.beginCommandEncoder();a.copyTextureToTexture({texture:e.getGPUTexture(),mipLevel:0,origin:{x:0,y:0,z:0}},{texture:t.getGPUTexture(),mipLevel:0,origin:{x:0,y:0,z:r}},{width:s,height:s,depthOrArrayLayers:1}),w.endCommandEncoder(a)}poseShadowCamera(e,t,r,s,a){this._shadowPos.copy(t).normalize(e.far),a.add(this._shadowPos,this._shadowCameraTarget),a.subtract(this._shadowPos,this._shadowPos),r.transform.lookAt(this._shadowPos,this._shadowCameraTarget),r.orthoOffCenter(-s,s,-s,s,e.near,e.far*2)}compute(){}renderShadow(e,t,r,s){let a=Q.instance.getRenderNodes(e.scene,t),n=w.beginCommandEncoder(),l=w.beginRenderPass(n,s);t.transform.updateWorldMatrix(),ks.enable&&(r.update(t,e.scene),r.collect(a,t)),w.bindCamera(l,t);let h=this.renderShadowBundleOp(e,t,s),u=this.renderShadowBundleTr(e,t,s);h.length>0&&l.executeBundles(h),this.drawShadowRenderNodes(e,t,l,a.opaqueList),u.length>0&&l.executeBundles(u),this.drawShadowRenderNodes(e,t,l,a.transparentList),w.endPass(l),w.endCommandEncoder(n)}renderShadowBundleOp(e,t,r){let s=Q.instance.getOpRenderGroup(e.scene);if(s){let a=[];return s.renderGroup.forEach(n=>{if(n.bundleMap.has(this._rendererType))a.push(n.bundleMap.get(this._rendererType));else{let l=w.recordBundleEncoder(r.renderBundleEncoderDescriptor);this.recordShadowRenderBundleNode(e,t,l,n.renderNodes);let h=l.finish();n.bundleMap.set(this._rendererType,h),a.push(h)}}),a}return[]}renderShadowBundleTr(e,t,r){let s=Q.instance.getTrRenderGroup(e.scene);if(s){let a=[];return s.renderGroup.forEach(n=>{if(n.bundleMap.has(this._rendererType))a.push(n.bundleMap.get(this._rendererType));else{let l=w.recordBundleEncoder(r.renderBundleEncoderDescriptor);this.recordShadowRenderBundleNode(e,t,l,n.renderNodes);let h=l.finish();n.bundleMap.set(this._rendererType,h),a.push(h)}}),a}return[]}recordShadowRenderBundleNode(e,t,r,s,a){if(w.bindCamera(r,t),s){w.bindGeometryBuffer(r,s[0].geometry);for(let n=0;n<s.length;++n){let l=s[n];l.transform.enable&&l.recordRenderPass2(e,this._rendererType,this.rendererPassState,a,r)}}}drawShadowRenderNodes(e,t,r,s,a){if(w.bindCamera(r,t),s)for(let n=A.setting.render.drawOpMin;n<Math.min(s.length,A.setting.render.drawOpMax);++n){let l=s[n];l.transform.enable&&l.enable&&l.renderPass2(e,this._rendererType,this.rendererPassState,a,r)}}}class Th extends di{constructor(){super(),o(this,"zBufferTexture"),o(this,"useRenderBundle",!1),o(this,"shadowPassCount"),o(this,"zCullingCompute"),this.passType=re.DEPTH;let e=S.presentationSize,t=1;this.zBufferTexture=Fe.createRTTexture(Ae.zBufferTexture_NAME,Math.floor(e[0]*t),Math.floor(e[1]*t),G.rgba16float,!1);let r=new Ce;r.clearValue=[0,0,0,0],r.loadOp="clear";let s=new Ze([],[],Fe.createRTTexture(Ae.zPreDepthTexture_NAME,Math.floor(e[0]),Math.floor(e[1]),G.depth32float,!1),null,!1);this.setRenderStates(s)}render(e,t){let r=e.camera,s=e.scene;w.cleanCache(),ft.start("DepthPass Renderer");let a=s;this.rendererPassState.camera3D=r;let n=Q.instance.getRenderNodes(a,r);this.compute(e,t);let l=this.renderBundleOp(e,n,t),h=[],u=w.beginCommandEncoder(),c=w.beginRenderPass(u,this.rendererPassState);l.length>0&&c.executeBundles(l);let f=Q.instance.getRenderShaderCollect(e);for(const d of f){let p=d[1];for(const m of p){let _=m[1];if(_.preInit){_.nodeUpdate(e,this._rendererType,this.rendererPassState,null);break}}}this.drawRenderNodes(e,c,u,n.opaqueList,t),h.length>0&&c.executeBundles(h),w.endPass(c),w.endCommandEncoder(u),ft.end("DepthPass Renderer")}drawRenderNodes(e,t,r,s,a,n){w.bindCamera(t,e.camera);for(let l=A.setting.render.drawOpMin;l<Math.min(s.length,A.setting.render.drawOpMax);++l){let h=s[l];h.transform.enable&&h.enable&&(h.preInit||h.nodeUpdate(e,this._rendererType,this.rendererPassState),h.renderPass2(e,this._rendererType,this.rendererPassState,n,t))}}}class Mh{constructor(){o(this,"map"),o(this,"passRendererList"),this.map=new Map,this.passRendererList=[]}addRenderer(e){this.map.has(e.passType)?console.error("same renderer pass repeat!"):(this.map.set(e.passType,e),e.passType<=8&&this.addPassRenderer(e))}getRenderer(e){return this.map.get(e)}addPassRenderer(e){this.passRendererList.push(e)}getAllRenderer(){return this.map}getAllPassRenderer(){return this.passRendererList}}class Dh extends di{constructor(){super(),o(this,"finalQuadView"),o(this,"postList"),this._rendererType=re.POST,this.postList=[],this.initRenderer()}initRenderer(){N.register("FullQuad_vert_wgsl",el),this.finalQuadView=new Ns("Quad_vert_wgsl","Quad_frag_wgsl",new Ze([],[]),null,null,!1)}attachPost(e,t){t.postRenderer=this,this.postList.indexOf(t)!=-1||(this.postList.push(t),t.onAttach(e))}detachPost(e,t){let r=this.postList.indexOf(t);return r>=0&&(this.postList.splice(r,1),t.onDetach(e),t.postRenderer=null),r>=0}render(e){let t=w.beginCommandEncoder();for(let s=0;s<this.postList.length;s++){const a=this.postList[s];a.enable&&a.render(e,t)}let r=w.lastRenderPassState.getLastRenderTexture();if(this.finalQuadView.renderToViewQuad(e,this.finalQuadView,t,r),this.debugViewQuads.length){let s=A.setting.render.debugQuad;s>=0&&this.debugViewQuads[s].renderToViewQuad(e,this.debugViewQuads[s],t,this.debugTextures[s])}w.endCommandEncoder(t)}}class Ph{constructor(e){o(this,"rendererMap"),o(this,"shadowMapPassRenderer"),o(this,"pointLightShadowRenderer"),o(this,"ddgiProbeRenderer"),o(this,"postRenderer"),o(this,"clusterLightingRender"),o(this,"occlusionSystem"),o(this,"depthPassRenderer"),o(this,"colorPassRenderer"),o(this,"pauseRender",!1),o(this,"pickFire"),o(this,"_view"),this._view=e,this.rendererMap=new Mh,this.occlusionSystem=new ks,this.clusterLightingRender=this.addRenderer(wh,e),A.setting.render.zPrePass&&(this.depthPassRenderer=this.addRenderer(Th)),this.shadowMapPassRenderer=new Bh,this.pointLightShadowRenderer=new Ih}addRenderer(e,t){let r;return t?r=new e(t):r=new e,this.rendererMap.addRenderer(r),r}get view(){return this._view}set view(e){this._view=e}start(){}stop(){}pause(){this.pauseRender=!0}resume(){this.pauseRender=!1}enablePost(e){this.postRenderer=this.addRenderer(Dh),this.postRenderer.setRenderStates(e)}addPost(e){return this.postRenderer||this.enablePost(wt.getGBufferFrame("ColorPassGBuffer")),e instanceof Ct&&this.postRenderer.attachPost(this.view,e),e}removePost(e){if(e instanceof Ct)this.postRenderer.detachPost(this.view,e);else for(let t=0;t<e.length;t++)this.postRenderer.detachPost(this.view,e[t])}renderFrame(){let e=this._view;pe.getLightEntries(e.scene).update(e),this.occlusionSystem.update(e.camera,e.scene),this.clusterLightingRender.render(e,this.occlusionSystem),this.shadowMapPassRenderer&&(Ve.update(e.scene),this.shadowMapPassRenderer.render(e,this.occlusionSystem)),this.pointLightShadowRenderer&&this.pointLightShadowRenderer.render(e,this.occlusionSystem),this.depthPassRenderer&&(this.depthPassRenderer.compute(e,this.occlusionSystem),this.depthPassRenderer.render(e,this.occlusionSystem)),A.setting.gi.enable&&this.ddgiProbeRenderer&&(this.ddgiProbeRenderer.compute(e,this.occlusionSystem),this.ddgiProbeRenderer.render(e,this.occlusionSystem));let t=this.rendererMap.getAllPassRenderer();for(let r=0;r<t.length;r++){const s=t[r];s.compute(e,this.occlusionSystem),s.render(e,this.occlusionSystem,this.clusterLightingRender.clusterLightingBuffer)}this.postRenderer&&this.postRenderer.postList.length>0&&this.postRenderer.render(e)}debug(){}}class Rh extends te{constructor(e=.001,t=1e4,r=90,s=!1){super(),o(this,"up_camera"),o(this,"down_camera"),o(this,"left_camera"),o(this,"right_camera"),o(this,"front_camera"),o(this,"back_camera"),this.initCubeCamera(e,t,r,s)}initCubeCamera(e,t,r=90,s=!1){this.up_camera=Ne.createCamera3DObject(this,"up"),this.down_camera=Ne.createCamera3DObject(this,"down"),this.left_camera=Ne.createCamera3DObject(this,"left"),this.right_camera=Ne.createCamera3DObject(this,"right"),this.front_camera=Ne.createCamera3DObject(this,"front"),this.back_camera=Ne.createCamera3DObject(this,"back"),this.up_camera.isShadowCamera=s,this.down_camera.isShadowCamera=s,this.left_camera.isShadowCamera=s,this.right_camera.isShadowCamera=s,this.front_camera.isShadowCamera=s,this.back_camera.isShadowCamera=s;let a=1;this.up_camera.perspective(r,a,e,t),this.up_camera.lookAt(g.ZERO,g.UP,g.DOWN),this.down_camera.perspective(r,a,e,t),this.down_camera.lookAt(g.ZERO,g.DOWN,g.DOWN),this.left_camera.perspective(r,a,e,t),this.left_camera.lookAt(g.ZERO,g.LEFT),this.right_camera.perspective(r,a,e,t),this.right_camera.lookAt(g.ZERO,g.RIGHT),this.front_camera.perspective(r,a,e,t),this.front_camera.lookAt(g.ZERO,g.FORWARD),this.back_camera.perspective(r,a,e,t),this.back_camera.lookAt(g.ZERO,g.BACK),this.up_camera.type=Ie.shadow,this.down_camera.type=Ie.shadow,this.left_camera.type=Ie.shadow,this.right_camera.type=Ie.shadow,this.front_camera.type=Ie.shadow,this.back_camera.type=Ie.shadow}}class Lh extends Ze{constructor(e,t){super([],[]),this.crateGBuffer(e,t)}crateGBuffer(e,t){let r=this.attachments,s=this.rtDescriptors,a=new oe(e,t,G.rgba16float,!1);a.name="positionMap";let n=new Ce;n.loadOp="load";let l=new oe(e,t,G.rgba16float,!1);l.name="normalMap";let h=new Ce;h.loadOp="load";let u=new oe(e,t,G.rgba16float,!1);u.name="colorMap";let c=new Ce;c.loadOp="load";let f=new oe(e,t,G.depth24plus,!1);f.name="depthTexture";let d=new Ce;d.loadOp="load",r.push(a),r.push(l),r.push(u),s.push(n),s.push(h),s.push(c),this.depthTexture=f}}let Uh=`
#include "GenerayRandomDir"
#include "MathShader"
#include "IrradianceVolumeData_frag"

struct ProbeData{
  offsetX:f32,
  offsetY:f32,
  offsetZ:f32,
  frame:f32,
}

 struct Uniforms {
     matrix : array<mat4x4<f32>>
 };

struct RayProbeBuffer{
  WPosition: vec3<f32>,
  WNormal:vec3<f32>,
  WRadiance:vec4<f32>,
}

struct CacheHitData{
  color:vec4<f32>,
  depth:vec4<f32>,
}

//  struct RayInfo{
//   rays:array<vec4<f32>,4096>
//  }

@group(0) @binding(0) var<storage, read> probes : array<ProbeData>;
@group(0) @binding(1) var<storage, read_write> irradianceBuffer : array<vec4<f32>>;
@group(0) @binding(2) var<storage, read_write> depthBuffer : array<vec4<f32>>;
@group(0) @binding(3) var<storage, read> uniformData : IrradianceVolumeData ;
@group(0) @binding(4) var probeIrradianceMap : texture_storage_2d<rgba16float, write>;
@group(0) @binding(5) var probeDepthMap : texture_storage_2d<rgba16float, write>;
@group(0) @binding(6) var<storage, read_write> depthRaysBuffer : array<vec4<f32>>;

@group(1) @binding(0) var positionMap : texture_2d<f32>;
@group(1) @binding(1) var normalMap : texture_2d<f32>;
@group(1) @binding(2) var colorMap : texture_2d<f32>;

@group(2) @binding(0)
var<storage, read> models : Uniforms;

var<private> probeID: u32 ;
var<private> workgroup_idx: u32 ;
var<private> workgroup_idy: u32 ;
var<private> hysteresis: f32 = 0.98 ;
var<private> epsilon: f32 = 1e-6 ;
var<private> probeLocation:vec3<f32> = vec3<f32>(0.0);
var<private> energyConservation: f32 = 0.85 ;
var<private> resultIrradiance: vec4<f32> ;
var<private> resultDepth: vec4<f32> ;
var<private> RAYS_PER_PROBE: f32 = 144.0 ;
var<private> OCT_RT_SIZE: u32;
var<private> PROBE_OCT_RT_SIZE: u32;
var<private> OCT_SIDE_SIZE_u32: u32;
var<private> OCT_SIDE_SIZE_f32: f32;
var<private> OCT_RT_SIZE_f32: f32;
var<private> PROBE_SOURCESIZE: f32;
var<private> PROBEMAP_SOURCESIZE: f32;
var<private> quaternion:vec4<f32> = vec4<f32>(0.0, -0.7071067811865475, 0.7071067811865475, 0.0);
var<private> randomMatrix:mat4x4<f32>;

@compute @workgroup_size( 8 , 8 , 1 )
fn CsMain(@builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
{
   RAYS_PER_PROBE = f32(i32(uniformData.rayNumber));
   OCT_RT_SIZE = u32(uniformData.OctRTMaxSize);
   OCT_RT_SIZE_f32 = f32(uniformData.OctRTMaxSize);
   OCT_SIDE_SIZE_u32 = u32(uniformData.OctRTSideSize);
   OCT_SIDE_SIZE_f32 = f32(uniformData.OctRTSideSize);
   PROBE_SOURCESIZE = f32(uniformData.ProbeSize);
   PROBEMAP_SOURCESIZE = f32(uniformData.ProbeSourceTextureSize);
   hysteresis = uniformData.hysteresis;
    // probe index
    probeID = globalInvocation_id.z ;
    // pixel coord
    workgroup_idx = globalInvocation_id.x ;
    workgroup_idy = globalInvocation_id.y;

    probeLocation = calcProbePosition(probeID);

    resultIrradiance = vec4<f32>(0.0);
    resultDepth = vec4<f32>(0.0,0.0,0.0,0.0);

    var tdr = normalize(getCurrentDir());
    let orientationIndex = u32(uniformData.orientationIndex);
    randomMatrix = models.matrix[orientationIndex];

    var distancePprobeUV = getSampleProbeUV(tdr.xyz);
    var rayUv:vec2<i32> = vec2<i32>(distancePprobeUV.xy * f32(PROBEMAP_SOURCESIZE - 1.0));
    let rayHitPosition = textureLoad(positionMap, rayUv, 0).xyz ;
    
    for(var i:f32 = 0.0; i < RAYS_PER_PROBE ; i = i + 1.0 ){
      radianceProbeOnce(i, tdr);
    }

    if (resultIrradiance.w > epsilon) {
      var color = vec3<f32>(resultIrradiance.xyz/(2.0*resultIrradiance.w)) ;
      color = pow(color.rgb, vec3<f32>(1.0 / uniformData.ddgiGamma));
      resultIrradiance = vec4<f32>(color,1.0-hysteresis);
    }

    // if nonzero
    if (resultDepth.w > epsilon) {
      resultDepth = vec4<f32>(resultDepth.xyz/(2.0*resultDepth.w),1.0-hysteresis) ;
    }

   let pixelCoord = getWriteOctUVByID();

   var lerpDataResult:CacheHitData;

   lerpDataResult.color = resultIrradiance;

   lerpDataResult.depth = resultDepth;

   lerpDataResult = lerpHitData(lerpDataResult, pixelCoord);

   writeRayHitData(pixelCoord, lerpDataResult);

   storePixelAtCoord(probeIrradianceMap, pixelCoord , vec4<f32>(lerpDataResult.color.xyz, 1.0), true);

   storePixelAtCoord(probeDepthMap, pixelCoord , vec4<f32>(resultDepth.xy, 0.0, 1.0), false);
}

fn lerpHitData(data:CacheHitData, coord:vec2<i32>) -> CacheHitData{
   let frameIndex = probes[probeID].frame;
   var newData:CacheHitData = data;

   //if(frameIndex > 1.0){
      var oldData = readRayHitData(coord);
      newData.color = mix(oldData.color, newData.color, uniformData.lerpHysteresis);
      newData.depth = mix(oldData.depth, newData.depth, uniformData.lerpHysteresis);
   //}
   return newData;
}

fn square(v:vec3<f32>) -> vec3<f32>{
   var v3 = v;
   v3.x = v3.x * v3.x;
   v3.y = v3.y * v3.y;
   v3.z = v3.z * v3.z;
   return v3;
}

 fn testSample() ->vec4<f32>{
   var ux = f32(workgroup_idx) / OCT_SIDE_SIZE_f32;
   var uy = f32(workgroup_idy) / OCT_SIDE_SIZE_f32;
   var uv = vec2<f32>(ux,uy) * 2.0 - 1.0 ;
   var dir = octDecode(uv);
   var probeUV = getSampleProbeUV(dir.xyz);
   var rayProbeBuffer = getCurrentRayHitBuffer(probeUV);
   return rayProbeBuffer.WRadiance;
 }

 fn gridCoordToProbeIndex(grid:vec3<i32>) -> i32
 {
     return grid.x + grid.z * i32(uniformData.gridXCount) + grid.y * i32(uniformData.gridXCount * uniformData.gridZCount);
 }

fn storePixelAtCoord(texture:texture_storage_2d<rgba16float, write>, coord:vec2<i32>, color:vec4<f32>, isColor:bool){
   let sideCnt = i32(OCT_SIDE_SIZE_u32);
   let sideBorderCnt = sideCnt + 2;
   let indexXY = coord / sideCnt;
   let modeXY = coord % sideCnt;

   var newCoord = indexXY * sideBorderCnt + modeXY;
   textureStore(texture, newCoord + 1, color);

   var borderCoord = vec2<i32>(-1);
   //\u5DE6\u53F3
   if(modeXY.x % (sideCnt - 1) == 0){
     borderCoord = modeXY;
     borderCoord.y = sideCnt - borderCoord.y;
     if(modeXY.x == sideCnt - 1){
       borderCoord.x = sideBorderCnt - 1;
     }
     borderCoord = indexXY * sideBorderCnt + borderCoord;
     textureStore(texture, borderCoord, color);
   }
   //\u4E0A\u4E0B
   if(modeXY.y % (sideCnt - 1) == 0){
     borderCoord = modeXY;
     borderCoord.x = sideCnt - borderCoord.x;
     if(modeXY.y == sideCnt - 1){
         borderCoord.y = sideBorderCnt - 1;
     }
     borderCoord = indexXY * sideBorderCnt + borderCoord;
     textureStore(texture, borderCoord, color);
   }
   //\u8865\u89D2
   if(modeXY.x % (sideCnt - 1) == 0 && modeXY.y % (sideCnt - 1) == 0){
      var cornerCoord = modeXY;
      if(modeXY.x == 0){
         cornerCoord.x = sideBorderCnt - 1;
      }else{
         cornerCoord.x = 0;
      }
       if(modeXY.y == 0){
         cornerCoord.y = sideBorderCnt - 1;
      }else{
         cornerCoord.y = 0;
      }
      cornerCoord = indexXY * sideBorderCnt + cornerCoord;
      textureStore(texture, cornerCoord, color);
   }
}

fn calcProbePosition(id:u32) -> vec3<f32>{
   var probeLocation = vec3<f32>(0.0);
   var blockCount = u32(uniformData.gridXCount * uniformData.gridZCount) ;
   var grid = vec3<u32>(0u);
   grid.x = (id % blockCount) % u32(uniformData.gridXCount);
   grid.y = id / blockCount;
   grid.z = (id % blockCount) / u32(uniformData.gridXCount);
   probeLocation.x = f32(grid.x) * uniformData.ProbeSpace + uniformData.startX;
   probeLocation.y = f32(grid.y) * uniformData.ProbeSpace + uniformData.startY;
   probeLocation.z = f32(grid.z) * uniformData.ProbeSpace + uniformData.startZ;
   return probeLocation;
}

fn getWriteOctUVByID() -> vec2<i32>
{
   var blockCount = u32(uniformData.gridXCount * uniformData.gridZCount) ;
   var offsetX = (probeID % blockCount) % u32(uniformData.gridXCount) ;
   var offsetY = u32(uniformData.gridZCount - 1.0) - (probeID % blockCount) / u32(uniformData.gridXCount) ;
   var offsetZ = probeID / blockCount ;
   var pixelCoord = vec2<i32>(i32(workgroup_idx), i32(workgroup_idy));
   pixelCoord.x = pixelCoord.x + i32(offsetX * OCT_SIDE_SIZE_u32);
   pixelCoord.y = pixelCoord.y + i32(offsetY * OCT_SIDE_SIZE_u32 + offsetZ * u32(uniformData.gridZCount) * OCT_SIDE_SIZE_u32);

   pixelCoord = offsetByCol(pixelCoord, OCT_SIDE_SIZE_f32, OCT_RT_SIZE, vec3<f32>(uniformData.gridXCount, uniformData.gridYCount, uniformData.gridZCount));
   return pixelCoord;
}

fn offsetByCol(pixelCoord0:vec2<i32>, octSideSize:f32, mapHeight:u32, counts:vec3<f32>) -> vec2<i32>
{
 var pixelCoord = pixelCoord0;
 let blockSize:vec2<i32> = vec2<i32>(i32(octSideSize * counts.x),  i32(octSideSize * counts.z));
 let blockSizeYBorder:i32 = i32((octSideSize + 2.0) * counts.z);
 let blockMaxRowBorder:i32 = i32(mapHeight) / blockSizeYBorder;
 let pixelCountYMax:i32 = blockMaxRowBorder * i32(octSideSize * counts.z);
 let col:i32 = pixelCoord.y / pixelCountYMax;

 pixelCoord.x = col * i32(octSideSize * counts.x) + pixelCoord.x;
 pixelCoord.y = pixelCoord.y % pixelCountYMax;

 return pixelCoord;
}

fn radianceProbeOnce(rayID:f32, tdr:vec3<f32>){
   var texelDirection = sphericalFibonacci(rayID, RAYS_PER_PROBE ) ;
   var rayDirection = normalize( vec3<f32>((randomMatrix * vec4<f32>(texelDirection, 1.0)).xyz));
   var probeUV = getSampleProbeUV(rayDirection.xyz);
   var rayWriteUV = getWriteRayInfoUV();

   var rayProbeBuffer = getCurrentRayHitBuffer(probeUV);
   var rayHitLocation = rayProbeBuffer.WPosition + normalize(rayProbeBuffer.WNormal) * 0.01;

   var rayProbeDistance = length(probeLocation - rayHitLocation) ;
   // rayProbeDistance = min(uniformData.ProbeSpace * 4.0, rayProbeDistance) ;

   // if (dot(rayProbeBuffer.WNormal, rayProbeBuffer.WNormal) < epsilon) {
   //   rayProbeDistance = epsilon ;
   // }

   let rid = i32(probeID) * i32(RAYS_PER_PROBE) + i32(rayID) ;
   depthRaysBuffer[rid] = vec4<f32>(rayDirection.xyz,rayProbeDistance) ;

   // Detect misses and force depth
   var i_weight = max(0.0, dot(tdr,rayDirection) );
   var d_weight = pow(i_weight, uniformData.depthSharpness);
   
   if (i_weight >= epsilon) {
     //  var weightColor = pow(weight, (2.0 - uniformData.probeRoughness) * 2.0);
      resultIrradiance += vec4(rayProbeBuffer.WRadiance.rgb, i_weight );
     
   }
   if(d_weight>= epsilon){
       resultDepth += vec4(rayProbeDistance * d_weight, rayProbeDistance * rayProbeDistance * d_weight, 0.0 , i_weight);
   }
}

fn getCurrentRayHitBuffer(probeUV:vec2<f32>) -> RayProbeBuffer {
  var rayProbeBuffer : RayProbeBuffer ;
  var uv:vec2<i32> = vec2<i32>(probeUV.xy * f32(PROBEMAP_SOURCESIZE - 1.0));
  rayProbeBuffer.WPosition = textureLoad(positionMap, uv, 0).xyz ;
  rayProbeBuffer.WNormal = normalize(textureLoad(normalMap, uv, 0).xyz * 2.0 - 1.0);
  rayProbeBuffer.WRadiance = textureLoad(colorMap, uv, 0).xyzw * energyConservation;
  return rayProbeBuffer ;
}

fn getSampleProbeUV(dir0:vec3<f32>) -> vec2<f32> {
   var dir = applyQuaternion(dir0, quaternion);
   let faceId = dir_to_faceId(dir);
   var targetUV:vec2<f32> = convert_xyz_to_cube_uv(dir.x, dir.y, dir.z);
   targetUV.x = 1.0 - targetUV.x;
   let threshould = 0.5 / PROBE_SOURCESIZE;
   targetUV = clamp(targetUV, vec2<f32>(threshould), vec2<f32>(1.0 - threshould));

   targetUV.x = f32(faceId) + targetUV.x;

   let aspect:f32 = PROBE_SOURCESIZE / PROBEMAP_SOURCESIZE;
   targetUV = targetUV * aspect ;

   var fullCol = u32(PROBEMAP_SOURCESIZE) / u32(PROBE_SOURCESIZE);
   var offsetSampleUv = vec2<f32>( f32(probeID / fullCol) * 6.0 , f32(probeID % fullCol)) * aspect;
   return targetUV + offsetSampleUv;
}

fn getWriteRayInfoUV() -> vec2<i32> {
  var writeUV = vec2<i32>(i32(workgroup_idy),i32(probeID)) ;
  return writeUV ;
}

fn writeRayHitData( uv:vec2<i32> , data:CacheHitData){
  let index = uv.y * i32(OCT_RT_SIZE) + uv.x ;
  irradianceBuffer[index] = data.color ;
  depthBuffer[index] = data.depth ;
}

fn readRayHitData( uv:vec2<i32> ) -> CacheHitData{
  var data:CacheHitData;
  let index = uv.y * i32(OCT_RT_SIZE) + uv.x ;
  data.color = irradianceBuffer[index] ;
  data.depth = depthBuffer[index] ;
  return data;
}

fn getCurrentDir() -> vec3<f32> {
  var ux = f32(workgroup_idx) / OCT_SIDE_SIZE_f32;
  var uy = f32(workgroup_idy) / OCT_SIDE_SIZE_f32;
  var uv = vec2<f32>(ux,uy) * 2.0 - 1.0 ;
  var dir = octDecode(uv) ;
  return normalize(dir) ;
}


`;class Oh{constructor(e){o(this,"irradianceBuffer"),o(this,"depthBuffer"),o(this,"probeIrradianceMap"),o(this,"probeDepthMap"),o(this,"volume"),o(this,"computeShader"),o(this,"depthRaysBuffer"),this.volume=e,this.initPipeline()}initPipeline(){this.computeShader=new be(Uh);let e=A.setting.gi,t=e.octRTMaxSize*e.octRTMaxSize;this.irradianceBuffer=new ge(t*4,GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST),this.computeShader.setStorageBuffer("irradianceBuffer",this.irradianceBuffer),this.depthBuffer=new ge(t*4,GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST),this.computeShader.setStorageBuffer("depthBuffer",this.depthBuffer),this.depthRaysBuffer=new ge(4096*4*2*2*2,GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC),this.computeShader.setStorageBuffer("depthRaysBuffer",this.depthRaysBuffer),this.computeShader.setStorageBuffer("probes",this.volume.probesBuffer),this.computeShader.setStorageBuffer("uniformData",this.volume.irradianceVolumeBuffer),this.computeShader.setStorageBuffer("models",pe.modelMatrixBindGroup.matrixBufferDst)}setTextures(e,t,r){this.probeIrradianceMap=t,this.probeDepthMap=r;let s=e[0],a=e[1],n=e[2];this.computeShader.setStorageTexture("probeIrradianceMap",this.probeIrradianceMap),this.computeShader.setStorageTexture("probeDepthMap",this.probeDepthMap),this.computeShader.setSamplerTexture("positionMap",s),this.computeShader.setSamplerTexture("normalMap",a),this.computeShader.setSamplerTexture("colorMap",n)}readBuffer(){return this.depthRaysBuffer.readBuffer()}compute(e,t){let r=this.volume.setting,s=w.beginCommandEncoder(),a=Q.instance.getProbes(e.scene);this.computeShader.workerSizeX=r.octRTSideSize/8,this.computeShader.workerSizeY=r.octRTSideSize/8,this.computeShader.workerSizeZ=a.length,w.computeCommand(s,[this.computeShader])}}let Nh=`
  #include "MathShader"
  #include "IrradianceVolumeData_frag"

  struct IrradianceField {
      probeStartPosition: vec4<f32>,
      probeCounts:vec4<f32>,
      probeStep:f32,
      irradianceTextureWidth:f32,
      irradianceTextureHeight:f32,
      irradianceProbeSideLength:f32,
  };

  @group(0) @binding(0) var outputBuffer : texture_storage_2d<rgba16float, write>;
  @group(0) @binding(1) var<storage,read> uniformData : IrradianceVolumeData ;

  @group(1) @binding(0) var normalMapSampler : sampler;
  @group(1) @binding(1) var normalMap : texture_2d<f32>;

  @group(1) @binding(2) var colorMapSampler : sampler;
  @group(1) @binding(3) var colorMap : texture_2d<f32>;

  @group(1) @binding(4) var litMapSampler : sampler;
  @group(1) @binding(5) var litMap : texture_2d<f32>;

  @group(1) @binding(6) var irradianceMapSampler : sampler;
  @group(1) @binding(7) var irradianceMap : texture_2d<f32>;

  var<private> wsn:vec3<f32>;
  var<private> ulitColor:vec4<f32>;
  var<private> litColor:vec4<f32>;
  var<private> irradianceFieldSurface : IrradianceField ;
  var<private> probeID:u32;

  var<private> quaternion:vec4<f32> = vec4<f32>(0.0, -0.7071067811865475, 0.7071067811865475, 0.0);

  fn getIrradianceFieldSurface() -> IrradianceField{
    let data = uniformData;
    irradianceFieldSurface.probeStartPosition = vec4<f32>(data.startX, data.startY, data.startZ, 0.0);
    irradianceFieldSurface.probeCounts = vec4<f32>(data.gridXCount, data.gridYCount, data.gridZCount, 0.0);
    irradianceFieldSurface.probeStep = data.ProbeSpace;
    irradianceFieldSurface.irradianceTextureWidth = data.OctRTMaxSize;
    irradianceFieldSurface.irradianceTextureHeight = data.OctRTMaxSize;
    irradianceFieldSurface.irradianceProbeSideLength = data.OctRTSideSize;
    return irradianceFieldSurface;
  }

  fn rotateDir(n:vec3<f32>) -> vec3<f32>{
     return normalize(applyQuaternion(-n, quaternion));
  }

  fn sampleLitColor(uv:vec2<i32>) -> vec4<f32>
  {
      var oc1:vec4<f32> = textureSampleLevel(litMap, litMapSampler, vec2<f32>(0.0), 0.0);
      var oc:vec4<f32> = textureLoad(litMap, uv, 0);
      return oc;
  }

  fn sampleNormal(uv:vec2<i32>) -> vec4<f32>
  {
      var oc1:vec4<f32> = textureSampleLevel(normalMap, normalMapSampler, vec2<f32>(0.0), 0.0);
      var oc:vec4<f32> = textureLoad(normalMap, uv, 0);
      return oc;
  }

  fn sampleColor(uv:vec2<i32>) -> vec4<f32>
  {
      var oc1:vec4<f32> = textureSampleLevel(colorMap, colorMapSampler, vec2<f32>(0.0), 0.0);
      var oc:vec4<f32> = textureLoad(colorMap, uv, 0);
      return oc;
  }

  fn sampleProbe(fragCoord:vec2<u32>){
    var uv = vec2<i32>(i32(fragCoord.x), i32(fragCoord.y)) ;

    litColor = sampleLitColor(uv);

    var normalMap = sampleNormal(uv);
    wsn = normalMap.xyz * 2.0 - 1.0;

    ulitColor = sampleColor(uv);
  }

  @compute @workgroup_size( 8 , 8 , 1 )
  fn CsMain(@builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
  {
    getIrradianceFieldSurface();
    var fragCoord = vec2<u32>( globalInvocation_id.x, globalInvocation_id.y);
    probeID = globalInvocation_id.z;
    fragCoord = fragCoord + getCoordOffset(probeID);

    sampleProbe(fragCoord);

    let irradiance = getIrradianceColor();
    let result = blendIrradianceColor(irradiance);
    textureStore(outputBuffer, vec2<i32>(fragCoord), result);
  }

  fn blendIrradianceColor(irradiance:vec4<f32>) -> vec4<f32>{
     var bounceColor = irradiance * ulitColor;
     let bounceIntensity = getBounceIntensity(uniformData.bounceIntensity);
     let conservation1 = 1.0 / sqrt((1.0 + bounceIntensity * 0.55));
     let conservation2 = 1.0 / sqrt((1.0 + bounceIntensity));
     var result = litColor * conservation2 + bounceColor * sqrt(bounceIntensity) * conservation1;
     return vec4<f32>(result.xyz, litColor.w);
  }

  fn getBounceIntensity(intensity:f32) -> f32 {
    var value = clamp(intensity, 0.0, 1.0) * 10.0;
    return value;
  }

  fn getCoordOffset(id:u32) -> vec2<u32>{
      var fullCol = u32(uniformData.ProbeSourceTextureSize / uniformData.ProbeSize);
      var offsetSampleUv = vec2<u32>( (id / fullCol) * 6u , id % fullCol) * u32(uniformData.ProbeSize);
      return offsetSampleUv;
  }

  fn getIrradianceColor() -> vec4<f32>{
     var probeIrradiance: vec4<f32> = vec4<f32>(0.0);
     if(length(wsn) > 0.01){
       probeIrradiance = getIrrdiaceIndex(i32(probeID), wsn);
     }
     return probeIrradiance;
  }

  fn getIrrdiaceIndex(index:i32, wsn:vec3<f32>) -> vec4<f32>{
    var wsN = rotateDir(wsn.xyz);
    var texCoord:vec2<f32> = textureCoordFromDirection(wsN,
      index,
      irradianceFieldSurface.irradianceTextureWidth,
      irradianceFieldSurface.irradianceTextureHeight,
      irradianceFieldSurface.irradianceProbeSideLength);

    var probeIrradiance: vec3<f32> = textureSampleLevel(irradianceMap, irradianceMapSampler, texCoord, 0.0).xyz;
    return vec4<f32>(probeIrradiance, 1.0);
  }

  fn textureCoordFromDirection(dir:vec3<f32>, probeIndex:i32, width:f32, height:f32, sideLength:f32) -> vec2<f32>
  {
      var uv = getWriteOctUVByID(dir, u32(probeIndex), sideLength) ;
      uv.x = uv.x / irradianceFieldSurface.irradianceTextureWidth;
      uv.y = uv.y / irradianceFieldSurface.irradianceTextureHeight;
      return uv ;
  }

  fn getWriteOctUVByID(dir:vec3<f32> , probeID:u32, size: f32) -> vec2<f32>
  {
      var blockCount = u32(irradianceFieldSurface.probeCounts.x * irradianceFieldSurface.probeCounts.z) ;
      var offsetX = (probeID % blockCount) % u32(irradianceFieldSurface.probeCounts.x) ;
      var offsetY = u32(irradianceFieldSurface.probeCounts.z - 1.0) - (probeID % blockCount) / u32(irradianceFieldSurface.probeCounts.x) ;
      var offsetZ = probeID / blockCount ;

      var pixelCoord = (( octEncode(dir) + 1.0 ) * 0.5) * vec2<f32>(size,size) ;

      var blockOffset = vec2<f32>(0.0);
      blockOffset.x = f32(offsetX) * size;
      blockOffset.y = f32(offsetY) * size + f32(offsetZ) * f32(irradianceFieldSurface.probeCounts.z) * size;

      let mapHeight = u32(irradianceFieldSurface.irradianceTextureHeight);
      var probeCounts:vec3<f32> = vec3<f32>(irradianceFieldSurface.probeCounts.xyz);

      var gridOffsetFrom = vec2<i32>(blockOffset) + 1;
      var gridOffsetTo = offsetByCol(gridOffsetFrom, size, mapHeight, probeCounts);

      pixelCoord = pixelCoord + vec2<f32>(gridOffsetTo - 1) + vec2<f32>(vec2<i32>(vec2<f32>(gridOffsetTo) / size) * 2);

      return pixelCoord + 1.0 ;
  }

  fn offsetByCol(pixelCoord0:vec2<i32>, octSideSize:f32, mapHeight:u32, counts:vec3<f32>) -> vec2<i32>
  {
    var pixelCoord = pixelCoord0;
    let blockSize:vec2<i32> = vec2<i32>(i32(octSideSize * counts.x),  i32(octSideSize * counts.z));
    let blockSizeYBorder:i32 = i32((octSideSize + 2.0) * counts.z);
    let blockMaxRowBorder:i32 = i32(mapHeight) / blockSizeYBorder;
    let pixelCountYMax:i32 = blockMaxRowBorder * i32(octSideSize * counts.z);
    let col:i32 = pixelCoord.y / pixelCountYMax;

    pixelCoord.x = col * i32(octSideSize * counts.x) + pixelCoord.x;
    pixelCoord.y = pixelCoord.y % pixelCountYMax;

    return pixelCoord;
  }
`;class Fh{constructor(e){o(this,"blendTexture"),o(this,"volume"),o(this,"computerShader"),this.volume=e,this.initPipeline()}initPipeline(){let e=A.setting.gi;this.blendTexture=new oe(e.probeSourceTextureSize,e.probeSourceTextureSize,G.rgba16float,!1,GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING),this.computerShader=new be(Nh),this.computerShader.setStorageTexture("outputBuffer",this.blendTexture),this.computerShader.setStorageBuffer("uniformData",this.volume.irradianceVolumeBuffer)}setInputs(e){let t=e[0],r=e[1],s=e[2],a=e[3];this.computerShader.setSamplerTexture("normalMap",t),this.computerShader.setSamplerTexture("colorMap",r),this.computerShader.setSamplerTexture("litMap",s),this.computerShader.setSamplerTexture("irradianceMap",a)}compute(e,t){let r=w.beginCommandEncoder(),s=this.volume.setting,a=s.probeXCount*s.probeYCount*s.probeZCount,n=s.probeSize;this.computerShader.workerSizeX=n*6/8,this.computerShader.workerSizeY=n/8,this.computerShader.workerSizeZ=a,w.computeCommand(r,[this.computerShader])}}let kh=`

#include "GlobalUniform"
#include "MathShader"
#include "FastMathShader"
#include "ColorUtil"

struct ConstUniform{
   screenWidth:f32,
   screenHeight:f32
}

struct LightData {
     index:f32,
     lightType:i32,
     radius:f32,
     linear:f32,
     
     position:vec3<f32>,
     lightMatrixIndex:f32,

     direction:vec3<f32>,
     quadratic:f32,

     lightColor:vec3<f32>,
     intensity:f32,

     innerCutOff :f32,
     outerCutOff:f32,
     range :f32,
     castShadow:i32,

     lightTangent:vec3<f32>,
     ies:f32,
};

struct Uniforms {
     matrix : array<mat4x4<f32>>
 };

const PointLightType = 1;
const DirectLightType = 2;
const SpotLightType = 3;

@group(0) @binding(1) var outputBuffer : texture_storage_2d<rgba16float, write>;
@group(0) @binding(2) var prefilterMapSampler: sampler;
@group(0) @binding(3) var prefilterMap: texture_cube<f32>;

@group(1) @binding(0) var positionMapSampler : sampler;
@group(1) @binding(1) var positionMap : texture_2d<f32>;

@group(1) @binding(2) var normalMapSampler : sampler;
@group(1) @binding(3) var normalMap : texture_2d<f32>;

@group(1) @binding(4) var colorMapSampler : sampler;
@group(1) @binding(5) var colorMap : texture_2d<f32>;

@group(1) @binding(6) var shadowMapSampler : sampler_comparison;
@group(1) @binding(7) var shadowMap : texture_depth_2d_array;

@group(1) @binding(8) var pointShadowMapSampler: sampler;
@group(1) @binding(9) var pointShadowMap: texture_depth_cube_array ;

@group(2) @binding(0)
var<storage,read> lightBuffer: array<LightData>;

@group(2) @binding(1)
var<storage, read> models : Uniforms;

struct ShadowStruct{
 directShadowVisibility:f32,
 pointShadows:array<f32,8>,
}

var<private> shadowStrut: ShadowStruct ;
var<private> ulitColor:vec3<f32>;
var<private> wPosition:vec3<f32>;
var<private> wNormal:vec3<f32>;

const LUMEN = 10.764;

fn samplePosition(uv:vec2<i32>) -> vec4<f32>
{
   var oc1:vec4<f32> = textureSampleLevel(positionMap, positionMapSampler, vec2<f32>(0.0), 0.0);
   var oc:vec4<f32> = textureLoad(positionMap, uv, 0) ;
   return oc;
}

fn sampleNormal(uv:vec2<i32>) -> vec4<f32>
{
   var oc1:vec4<f32> = textureSampleLevel(normalMap, normalMapSampler, vec2<f32>(0.0), 0.0);
   var oc:vec4<f32> = textureLoad(normalMap, uv, 0);
   return oc;
}

fn sampleColor(uv:vec2<i32>) -> vec4<f32>
{
   var oc1:vec4<f32> = textureSampleLevel(colorMap, colorMapSampler, vec2<f32>(0.0), 0.0);
   var oc:vec4<f32> = textureLoad(colorMap, uv, 0);
   ulitColor = vec3(oc.xyz);
   return oc;
}

const csmCount:i32 = ${lt.Cascades} ;
fn directShadowMaping(P:vec3<f32>, N:vec3<f32>, shadowBias: f32)  {
  let enableCSM:bool = globalUniform.enableCSM > 0.5;
  var light = lightBuffer[0];
  var visibility = 1.0;
  var shadowIndex = i32(light.castShadow);
  if (shadowIndex >= 0 ) {
    var shadowMatrix:mat4x4<f32>;
    if(enableCSM && csmCount > 1){
      for(var csm:i32 = 0; csm < csmCount; csm ++){
        var csmShadowBias = globalUniform.csmShadowBias[csm];
        shadowMatrix = globalUniform.csmMatrix[csm];
        let csmShadowResult = directShadowMapingIndex(light, shadowMatrix, P, N, csm, csmShadowBias);
        if(csmShadowResult.y < 0.5){
          visibility = csmShadowResult.x;
          break;
        }
      }
    }else{
      shadowMatrix = globalUniform.shadowMatrix[shadowIndex];
      visibility = directShadowMapingIndex(light, shadowMatrix, P, N, shadowIndex, shadowBias).x;
    }
  }
  shadowStrut.directShadowVisibility = visibility;
}

fn directShadowMapingIndex(light:LightData, matrix:mat4x4<f32>, P:vec3<f32>, N:vec3<f32>, depthTexIndex:i32, shadowBias:f32) -> vec2<f32>
{
  var visibility = 1.0;
  var isOutSideArea:f32 = 1.0;
  var shadowPosTmp = matrix * vec4<f32>(P.xyz, 1.0);
  var shadowPos = shadowPosTmp.xyz / shadowPosTmp.w;
  var varying_shadowUV = shadowPos.xy * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5, 0.5);
  if (varying_shadowUV.x <= 1.0
    && varying_shadowUV.x >= 0.0
    && varying_shadowUV.y <= 1.0
    && varying_shadowUV.y >= 0.0
    && shadowPosTmp.z <= 1.0
    && shadowPosTmp.z >= 0.0)
  {
    isOutSideArea = 0.0;
    var uvOnePixel = 1.0 / vec2<f32>(globalUniform.shadowMapSize);
    var NoL = abs(dot(N, normalize(light.direction)));
    var bias = shadowBias / max(NoL, 0.000001);
    visibility = textureSampleCompareLevel(shadowMap, shadowMapSampler, varying_shadowUV, depthTexIndex, shadowPos.z - bias);
    visibility += 0.001;
  }
  return vec2<f32>(visibility, isOutSideArea);
}

fn pointShadowMapCompare(shadowBias:f32){
   for(var i:i32 = i32(0) ; i < i32(8); i = i + 1 )
   { 
       var v = 1.0 ;
       let light = lightBuffer[i] ;
       if(light.castShadow < 0 ){
         shadowStrut.pointShadows[i] = v ;
         continue ;
       }

       let frgToLight = wPosition - light.position.xyz;
       var dir:vec3<f32> = normalize(frgToLight)  ;

       var len = length(frgToLight) ;
       var depth = textureSampleLevel(pointShadowMap,pointShadowMapSampler,dir.xyz,i,0); 
       depth *= globalUniform.far ;
       if((len - shadowBias) > depth){
          v = 0.0 ; 
       }
       shadowStrut.pointShadows[i] = v ;
   }
} 

fn directLighting( albedo:vec3<f32> , WP :vec3<f32>, N:vec3<f32> , V:vec3<f32> , light:LightData , shadowBias:f32  ) -> vec3<f32> {
 var L = -normalize(light.direction.xyz) ;
 var NoL = max(dot(N,L),0.0);
 let lightCC = pow( light.lightColor.rgb,vec3<f32>(2.2));
 var lightColor = getHDRColor( lightCC , light.linear ) ;
 var att = light.intensity / LUMEN ;
 if(light.castShadow>=0){
     lightColor *= shadowStrut.directShadowVisibility ;
 }
 let finalLight = (albedo / PI) * lightColor * NoL * att * 2.0 ;
 return finalLight ;
}

fn pointLighting( albedo:vec3<f32>,WP:vec3<f32>, N:vec3<f32>, V:vec3<f32>, light:LightData ) -> vec3<f32> {
 let lightPos = models.matrix[u32(light.lightMatrixIndex)][3].xyz;
 var dir = lightPos.xyz - WP ;
 let dist = length(dir);
 var color = vec3<f32>(0.0) ;

 if(dist != 0.0){
   dir *= 1.0 / dist ;
 }

 if( abs(dist) < light.range ){
     var L = dir ;
     var atten = 1.0 ;
     atten = 1.0 - smoothstep(0.0,light.range,dist) ;
     atten *= 1.0 / max(light.radius,0.0001) ;

     var lightColor = light.lightColor.rgb  ;
     lightColor = getHDRColor(lightColor , light.linear ) * light.intensity / LUMEN * 2.0;
     color = (albedo / PI) * lightColor.rgb * atten ;
 }

 return  color *0.0;
}

fn spotLight( albedo:vec3<f32>,WP:vec3<f32>, N:vec3<f32>, V:vec3<f32>, light:LightData ) -> vec3<f32> {
 let lightPos = models.matrix[u32(light.lightMatrixIndex)][3].xyz;
 var dir = lightPos.xyz - WP ;
 let dist = length(dir) ;

 if(dist != 0.0){
   dir *= 1.0 / dist ;
 }

 var color = vec3<f32>(0.0) ;
 if( abs(dist) < light.range * 2.0 ){
     var L = dir ;
     let theta = dot(-L, normalize(light.direction));
     let angle = acos(theta) ;
     var atten = 1.0 ;
     atten = 1.0 - smoothstep(0.0,light.range,dist) ;
     atten *= 1.0 / max(light.radius,0.1) ;
     if(angle < light.outerCutOff){
       if(angle > light.innerCutOff){
         atten *= 1.0 - smoothstep(light.innerCutOff, light.outerCutOff, angle) ;
       }
     }else{
       atten = 0.0 ;
     }
     var lightColor = light.lightColor.rgb  ;
     lightColor = getHDRColor(lightColor , light.linear ) * light.intensity / LUMEN * 2.0;
     color = (albedo / PI) * lightColor.rgb * atten ;
   }
 return  color ;
}

fn coordFun(fragCoord:vec2<u32>)-> vec4<f32>{
 var uv = vec2<i32>(i32(fragCoord.x), i32(fragCoord.y)) ;
 var pos = samplePosition(uv);

 var normalMap = sampleNormal(uv);
 var normal = normalize( normalMap.xyz * 2.0 - 1.0 );

 var color = sampleColor(uv);
 var emissive = vec4<f32>(pos.a,normalMap.a,color.a,0.0) * 1.0 ;
 if(pos.w + 1.0 > 10000.0){
   return vec4<f32>(color);
 }
 var V = normalize(pos.xyz - globalUniform.cameraWorldMatrix[3].xyz);
 var N = normal.xyz ;

 wPosition = pos.xyz;
 wNormal = N;

 directShadowMaping(wPosition, wNormal, globalUniform.shadowBias);
 pointShadowMapCompare(globalUniform.shadowBias);

 var lighting = vec3<f32>(0.0);
 let lightCount = 32 ;
 for(var i:i32 = 0 ; i < lightCount ; i = i + 1 )
 {
     let light = lightBuffer[i];
     switch (light.lightType) {
         case PointLightType: {
             lighting += pointLighting(color.rgb,pos.xyz,N,V,light);
         }
         case DirectLightType: {
             lighting += directLighting(color.rgb,pos.xyz,N,V,light,globalUniform.shadowBias);
         }
         case SpotLightType: {
             lighting += spotLight(color.rgb,pos.xyz,N,V,light);
         }
         default: {
         }
     }
 }

 // lighting = vec3<f32>(1.0) / (vec3<f32>(1.0) + lighting.rgb) * lighting.rgb;

 var skyLight: vec3<f32> = globalUniform.skyExposure * (textureSampleLevel(prefilterMap, prefilterMapSampler, N.xyz, 8.0 ).rgb);
 // skyLight = LinearToGammaSpace(skyLight);
 // skyLight = (color.rgb / 3.1415926 ) * skyLight;
 // skyLight = vec3<f32>(1.0) / (vec3<f32>(1.0) + skyLight.rgb) * skyLight.rgb;

 lighting = lighting.rgb ;//+ skyLight.rgb ;

 return vec4<f32>(lighting.rgb,color.w)+emissive;
}

// fn vertexToCoord(vertexPosition:vec3<f32>) -> vec4<f32>{
//   var worldPos = vec4<f32>(vertexPosition.xyz, 1.0);
//   var fragPosition = globalUniform.viewMat * worldPos ;
//   // var position = globalUniform.projMat * fragPosition ;
//   return fragPosition;
// }

@compute @workgroup_size( 8 , 8 , 1 )
fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
{
   var fragCoord = vec2<u32>( globalInvocation_id.x, globalInvocation_id.y);
   var color = coordFun(fragCoord);
   
   // color = vec4(pow(color.rgb,vec3<f32>(1.0/2.4)),1.0);
   textureStore(outputBuffer, vec2<i32>(fragCoord),color);
}

`;class zh{constructor(){o(this,"computeShader"),o(this,"worldPosMap"),o(this,"worldNormalMap"),o(this,"colorMap"),o(this,"shadowMap"),o(this,"pointShadowMap"),o(this,"lightingTexture");let e=A.setting.gi;this.lightingTexture=new oe(e.probeSourceTextureSize,e.probeSourceTextureSize,G.rgba16float,!1,GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING)}create(e){let t=pe.getLightEntries(e.scene);this.computeShader=new be(kh);let r=pe.getCameraGroup(e.camera);this.computeShader.setUniformBuffer("globalUniform",r.uniformGPUBuffer),this.computeShader.setStorageTexture("outputBuffer",this.lightingTexture),this.computeShader.setStorageBuffer("lightBuffer",t.storageGPUBuffer),this.computeShader.setStorageBuffer("models",pe.modelMatrixBindGroup.matrixBufferDst),this.computeShader.setSamplerTexture("positionMap",this.worldPosMap),this.computeShader.setSamplerTexture("normalMap",this.worldNormalMap),this.computeShader.setSamplerTexture("colorMap",this.colorMap),this.computeShader.setSamplerTexture("shadowMap",this.shadowMap),this.computeShader.setSamplerTexture("pointShadowMap",this.pointShadowMap),this.computeShader.setSamplerTexture("prefilterMap",A.res.defaultSky)}setInputs(e){this.worldPosMap=e[0],this.worldNormalMap=e[1],this.colorMap=e[2],this.shadowMap=e[3],this.pointShadowMap=e[4]}compute(e,t){this.computeShader||this.create(e);let r=w.beginCommandEncoder(),s=A.setting.gi;this.computeShader.workerSizeX=s.probeSourceTextureSize/8,this.computeShader.workerSizeY=s.probeSourceTextureSize/8,this.computeShader.workerSizeZ=1,w.computeCommand(r,[this.computeShader])}}let Hs=new je("GIRenderStartEvent"),Co=new je("GIRenderCompleteEvent");class mg{constructor(){o(this,"count"),o(this,"complete")}}class Gh extends di{constructor(e){super(),o(this,"cubeCamera"),o(this,"volume"),o(this,"probeCountPerFrame",1),o(this,"nextProbeIndex",-1),o(this,"tempProbeList",[]),o(this,"isRenderCloudGI"),o(this,"probeRenderResult"),o(this,"renderStatus","none"),o(this,"positionMap"),o(this,"normalMap"),o(this,"colorMap"),o(this,"probeNext",128),o(this,"sizeW"),o(this,"sizeH"),o(this,"lightingPass"),o(this,"bouncePass"),o(this,"irradianceComputePass"),o(this,"irradianceDepthMap"),o(this,"irradianceColorMap"),this.passType=re.GI,this.volume=e;let t=e.setting;this.cubeCamera=new Rh(.01,5e3),this.sizeW=t.probeSourceTextureSize,this.sizeH=t.probeSourceTextureSize,this.probeNext=t.probeSourceTextureSize/t.probeSize,this.initIrradianceMap(e),this.probeRenderResult=new mg;let r=new Lh(this.sizeW,this.sizeH);this.positionMap=r.attachments[0],this.normalMap=r.attachments[1],this.colorMap=r.attachments[2],this.setRenderStates(r)}setInputTexture(e){this.lightingPass=new zh,this.bouncePass=new Fh(this.volume),this.irradianceComputePass=new Oh(this.volume),this.lightingPass.setInputs([this.positionMap,this.normalMap,this.colorMap,e[0],e[1]]),this.bouncePass.setInputs([this.normalMap,this.colorMap,this.lightingPass.lightingTexture,this.irradianceColorMap]),this.irradianceComputePass.setTextures([this.positionMap,this.normalMap,this.bouncePass.blendTexture],this.irradianceColorMap,this.irradianceDepthMap)}setIrradianceData(e,t,r,s){if(r!=this.irradianceColorMap.width||s!=this.irradianceColorMap.height){console.error("irradiance image size not match !");return}this.writeToTexture(this.irradianceColorMap,e,r,s),this.writeToTexture(this.irradianceDepthMap,t,r,s)}updateProbe(e,t,r){let s=Q.instance.getLights(e.scene),a=this.volume.setting.probeSize;t.drawCallFrame+=1,this.cubeCamera.x=t.x,this.cubeCamera.y=t.y,this.cubeCamera.z=t.z,this.volume.setting.debugCamera?(this.cubeCamera.x=e.camera.transform.x,this.cubeCamera.y=e.camera.transform.y,this.cubeCamera.z=e.camera.transform.z,this.cubeCamera.rotationX=e.camera.transform.rotationX,this.cubeCamera.rotationY=e.camera.transform.rotationY,this.cubeCamera.rotationZ=e.camera.transform.rotationZ):(this.cubeCamera.rotationX=t.rotationX,this.cubeCamera.rotationY=t.rotationY,this.cubeCamera.rotationZ=t.rotationZ);let n=this.cubeCamera,l=Math.floor(t.index/this.probeNext)*(a*6),h=Math.floor(t.index%this.probeNext)*a;r.setViewport(0+l,h,a,a,0,1),this.renderSceneOnce(e,n.right_camera,r,s),r.setViewport(a+l,h,a,a,0,1),this.renderSceneOnce(e,n.left_camera,r,s),r.setViewport(a*2+l,h,a,a,0,1),this.renderSceneOnce(e,n.up_camera,r,s),r.setViewport(a*3+l,h,a,a,0,1),this.renderSceneOnce(e,n.down_camera,r,s),r.setViewport(a*4+l,h,a,a,0,1),this.renderSceneOnce(e,n.front_camera,r,s),r.setViewport(a*5+l,h,a,a,0,1),this.renderSceneOnce(e,n.back_camera,r,s)}renderSceneOnce(e,t,r,s){this.volume.uploadBuffer();let a=Q.instance.getRenderNodes(e.scene,t);w.bindCamera(r,t);let n=Math.max(0,A.setting.render.drawOpMin),l=Math.min(A.setting.render.drawOpMax,a.opaqueList.length),h=Q.instance.getRenderShaderCollect(e);for(const u of h){let c=u[1];for(const f of c){let d=f[1];if(d.preInit){d.nodeUpdate(e,this.passType,this.rendererPassState,null);break}}}for(let u=n;u<l;++u){let c=a.opaqueList[u];c.enable&&c.transform.enable&&(c.preInit||c.nodeUpdate(e,this.passType,this.rendererPassState,null),c.renderPass2(e,this.passType,this.rendererPassState,null,r))}Q.instance.sky&&(Q.instance.sky.preInit||Q.instance.sky.nodeUpdate(e,this.passType,this.rendererPassState,null),Q.instance.sky.renderPass2(e,this.passType,this.rendererPassState,null,r)),n=Math.max(0,A.setting.render.drawTrMin),l=Math.min(A.setting.render.drawTrMax,a.transparentList.length);for(let u=n;u<l;++u){let c=a.transparentList[u];c.enable&&c.transform.enable&&(c.preInit||c.nodeUpdate(e,this.passType,this.rendererPassState,null),c.renderPass2(e,this.passType,this.rendererPassState,null,r))}}render(e,t){if(!A.setting.gi.enable)return;this.volume.updateOrientation(),this.volume.isVolumeFrameChange=!1,this.volume.uploadBuffer(),this.rendProbe(e);let r=this.probeRenderResult.count>0;(Q.instance.state.giLightingChange||r||A.setting.gi.realTimeGI)&&(Q.instance.state.giLightingChange=!1,this.lightingPass.compute(e,this.rendererPassState),this.bouncePass.compute(e,this.rendererPassState),this.irradianceComputePass.compute(e,this.rendererPassState)),this.probeRenderResult.complete&&this.dispatchEvent(Co)}startRenderGI(e=0){this.nextProbeIndex==-1&&e==0&&this.dispatchEvent(Hs),this.nextProbeIndex=e,this.renderStatus="rendering"}startRenderCloudGI(){this.dispatchEvent(Hs),this.nextProbeIndex=0,this.renderStatus="rendering",this.isRenderCloudGI=!0}rendProbe(e){let t=A.setting.gi.autoRenderProbe,r=!1;if(t?(this.nextProbeIndex==-1&&this.startRenderGI(),r=!0):r=this.renderStatus=="rendering",this.probeRenderResult.count=0,this.probeRenderResult.complete=!1,r){let s=Q.instance.getProbes(e.scene);this.renderContext.clean(),this.renderContext.beginRenderPass(),this.tempProbeList.length=0;let a=Math.min(this.probeCountPerFrame,s.length);for(this.probeRenderResult.count=a;a>0;){const l=s[this.nextProbeIndex];this.updateProbe(e,l,this.renderContext.encoder),a--,this.nextProbeIndex++,l.drawCallFrame<3&&this.tempProbeList.push(l)}this.tempProbeList.length>0&&this.volume.updateProbes(this.tempProbeList);let n=this.nextProbeIndex>=s.length;this.nextProbeIndex>=s.length&&this.isRenderCloudGI&&this.updateProbe(e,s[0],this.renderContext.encoder),this.renderContext.endRenderPass(),n&&(this.nextProbeIndex=-1,this.renderStatus="complete",this.probeRenderResult.complete=!0)}}initIrradianceMap(e){let t=e.setting,r=GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_SRC|GPUTextureUsage.COPY_DST;this.irradianceDepthMap=new oe(t.octRTMaxSize,t.octRTMaxSize,G.rgba16float,!1,r),this.irradianceDepthMap.name="irradianceDepthMap",this.irradianceColorMap=new oe(t.octRTMaxSize,t.octRTMaxSize,G.rgba16float,!1,r),this.irradianceColorMap.name="irradianceColorMap"}writeToTexture(e,t,r,s){console.log(e.name);const a=S.device.createBuffer({size:t.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC});S.device.queue.writeBuffer(a,0,t);const n=w.beginCommandEncoder();n.copyBufferToTexture({buffer:a,bytesPerRow:r*16},{texture:e.getGPUTexture()},{width:r,height:s,depthOrArrayLayers:1}),w.endCommandEncoder(n)}}class wo extends Ph{constructor(e){super(e)}start(){super.start();let e=wt.getGBufferFrame("ColorPassGBuffer");{let t=[],r=new eh;if(A.setting.render.zPrePass&&(e.zPreTexture=this.depthPassRenderer.rendererPassState.depthTexture),r.setRenderStates(e),A.setting.gi.enable){let s=pe.getLightEntries(this.view.scene);this.ddgiProbeRenderer=new Gh(s.irradianceVolume),this.ddgiProbeRenderer.setInputTexture([this.shadowMapPassRenderer.depth2DArrayTexture,this.pointLightShadowRenderer.cubeArrayTexture]),r.setIrradiance(this.ddgiProbeRenderer.irradianceColorMap,this.ddgiProbeRenderer.irradianceDepthMap),this.rendererMap.addRenderer(this.ddgiProbeRenderer),t.push(this.ddgiProbeRenderer.positionMap,this.ddgiProbeRenderer.normalMap,this.ddgiProbeRenderer.colorMap,this.ddgiProbeRenderer.lightingPass.lightingTexture,this.ddgiProbeRenderer.irradianceColorMap,this.ddgiProbeRenderer.irradianceDepthMap)}this.postRenderer&&this.postRenderer.setDebugTexture(t),this.rendererMap.addRenderer(r)}A.setting.render.debug&&this.debug()}debug(){}}class Qh{constructor(){o(this,"_factor"),o(this,"_doubleFactor"),this._factor=1,this._doubleFactor=2}get accelerateInterpolator(){return this._factor}set accelerateInterpolator(e){this._factor=e,this._doubleFactor=2*this._factor}getInterpolation(e){return this._factor==1?e*e:Math.pow(e,this._doubleFactor)}}class Vh{constructor(){o(this,"_factor",1)}get decelerateInterpolator(){return this._factor}set decelerateInterpolator(e){this._factor=e}getInterpolation(e){let t;return this._factor==1?t=1-(1-e)*(1-e):t=1-Math.pow(1-e,2*this._factor),t}}class Hh{constructor(){o(this,"_factor",1)}getInterpolation(e){return Math.cos((e+1)*Math.PI)/2+.5}}class Yh{getInterpolation(e){return e}}class Xh{getInterpolation(e){return 4.9*e+4.9*e}}class At{constructor(){}static bounce(e){return e*e*9.8}getInterpolation(e){return e*=1.1226,e<.3535?At.bounce(e):e<.7408?At.bounce(e-.54719)+.7:e<.9644?At.bounce(e-.8526)+.9:At.bounce(e-1.0435)+.95}getBounceInterpolation(e){return e<.5?At.bounce(e):At.bounce(e-1)}geJumpUp(e,t){return t<.5?(t=t/.5,e*t-At.bounce(t)):t<.8?(t=(t-.5)/(.8-.5),(e*t-At.bounce(t))*.3):t<1?(t=(t-.8)/(1-.8),(e*t-At.bounce(t))*.15):e*t-At.bounce(t)}}class Wh{constructor(){o(this,"_tension"),this._tension=2}get anticipateInterpolator(){return this._tension}set anticipateInterpolator(e){this._tension=e}getInterpolation(e){return e*e*((this._tension+1)*e-this._tension)}}class Ss{constructor(){o(this,"_tension"),this._tension=1*1.5}anticipateOvershootInterpolator(e){this._tension=e*1.5}anticipateOvershootInterpolator2(e,t){this._tension=e*t}getInterpolation(e){return e<.5?.5*Ss.a(e*2,this._tension):.5*(Ss.o(e*2-2,this._tension)+2)}static a(e,t){return e*e*((t+1)*e-t)}static o(e,t){return e*e*((t+1)*e+t)}}class jh{constructor(e){o(this,"_cycles"),this._cycles=e}getInterpolation(e){return Math.sin(2*this._cycles*Math.PI*e)}}class qh{constructor(){o(this,"_tension"),this._tension=2}getInterpolation(e){return e-=1,e*e*((this._tension+1)*e+this._tension)+1}}var bo=(i=>(i[i.AccelerateInterpolator=0]="AccelerateInterpolator",i[i.DecelerateInterpolator=1]="DecelerateInterpolator",i[i.AccelerateDecelerateInterpolator=2]="AccelerateDecelerateInterpolator",i[i.LinearInterpolator=3]="LinearInterpolator",i[i.BounceInterpolator=4]="BounceInterpolator",i[i.AnticipateInterpolator=5]="AnticipateInterpolator",i[i.AnticipateOvershootInterpolator=6]="AnticipateOvershootInterpolator",i[i.CycleInterpolator=7]="CycleInterpolator",i[i.OvershootInterpolator=8]="OvershootInterpolator",i[i.JumperInterpolator=9]="JumperInterpolator",i))(bo||{});const or=class{constructor(){o(this,"complete",!1),o(this,"onComplete"),o(this,"onProgress"),o(this,"target"),o(this,"property"),o(this,"targetProperty"),o(this,"durtion"),o(this,"interpolatorEnum"),o(this,"delayTime",0),o(this,"_interpolator"),o(this,"_ct",0),o(this,"_p",0)}static to(i,e,t,r=0){var s=new or;return s.target=i,s.property=e,s.durtion=t,s.interpolatorEnum=r,s.start(),s.delayTime=e.delayTime?e.delayTime:0,e.onComplete&&(s.onComplete=e.onComplete),e.onProgress&&(s.onProgress=e.onProgress),this.interpolators.push(s),s}static tick(i){let e=or.interpolators;for(let t of e)t.complete?or.remove(t,!0):t.tick(i)}static remove(i,e){let t=or.interpolators,r=t.indexOf(i);r!=-1&&t.splice(r,1),e&&i.dispose()}static removeList(i,e){i.forEach(t=>{this.remove(t,e)})}start(){window.AccelerateInterpolator=Qh,window.DecelerateInterpolator=Vh,window.AccelerateDecelerateInterpolator=Hh,window.LinearInterpolator=Yh,window.BounceInterpolator=At,window.AnticipateInterpolator=Wh,window.AnticipateOvershootInterpolator=Ss,window.CycleInterpolator=jh,window.OvershootInterpolator=qh,window.JumperInterpolator=Xh,this._interpolator=new window[bo[this.interpolatorEnum]],this.targetProperty={};for(let i in this.property)this.targetProperty[i]=this.target[i]}tick(i){if(this.delayTime<=0){this._p=Math.min(this._ct/this.durtion,1);let e=this._interpolator.getInterpolation(this._p),t=this.property,r=this.target,s=this.targetProperty,a,n;for(let l in t)n=t[l],a=s[l],r[l]=a+(n-a)*e;this.onProgress!=null&&this.onProgress(this._p),this._ct>=this.durtion&&(this.complete=!0,this.onComplete!=null&&this.onComplete(this.target)),this._ct+=i}else this.delayTime-=i}dispose(){this.onComplete=null,this.onProgress=null,this.target=null,this.property=null,this.targetProperty=null,this.interpolatorEnum=null,this._interpolator=null,or.remove(this)}};let So=or;o(So,"interpolators",[]);class it{static hasString(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}static getEllipsis(e,t=4){let r=e;return r.length>t&&(r=r.slice(0,t)+"..."),r}static getURLName(e){var t;t=e.split("/");let r=t[t.length-1];return r=r.split(".")[0],r}static getFileFormat(e){var t=e.lastIndexOf(".");t++;var r=e.length;e.indexOf("?",t)!==-1&&(r=e.indexOf("?",t));var s=e.substr(t,r-t);return s=s.toLowerCase(),s}static readLineProperty(e,t){e.trim().split(" ").forEach((r,s)=>{let a=r.split("=");if(a.length>1){let n=a[0],l=a[1];Object.prototype.hasOwnProperty.call(t,n)&&(l.indexOf('"')==-1?t[n]=parseFloat(a[1]):t[n]=l.replace('"',"").replace('"',""))}})}static getPath(e){var t=e.lastIndexOf("/");return t++,e.substring(0,t)}static normalizePath(e){var t=e.replaceAll("//","/");return t=t.replaceAll("\\","/"),t}static getStringList(e,t=";"){return e.split(t)}static formatTime(e){let r=e/1e3/60,s=Math.floor(r),a=Math.floor(r-s);return[s.toString(),a.toString()]}static trim(e){return e.replace(/^\s+/g,"").replace(/\s+$/g,"")}static isEmpty(e){return!e||typeof e>"u"||e==null||typeof e=="string"&&this.trim(e)===""||e==="null"}static strCut(e,t){if(e.length*2<=t)return e;for(var r=0,s="",a=0;a<e.length;a++)if(s=s+e.charAt(a),e.charCodeAt(a)>128){if(r=r+2,r>=t)return s.substring(0,s.length-1)+"..."}else if(r=r+1,r>=t)return s.substring(0,s.length-2)+"...";return s}static toQueryPair(e,t,r=!1){return e+"="+(r?encodeURIComponent(t):t)}static stringFormat(e,...t){if(arguments.length===0)throw new Error("please give arg at least one !");if(arguments.length===2&&typeof arguments[1]=="object")for(let r in arguments[1]){let s=new RegExp("({"+r+"})","g");e=e.replace(s,arguments[1][r])}else for(let r=0;r<t.length;r++){if(t[r]==null)return e;{let s=new RegExp("({["+r+"]})","g");e=e.replace(s,t[r])}}return e}static parseJson2String(e,t){let r=null,s="",a=0,n="    ";return t=t||{},t.newlineAfterColonIfBeforeBraceOrBracket=t.newlineAfterColonIfBeforeBraceOrBracket===!0,t.spaceAfterColon=t.spaceAfterColon!==!1,typeof e!="string"||(e=JSON.parse(e)),e=JSON.stringify(e),r=/([\{\}])/g,e=e.replace(r,`\r
$1\r
`),r=/([\[\]])/g,e=e.replace(r,`\r
$1\r
`),r=/(\,)/g,e=e.replace(r,`$1\r
`),r=/(\r\n\r\n)/g,e=e.replace(r,`\r
`),r=/\r\n\,/g,e=e.replace(r,","),t.newlineAfterColonIfBeforeBraceOrBracket||(r=/\:\r\n\{/g,e=e.replace(r,":{"),r=/\:\r\n\[/g,e=e.replace(r,":[")),t.spaceAfterColon&&(r=/\:/g,e=e.replace(r,":")),e.split(`\r
`).forEach(function(l,h){let u=0,c=0,f="";for(l.match(/\{$/)||l.match(/\[$/)?c=1:l.match(/\}/)||l.match(/\]/)?a!==0&&(a-=1):c=0,u=0;u<a;u++)f+=n;s+=f+l+`\r
`,a+=c}),s}static compareVersion(e,t){e=e.split("."),t=t.split(".");let r=Math.max(e.length,t.length);for(;e.length<r;)e.push("0");for(;t.length<r;)t.push("0");for(let s=0;s<r;s++){let a=parseInt(e[s]),n=parseInt(t[s]);if(a>n)return 1;if(a<n)return-1}return 0}static buildRandomCode(){let e="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789",t=e.length,r="";for(let a=0;a<26;a++){let n=Math.floor(Math.random()*t);r+=e.charAt(n)}return`${new Date().getTime()}-${r}`}static UUID(){return"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,function(e){var t=Math.random()*16|0,r=e=="x"?t:t&3|8;return r.toString(16)})}static stringToHash(e){let t=0;if(e.length==0)return t;for(let r=0;r<e.length;r++){const s=e.charCodeAt(r);t=(t<<5)-t+s,t=t&t}return t}static parseUrl(e,t){return t.match(/^(blob|http|https):/)?t:e+t}}o(it,"_filterChar",[" ","  ",";",`
`,"\r","	",`
`,"\r","	"]);class ii extends at{constructor(e=!0){super(),o(this,"_source"),o(this,"imageData"),this.useMipmap=e}get source(){return this._source}set source(e){this._source=e,this._source instanceof HTMLImageElement?this._source.decode().then(async()=>{if(this._source instanceof HTMLImageElement){const t=await createImageBitmap(this._source,{imageOrientation:this.flipY?"flipY":"from-image"});this.generate(t)}}):(this._source instanceof HTMLCanvasElement||this._source instanceof ImageBitmap)&&this.generate(this._source)}async load(e,t){if(e.indexOf(";base64")!=-1){const r=document.createElement("img");let s=e.indexOf("data:image"),a=e.substring(s,e.length);r.src=a,await r.decode(),r.width=Math.max(r.width,32),r.height=Math.max(r.height,32);const n=await createImageBitmap(r,{resizeWidth:r.width,resizeHeight:r.height,imageOrientation:this.flipY?"flipY":"from-image"});this.format=G.rgba8unorm,this.generate(n)}else{const r=await fetch(e,{headers:Object.assign({Accept:"image/avif,image/webp,*/*"},t?.headers)});let s=await ji.read(e,r,t),a=new Blob([s],{type:"image/jpeg"});s=null,await this.loadFromBlob(a)}return this.name=it.getURLName(e),!0}async loadFromBlob(e){this.imageData=e;let t=await createImageBitmap(e,{imageOrientation:this.flipY?"flipY":"from-image"});if(t.width<32||t.height<32){let r=Math.max(t.width,32),s=Math.max(t.height,32);t=await createImageBitmap(t,{resizeWidth:r,resizeHeight:s,imageOrientation:this.flipY?"flipY":"from-image"})}return this.format=G.rgba8unorm,this.generate(t),!0}}class ji{constructor(){o(this,"baseUrl",""),o(this,"initUrl"),o(this,"_progress",0)}async loadBinData(e,t){return this.baseUrl=it.getPath(e),this.initUrl=e,new Promise(async(r,s)=>{fetch(e,{headers:t?.headers}).then(async a=>{if(a.ok){let n=await ji.read(e,a,t),l=n.buffer;n=null,r(l)}else throw Error("request rejected with status "+a.status)}).catch(a=>{t.onError&&t.onError(a),s(a)})})}async loadAsyncBitmapTexture(e,t){this.baseUrl=it.getPath(e),this.initUrl=e;let r=new ii;return r.url=e,r.name=it.getURLName(e),await r.load(e,t),A.res.addTexture(e,r),r}async loadJson(e,t){return this.baseUrl=it.getPath(e),this.initUrl=e,new Promise(async(r,s)=>{fetch(e,{headers:t?.headers}).then(async a=>{if(a.ok){let n=await ji.read(e,a,t);const h=new TextDecoder("utf-8").decode(n);n=null,r(JSON.parse(h))}else throw Error("request rejected with status"+a.status)}).catch(a=>{t.onError&&t.onError(a),s(a)})})}async loadTxt(e,t){return this.baseUrl=it.getPath(e),new Promise(async(r,s)=>{fetch(e).then(async a=>{if(a.ok){let n=await ji.read(e,a,t);const h=new TextDecoder("utf-8").decode(n);n=null,r({data:h})}else throw Error("request rejected with status"+a.status)}).catch(a=>{t.onError&&t.onError(a),s(a)})})}static async read(e,t,r){const s=t.body.getReader(),a=+t.headers.get("Content-Length");let n=0,l=[],h=[];for(;;){const{done:f,value:d}=await s.read();if(f){a>0&&r&&r.onComplete&&r.onComplete.call(this,e);break}l.push(d),n+=d.length,a>0?r&&r.onProgress&&r.onProgress.call(this,n,a,e):h.push(d.length)}if(h.length>0)for(let f=0;f<l.length;f++)console.log(h[f]),r&&r.onProgress&&r.onProgress.call(this,h[f],n,e),h[f]==n&&r&&r.onComplete&&r.onComplete.call(this,e);let u=new Uint8Array(n),c=0;for(let f of l)u.set(f,c),c+=f.length;return u}}class ht extends ji{async load(e,t,r,s){switch(t.format){case"bin":return new Promise(async(a,n)=>{this.loadBinData(e,r).then(async l=>{let h=new t;if(h.userData=s,h.baseUrl=this.baseUrl,h.initUrl=e,await h.parseBuffer(l),h.verification())a(h);else throw new Error("parser error")}).catch(l=>{n(l)})});case"json":return new Promise((a,n)=>{this.loadJson(e,r).then(async l=>{let h=new t;h.userData=s,h.baseUrl=this.baseUrl,h.initUrl=e,h.loaderFunctions=r,await h.parseJson(l),a(h)}).catch(l=>{n(l)})});case"text":return new Promise((a,n)=>{this.loadTxt(e,r).then(async l=>{let h=new t;h.userData=s,h.baseUrl=this.baseUrl,h.initUrl=e,h.loaderFunctions=r,l.data?(await h.parseString(l.data),a(h)):n("text load is empty!")}).catch(l=>{n(l)})})}}}class Xt{constructor(){o(this,"baseUrl"),o(this,"initUrl"),o(this,"loaderFunctions"),o(this,"userData"),o(this,"data")}parseString(e){}parseJson(e){}parseBuffer(e){}parseTexture(e){throw this.parserError("Method not implemented.",-1)}parse(e){}verification(e){throw this.parserError("Method not implemented.",-1)}parserError(e,t){console.error(`error id:${t} ${e}`)}}o(Xt,"format","bin");class Ys{constructor(){o(this,"asset"),o(this,"accessors"),o(this,"buffers"),o(this,"bufferViews"),o(this,"materials"),o(this,"meshes"),o(this,"nodes"),o(this,"scene",0),o(this,"scenes"),o(this,"textures"),o(this,"cameras"),o(this,"skins"),o(this,"resources"),o(this,"images"),o(this,"samplers"),o(this,"animations"),o(this,"extensions")}}class Ag{constructor(){o(this,"nodes")}}class _g{constructor(){o(this,"name"),o(this,"type"),o(this,"color"),o(this,"intensity"),o(this,"range"),o(this,"spot"),o(this,"isParsed")}}class xg{constructor(){o(this,"name"),o(this,"rotation"),o(this,"scale"),o(this,"translation"),o(this,"children"),o(this,"matrix"),o(this,"mesh",-1),o(this,"isParsed"),o(this,"dnode"),o(this,"camera"),o(this,"skin"),o(this,"nodeId"),o(this,"primitives"),o(this,"extensions"),o(this,"light")}}class vg{constructor(){o(this,"attributes"),o(this,"indices"),o(this,"material"),o(this,"mode"),o(this,"name"),o(this,"targets"),o(this,"extensions"),o(this,"morphTargetsRelative")}}class yg{constructor(){o(this,"name"),o(this,"primitives"),o(this,"isParsed"),o(this,"dprimitives"),o(this,"weights"),o(this,"extras")}}class Cg{constructor(){o(this,"bufferView"),o(this,"componentType"),o(this,"count"),o(this,"type"),o(this,"max"),o(this,"min"),o(this,"isParsed"),o(this,"daccessor"),o(this,"normalized"),o(this,"sparse"),o(this,"byteOffset"),o(this,"computeResult")}}const wg=window.SharedArrayBuffer?function(e){return e&&e.buffer&&(e.buffer instanceof ArrayBuffer||e.buffer instanceof window.SharedArrayBuffer)}:function(e){return e&&e.buffer&&e.buffer instanceof ArrayBuffer},Io=5120,is=5121,Eo=5122,Bo=5123,To=5124,Mo=5125,Do=5126,bg=32819,Sg=32820,Ig=33635,Eg=5131,Bg=33640,Tg=35899,Mg=35902,Dg=36269,Pg=34042,Kh={};{const i=Kh;i[Io]=Int8Array,i[is]=Uint8Array,i[Eo]=Int16Array,i[Bo]=Uint16Array,i[To]=Int32Array,i[Mo]=Uint32Array,i[Do]=Float32Array,i[bg]=Uint16Array,i[Sg]=Uint16Array,i[Ig]=Uint16Array,i[Eg]=Uint16Array,i[Bg]=Uint32Array,i[Tg]=Uint32Array,i[Mg]=Uint32Array,i[Dg]=Uint32Array,i[Pg]=Uint32Array}function Rg(i){switch(i){case Int8Array:return Io;case Uint8Array:return is;case Uint8ClampedArray:return is;case Int16Array:return Eo;case Uint16Array:return Bo;case Int32Array:return To;case Uint32Array:return Mo;case Float32Array:return Do;default:throw new Error("unsupported typed array type")}}function Lg(i){if(i instanceof Int8Array)return Io;if(i instanceof Uint8Array||i instanceof Uint8ClampedArray)return is;if(i instanceof Int16Array)return Eo;if(i instanceof Uint16Array)return Bo;if(i instanceof Int32Array)return To;if(i instanceof Uint32Array)return Mo;if(i instanceof Float32Array)return Do;throw new Error("unsupported typed array type")}function Po(i){const e=Kh[i];if(!e)throw new Error("unkonw gl type");return e}function Ug(i,e=Float32Array){return wg(i)?i:new e(i)}class rs{static async apply(e,t){if(!t.extensions)return;const r=t.extensions.KHR_draco_mesh_compression;if(!r)return;let s=this._workers.get(e.gltf);s||(s=new Worker(await this.initDecoder()),this._workers.set(e.gltf,s)),s.postMessage({type:"init",decoderConfig:{}});let a=e.parseBufferView(r.bufferView);if(!a.result){let n=await new Promise((l,h)=>{s.onmessage=u=>{const c=u.data;c.type=="decode"?l(c.result):c.type=="error"&&h(c.error)},s.postMessage({type:"decoder",buffer:a,attributes:r.attributes},[a])});a.result=n}return a.result}static unload(e){let t=this._workers.get(e);t&&(t.terminate(),this._workers.delete(e))}static async initDecoder(){if(!this._workerCode){let e=await new ht().loadTxt("https://cdn.orillusion.com/draco_decoder_gltf.js");const t=new Blob([e.data,"",`(${Og})()`],{type:"application/javascript"});this._workerCode=URL.createObjectURL(t)}return this._workerCode}}o(rs,"_workerCode"),o(rs,"_workers",new Map);function Og(){let i,e;onmessage=t=>{const r=t.data;switch(r.type){case"init":i=r.decoderConfig,e=new Promise((n,l)=>{i.onModuleLoaded=h=>{n({draco:h})},DracoDecoderModule(i)});break;case"decoder":const s=r.buffer,a=r.attributes;e.then(n=>{const l=n.draco;let h=new l.Decoder,u=new l.DecoderBuffer;u.Init(new Int8Array(s),s.byteLength);let c,f;try{const d=h.GetEncodedGeometryType(u);d==l.TRIANGULAR_MESH?(f=new l.Mesh,c=h.DecodeBufferToMesh(u,f)):self.postMessage(new Error("INVALID_GEOMETRY_TYPE:"+d)),c.ok()||self.postMessage(new Error("DracoDecode:"+c.error_msg()));let p={};for(const m in a){let _=h.GetAttributeByUniqueId(f,a[m]);const v=_.num_components(),C=f.num_points()*v,B=C*Float32Array.BYTES_PER_ELEMENT,T=l.DT_FLOAT32,M=l._malloc(B);h.GetAttributeDataArrayForAllPoints(f,_,T,B,M);const D=new Float32Array(l.HEAPF32.buffer,M,C).slice();l._free(M),p[m]={data:D,numComponents:v,normalize:!1}}{const _=f.num_faces()*3,v=_*4,y=l._malloc(v);h.GetTrianglesUInt32Array(f,v,y);const C=new Uint32Array(l.HEAPF32.buffer,y,_).slice();l._free(y),p.indices={data:C,numComponents:1,normalize:!1}}self.postMessage({type:"decode",result:p})}catch(d){self.postMessage({type:"error",error:d.message})}finally{l.destroy(f),l.destroy(h),l.destroy(u)}});break}}}class Jh{constructor(e){o(this,"gltf"),this.gltf=e}parse(e){const t=this.gltf.cameras[e];if(!t)return this.errorMiss("camera",e);if(t.isParsed)return t.dcamera;t.isParsed=!0,t.dcamera=!1;const{name:r,type:s,perspective:a,orthographic:n}=t;if(s==="perspective"&&a){const{aspectRatio:l,yfov:h,zfar:u,znear:c}=a;t.dcamera=Object.assign({},{name:r,type:s,yfov:h,znear:c,aspectRatio:l,zfar:u})}else if(s==="orthographic"&&n){const{xmag:l,ymag:h,zfar:u,znear:c}=n;t.dcamera=Object.assign({},{name:r,type:s,xmag:l,ymag:h,zfar:u,znear:c})}return t.dcamera}errorMiss(e,t){throw new Error(e+t)}}const Zh=class extends Xt{constructor(){super(...arguments),o(this,"_gltf")}async parseJson(i){this._gltf=new Ys,this._gltf={...this._gltf,...i},this._gltf.resources={},await Promise.all([this.load_gltf_bin(),this.load_gltf_textures()]);let e=new js,t=await e.parse(this.initUrl,this._gltf,this._gltf.scene);return e.destory(),e=null,t?(this.data=t.rootNode,t.rootNode):(this._gltf=null,null)}verification(){if(this.data)return!0;throw new Error("Method not implemented.")}static getMeshNameCounter(){return function(){return`GLTF_NO_NAME_PRIMITIVE_${Zh._counter++}`}}static getModelNameCounter(){let i=0;return function(){return`GLTF_NO_NAME_MESH_${i++}`}}static getTexCoordDefine(i){return`UV_NUM ${i}`}static getVertexColorDefine(i){return`HAS_VERTEXCOLOR ${i}`}static getBaseColorTextureDefine(){return"HAS_BASECOLORMAP"}static getMetalRoughnessDefine(){return"HAS_METALROUGHNESSMAP"}static getNormalMapDefine(){return"HAS_NORMALMAP"}static getEmissiveMapDefine(){return"HAS_EMISSIVEMAP"}static getOcclusionMapDefine(){return"HAS_OCCLUSIONMAP"}static getMorphTargetsDefine(i){return`MORPH_TARGET_NUM ${i}`}static getMorphtargetPositionDefine(){return"HAS_MORPH_POSITION"}static getMorphtargetNormalDefine(){return"HAS_MORPH_NORMAL"}static getMorphtargetTangentDefine(){return"HAS_MORPH_TANGENT"}static getJointsNumDefine(i){return`JOINTS_NUM ${i}`}static getJointVec8Define(){return"JOINT_VEC8"}static getHasNormalDefine(){return"HAS_NORMAL"}static getHasTangentDefine(){return"HAS_TANGENT"}static getHasNormalMapDefine(){return"HAS_NORMAL_MAP"}static getAlphaMaskDefine(){return"ALPHA_MASK"}static getAlphaBlendDefine(){return"ALPHA_BLEND"}async load_gltf_bin(){var i;if(this._gltf.buffers&&this._gltf.buffers.length>0){let e=[];for(let t=0;t<this._gltf.buffers.length;t++){const r=this._gltf.buffers[t];if(r.uri.substring(0,5)!=="data:"){let s=it.parseUrl(this.baseUrl,r.uri);(i=this.loaderFunctions)!=null&&i.onUrl&&(s=await this.loaderFunctions.onUrl(s));let a=new ht().loadBinData(s,this.loaderFunctions).then(n=>{this._gltf.resources[r.uri]=n});e.push(a)}}await Promise.all(e)}}async load_gltf_textures(){var i;if(this._gltf,this._gltf.images){let e=[];for(let t=0;t<this._gltf.images.length;t++){const r=this._gltf.images[t];if(r.uri){let s=it.parseUrl(this.baseUrl,r.uri);(i=this.loaderFunctions)!=null&&i.onUrl&&(s=await this.loaderFunctions.onUrl(s));let a=new ht().loadAsyncBitmapTexture(s,this.loaderFunctions).then(n=>{n.name=it.getURLName(r.uri),this._gltf.resources[n.name]=n});e.push(a)}}await Promise.all(e)}}};let Ke=Zh;o(Ke,"format","json"),o(Ke,"_counter",0),o(Ke,"defaultMaterial",{name:"GLTF_DEFAULT_MATERIAL",alphaCutoff:.33,alphaMode:"MASK",pbrMetallicRoughness:{name:"GLTF_DEFAULT_MATERIAL",defines:[],doubleSided:!1,baseColorFactor:[1,1,1,1],metallicFactor:1,roughnessFactor:1,emissiveFactor:[0,0,0]}});class $h{constructor(e){o(this,"gltf"),o(this,"subParser"),this.gltf=e.gltf,this.subParser=e}async parse(e){const t=this.gltf.meshes[e];if(!t)return this.errorMiss("mesh",e);if(t.isParsed)return t.dprimitives;const r=t.primitives,s=t.extras,a=[];for(let n=0;n<r.length;n++){const l=r[n],{attributes:h,indices:u,material:c,mode:f,name:d,targets:p,morphTargetsRelative:m,extensions:_}=l;let v=t.name;for(let P in h)v+=P;v+=`indices:${u}`,v+=`material:${c}`;const y={attribArrays:{indices:[]},weights:[],defines:[],material:null,drawMode:null,meshName:null,modelName:null,morphTargetsRelative:!1,targetNames:s?s.targetNames:null};let C=!1,B=0,T=!1,M;_&&_.KHR_draco_mesh_compression&&(M=await rs.apply(this.subParser,l));for(const P in h){const L=M?M[P]:this.parseAccessor(h[P]);if(L){let I;switch(P){case"POSITION":I=Y.position;break;case"NORMAL":I=Y.normal,C=!0;break;case"TEXCOORD_0":I=Y.uv,B++;break;case"JOINTS_0":I=Y.joints0;break;case"JOINTS_1":I=Y.joints1,T=!0;break;case"WEIGHTS_0":I=Y.weights0;break;case"WEIGHTS_1":I=Y.weights1;break;default:I=P}y.attribArrays[I]=L}}if(C&&y.defines.push(Ke.getHasNormalDefine()),B&&y.defines.push(Ke.getTexCoordDefine(B)),T&&y.defines.push(Ke.getJointVec8Define()),u!==void 0){const P=M?M.indices:this.parseAccessor(u);P&&(y.attribArrays.indices=P)}const D=await this.parseMaterial(c);if(D&&(y.material=D,y.defines=y.defines.concat(D.defines)),y.drawMode=f===void 0?4:f,y.meshName=()=>v,y.modelName=t.name||Ke.getModelNameCounter(),p){y.defines.push(Ke.getMorphTargetsDefine(p.length)),y.morphTargetsRelative=!0;let P=!1,L=!1,I=!1;for(let O=0;O<p.length;O++){const k=p[O];Object.keys(k).forEach(H=>{const W=this.parseAccessor(k[H]);if(W){let ne;switch(H){case"POSITION":ne=le.MORPH_POSITION_PREFIX+O,P=!0;break;case"NORMAL":ne=le.MORPH_NORMAL_PREFIX+O,L=!0;break;case"TANGENT":ne=le.MORPH_TANGENT_PREFIX+O,I=!0;break;default:ne=!1}ne?y.attribArrays[ne]=W:console.error(`glTF has unsupported morph target attribute ${H}`)}})}P&&y.defines.push(Ke.getMorphtargetPositionDefine()),L&&y.defines.push(Ke.getMorphtargetNormalDefine()),I&&y.defines.push(Ke.getMorphtargetTangentDefine()),y.weights=t.weights||new Array(p.length).fill(0)}a.push(y)}return t.dprimitives=a,t.isParsed=!0,t.dprimitives}parseAccessor(e){return this.subParser.parseAccessor(e)}parseMaterial(e){return this.subParser.parseMaterial(e)}errorMiss(e,t){throw new Error(e+t)}}class eu{constructor(e){o(this,"gltf"),o(this,"subParser"),this.gltf=e.gltf,this.subParser=e}async parse(e){let t;if(e==null?t=Ke.defaultMaterial:t=this.gltf.materials[e],!t)return this.errorMiss("material",e);if(t.isParsed)return t.dmaterial;let{name:r,pbrMetallicRoughness:s,normalTexture:a,occlusionTexture:n,emissiveTexture:l,emissiveFactor:h,alphaMode:u,alphaCutoff:c,doubleSided:f,extensions:d}=t;const p={name:r,defines:[],doubleSided:!!f,baseColorFactor:[1,1,1,1],emissiveFactor:null,alphaCutoff:0,enableBlend:!1,baseColorTexture:null,metallicRoughnessTexture:null,normalTexture:null,occlusionTexture:null,emissiveTexture:null,transformUV1:null,transformUV2:null,extensions:null};if(s){const{baseColorFactor:m,metallicFactor:_,roughnessFactor:v,baseColorTexture:y,metallicRoughnessTexture:C}=s;if(Object.assign(p,{baseColorFactor:m||[1,1,1,1],metallicFactor:_===void 0?1:_,roughnessFactor:v===void 0?.5:v}),y){let B=y.extensions;if(B){let M=B.KHR_texture_transform;M&&(p.transformUV1=new j(M.offset?M.offset[0]:0,M.offset?M.offset[1]:0,M.scale?M.scale[0]:1,M.scale?M.scale[1]:1))}const T=await this.parseTexture(y.index);T?p.baseColorTexture=T:p.baseColorTexture=A.res.redTexture}if(C){const B=await this.parseTexture(C.index);B?p.metallicRoughnessTexture=B:p.metallicRoughnessTexture=A.res.blackTexture}}else Object.assign(p,{baseColorFactor:[1,1,1,1],metallicFactor:0,roughnessFactor:.5});if(p.baseColorFactor&&p.baseColorFactor[3]<1&&(u=u==="MASK"?"MASK":"BLEND"),u&&u!=="OPAQUE"&&(u==="MASK"&&(p.defines.push(Ke.getAlphaMaskDefine()),p.alphaCutoff=c===void 0?.5:c),u==="BLEND"&&(p.defines.push(Ke.getAlphaBlendDefine()),p.enableBlend=!0)),a){const m=await this.parseTexture(a.index);m?p.normalTexture=m:p.normalTexture=A.res.normalTexture}if(n){const m=await this.parseTexture(n.index);m&&(p.occlusionTexture=m)}if(h&&(p.emissiveFactor=h),l){const m=await this.parseTexture(l.index);m?p.emissiveTexture=m:p.emissiveTexture=A.res.blackTexture}return d&&(p.extensions=d),t.isParsed=!0,t.dmaterial=p,p}async parseTexture(e){return this.subParser.parseTexture(e)}errorMiss(e,t){throw new Error(e+t)}}class tu{constructor(e){o(this,"gltf"),o(this,"subParser"),this.gltf=e.gltf,this.subParser=e}parse(e){const t=this.gltf.skins[e];if(!t)return this.errorMiss("skin",e);if(t.isParsed)return t.dskin;const{name:r,joints:s,inverseBindMatrices:a,skeleton:n}=t;if(!s)return this.errorMiss("skin.joints",e);t.isParsed=!0,t.dskin=!1;let l={name:r,skeleton:null,inverseBindMatrices:null,joints:s,defines:[Ke.getJointsNumDefine(s.length)]};if(n)l.skeleton=n;else{var h=-1;for(let u=0;u<this.gltf.nodes.length;u++)if(this.gltf.nodes[u].name=="root"){h=u;break}if(h==-1){let u=this.gltf.scenes[this.gltf.scene];h=u.nodes[u.nodes.length-1]}l.skeleton=h}if(l.inverseBindMatrices=le.IDENTITY_INVERSE_BIND_MATRICES,a!==void 0){const u=this.parseAccessor(a);if(u){const c=u.data,f=[];for(let d=0;d<c.length;d+=16)f.push(c.slice(d,d+16));l.inverseBindMatrices=f}else l=null}return t.dskin=l,t.dskin}parseAccessor(e){return this.subParser.parseAccessor(e)}errorMiss(e,t){throw new Error(e+t)}}class iu{constructor(e=""){o(this,"name",""),o(this,"index",0),o(this,"parent",null),o(this,"children",[]),o(this,"scale",new g),o(this,"rotation",new q),o(this,"translation",new g),this.name=e}}class ru{constructor(e=[]){o(this,"joints"),this.joints=e}get numJoint(){return this.joints.length}addJoint(e){e.index=this.joints.push(e)-1}getJointName(e){return this.joints[e].name}getJointParentIndex(e){let t=this.joints[e];return t.parent?t.parent.index:-1}getJointByName(e){for(let t of this.joints)if(t.name==e)return t;return null}}class Ro{constructor(e,t=!1){o(this,"index"),o(this,"worldMatrix"),this.index=e,this.worldMatrix=new V(!t)}}class ss{constructor(e,t=!1){o(this,"time"),o(this,"_skeleton"),o(this,"_jointsPose"),o(this,"mJointMatrixIndexTable"),this._skeleton=e,this._jointsPose=new Array(e.numJoint),this.mJointMatrixIndexTable=new Array(e.numJoint);for(let r=0;r<e.numJoint;r++){let s=new Ro(r,t);this._jointsPose[r]=s,this.mJointMatrixIndexTable[r]=s.worldMatrix.index}}buildSkeletonPose(e){let t=new g,r=new q,s=new g,a=new Array(this._skeleton.numJoint);this.time=e[11]>0?e[11]:e[24];for(let n=0;n<this._skeleton.numJoint;n++){let l=12*n*4,h=new Float32Array(e.buffer,e.byteOffset+l,12),u=new V;t.set(h[0],h[1],h[2]),r.set(h[4],h[5],h[6],h[7]),s.set(h[8],h[9],h[10]),Rs(r.getEulerAngles(),s,t,u),a[n]=u;let c=new Ro(n);const f=this._skeleton.getJointParentIndex(n);if(f<0)c.worldMatrix.copyFrom(u);else{let d=this._jointsPose[f];_l(d.worldMatrix,u,c.worldMatrix)}this._jointsPose[n]=c}}get numJoint(){return this._skeleton.numJoint}get joints(){return this._jointsPose}get jointMatrixIndexTable(){return this.mJointMatrixIndexTable}lerp(e,t,r){for(let s=0;s<this._jointsPose.length;s++){let a=e._jointsPose[s],n=t._jointsPose[s];this._jointsPose[s].worldMatrix.lerp(a.worldMatrix,n.worldMatrix,r)}}copyFrom(e){for(let t=0;t<this._jointsPose.length;t++)this._jointsPose[t].worldMatrix.copyFrom(e._jointsPose[t].worldMatrix)}reset(){for(let e=0;e<this._jointsPose.length;e++)this._jointsPose[e].worldMatrix.identity()}}class su extends je{constructor(e,t){super(),o(this,"skeletonAnimation"),this.type=e,this.time=t}}class ma{constructor(e,t,r,s){if(o(this,"name",""),o(this,"_skeleton"),o(this,"_skeletonPoses"),o(this,"_animationClipData"),o(this,"_events"),this.name=e,this._skeleton=t,this._animationClipData=s,r>0&&s){this._skeletonPoses=new Array(r);let a=12*t.numJoint;for(let n=0;n<r;n++){let l=a*n*4,h=new Float32Array(s.buffer,l,a),u=new ss(t);u.buildSkeletonPose(h),this._skeletonPoses[n]=u}}}get totalTime(){return this._skeletonPoses[this._skeletonPoses.length-1].time}get frameRate(){return this.totalTime/this._skeletonPoses.length}get skeleton(){return this._skeleton}get numFrame(){return this._skeletonPoses.length-1}get animationClipData(){return this._animationClipData}getSkeletonPose(e){return this._skeletonPoses[e]}getLerpSkeletonPose(e,t,r,s){let a=this.getSkeletonPose(e),n=this.getSkeletonPose(t);return s.lerp(a,n,r),s}createSubClip(e,t,r){var s=new ma(e,this._skeleton,0,null);const a=Math.max(Math.floor(t/this.frameRate),0),n=Math.min(Math.floor(r/this.frameRate),this._skeletonPoses.length-1);s._skeletonPoses=this._skeletonPoses.slice(a,n);const l=12*this._skeleton.numJoint*4;return this._animationClipData=new Float32Array(this._animationClipData,a*l,(n-a)*l),s}addEvent(e,t){this._events||(this._events=new Array),this._events.push(new su(e,t))}removeEvent(e){this._events&&(this._events=this._events.filter(t=>t.type!=e))}getEvents(){return this._events}}class Lo{constructor(e){o(this,"gltf"),o(this,"subParser"),this.gltf=e.gltf,this.subParser=e}parse(e){let t=new ru;return this.buildSkeleton(t,void 0,e),t}parseSkeletonAnimation(e,t){let r=this.subParser.parseAccessor(t.samplers[0].input).data.length,s=12*e.numJoint,a=new Float32Array(s*r);for(var n=0;n<e.numJoint;n++)for(var l=0;l<r;l++){var h=s*l+12*n;a[h+0]=1,a[h+1]=1,a[h+2]=1,a[h+3]=1}for(let f of t.channels){let d=t.samplers[f.sampler];const p=this.subParser.parseAccessor(d.input),m=this.subParser.parseAccessor(d.output);let _=f.target.node,v=f.target.path,y=this.gltf.nodes[_];if(!y)continue;let C=e.getJointByName(y.name);switch(v){case"scale":for(var l=0;l<r;l++){var u=l*m.numComponents,h=s*l+12*C.index;a[h+0]=m.data[u+0],a[h+1]=m.data[u+1],a[h+2]=m.data[u+2],a[h+3]=1}break;case"rotation":for(var l=0;l<r;l++){var u=l*m.numComponents,h=s*l+12*C.index+4;a[h+0]=m.data[u+0],a[h+1]=m.data[u+1],a[h+2]=m.data[u+2],a[h+3]=m.data[u+3]}break;case"translation":for(var l=0;l<r;l++){var u=l*m.numComponents,h=s*l+12*C.index+8;a[h+0]=m.data[u+0],a[h+1]=m.data[u+1],a[h+2]=m.data[u+2],a[h+3]=p.data[l*p.numComponents]}break}}return new ma(t.name,e,r,a)}buildSkeleton(e,t,r,s=0){let a=this.gltf.nodes[r];a.name||(a.name="Node_"+r);let n=new iu(a.name);if(n.parent=t,a.scale&&n.scale.set(a.scale[0],a.scale[1],a.scale[2]),a.rotation&&n.rotation.set(a.rotation[0],a.rotation[1],a.rotation[2],a.rotation[3]),a.translation&&n.translation.set(a.translation[0],a.translation[1],a.translation[2]),e.addJoint(n),a.children)for(let l of a.children)this.buildSkeleton(e,n,l,s+1)}}class au{constructor(e){o(this,"loop",!0),o(this,"speed",1),o(this,"t",0),o(this,"time",0),o(this,"weight",0),o(this,"currFrame",0),o(this,"lastFrame",-1),o(this,"nextFrame",0),o(this,"clip"),o(this,"animation"),o(this,"_isEnd",!1),o(this,"_currSkeletonPose"),this.clip=e,this._currSkeletonPose=new ss(this.clip.skeleton)}reset(){this.time=0,this.weight=0,this._isEnd=!1}get name(){return this.clip.name}get currSkeletonPose(){return this._currSkeletonPose}update(e){this.time=(this.time+e*this.speed)%this.clip.totalTime;let t=this.time/this.clip.frameRate;if(this.currFrame=Math.trunc(t),this.t=t-this.currFrame,this.currFrame<0&&(this.currFrame=this.clip.numFrame+this.currFrame),this.time>=0?this.nextFrame=(this.currFrame+1)%this.clip.numFrame:(this.nextFrame=this.currFrame-1,this.nextFrame<0&&(this.nextFrame=this.clip.numFrame+this.nextFrame),this.t=1-this.t),this._isEnd)this.currFrame=this.nextFrame=this.speed<0?0:this.clip.numFrame-1;else if(this.currFrame!=this.lastFrame){let a=this.speed<0?0:this.clip.numFrame;this.currFrame==a&&(this.loop?(this.currFrame=0,this.nextFrame=1,this.time=this.t=0):(this.currFrame=this.nextFrame=this.speed<0?0:this.clip.numFrame-1,this._isEnd=!0));var r=this.clip.getEvents();if(r)for(let n of r){var s=Math.floor(n.time/this.clip.frameRate);if(s=Math.min(s,this.clip.numFrame),s=Math.max(s,0),s==this.currFrame){n.skeletonAnimation=this.animation,this.animation.eventDispatcher.dispatchEvent(n);break}}this.lastFrame=this.currFrame}this.clip.getLerpSkeletonPose(this.currFrame,this.nextFrame,this.t,this._currSkeletonPose)}}class vi extends Ee{constructor(){super(),o(this,"isPlaying",!0),o(this,"timeScale",1),o(this,"_skeleton"),o(this,"_clips",[]),o(this,"_clipStates",new Map),o(this,"_mixSkeletonPose"),o(this,"_mixTempSkeletonPose"),o(this,"_currentClipState"),o(this,"_bindList",[]),o(this,"_jointMatrixIndexTableBuffer"),o(this,"_crossFadeState")}start(){}get currName(){return this._currentClipState?this._currentClipState.name:""}set skeleton(e){this._skeleton=e,this._mixSkeletonPose=new ss(this._skeleton,!0),this._mixTempSkeletonPose=new ss(this._skeleton);const t=new Float32Array(this._mixSkeletonPose.jointMatrixIndexTable);this._jointMatrixIndexTableBuffer=new ge(this._skeleton.numJoint*4,0,t)}get skeleton(){return this._skeleton}get finalSkeletonPose(){return this._mixSkeletonPose}get jointMatrixIndexTableBuffer(){return this._jointMatrixIndexTableBuffer}getJointIndexTable(e){let t=new Array;for(let r=0;r<e.length;r++){const s=e[r];let a=this._skeleton.getJointByName(s);t[r]=a?a.index:-1}return t}addAnimationClip(e){if(!this._clipStates.has(e.name)){this._clips.push(e);let t=new au(e);t.animation=this,this._clipStates.set(e.name,t),this._currentClipState||this.setCurrentClipState(t)}}getAnimationClip(e){var t=this.getAnimationClipState(e);return t?t.clip:null}getAnimationClips(){return this._clips}getAnimationClipState(e){return this._clipStates.has(e)?this._clipStates.get(e):null}getAnimationClipStates(){return this._clipStates}pause(){this.isPlaying=!1}resume(){this.isPlaying=!0}play(e,t=1,r=!1){if(this._currentClipState&&this._currentClipState.name==e)return r&&this._currentClipState.reset(),!1;let s=this.getAnimationClipState(e);return s?(s.speed=t,s.reset(),this._clipStates.forEach((a,n)=>{a.weight=0}),this.setCurrentClipState(s),!0):!1}crossFade(e,t){if(t<.01){this.play(e);return}if(this._currentClipState.name==e)return;let r=this.getAnimationClipState(e);r&&(r.reset(),this._crossFadeState?(this._crossFadeState.inClip&&(this._crossFadeState.inClip.weight=0),this._crossFadeState.outClip&&(this._crossFadeState.outClip.weight=0),this._crossFadeState.reset(r,this._currentClipState,t)):this._crossFadeState=new Ng(r,this._currentClipState,t),this._currentClipState=r)}setAnimIsLoop(e,t){this._clipStates.has(e)&&(this._clipStates.get(e).loop=t)}addJointBind(e,t){this._bindList.push({jointName:e,obj:t})}removeJointBind(e){for(let t=0;t<this._bindList.length;t++)if(this._bindList[t].obj==e){this._bindList.splice(t,1);break}}onUpdate(){if(!this.isPlaying)return;let e=he.delta*.001*this.timeScale;this._crossFadeState&&this._crossFadeState.update(e);var t=0,r=[];if(this._clipStates.forEach((a,n)=>{a.weight>0&&(a.update(e),t+=a.weight,r.push(a))}),r.length>0){this._mixSkeletonPose.copyFrom(r[0].currSkeletonPose);for(var s=1;s<r.length;++s){const a=r[s];this._mixTempSkeletonPose.lerp(this._mixSkeletonPose,a.currSkeletonPose,a.weight/t),this._mixSkeletonPose.copyFrom(this._mixTempSkeletonPose)}}}cloneTo(e){let t=e.addComponent(vi);t.skeleton=this.skeleton;for(var r=0;r<this._clips.length;++r)t.addAnimationClip(this._clips[r])}setCurrentClipState(e){this._currentClipState!=e&&(this._currentClipState=e,this._currentClipState.weight=1)}}class Ng{constructor(e,t,r){o(this,"inClip"),o(this,"outClip"),o(this,"currentTime"),o(this,"crossFadeTime"),this.reset(e,t,r)}reset(e,t,r){this.inClip=e,this.outClip=t,this.currentTime=0,this.crossFadeTime=r}update(e){!this.inClip||!this.outClip||(this.currentTime+=e,this.inClip.weight=Math.min(Math.abs(this.currentTime%this.crossFadeTime)/this.crossFadeTime,1),this.outClip.weight=1-this.inClip.weight,Math.abs(this.currentTime)>=this.crossFadeTime&&(this.inClip.weight=1,this.outClip.weight=0,this.inClip=null,this.outClip=null))}}class Xs{static add(e){this.list.indexOf(e)==-1&&this.list.push(e)}static remove(e){let t=this.list.indexOf(e);t!=-1&&this.list.splice(t,1)}}o(Xs,"list",[]);class Ws extends Ee{constructor(){super(),o(this,"name"),o(this,"size",1),o(this,"lightData"),o(this,"dirFix",1),o(this,"bindOnChange"),o(this,"needUpdateShadow",!0),o(this,"realTimeShadow",!0),o(this,"_castGI",!1),o(this,"_castShadow",!1),o(this,"_iesProfiles")}init(){this.transform.object3D.bound=new Be(new g,new g),this.lightData=new Gr,this.lightData.lightMatrixIndex=this.transform.worldMatrix.index}onChange(){this.bindOnChange&&this.bindOnChange(),this.transform.object3D.bound.setFromCenterAndSize(this.transform.worldPosition,new g(this.size,this.size,this.size)),this._castGI&&(Q.instance.state.giLightingChange=!0),this._castShadow?(this.needUpdateShadow=!0,Ve.addShadowLight(this)):Ve.removeShadowLight(this)}start(){this.transform.onPositionChange=()=>this.onPositionChange(),this.transform.onScaleChange=()=>this.onScaleChange(),this.transform.onRotationChange=()=>this.onRotChange(),this.onPositionChange(),this.onRotChange(),this.onScaleChange()}onPositionChange(){this.lightData.lightPosition.copyFrom(this.transform.worldPosition)}onRotChange(){this.dirFix==1?this.lightData.direction.copyFrom(this.transform.forward):this.lightData.direction.copyFrom(this.transform.back),this.lightData.lightTangent.copyFrom(this.transform.up),this.onChange()}onScaleChange(){this.onChange()}onEnable(){this.onChange(),Q.instance.addLight(this.transform.scene3D,this)}onDisable(){this.onChange(),Q.instance.removeLight(this.transform.scene3D,this),Ve.removeShadowLight(this)}set iesProfiles(e){this._iesProfiles=e,this.lightData.iesIndex=e.index,Bi.use=!0,this.onChange()}get iesProfile(){return this._iesProfiles}get r(){return this.lightData.lightColor.r}set r(e){this.lightData.lightColor.r=e,this.onChange()}get g(){return this.lightData.lightColor.g}set g(e){this.lightData.lightColor.g=e,this.onChange()}get b(){return this.lightData.lightColor.b}set b(e){this.lightData.lightColor.b=e,this.onChange()}get lightColor(){return this.lightData.lightColor}set lightColor(e){this.lightData.lightColor=e,this.onChange()}get intensity(){return this.lightData.intensity}set intensity(e){this.lightData.intensity=e,this.onChange()}set castShadow(e){e!=this._castShadow&&(this._castShadow=e,this.onChange())}get castShadow(){return this._castShadow}get shadowIndex(){return this.lightData.castShadowIndex}get castGI(){return this._castGI}set castGI(e){e?Xs.add(this):Xs.remove(this),this._castGI=e,e&&this.onChange()}get direction(){return this.lightData.direction}destroy(e){this.bindOnChange=null,Q.instance.removeLight(this.transform.scene3D,this),Ve.removeShadowLight(this),this.transform.eventDispatcher.removeEventListener(Oe.ROTATION_ONCHANGE,this.onRotChange,this),this.transform.eventDispatcher.removeEventListener(Oe.SCALE_ONCHANGE,this.onScaleChange,this),super.destroy(e)}}class ou extends Ws{constructor(){super(),o(this,"shadowCamera")}init(){super.init(),this.object3D.name==""&&(this.object3D.name="DirectionLight_"+Pt()),this.radius=Number.MAX_SAFE_INTEGER,this.lightData.lightType=Qe.DirectionLight,this.lightData.linear=0,this.lightData.quadratic=.3}start(){super.start(),this.castGI=!0}get radius(){return this.lightData.range}set radius(e){this.lightData.range=e,this.onChange()}get indirect(){return this.lightData.quadratic}set indirect(e){this.lightData.quadratic=e,this.onChange()}debug(){}}class nu extends Ws{constructor(){super()}init(){super.init(),this.lightData.lightType=Qe.PointLight,this.object3D.name==""&&(this.object3D.name="PointLight"+Pt())}get range(){return this.lightData.range}set range(e){this.lightData.range=e,this.onChange()}get at(){return this.lightData.linear}set at(e){this.lightData.linear=e,this.onChange()}get radius(){return this.lightData.radius}set radius(e){this.lightData.radius=e,this.onChange()}get quadratic(){return this.lightData.quadratic}set quadratic(e){this.lightData.quadratic=e,this.onChange()}start(){this.transform.rotationX=90,super.start()}onUpdate(){}onGraphic(e){let t=e.graphic3D.createCustomShape(`PointLight_${this.object3D.instanceID}`,this.transform);t.buildAxis(),t.buildCircle(g.ZERO,this.range,32,g.X_AXIS),t.buildCircle(g.ZERO,this.range,32,g.Y_AXIS),t.buildCircle(g.ZERO,this.range,32,g.Z_AXIS)}debug(){}debugDraw(e){}}class lu extends Ws{constructor(){super()}init(){super.init(),this.lightData.lightType=Qe.SpotLight,this.object3D.name==""&&(this.object3D.name="SpotLight"+Pt())}get innerAngle(){return this.lightData.innerAngle/this.lightData.outerAngle*100}set innerAngle(e){this.lightData.innerAngle=K(e,0,100)/100*this.lightData.outerAngle,this.onChange()}get outerAngle(){return this.lightData.outerAngle*qi*2}set outerAngle(e){this.lightData.outerAngle=K(e,1,179)*_e*.5,this.onChange()}get radius(){return this.lightData.radius}set radius(e){this.lightData.radius=e,this.onChange()}get range(){return this.lightData.range}set range(e){this.lightData.range=e,this.onChange()}get at(){return this.lightData.linear}set at(e){this.lightData.linear=e,this.onChange()}start(){super.start(),this.lightData.lightType=Qe.SpotLight}onUpdate(){}onGraphic(e){let t=e.graphic3D.createCustomShape(`SpotLight_${this.object3D.instanceID}`,this.transform);const r=this.range,s=this.outerAngle/2;t.buildAxis();let a=(90-s)*_e,n=r*Math.cos(a),l=r*Math.sin(a);t.buildLines([g.ZERO,new g(0,n,l)]),t.buildLines([g.ZERO,new g(n,0,l)]),a=(90+s)*_e,n=r*Math.cos(a),l=r*Math.sin(a),t.buildLines([g.ZERO,new g(0,n,l)]),t.buildLines([g.ZERO,new g(n,0,l)]),t.buildArcLine(g.ZERO,r,90-s,90+s,16,g.X_AXIS),t.buildArcLine(g.ZERO,r,90-s,90+s,16,g.Y_AXIS),t.buildCircle(new g(0,0,r*Math.sin(a)),r*Math.cos(a),32,g.Z_AXIS)}debug(){}debugDraw(e){}}class Aa extends ce{constructor(){super(),o(this,"skinJointsName"),o(this,"mInverseBindMatrixData"),o(this,"mInverseBindMatrixBuffer"),o(this,"mSkeletonAnimation"),o(this,"mJointIndexTableBuffer"),this.addRendererMask(Ue.SkinnedMesh)}start(){if(super.start(),this.skeletonAnimation=this.object3D.getComponent(vi),!this.skeletonAnimation){let e=this.object3D.parentObject.parentObject.getComponentsInChild(vi);e.length>0&&(this.skeletonAnimation=e[0]),this.skeletonAnimation||(this.skeletonAnimation=this.object3D.getComponentFromParent(vi))}}onEnable(){super.onEnable()}get skeletonAnimation(){return this.mSkeletonAnimation}set skeletonAnimation(e){if(this.mSkeletonAnimation=e,!!e&&!this.mJointIndexTableBuffer){let t=this.mSkeletonAnimation.getJointIndexTable(this.skinJointsName);this.mJointIndexTableBuffer=new ge(t.length*4,0,new Float32Array(t)),this.mJointIndexTableBuffer.visibility=GPUShaderStage.VERTEX|GPUShaderStage.COMPUTE}}get skinInverseBindMatrices(){return this.mInverseBindMatrixData}set skinInverseBindMatrices(e){this.mInverseBindMatrixData=e;var t=new Float32Array(e.length*16);for(let r=0;r<e.length;r++){let s=r*16,a=e[r];t.set(a,s)}this.mInverseBindMatrixBuffer=new ge(t.byteLength,0,t),this.mInverseBindMatrixBuffer.visibility=GPUShaderStage.VERTEX|GPUShaderStage.COMPUTE}get inverseBindMatrixBuffer(){return this.mInverseBindMatrixBuffer}get jointIndexTableBuffer(){return this.mJointIndexTableBuffer.buffer}cloneTo(e){let t=e.addComponent(Aa);t.geometry=this.geometry,t.material=this.material.clone(),t.castShadow=this.castShadow,t.castGI=this.castGI,t.receiveShadow=this.receiveShadow,t.rendererMask=this.rendererMask,t.skinJointsName=this.skinJointsName,t.skinInverseBindMatrices=this.skinInverseBindMatrices,t.mJointIndexTableBuffer=this.mJointIndexTableBuffer}nodeUpdate(e,t,r,s){for(let a=0;a<this.materials.length;a++){let l=this.materials[a].getPass(t);if(l)for(let h=0;h<l.length;h++){const u=l[h];u.pipeline||(u.setStorageBuffer("jointsMatrixIndexTable",this.mSkeletonAnimation.jointMatrixIndexTableBuffer),u.setStorageBuffer("jointsInverseMatrix",this.mInverseBindMatrixBuffer),u.setStorageBuffer("jointsIndexMapingTable",this.mJointIndexTableBuffer))}}super.nodeUpdate(e,t,r,s)}}class hu{static apply(e,t,r){let s=t.extensions;if(s&&s.KHR_materials_clearcoat){r.defaultPass.setDefine("USE_CLEARCOAT",!0);let a=s.KHR_materials_clearcoat;"clearcoatFactor"in a&&(t.clearcoatFactor=a.clearcoatFactor,r.clearcoatFactor=t.clearcoatFactor),"clearcoatRoughnessFactor"in a&&(t.clearcoatRoughnessFactor=a.clearcoatRoughnessFactor,r.clearcoatRoughnessFactor=t.clearcoatRoughnessFactor)}}}class uu{static apply(e,t,r){let s=t.extensions;s&&s.KHR_materials_emissive_strength?(r.emissiveIntensity=s.KHR_materials_emissive_strength.emissiveStrength*.5,r.emissiveMap==A.res.blackTexture&&(r.emissiveMap=A.res.whiteTexture)):r.emissiveIntensity=1}}class cu{static apply(e,t,r){let s=t.extensions;s&&s.KHR_materials_unlit?r.supportLight=!0:r.supportLight=!1}}class fu{constructor(e){o(this,"gltf"),o(this,"subParser"),o(this,"_testCount",8),o(this,"_hasCastShadow",!1),this.gltf=e.gltf,this.subParser=e}async convertNodeToObject3D(e,t){const r=new te;if(r.name=e.name,r[le.GLTF_NODE_INDEX_PROPERTY]=e.nodeId,e.nodeObj=r,e.matrix&&(e.translation=[0,0,0],e.rotation=[0,0,0,1],e.scale=[1,1,1]),e.translation&&(r.transform.x=e.translation[0],r.transform.y=e.translation[1],r.transform.z=e.translation[2]),e.rotation){let s=new q;s.setFromArray(e.rotation),r.transform.localRotQuat=s}if(e.scale&&(r.transform.scaleX=e.scale[0],r.transform.scaleY=e.scale[1],r.transform.scaleZ=e.scale[2]),t.addChild(r),e.light&&this.convertLight(e,r),e.primitives&&this.convertprimitives(e,r),e.skeleton){let s=r.addComponent(vi);if(s){s.skeleton=this.subParser.parseSkeleton(e.skeleton.skeleton);for(let a=0;a<this.gltf.animations.length;a++){let n=this.gltf.animations[a];n.name||(n.name=a.toString());let l=this.subParser.parseSkeletonAnimation(s.skeleton,n);s.addAnimationClip(l)}}}return r}convertLight(e,t){switch(e.light.type){case"directional":let r=t.addComponent(ou);t.name=e.light.name,r.intensity=e.light.intensity*.1,r.radius=Number.MAX_SAFE_INTEGER,r.dirFix=-1,this._hasCastShadow||(this._hasCastShadow=!0,r.castShadow=this._hasCastShadow),r.lightColor=e.light.color?new z(e.light.color[0],e.light.color[1],e.light.color[2]):new z(1,1,1,1),r.debug();break;case"point":if(this._testCount>0){let a=t.addComponent(nu);a.name=e.light.name,a.intensity=e.light.intensity?e.light.intensity*8*2:1,a.radius=8,a.at=2,a.range=e.light.range?e.light.range:8,a.lightColor=e.light.color?new z(e.light.color[0],e.light.color[1],e.light.color[2]):new z(1,1,1,1)}this._testCount--;break;case"spot":let s=t.addComponent(lu);s.name=e.light.name,s.intensity=e.light.intensity*5,s.radius=1,s.dirFix=-1,s.at=2,s.range=e.light.range?e.light.range:8,s.outerAngle=e.light.spot.outerConeAngle*qi,s.lightColor=e.light.color?new z(e.light.color[0],e.light.color[1],e.light.color[2]):new z(1,1,1,1);break}}convertprimitives(e,t){for(let r=0;r<e.primitives.length;r++){const s=e.primitives[r];s.modelName;let a=s.material;a.name==null&&(a.name=Pt());let n,l=`matkey_${a.name}`;if(a&&this.gltf.resources[l])n=this.gltf.resources[l];else{let d=n=new yi;if(this.gltf.resources[l]=d,d.name=a.name,s.material){const{baseColorTexture:p,baseColorFactor:m,metallicFactor:_,roughnessFactor:v,doubleSided:y,metallicRoughnessTexture:C,normalTexture:B,occlusionTexture:T,emissiveTexture:M,emissiveFactor:D,enableBlend:P,alphaCutoff:L}=s.material;let I=d=this.applyMaterialExtensions(s.material,d);if("enableBlend"in s.material&&(s.material.enableBlend?(I.blendMode=xe.NORMAL,I.depthWriteEnabled=!1):I.blendMode=xe.NONE,s.material.defines&&s.material.defines.indexOf("ALPHA_BLEND")!=-1&&(I.blendMode=xe.ALPHA,I.transparent=!0,I.depthWriteEnabled=!1)),"alphaCutoff"in s.material&&L>0&&(I.alphaCutoff=L,I.blendMode=xe.NORMAL,I.transparent=!0,I.depthWriteEnabled=!1),s.material.transformUV1&&(I.uvTransform_1=s.material.transformUV1),s.material.transformUV2&&(I.uvTransform_2=s.material.transformUV2),I.baseColor=new z(m[0],m[1],m[2],m[3]),I.roughness=v,I.metallic=_,I.doubleSide=y,I.ao=1,p&&(I.baseMap=p),B&&(I.normalMap=B),C&&(I.maskMap=C),T&&C!=T&&(I.aoMap=T),M&&(I.emissiveMap=M),D&&(D[0]>0||D[1]>0||D[2]>0)){I.emissiveMap&&I.emissiveMap==A.res.blackTexture&&(I.emissiveMap=A.res.whiteTexture);let O=D[3]?D[3]:1;I.emissiveColor=new z(D[0],D[1],D[2],O),I.emissiveIntensity=1}}}const{attribArrays:h,modelName:u,drawMode:c}=s;let f;if(!h.indices.data){let d=[],p=h.position.data.length/3/3;for(let m=0;m<p;m++){let _=m*3;d.push(_+2),d.push(_+0),d.push(_+1)}h.indices={data:new Uint8Array(d),normalize:!1,numComponents:1}}if(!h.normal){let d=[],p=h.position.data.length/3;for(let m=0;m<p;m++)d.push(0),d.push(0),d.push(0);h.normal={data:new Float32Array(d),normalize:!1,numComponents:3}}if(h.indices.data&&h.indices.data.length>3){let d=s.meshName();this.gltf.resources[d]?f=this.gltf.resources[d]:(f||(f=this.createGeometryBase(d,h,s)),this.gltf.resources[d]=f);const p=new te;if(p.name=u+r,this.gltf.animations&&h[Y.joints0]!=null){f||(f=this.createGeometryBase(u,h,s)),this.gltf.resources[d]=f;let m=this.gltf.nodes[e.skin.skeleton];if(m.dnode&&m.dnode.nodeObj){let y=m.dnode.nodeObj.addComponent(vi);if(y){y.skeleton=this.subParser.parseSkeleton(e.skin.skeleton);for(let C=0;C<this.gltf.animations.length;C++){let B=this.gltf.animations[C];B.name||(B.name=C.toString());let T=this.subParser.parseSkeletonAnimation(y.skeleton,B);y.addAnimationClip(T)}}}else m.dnode.skeleton=e.skin;let _=p.addComponent(Aa);_.castShadow=!0,_.castGI=!0,_.geometry=f,_.material=n,_.skinJointsName=this.parseSkinJoints(e.skin),_.skinInverseBindMatrices=e.skin.inverseBindMatrices}else{f||(f=this.createGeometryBase(u,h,s)),this.gltf.resources[d]=f,f.hasAttribute(Y.joints0)&&f.vertexAttributeMap.delete(Y.joints0);let m=p.addComponent(ce);m.castShadow=!0,m.castGI=!0,m.geometry=f,m.material=n}e.skin&&e.skin.defines,t.addChild(p)}}}createGeometryBase(e,t,r){let s=new tt;s.name=e,s.morphTargetsRelative=r.morphTargetsRelative;let a=r.targetNames;if(a&&a.length>0){let l=s.morphTargetDictionary={};for(let h=0;h<a.length;h++)l[a[h]]=h}if(s.morphTargetDictionary){let l=t.position.data.length/3,h=new Float32Array(l);for(let u=0;u<l;u++)h[u]=u;t.vIndex={data:h,normalize:!1,numComponents:1}}for(const l in t){let h=t[l];s.setAttribute(l,h.data)}let n=s.getAttribute(Y.indices);return s.addSubGeometry({indexStart:0,indexCount:n.data.length,vertexStart:0,index:0}),s}applyMaterialExtensions(e,t){return hu.apply(this.gltf,e,t),cu.apply(this.gltf,e,t),uu.apply(this.gltf,e,t),t}parseSkinJoints(e){let t=[];for(let r of e.joints){let s=this.gltf.nodes[r];t.push(s.name)}return t}}class js{constructor(){o(this,"currentSceneName"),o(this,"gltf"),o(this,"initUrl"),o(this,"_generator"),o(this,"_version"),o(this,"_BASE64_MARKER",";base64,"),o(this,"_cameraParser",null),o(this,"_meshParser",null),o(this,"_materialParser",null),o(this,"_skinParser",null),o(this,"_skeletonParser",null),o(this,"_converter",null)}get version(){return this.version?this.version:this.gltf?this.gltf.asset?(this._version=this.gltf.asset.version,this.gltf.asset.minVersion&&(this._version+=`\r minVersion${this.gltf.asset.minVersion}`),this.version):this.errorMiss("asset"):(console.warn("glTF not loaded."),null)}async parse(e,t,r){this.gltf=t,this.initUrl=e;const{version:s,generator:a}=this.gltf.asset;if(this._generator=a,s!=="2.0")return console.error(`GLTFParser only support glTF 2.0 for now! Received glTF version: ${this.version}`),!1;const n={nodes:await this.parseScene(r),animations:this.parseAnimations(),name:this.currentSceneName};return await this.convertToNode(n)}destory(){rs.unload(this.gltf),this.gltf=null}async parseScene(e){const t=e||this.gltf.scene||0,r=this.gltf.scenes[t];if(typeof r>"u")return this.errorMiss("scene",t);this.currentSceneName=r.name||"GLTF_NO_NAME_SCENE";const s=[],a=r.nodes;for(let n=0;n<a.length;n++){const l=await this.parseNode(a[n]);l&&s.push(l)}return s}async parseNode(e){const t=this.gltf.nodes[e];if(!t)return this.errorMiss("node",e);if(t.isParsed)return t.dnode;const{name:r,matrix:s,translation:a,rotation:n,scale:l}=t,h={name:r,matrix:s,translation:a,rotation:n,scale:l,nodeId:e,camera:null,primitives:null,skin:null,children:null,light:null};if(t.camera!==void 0&&(h.camera=this.parseCamera(t.camera)),t.mesh!==void 0&&(h.primitives=await this.parseMesh(t.mesh)),t.extensions!==void 0&&this.applyNodeExtensions(t,h),t.skin!==void 0){const u=this.parseSkin(t.skin);u&&(h.skin=u)}if(h.children=[],t.children)for(let u=0;u<t.children.length;u++)h.children.push(await this.parseNode(t.children[u]));return t.dnode=h,t.isParsed=!0,t.dnode}errorMiss(e,t){throw new Error(e+t)}parseCamera(e){return this._cameraParser||(this._cameraParser=new Jh(this.gltf)),this._cameraParser.parse(e)}async parseMesh(e){return this._meshParser||(this._meshParser=new $h(this)),this._meshParser.parse(e)}async parseTexture(e){let t=this.gltf.textures[e];if(t&&!t.dtexture){if(t&&t.source!=null){let r=this.gltf.images[t.source];if(r.uri){let s=r.uri;s=it.getURLName(s),t.dtexture=this.gltf.resources[s]}else if(r.bufferView){let s=this.parseBufferView(r.bufferView),a=new ii,n=new Blob([s],{type:r.mimeType});await a.loadFromBlob(n),t.dtexture=a}else t.dtexture=this.gltf.resources[r.name]}else if(t.name){let r=it.getURLName(t.name);t.dtexture=this.gltf.resources[r]}}return t.dtexture||console.log("miss texture , please check texture!",e,t),t.dtexture}async parseMaterial(e){return this._materialParser||(this._materialParser=new eu(this)),this._materialParser.parse(e)}parseAnimations(){return[]}async parseObject3D(e,t){return this._converter||(this._converter=new fu(this)),this._converter.convertNodeToObject3D(e,t)}parseSkeleton(e){return this._skeletonParser||(this._skeletonParser=new Lo(this)),this._skeletonParser.parse(e)}parseSkeletonAnimation(e,t){return this._skeletonParser||(this._skeletonParser=new Lo(this)),this._skeletonParser.parseSkeletonAnimation(e,t)}async traverse(e,t){for(let r=0;r<t.length;r++){const s=await this.parseObject3D(t[r],e);await this.traverse(s,t[r].children)}}async convertToNode(e){const t=new te;t.name=e.name;const r=e.nodes;e.animations;const s=[],a=[];await this.traverse(t,r);let n;return{rootNode:t,textures:s,animations:n,cameras:a}}parseSkin(e){return this._skinParser||(this._skinParser=new tu(this)),this._skinParser.parse(e)}parseAccessor(e){const t=this.gltf.accessors[e];if(!t)return this.errorMiss("accessor",e);if(t.isParsed)return t.daccessor;t.isParsed=!0,t.daccessor=!1;const r=!!t.normalized,s=this.gltf.bufferViews[t.bufferView],a=s&&s.byteStride,n=Po(t.componentType);let l=1;switch(t.type){case"SCALAR":l=1;break;case"VEC2":l=2;break;case"VEC3":l=3;break;case"VEC4":case"MAT2":l=4;break;case"MAT3":l=9;break;case"MAT4":l=16;break;default:l=0;break}if(l===0)return console.error(`glTF has unknown data type in accessor: ${t.type}`),!1;const h=l*n.BYTES_PER_ELEMENT;let u;if(s!==void 0){if(u=this.parseBufferView(t.bufferView),!u)return t.daccessor}else u=new Uint8Array(h*t.count).buffer;let c=this.getTypedArrayFromArrayBuffer(u,a,t.byteOffset||0,n,l,t.count);if(t.sparse){const{count:f,indices:d,values:p}=t.sparse;c=new n(c);const m=d.byteOffset||0,_=this.gltf.bufferViews[d.bufferView],v=Po(d.componentType),y=this.parseBufferView(d.bufferView),C=this.getTypedArrayFromArrayBuffer(y,_.byteStride,m,v,1,f),B=p.byteOffset||0,T=this.gltf.bufferViews[p.bufferView],M=this.parseBufferView(p.bufferView),D=this.getTypedArrayFromArrayBuffer(M,T.byteStride,B,n,l,f);for(let P=0;P<C.length;P++)c.set(D.slice(P*l,P*l+l),C[P]*l)}return t.computeResult={typedArray:c,arrayType:n,numComponents:l},t.daccessor={data:c,numComponents:l,normalize:r},t.daccessor}getTypedArrayFromArrayBuffer(e,t,r,s,a,n){let l;const h=a*s.BYTES_PER_ELEMENT;if(t&&h!==t){const u=a*n;l=new s(u);for(let c=0;c<n;c++){const f=new s(e,r+c*t,a);for(let d=0;d<a;d++)l[c*a+d]=f[d]}}else l=new s(e,r,n*a);return l}parseBufferView(e){const t=this.gltf.bufferViews[e];if(!t)return this.errorMiss("bufferView",e);if(t.isParsed)return t.dbufferView;t.isParsed=!0,t.dbufferView=!1;const r=this.parseBuffer(t.buffer);if(r){const{byteOffset:s,byteLength:a}=t,n=new Uint8Array(r,s||0,a);t.dbufferView=new Uint8Array(n).buffer}return t.dbufferView}parseBuffer(e){const t=this.gltf.buffers[e];if(!t)return this.errorMiss("buffer",e);if(t.isParsed)return t.dbuffer;if(t.isParsed=!0,t.dbuffer=!1,t.uri.substring(0,5)!=="data:"){const r=t.uri,s=this.gltf.resources[r];s?s.byteLength===t.byteLength?t.dbuffer=this.gltf.resources[r]:console.error(`load gltf resource "${r}" at buffers[${e} failed, ArrayBuffer.byteLength not equals buffer's byteLength]`):console.error(`load gltf resource "${r}" at buffers[${e}] failed`)}else{const r=t.uri.indexOf(this._BASE64_MARKER)+this._BASE64_MARKER.length,s=window.atob(t.uri.substring(r)),a=new Uint8Array(s.length);for(let n=0;n<s.length;n++)a[n]=s.charCodeAt(n);t.dbuffer=a.buffer}return t.dbuffer}getLight(e){return this.gltf.extensions.KHR_lights_punctual.lights[e]}applyNodeExtensions(e,t){let r=e.extensions;r.KHR_lights_punctual&&this.gltf.extensions.KHR_lights_punctual&&(t.light=this.getLight(r.KHR_lights_punctual.light))}}class du{constructor(){o(this,"magic"),o(this,"version"),o(this,"length")}}class gu{constructor(){o(this,"chunkLength"),o(this,"chunkType"),o(this,"chunkData")}}class qs extends Xt{constructor(){super(...arguments),o(this,"_gltf")}async parseBuffer(e){let t=new Uint8Array(e);t.pos=0;const r=this.parseHeader(t);if(r.magic!=1179937895)return console.error("invalid GLB file"),!1;if(r.version!==2)return console.error(`GLBParser only support glTF 2.0 for now! Received glTF version: ${r.version}`),!1;let s=[];for(;t.pos<t.length;){let f=this.parseChunk(t);s.push(f)}if(s[0].chunkType!=1313821514)return console.error("invalid GLBChunk"),!1;let a="",n=65535,l=s[0].chunkData;for(let f=0;f<l.length;f+=n){let d=l.length-f;d=Math.min(d,n);let p=l.subarray(f,f+d);a+=String.fromCharCode(...p)}let h=JSON.parse(a);this._gltf=new Ys,this._gltf={...this._gltf,...h},this._gltf.resources={};for(let f=0;f<this._gltf.buffers.length;f++){let d=this._gltf.buffers[f];d.isParsed=!0,d.dbuffer=s[f+1].chunkData.buffer}if(this._gltf.images)for(let f=0;f<this._gltf.images.length;f++){let d=this._gltf.images[f];d.name=d.name||"bufferView_"+d.bufferView.toString();const p=this._gltf.bufferViews[d.bufferView],m=this._gltf.buffers[p.buffer];let _=new Uint8Array(m.dbuffer,p.byteOffset,p.byteLength),v=new Blob([_],{type:d.mimeType}),y=new ii;await y.loadFromBlob(v),y.name=d.name,this._gltf.resources[d.name]=y}let c=await new js().parse(this.initUrl,this._gltf,this._gltf.scene);return c?(this.data=c.rootNode,c.rootNode):null}async parseJsonAndBuffer(e,t){this._gltf=new Ys,this._gltf={...this._gltf,...e},this._gltf.resources={};let r=this._gltf.buffers[0];if(r.isParsed=!0,r.dbuffer=t,this._gltf.images)for(let n=0;n<this._gltf.images.length;n++){let l=this._gltf.images[n];l.name=l.name||"bufferView_"+l.bufferView.toString();const h=this._gltf.bufferViews[l.bufferView],u=this._gltf.buffers[h.buffer];let c=new Uint8Array(u.dbuffer,h.byteOffset,h.byteLength),f=new Blob([c],{type:l.mimeType}),d=new ii;await d.loadFromBlob(f),d.name=l.name,this._gltf.resources[l.name]=d}let a=await new js().parse(this.initUrl,this._gltf,this._gltf.scene);return a?(this.data=a.rootNode,a.rootNode):null}verification(){if(this.data)return!0;throw new Error("Method not implemented.")}parseHeader(e){let t=e.pos,r=new du,s=new Uint32Array(e.buffer,t,3);return e.pos+=s.byteLength,r.magic=s[0],r.version=s[1],r.length=s[2],r}parseChunk(e){let t=e.pos,r=new gu,s=new Uint32Array(e.buffer,t,2);t=e.pos+=s.byteLength,r.chunkLength=s[0],r.chunkType=s[1],r.chunkData=new Uint8Array(e.buffer,t,r.chunkLength);const a=new Uint8Array(r.chunkLength);for(let n=0;n<r.chunkLength;n++)a[n]=r.chunkData[n];return r.chunkData=a,e.pos+=r.chunkLength,r}}o(qs,"format","bin");class as{constructor(e=0,t="\0"){o(this,"Type",0),o(this,"Line",0),o(this,"Colume",0),o(this,"Literal",""),this.Type=e,this.Literal=t}isTypeEqual(e){return this.Type==e}isLiteralEqual(e){return this.Literal==e}isBuiltinType(){return this.Type>33&&this.Type<101}isDataType(){return this.Type==1||this.isBuiltinType()}isOperation(){return this.Type>102&&this.Type<127}isAssignOperation(){return this.Type>128&&this.Type<133}get nOperationPriorityLevel(){switch(this.Type){case 26:return 1;case 27:return 1;case 125:return 2;case 110:return 3;case 114:return 3;case 105:return 4;case 106:return 4;case 103:return 5;case 104:return 5;case 115:return 6;case 116:return 6;case 119:return 7;case 120:return 7;case 122:return 7;case 123:return 7;case 121:return 8;case 124:return 8;case 111:return 9;case 113:return 10;case 112:return 11;case 107:return 12;case 109:return 13;case 108:return 14;case 24:return 15;case 126:return 16;case 129:return 16;case 130:return 16;case 131:return 16;case 132:return 16}return 99}}var x=(i=>(i[i.EOF=0]="EOF",i[i.IDENT=1]="IDENT",i[i.VOID=2]="VOID",i[i.CONST=3]="CONST",i[i.LAYOUT=4]="LAYOUT",i[i.PRECISION=5]="PRECISION",i[i.ATTRIBUTE=6]="ATTRIBUTE",i[i.UNIFORM=7]="UNIFORM",i[i.VARYING=8]="VARYING",i[i.INVARIANT=9]="INVARIANT",i[i.IN=10]="IN",i[i.OUT=11]="OUT",i[i.INOUT=12]="INOUT",i[i.IF=13]="IF",i[i.ELSE=14]="ELSE",i[i.FOR=15]="FOR",i[i.WHILE=16]="WHILE",i[i.DO=17]="DO",i[i.BREAK=18]="BREAK",i[i.RETURN=19]="RETURN",i[i.CONTINUE=20]="CONTINUE",i[i.STRUCT=21]="STRUCT",i[i.COMMA=22]="COMMA",i[i.COLON=23]="COLON",i[i.QUEMARK=24]="QUEMARK",i[i.SEMICOLON=25]="SEMICOLON",i[i.LEFTSAMLL=26]="LEFTSAMLL",i[i.RIGHTSAMLL=27]="RIGHTSAMLL",i[i.LEFTMEDI=28]="LEFTMEDI",i[i.RIGHTMEDI=29]="RIGHTMEDI",i[i.LEFTBIG=30]="LEFTBIG",i[i.RIGHTBIG=31]="RIGHTBIG",i[i.LITERAL=32]="LITERAL",i[i.BeginBuiltinType=33]="BeginBuiltinType",i[i.INT=34]="INT",i[i.INT_ARRAY=35]="INT_ARRAY",i[i.UINT=36]="UINT",i[i.UINT_ARRAY=37]="UINT_ARRAY",i[i.BOOL=38]="BOOL",i[i.BOOL_ARRAY=39]="BOOL_ARRAY",i[i.FLOAT=40]="FLOAT",i[i.FLOAT_ARRAY=41]="FLOAT_ARRAY",i[i.DOUBLE=42]="DOUBLE",i[i.DOUBLE_ARRAY=43]="DOUBLE_ARRAY",i[i.VEC2=44]="VEC2",i[i.VEC2_ARRAY=45]="VEC2_ARRAY",i[i.VEC3=46]="VEC3",i[i.VEC3_ARRAY=47]="VEC3_ARRAY",i[i.VEC4=48]="VEC4",i[i.VEC4_ARRAY=49]="VEC4_ARRAY",i[i.BVEC2=50]="BVEC2",i[i.BVEC2_ARRAY=51]="BVEC2_ARRAY",i[i.BVEC3=52]="BVEC3",i[i.BVEC3_ARRAY=53]="BVEC3_ARRAY",i[i.BVEC4=54]="BVEC4",i[i.BVEC4_ARRAY=55]="BVEC4_ARRAY",i[i.IVEC2=56]="IVEC2",i[i.IVEC2_ARRAY=57]="IVEC2_ARRAY",i[i.IVEC3=58]="IVEC3",i[i.IVEC3_ARRAY=59]="IVEC3_ARRAY",i[i.IVEC4=60]="IVEC4",i[i.IVEC4_ARRAY=61]="IVEC4_ARRAY",i[i.UVEC2=62]="UVEC2",i[i.UVEC2_ARRAY=63]="UVEC2_ARRAY",i[i.UVEC3=64]="UVEC3",i[i.UVEC3_ARRAY=65]="UVEC3_ARRAY",i[i.UVEC4=66]="UVEC4",i[i.UVEC4_ARRAY=67]="UVEC4_ARRAY",i[i.MAT2x2=68]="MAT2x2",i[i.MAT2x2_ARRAY=69]="MAT2x2_ARRAY",i[i.MAT2x3=70]="MAT2x3",i[i.MAT2x3_ARRAY=71]="MAT2x3_ARRAY",i[i.MAT2x4=72]="MAT2x4",i[i.MAT2x4_ARRAY=73]="MAT2x4_ARRAY",i[i.MAT3x2=74]="MAT3x2",i[i.MAT3x2_ARRAY=75]="MAT3x2_ARRAY",i[i.MAT3x3=76]="MAT3x3",i[i.MAT3x3_ARRAY=77]="MAT3x3_ARRAY",i[i.MAT3x4=78]="MAT3x4",i[i.MAT3x4_ARRAY=79]="MAT3x4_ARRAY",i[i.MAT4x2=80]="MAT4x2",i[i.MAT4x2_ARRAY=81]="MAT4x2_ARRAY",i[i.MAT4x3=82]="MAT4x3",i[i.MAT4x3_ARRAY=83]="MAT4x3_ARRAY",i[i.MAT4x4=84]="MAT4x4",i[i.MAT4x4_ARRAY=85]="MAT4x4_ARRAY",i[i.SAMPLER=86]="SAMPLER",i[i.SAMPLER_1D=87]="SAMPLER_1D",i[i.SAMPLER_2D=88]="SAMPLER_2D",i[i.SAMPLER_3D=89]="SAMPLER_3D",i[i.SAMPLER_CUBE=90]="SAMPLER_CUBE",i[i.SAMPLER_SHADOW=91]="SAMPLER_SHADOW",i[i.SAMPLER_1D_SHADOW=92]="SAMPLER_1D_SHADOW",i[i.SAMPLER_2D_SHADOW=93]="SAMPLER_2D_SHADOW",i[i.TEXTURE_1D=94]="TEXTURE_1D",i[i.TEXTURE_1D_ARRAY=95]="TEXTURE_1D_ARRAY",i[i.TEXTURE_2D=96]="TEXTURE_2D",i[i.TEXTURE_2D_ARRAY=97]="TEXTURE_2D_ARRAY",i[i.TEXTURE_3D=98]="TEXTURE_3D",i[i.TEXTURE_CUBE=99]="TEXTURE_CUBE",i[i.TEXTURE_CUBE_ARRAY=100]="TEXTURE_CUBE_ARRAY",i[i.EndBuiltinType=101]="EndBuiltinType",i[i.BeginOperation=102]="BeginOperation",i[i.ADD=103]="ADD",i[i.SUB=104]="SUB",i[i.MUL=105]="MUL",i[i.DIV=106]="DIV",i[i.AND=107]="AND",i[i.OR=108]="OR",i[i.XOR=109]="XOR",i[i.NOT=110]="NOT",i[i.BITAND=111]="BITAND",i[i.BITOR=112]="BITOR",i[i.BITXOR=113]="BITXOR",i[i.BITNOT=114]="BITNOT",i[i.BITSHIFT_L=115]="BITSHIFT_L",i[i.BITSHIFT_R=116]="BITSHIFT_R",i[i.INC=117]="INC",i[i.DEC=118]="DEC",i[i.GREATER=119]="GREATER",i[i.GREATEREQUAL=120]="GREATEREQUAL",i[i.EQUAL=121]="EQUAL",i[i.LESS=122]="LESS",i[i.LESSEQUAL=123]="LESSEQUAL",i[i.NOTEQUAL=124]="NOTEQUAL",i[i.DOT=125]="DOT",i[i.ASSIGN=126]="ASSIGN",i[i.EndOperation=127]="EndOperation",i[i.BeginAssignOperation=128]="BeginAssignOperation",i[i.ADDASSIGN=129]="ADDASSIGN",i[i.SUBASSIGN=130]="SUBASSIGN",i[i.MULASSIGN=131]="MULASSIGN",i[i.DIVASSIGN=132]="DIVASSIGN",i[i.EndAssignOperation=133]="EndAssignOperation",i))(x||{});class nr{constructor(e){o(this,"_char"),o(this,"_line"),o(this,"_column"),o(this,"_source"),o(this,"_currPosition"),o(this,"_nextPosition"),this.reset(e)}reset(e){this._char="",this._line=0,this._column=0,this._source=e,this._currPosition=0,this._nextPosition=0}get source(){return this._source}getChar(){return this._char}get currPosition(){return this._currPosition}peekChar(){return this._nextPosition>=this._source.length?"\0":this._source[this._nextPosition]}readChar(){this._char=this._nextPosition>=this._source.length?"\0":this._source[this._nextPosition],this._char!==`
`?this._column++:(this._line++,this._column=0),this._currPosition=this._nextPosition,this._nextPosition++}readCharAndSkipWhitespace(){this.readChar(),this.skipWhitespace()}readIdentifier(){for(var e=this._currPosition;this.isIdentifier(this._char);)this.readChar();return this._source.substring(e,this._currPosition)}isIdentifier(e){var t=e.charCodeAt(0);return 97<=t&&t<=122||65<=t&&t<=90||48<=t&&t<=57||t==95}skipWhitespace(){for(;this.IsWhitespace(this._char);)this.readChar()}IsWhitespace(e){return e===" "||e==="	"||e==="\r"||e===`
`}skipComment(){for(;this._char!==`
`&&this._char!=="\0";)this.readChar();this.skipWhitespace()}skipMultilineComment(){if(!(this._char!=="/"&&this.peekChar()!=="*")){this.readChar(),this.readChar();for(let e=1;e>0&&this._char!=="\0";)if(this.readChar(),this._char==="/"&&this.peekChar()==="*"){e++,this.readChar();continue}else if(this._char==="*"&&this.peekChar()==="/"){e--,this.readChar();continue}this.readChar(),this.readChar(),this.skipWhitespace()}}isDigit(e){var t=e.charCodeAt(0);return 48<=t&&t<=57}readNumber(){for(var e=this._currPosition;this.isDigit(this._char);)this.readChar();if(this._char===".")for(this.readChar();this.isDigit(this._char);)this.readChar();return this._source.substring(e,this._currPosition)}readValue(){return this.isDigit(this._char)?this.readNumber():this.readIdentifier()}readLine(){var e=this._currPosition,t=this._source.indexOf(`
`,this._currPosition);return t==-1&&(t=this._source.length),this._line++,this._column=0,this._currPosition=t,this._nextPosition=t+1,this._source.substring(e,t+1)}}class pu extends nr{constructor(e){super(e.source),o(this,"_tokenPosition",0),o(this,"_tokens",[]),this.parse()}skipToken(e){this._tokenPosition+=e}peekToken(e){return this._tokenPosition+e>=this._tokens.length?new as(x.EOF,"\0"):this._tokens[this._tokenPosition+e]}GetNextToken(){if(this._tokenPosition>=this._tokens.length)return new as(x.EOF,"\0");let e=this._tokens[this._tokenPosition];return this._tokenPosition++,e}get currTokenPosition(){return this._tokenPosition}parse(){this.readChar(),this._tokens=new Array;var e;do e=this.nextToken(),this._tokens.push(e);while(e.Type!=x.EOF)}nextToken(){if(this.skipWhitespace(),this._char==="/"){if(this.peekChar()==="/")return this.skipComment(),this.nextToken();if(this.peekChar()==="*")return this.skipMultilineComment(),this.nextToken()}var e=new as;switch(e.Line=this._line,e.Colume=this._column,this._char){case"\0":e.Type=x.EOF,e.Literal="EOF";break;case".":e.Type=x.DOT,e.Literal=".";break;case",":e.Type=x.COMMA,e.Literal=",";break;case":":e.Type=x.COLON,e.Literal=":";break;case"?":e.Type=x.QUEMARK,e.Literal="?";break;case";":e.Type=x.SEMICOLON,e.Literal=";";break;case"(":e.Type=x.LEFTSAMLL,e.Literal="(";break;case")":e.Type=x.RIGHTSAMLL,e.Literal=")";break;case"[":e.Type=x.LEFTMEDI,e.Literal="[";break;case"]":e.Type=x.RIGHTMEDI,e.Literal="]";break;case"{":e.Type=x.LEFTBIG,e.Literal="{";break;case"}":e.Type=x.RIGHTBIG,e.Literal="}";break;case"+":if(this.peekChar()==="+"){this.readChar(),e.Type=x.INC,e.Literal="++";break}else if(this.peekChar()==="="){this.readChar(),e.Type=x.ADDASSIGN,e.Literal="+=";break}e.Type=x.ADD,e.Literal="+";break;case"-":if(this.peekChar()==="-"){this.readChar(),e.Type=x.DEC,e.Literal="--";break}else if(this.peekChar()==="="){this.readChar(),e.Type=x.SUBASSIGN,e.Literal="-=";break}e.Type=x.SUB,e.Literal="-";break;case"*":if(this.peekChar()==="="){this.readChar(),e.Type=x.MULASSIGN,e.Literal="*=";break}e.Type=x.MUL,e.Literal="*";break;case"/":if(this.peekChar()==="="){this.readChar(),e.Type=x.DIVASSIGN,e.Literal="/=";break}e.Type=x.DIV,e.Literal="/";break;case"&":if(this.peekChar()==="&"){this.readChar(),e.Type=x.AND,e.Literal="&&";break}e.Type=x.BITAND,e.Literal="&";break;case"|":if(this.peekChar()==="|"){this.readChar(),e.Type=x.OR,e.Literal="||";break}e.Type=x.BITOR,e.Literal="&";break;case"^":e.Type=x.BITXOR,e.Literal="^";break;case"!":if(this.peekChar()==="="){this.readChar(),e.Type=x.NOTEQUAL,e.Literal="!=";break}e.Type=x.NOT,e.Literal="!";break;case">":if(this.peekChar()==="="){this.readChar(),e.Type=x.GREATEREQUAL,e.Literal=">=";break}else if(this.peekChar()===">"){this.readChar(),e.Type=x.BITSHIFT_R,e.Literal=">>";break}e.Type=x.GREATER,e.Literal=">";break;case"=":if(this.peekChar()==="="){this.readChar(),e.Type=x.EQUAL,e.Literal="==";break}e.Type=x.ASSIGN,e.Literal="=";break;case"<":if(this.peekChar()==="="){this.readChar(),e.Type=x.LESSEQUAL,e.Literal="<=";break}else if(this.peekChar()==="<"){this.readChar(),e.Type=x.BITSHIFT_L,e.Literal="<<";break}e.Type=x.LESS,e.Literal="<";break;default:return this.isDigit(this._char)?this.readDecimal():(e.Literal=this.readIdentifier(),e.Type=this.lookupIdentifier(e.Literal),this.getChar()=="["&&this.peekChar()=="]"&&e.isBuiltinType()&&(e.Type++,e.Literal+="[]",this.readChar(),this.readChar()),e)}return this.readChar(),e}readDecimal(){var e=new as;e.Line=this._line,e.Colume=this._column,e.Type=x.LITERAL;var t=this.readNumber();return this._char==="e"?(e.Literal=t+this._char,this.readChar(),e.Literal+=this._char,this.readChar(),e.Literal+=this.readNumber(),e.Type=x.LITERAL,e):this._char==="u"?(this.readChar(),e.Type=x.LITERAL,e.Literal=t+"u",e):this._char==="f"?(this.readChar(),e.Type=x.LITERAL,e.Literal=t+"f",e):(e.Type=x.LITERAL,e.Literal=t,e)}lookupIdentifier(e){switch(e){case"void":return x.VOID;case"int":return x.INT;case"uint":return x.UINT;case"bool":return x.BOOL;case"true":return x.BOOL;case"false":return x.BOOL;case"float":return x.FLOAT;case"vec2":return x.VEC2;case"vec3":return x.VEC3;case"vec4":return x.VEC4;case"bvec2":return x.BVEC2;case"bvec3":return x.BVEC3;case"bvec4":return x.BVEC4;case"ivec2":return x.IVEC2;case"ivec3":return x.IVEC3;case"ivec4":return x.IVEC4;case"uvec2":return x.UVEC2;case"uvec3":return x.UVEC3;case"uvec4":return x.UVEC4;case"mat2":return x.MAT2x2;case"mat2x2":return x.MAT2x2;case"mat2x3":return x.MAT2x3;case"mat2x4":return x.MAT2x4;case"mat3":return x.MAT3x3;case"mat3x2":return x.MAT3x2;case"mat3x3":return x.MAT3x3;case"mat3x4":return x.MAT3x4;case"mat4":return x.MAT4x4;case"mat4x2":return x.MAT4x2;case"mat4x3":return x.MAT4x3;case"mat4x4":return x.MAT4x4;case"sampler":return x.SAMPLER;case"sampler1D":return x.SAMPLER_1D;case"sampler2D":return x.SAMPLER_2D;case"sampler3D":return x.SAMPLER_3D;case"samplerCube":return x.SAMPLER_CUBE;case"samplerShadow":return x.SAMPLER_SHADOW;case"sampler1DShadow":return x.SAMPLER_1D_SHADOW;case"sampler2DShadow":return x.SAMPLER_2D_SHADOW;case"texture1D":return x.TEXTURE_1D;case"texture2D":return x.TEXTURE_2D;case"texture3D":return x.TEXTURE_3D;case"textureCube":return x.TEXTURE_CUBE;case"texture1DArray":return x.TEXTURE_1D_ARRAY;case"texture2DArray":return x.TEXTURE_2D_ARRAY;case"textureCubeArray":return x.TEXTURE_CUBE_ARRAY;case"const":return x.CONST;case"layout":return x.LAYOUT;case"precision":return x.PRECISION;case"attribute":return x.ATTRIBUTE;case"uniform":return x.UNIFORM;case"varying":return x.VARYING;case"invariant":return x.INVARIANT;case"in":return x.IN;case"out":return x.OUT;case"inout":return x.INOUT;case"if":return x.IF;case"else":return x.ELSE;case"for":return x.FOR;case"while":return x.WHILE;case"do":return x.DO;case"break":return x.BREAK;case"return":return x.RETURN;case"continue":return x.CONTINUE;case"struct":return x.STRUCT}return x.IDENT}}class Fg{constructor(){o(this,"name",""),o(this,"value",""),o(this,"args",[])}}class mu extends nr{constructor(e){super(e),o(this,"_result"),o(this,"_skipLine"),o(this,"_definitionTables"),this._result="",this._skipLine=!1,this._definitionTables=new Map,this.parse()}parse(){for(this.readChar();this._char!=="\0";){if(this.skipWhitespace(),this._char==="/"){if(this.peekChar()==="/"){this.skipComment();continue}if(this.peekChar()==="*"){this.skipMultilineComment();continue}}if(this._char==="#"){this.readCharAndSkipWhitespace();var e=this.readIdentifier();switch(e){case"version":this.readLine().trim();break;case"define":this.readCharAndSkipWhitespace();var t=this.readIdentifier();if(this.getChar()==="("){let l=new Fg;if(this.readCharAndSkipWhitespace(),this.getChar()!==")")do{var r=this.readIdentifier();if(l.args.push(r),this.skipWhitespace(),this.getChar()===","){this.readCharAndSkipWhitespace();continue}}while(this.getChar()!==")");this.readCharAndSkipWhitespace(),l.name=t,l.value=this.readLine().trim(),this._definitionTables.set(t,l),this.readCharAndSkipWhitespace()}else{let l=this.readLine().trim();l[0]=="="&&(l=l.substring(1)),this._definitionTables.set(t,l)}break;case"if":let n=this.readLine().trim();if(n=="0"||n=="false"){this._skipLine=!0;break}if(this._definitionTables.has(n)&&(n=this._definitionTables.get(n),n=="0"||n=="false")){this._skipLine=!0;break}break;case"ifdef":this.readCharAndSkipWhitespace();var s=this.readIdentifier();this._skipLine=!this._definitionTables.has(s);break;case"else":this._skipLine=!this._skipLine;break;case"endif":this._skipLine=!1;break;default:throw"Unknown preprocessing command:"+e}}else{var a=this.readLine();if(!this._skipLine){for(let n of this._definitionTables.keys()){let l=a.indexOf(n);if(l!=-1){let h=this._definitionTables.get(n);if(typeof h=="string")a=a.replace(n,h);else{let u=h,c=new nr(a.substring(l+n.length));if(c.readCharAndSkipWhitespace(),c.getChar()==="("){c.readCharAndSkipWhitespace();for(let m=1;c.getChar()!=="\0"&&m>0;){switch(c.getChar()){case"(":m++;break;case")":m--;break}c.readCharAndSkipWhitespace()}}let f=l,d=f+n.length+c.currPosition,p=a.substring(f,d).trim();if(u.args.length>0){let m=[],_=p.substring(p.indexOf("(")+1,p.lastIndexOf(")")).trim();_.length>0&&(m=this.parseArgs(_));let v=u.value.substring(u.value.indexOf("("));for(let y=0;y<u.args.length;y++)v=v.replace(u.args[y],m[y]);v=u.value.substring(0,u.value.indexOf("("))+v,a=a.replace(p,v)}else a=a.replace(p,u.value)}}}this._result+=a}this.readChar()}}}get source(){return this._result}parseArgs(e){let t=[],r=0,s=new nr(e),a=s.currPosition;if(s.readCharAndSkipWhitespace(),s.getChar()!=="\0")for(s.readCharAndSkipWhitespace();s.getChar()!=="\0";){switch(s.getChar()){case"(":r++;break;case")":r--;break;case",":if(r==0){let n=e.substring(a,s.currPosition);t.push(n),a=s.currPosition+1}break}s.readCharAndSkipWhitespace()}if(a<s.currPosition){let n=e.substring(a,s.currPosition);t.push(n)}return t}}class Au{constructor(e){o(this,"result"),o(this,"ASTRoot"),o(this,"_syntax"),this.result="",this._syntax=e,this.ASTRoot=e.ASTRoot}generateWGSL(){let e=new Uo;var t=new yu;let r=[],s=[],a=[];for(let c of this.ASTRoot.nodes)if(c instanceof vs)if(c.scope=="in")if(c.nodes[0]instanceof Te){e.layoutsIn.push(c);let f=new No;f.name=c.nodes[0].name,f.type=c.nodes[0].type,f.locationID=Number.parseInt(c.qualifier.get("location")),t.inputAttribute.push(f)}else if(c.qualifier.has("local_size_x"))e.workGroupSize=c;else throw"not impl";else if(c.scope=="out")if(e.layoutsOut.push(c),c.nodes[0]instanceof Te){let f=new No;f.name=c.nodes[0].name,f.type=c.nodes[0].type,f.locationID=Number.parseInt(c.qualifier.get("location")),t.outputAttribute.push(f)}else throw"not impl";else if(c.scope=="uniform")if(s.push(c),c.nodes[0]instanceof Te){let f=new Oo;f.name=c.nodes[0].name,f.type=c.nodes[0].type,f.setID=Number.parseInt(c.qualifier.get("set")),f.bindingID=Number.parseInt(c.qualifier.get("binding")),t.uniformInfo.push(f)}else if(c.nodes[0]instanceof oi){let f=new Oo;f.name="unif"+t.uniformInfo.length.toString(),f.type=c.nodes[0].name,f.setID=Number.parseInt(c.qualifier.get("set")),f.bindingID=Number.parseInt(c.qualifier.get("binding")),t.uniformInfo.push(f)}else throw"not impl";else c.scope=="buffer"&&r.push(c);else a.push(c);e.stage="fragment";let n=0,l=new nr(""),h=this._syntax.lexer.source,u=new Map;for(;(n=h.indexOf("gl_",n))!=-1;){l.reset(h.substring(n,n+32)),l.readChar();let c=l.readIdentifier();if(n+=c.length,!u.has(c))switch(u.set(c,c),c){case"gl_InstanceID":e.stage="vertex",e.builtinIn.push("@builtin(instance_index) gl_InstanceID: u32");break;case"gl_Position":e.stage="vertex",e.builtinOut.push("@builtin(position) gl_Position: vec4<f32>"),e.addIdentifier("gl_Position","stout.gl_Position");break;case"gl_VertexIndex":e.stage="vertex",e.builtinIn.push("@builtin(vertex_index) gl_VertexIndex: u32");break;case"gl_FrontFacing":e.stage="fragment",e.builtinIn.push("@builtin(front_facing) gl_FrontFacing: bool");break;case"gl_FragDepth":e.stage="fragment",e.builtinOut.push("@builtin(frag_depth) gl_FragDepth: f32"),e.addIdentifier("gl_FragDepth","stout.gl_FragDepth");break;case"gl_WorkGroupID":e.stage="compute",e.builtinIn.push("@builtin(workgroup_id) gl_WorkGroupID: vec3<u32>");break;case"gl_NumWorkGroups":e.stage="compute",e.builtinIn.push("@builtin(num_workgroups) gl_NumWorkGroups: vec3<u32>");break;case"gl_LocalInvocationID":e.stage="compute",e.builtinIn.push("@builtin(local_invocation_id) gl_LocalInvocationID: vec3<u32>");break;case"gl_LocalInvocationIndex":e.stage="compute",e.builtinIn.push("@builtin(local_invocation_index) gl_LocalInvocationIndex: u32");break;case"gl_GlobalInvocationID":e.stage="compute",e.builtinIn.push("@builtin(global_invocation_id) gl_GlobalInvocationID: vec3<u32>");break;default:throw"Unprocessed built-in variables: "+c}}for(let c of s)c.nodes[0]instanceof oi&&(t.sourceCode+=c.nodes[0].formatToWGSL(e,0),t.sourceCode+=`\r
`);for(let c of s)t.sourceCode+=c.formatToWGSL(e,0);t.sourceCode+=`\r
`;for(let c of r)c.nodes[0]instanceof oi&&(t.sourceCode+=c.nodes[0].formatToWGSL(e,0),t.sourceCode+=`\r
`);for(let c of r)t.sourceCode+=c.formatToWGSL(e,0);t.sourceCode+=`\r
`;for(let c of a)t.sourceCode+=c.formatToWGSL(e,0),c instanceof Te&&(t.sourceCode+=`;\r
`);return t}}class Uo{constructor(e){o(this,"_stage","fragment"),o(this,"_builtinIn",[]),o(this,"_builtinOut",[]),o(this,"_layoutsIn",[]),o(this,"_layoutsOut",[]),o(this,"_layoutUniformCount",0),o(this,"_workGroupSize"),o(this,"_parentContext"),o(this,"_identifierEnv",new Map),this._parentContext=e}get stage(){return this.parentContext!=null?this.parentContext.stage:this._stage}set stage(e){this.parentContext!=null&&(this.parentContext.stage=e),this._stage=e}get builtinIn(){return this.parentContext!=null?this.parentContext.builtinIn:this._builtinIn}get builtinOut(){return this.parentContext!=null?this.parentContext.builtinOut:this._builtinOut}get layoutsIn(){return this.parentContext!=null?this.parentContext.layoutsIn:this._layoutsIn}get layoutsOut(){return this.parentContext!=null?this.parentContext.layoutsOut:this._layoutsOut}get layoutUniformCount(){return this.parentContext!=null?this.parentContext.layoutUniformCount:this._layoutUniformCount}set layoutUniformCount(e){if(this.parentContext!=null){this.parentContext.layoutUniformCount=e;return}this._layoutUniformCount=e}get workGroupSize(){return this.parentContext!=null?this.parentContext.workGroupSize:this._workGroupSize}set workGroupSize(e){this.parentContext!=null&&(this.parentContext.workGroupSize=e),this._workGroupSize=e}get parentContext(){return this._parentContext}findIdentifier(e){return this._identifierEnv.has(e)?this._identifierEnv.get(e):this._parentContext!=null?this._parentContext.findIdentifier(e):e}addIdentifier(e,t){this._identifierEnv.set(e,t)}hasIdentifier(e){return this._identifierEnv.has(e)}}class me{constructor(){o(this,"nodes",[])}addNode(e){this.nodes.push(e)}formatToWGSL(e,t){return""}}class oi extends me{constructor(e){super(),o(this,"name",""),o(this,"fields",[]),this.name=e}static parse(e){if(e.peekToken(0).Type==x.IDENT&&e.peekToken(1).Type==x.LEFTBIG){let t=new oi(e.peekToken(0).Literal);for(e.skipToken(2);e.peekToken(0).Type!=x.RIGHTBIG;){let r=Te.parse(e);t.fields.push(r)}return e.peekToken(0).Type==x.RIGHTBIG&&e.skipToken(1),e.peekToken(0).Type==x.SEMICOLON&&e.skipToken(1),t}throw"Error parsing structure: Unexpected character"}formatToWGSL(e,t){let r="",s=t<=0?"":"    ".repeat(t);r+=s+"struct "+this.name+` {\r
`;for(let a of this.fields)a.arraySize.nodes.length<=0?r+=s+"  "+a.name+": "+St(a.type)+`,\r
`:a.arraySize.nodes[0]instanceof ni?r+=s+"  "+a.name+": array<"+St(a.type)+", "+a.arraySize.nodes[0].value+`>,\r
`:r+=s+"  "+a.name+": array<"+St(a.type)+", "+a.arraySize.nodes[0].formatToWGSL(e,0)+`>,\r
`;return r+=s+`};\r
`,r}}class _a extends me{constructor(e,t,r,s){super(),o(this,"name"),o(this,"args"),o(this,"body"),o(this,"returnType"),this.name=e,this.args=t,this.body=r,this.returnType=s}static parse(e){if((e.peekToken(0).isBuiltinType()||e.peekToken(0).Type==x.VOID)&&e.peekToken(1).Type==x.IDENT&&e.peekToken(2).Type==x.LEFTSAMLL){let t=e.peekToken(0).Literal,r=e.peekToken(1).Literal;e.skipToken(2);let s=new Array;if(e.peekToken(0).Type!=x.LEFTSAMLL)throw"Error parsing function parameter list: Unexpected character";for(e.skipToken(1);e.peekToken(0).Type!=x.EOF;){if(e.peekToken(0).Type==x.RIGHTSAMLL){e.skipToken(1);break}(e.peekToken(0).Type==x.INOUT||e.peekToken(0).Type==x.IN||e.peekToken(0).Type==x.OUT)&&e.skipToken(1);let n=Te.parse(e);s.push(n),e.peekToken(0).Type==x.COMMA&&e.skipToken(1)}let a=Gt.parse(e);return new _a(r,s,a,t)}throw"Error parsing function: Unexpected character"}formatToWGSL(e,t){let r="",s=t<=0?"":"    ".repeat(t),a,n=e.layoutsOut.length>0||e.builtinOut.length>0;switch(e.stage){case"compute":a="ComputeOutput";break;case"vertex":a="VertexOutput";break;case"fragment":a="FragmentOutput";break;default:a="StructOutput";break}if(this.name=="main"&&n){r+="struct "+a+` {\r
`;for(let c of e.layoutsOut)if(c.nodes[0]instanceof Te){let f=c.nodes[0];c.qualifier.size==1&&c.qualifier.has("location")&&(r+="  @location("+c.qualifier.get("location")+") "),r+=f.name+": "+St(f.type)+`,\r
`,e.addIdentifier(f.name,"stout."+f.name)}let u=e.builtinOut;for(let c of u)r+="  "+c+`,\r
`;r+=`};\r
\r
`}let l="";if(this.name=="main"&&(e.workGroupSize!=null?l+="@"+e.stage+" "+e.workGroupSize.formatToWGSL(e,0)+` \r
`:l+="@"+e.stage+`\r
`),e=new Uo(e),l+=s+"fn "+this.name+"(",this.name!="main"){for(let u=0;u<this.args.length;u++){let c=this.args[u];u>0&&(l+=", "),l+=c.name+": "+St(c.type),e.addIdentifier(c.name,c.name)}l+=") -> "+St(this.returnType)}else{let u=e.layoutsIn;for(let f=0;f<u.length;f++){let d=u[f];if(f>0?l+=`,\r
    `:l+=`\r
    `,d.nodes[0]instanceof Te){let p=d.nodes[0];d.qualifier.size==1&&d.qualifier.has("location")&&(l+="@location("+d.qualifier.get("location")+") "),l+=p.name+": "+St(p.type),e.addIdentifier(p.name,p.name)}}u.length>0&&(l+=`,\r
    `);let c=e.builtinIn;for(let f of c)l+=f+`,\r
    `;n?l+=") -> "+a:l+=") "}let h="";this.name=="main"&&n&&(h+="    var stout: "+a+` ;\r
`);for(let u of this.body.nodes)h+=u.formatToWGSL(e,t+1),!(u instanceof Gi)&&!(u instanceof Xi)&&!(u instanceof Yi)&&(h+=`;\r
`);return this.name=="main"&&n&&(h+=`    return stout;\r
`),r+=l+` {\r
`,r+=h,r+=s+`}\r
`,r+=`\r
`,r}}class xa extends me{constructor(){super(),o(this,"args",[])}static parse(e){if(e.peekToken(0).Type==x.LEFTSAMLL){e.skipToken(1);let t=new xa;for(;e.peekToken(0).Type!=x.EOF;){if(e.peekToken(0).Type==x.RIGHTSAMLL){e.skipToken(1);break}let r=ie.parse(e);t.args.push(r),e.peekToken(0).Type==x.COMMA&&e.skipToken(1)}return t}throw"Error parsing function argument table: Unexpected character"}}class Hi extends me{constructor(e,t){super(),o(this,"name"),o(this,"args"),this.name=e,this.args=t}static parse(e){if(e.peekToken(0).isDataType()&&e.peekToken(1).Type==x.LEFTSAMLL){let t=e.peekToken(0).Literal;e.skipToken(1);let r=xa.parse(e);return new Hi(t,r)}throw"Error parsing function argument table: Unexpected character"}formatToWGSL(e,t){let r="",s=t<=0?"":"    ".repeat(t);if(this.name=="texture"&&this.args.args[0].nodes[0]instanceof Hi){let a=this.args.args[0].nodes[0];if(a.name=="sampler2D"){r+=s+"textureSample(";for(let n=0;n<a.args.args.length;n++){let l=a.args.args[n];n>0&&(r+=", "),r+=l.formatToWGSL(e,0)}for(let n=1;n<this.args.args.length;n++){let l=this.args.args[n];n>0&&(r+=", "),r+=l.formatToWGSL(e,0)}return r+=")",r}}r+=s+St(this.name)+"(";for(let a=0;a<this.args.args.length;a++){let n=this.args.args[a];a>0&&(r+=", "),r+=n.formatToWGSL(e,0)}return r+=")",r}}class Te extends me{constructor(e,t,r=new ie){super(),o(this,"type"),o(this,"name"),o(this,"arraySize"),o(this,"hasIn"),o(this,"hasOut"),o(this,"hasConst"),this.type=e,this.name=t,this.hasIn=!1,this.hasOut=!1,this.hasConst=!1,this.arraySize=r}static parse(e){let t=new Te("",""),r=e.peekToken(0);if(r.Type==x.CONST)e.skipToken(1),t.hasConst=!0;else if(r.Type==x.IN)e.skipToken(1),t.hasIn=!0;else if(r.Type==x.OUT)e.skipToken(1),t.hasOut=!0;else if(r.Type==x.INOUT)e.skipToken(1),t.hasIn=!0,t.hasOut=!0;else if(!r.isDataType())throw"Error parsing declaration expression: Unexpected character("+r.Literal+")";if(r=e.peekToken(0),r.isDataType()&&e.peekToken(1).Type==x.LEFTMEDI){if(t.type=r.Literal,e.skipToken(2),t.arraySize=ie.parse(e),e.peekToken(0).Type==x.RIGHTMEDI&&e.skipToken(1),e.peekToken(0).Type!=x.IDENT)throw"Unexpected";t.name=e.peekToken(0).Literal,e.skipToken(1)}else if(r.isDataType()&&e.peekToken(1).Type==x.IDENT&&e.peekToken(2).Type==x.LEFTMEDI)t.type=e.peekToken(0).Literal,t.name=e.peekToken(1).Literal,e.skipToken(3),e.peekToken(0).Type==x.RIGHTMEDI?e.skipToken(1):(t.arraySize=ie.parse(e),e.peekToken(0).Type==x.RIGHTMEDI&&e.skipToken(1));else if(r.isDataType()&&e.peekToken(1).Type==x.IDENT)t.type=e.peekToken(0).Literal,t.name=e.peekToken(1).Literal,e.skipToken(2);else throw"Error parsing declaration expression: Unexpected character("+r.Literal+")";if(r=e.peekToken(0),r.Type==x.SEMICOLON)return e.skipToken(1),t;if(r.Type==x.RIGHTSAMLL)return t;if(r.Type==x.ASSIGN){let s=e.peekToken(0);e.skipToken(1);let a=new ri(t.name),n=ie.parse(e);return e.peekToken(0).Type==x.SEMICOLON&&e.skipToken(1),t.addNode(new Ai(s,a,n)),t}else if(r.Type==x.COMMA){for(;e.peekToken(0).Type==x.COMMA&&e.peekToken(1).Type==x.IDENT;){let s=new Te(t.type,e.peekToken(1).Literal);t.addNode(s),e.skipToken(2),e.peekToken(0).Type==x.ASSIGN&&(e.skipToken(-1),s.addNode(ie.parse(e)))}return t}throw"Error parsing declaration expression: Unexpected character("+e.peekToken(0).Literal+")"}formatToWGSL(e,t){let r="",s=t<=0?"":"    ".repeat(t);if(this.hasConst?r+=s+"let ":r+=s+"var ",e.addIdentifier(this.name,this.name),this.arraySize.nodes.length<=0?r+=this.name+": "+St(this.type):this.arraySize.nodes[0]instanceof ni?r+=this.name+": array<"+St(this.type)+", "+this.arraySize.nodes[0].value+">":r+=this.name+": array<"+St(this.type)+", "+this.arraySize.nodes[0].formatToWGSL(e,0)+">",this.nodes.length>0&&this.nodes[0]instanceof Ai)r+=" = "+this.nodes[0].rightValue.formatToWGSL(e,0);else if(this.nodes.length>0&&this.nodes[0]instanceof ie&&this.nodes[0].nodes[0]instanceof Ai)r+=" = "+this.nodes[0].nodes[0].rightValue.formatToWGSL(e,0);else if(this.nodes.length>0&&this.nodes[0]instanceof Te){r+=`;\r
`;for(let a of this.nodes)r+=a.formatToWGSL(e,t)+`;\r
`}else r+=`;\r
`;return r}}class Yi extends me{constructor(e,t,r,s){super(),o(this,"expression1"),o(this,"condition"),o(this,"expression2"),o(this,"loopBody"),this.expression1=e,this.condition=t,this.expression2=r,this.loopBody=s}static parse(e){if(e.peekToken(0).Type==x.FOR&&e.peekToken(1).Type==x.LEFTSAMLL){e.skipToken(2);let t;e.peekToken(0).Type==x.SEMICOLON?(e.skipToken(1),t=new ie):e.peekToken(0).isDataType()&&e.peekToken(1).Type==x.IDENT&&e.peekToken(2).Type==x.ASSIGN?(t=new Te(e.peekToken(0).Literal,e.peekToken(1).Literal),e.skipToken(1),t.addNode(ie.parse(e)),e.peekToken(0).Type==x.SEMICOLON&&e.skipToken(1)):(t=ie.parse(e),e.peekToken(0).Type==x.SEMICOLON&&e.skipToken(1));let r;e.peekToken(0).Type==x.SEMICOLON?(e.skipToken(1),r=new ie):(r=ie.parse(e),e.peekToken(0).Type==x.SEMICOLON&&e.skipToken(1));let s;e.peekToken(0).Type==x.SEMICOLON?(e.skipToken(1),s=new ie):(s=ie.parse(e),e.peekToken(0).Type==x.SEMICOLON&&e.skipToken(1)),e.peekToken(0).Type==x.RIGHTSAMLL&&e.skipToken(1);let a;return e.peekToken(0).Type==x.LEFTBIG?a=Gt.parse(e):a=new Gt,new Yi(t,r,s,a)}throw"Error parsing for loop: Unexpected character"}formatToWGSL(e,t){let r="",s=t<=0?"":"    ".repeat(t);r+=s+"for (",r+=this.expression1.formatToWGSL(e,0)+"; ",r+=this.condition.formatToWGSL(e,0)+"; ",r+=this.expression2.formatToWGSL(e,0)+")",r+=` { \r
`;for(let a of this.loopBody.nodes)r+=a.formatToWGSL(e,t+1),!(a instanceof Gi)&&!(a instanceof Xi)&&!(a instanceof Yi)&&(r+=`;\r
`);return r+=s+`} \r
`,r}}class Xi extends me{constructor(e,t){super(),o(this,"conditionExpr"),o(this,"loopBody"),this.conditionExpr=e,this.loopBody=t}static parse(e){if(e.peekToken(0).Type==x.WHILE){e.skipToken(1),e.peekToken(0).Type==x.LEFTSAMLL&&e.skipToken(1);let t=ie.parse(e);e.peekToken(0).Type==x.RIGHTSAMLL&&e.skipToken(1);let r=Gt.parse(e);return new Xi(t,r)}throw"Error parsing while loop: Unexpected character"}formatToWGSL(e,t){let r="",s=t<=0?"":"    ".repeat(t);r+=s+`loop {\r
`,r+=s+"    if ("+this.conditionExpr.formatToWGSL(e,0)+`) { break; }\r
\r
`;for(let a of this.loopBody.nodes)r+=a.formatToWGSL(e,t+1),!(a instanceof Gi)&&!(a instanceof Xi)&&!(a instanceof Yi)&&(r+=`;\r
`);return r+=s+`}\r
`,r}}class kg extends me{constructor(){super()}}class Gi extends me{constructor(e,t,r){super(),o(this,"conditionExpr"),o(this,"trueBranch"),o(this,"falseBranch"),this.conditionExpr=e,this.trueBranch=t,this.falseBranch=r}static parse(e){if(e.peekToken(0).Type==x.IF){e.skipToken(1),e.peekToken(0).Type==x.LEFTSAMLL&&e.skipToken(1);let t=ie.parse(e),r,s=new Gt;if(e.peekToken(0).Type==x.RIGHTSAMLL&&e.skipToken(1),e.peekToken(0).Type==x.LEFTBIG?r=Gt.parse(e):(r=new Gt,e.peekToken(0).Type==x.RETURN?r.addNode(_s.parse(e)):r.addNode(ie.parse(e))),e.peekToken(0).Type==x.ELSE)if(e.skipToken(1),e.peekToken(0).Type==x.LEFTBIG)s=Gt.parse(e);else throw"not impl";return new Gi(t,r,s)}throw"Error parsing IF branch statement: Unexpected character"}formatToWGSL(e,t){let r="",s=t<=0?"":"    ".repeat(t);r+=s+"if ("+this.conditionExpr.formatToWGSL(e,0)+`) {\r
`;for(let a of this.trueBranch.nodes)r+=a.formatToWGSL(e,t+1)+`;\r
`;if(this.falseBranch.nodes.length>0){r+=s+`} else {\r
`;for(let a of this.falseBranch.nodes)r+=a.formatToWGSL(e,t+1)+`;\r
`}return r+=s+`}\r
`,r}}class ie extends me{constructor(){super()}static parse(e){let t=new Array,r=new Array,s=0;for(;e.peekToken(0).Type!=x.EOF;){let a=e.peekToken(0);if(a.Type==x.SEMICOLON||a.Type==x.RIGHTMEDI||a.Type==x.COMMA||a.Type==x.COLON||a.Type==x.RIGHTBIG)break;if(a.isOperation()){if(a.isOperation()){if(a.Type==x.INC||a.Type==x.DEC){let n=a;e.skipToken(1);let l=ie.parse(e);r.push(new lr(n,void 0,l));continue}else if(t.length>0){if(t[t.length-1].nOperationPriorityLevel<=a.nOperationPriorityLevel)ie.unionOperation(t,r);else if(t.length>0&&t[t.length-1].Literal=="-"){let l=t.pop(),h=r.pop();r.push(new lr(l,void 0,h))}}t.push(a),e.skipToken(1)}}else if(a.Type==x.LITERAL){r.push(new ni(a.Literal)),e.skipToken(1);continue}else if(a.Type==x.LEFTSAMLL){s++,t.push(a),e.skipToken(1);continue}else if(a.Type==x.RIGHTSAMLL){if(s<=0)break;for(s--;ie.unionOperation(t,r););if(t[t.length-1].Type==x.LEFTSAMLL){t.pop();let n=new _u;n.addNode(r.pop()),r.push(n)}e.skipToken(1);continue}else if(a.Type==x.IDENT){if(e.peekToken(1).Type==x.INC||e.peekToken(1).Type==x.DEC){let n=e.peekToken(1),l=new ri(a.Literal);r.push(new lr(n,l,void 0)),e.skipToken(2);continue}else if(e.peekToken(1).Type==x.LEFTSAMLL){r.push(Hi.parse(e));continue}else if(e.peekToken(1).Type==x.DOT){r.push(xs.parse(e));continue}else if(e.peekToken(1).Type==x.LEFTMEDI){r.push(Wi.parse(e));continue}r.push(new ri(a.Literal)),e.skipToken(1);continue}else{if(a.isBuiltinType()&&e.peekToken(1).Type==x.LEFTSAMLL){r.push(Hi.parse(e));continue}if(a.isAssignOperation()){let n=a;e.skipToken(1);let l=r.pop(),h=ie.parse(e);r.push(new Ai(n,l,h));continue}if(a.Type==x.LEFTBIG&&(e.peekToken(1).Type==x.LITERAL||e.peekToken(1).Type==x.SUB&&e.peekToken(2).Type==x.LITERAL)){r.push(Is.parse(e));continue}if(a.Type==x.QUEMARK){t.length>0&&t[t.length-1].nOperationPriorityLevel<=a.nOperationPriorityLevel&&ie.unionOperation(t,r),e.skipToken(1);let n=r.pop(),l=ie.parse(e);e.peekToken(0).Type==x.COLON&&e.skipToken(1);let h=ie.parse(e);if(r.push(new xu(n,l,h)),e.peekToken(-1).Type==x.SEMICOLON)break;continue}if(a.Type==x.LEFTMEDI){e.skipToken(1);let n=ie.parse(e);e.peekToken(0).Type==x.RIGHTMEDI&&e.skipToken(1);let l=r.pop();r.push(new Wi(l,n));continue}throw"An unexpected character"}}for(;t.length>0&&ie.unionOperation(t,r););if(t.length<=0&&r.length==1){let a=new ie;return a.addNode(r.pop()),a}throw"Error parsing expression: Unexpected character("+e.peekToken(0).Literal+")"}formatToWGSL(e,t){return this.nodes[0].formatToWGSL(e,t)}static unionOperation(e,t){if(e.length<0||t.length<2){if(e.length>0&&e[e.length-1].Literal=="-"){let r=e.pop(),s=t.pop();return t.push(new lr(r,void 0,s)),!0}return!1}if(e[e.length-1].isOperation()){let r=t.pop(),s=e.pop(),a=t.pop();return s.Type==x.DOT?t.push(new xs(a,r)):t.push(new Ai(s,a,r)),!0}return!1}}class _u extends me{constructor(){super()}formatToWGSL(e,t){return(t<=0?"":"    ".repeat(t))+"("+this.nodes[0].formatToWGSL(e,0)+")"}}class ri extends me{constructor(e){super(),o(this,"name"),this.name=e}formatToWGSL(e,t){return(t<=0?"":"    ".repeat(t))+e.findIdentifier(this.name)}}class ni extends me{constructor(e){super(),o(this,"value"),this.value=e}static parse(e){let t=e.peekToken(0);if(t.Type==x.SUB&&e.peekToken(1).Type==x.LITERAL){let r=new ni("-"+e.peekToken(1).Literal);return e.skipToken(2),r}else if(t.Type==x.LITERAL){let r=new ni(t.Literal);return e.skipToken(1),r}throw"Error parsing literal constants: Unexpected characters("+t.Literal+")"}formatToWGSL(e,t){return(t<=0?"":"    ".repeat(t))+this.value}}class Is extends ni{constructor(e){super(""),o(this,"arrayValue"),this.arrayValue=e}static parse(e){if(e.peekToken(0).Type==x.LEFTBIG&&e.peekToken(1).Type==x.LITERAL||e.peekToken(0).Type==x.LEFTBIG&&e.peekToken(1).Type==x.SUB&&e.peekToken(2).Type==x.LITERAL){e.skipToken(1);let t=[];for(;e.peekToken(0).Type!=x.RIGHTBIG;){if(e.peekToken(0).Type==x.LEFTSAMLL){t.push(Is.parse(e));continue}if(t.push(ni.parse(e)),e.peekToken(0).Type==x.COMMA){e.skipToken(1);continue}else if(e.peekToken(0).Type==x.RIGHTBIG){e.skipToken(1);break}else throw"Error parsing array constants: Unexpected characters"}return new Is(t)}throw"Error parsing array constants: Unexpected characters"}formatToWGSL(e,t){let r="",s=t<=0?"":"    ".repeat(t);this.arrayValue[0].value.includes(".")?r+=s+"array<f32, "+this.arrayValue.length.toString()+">(":r+=s+"array<i32, "+this.arrayValue.length.toString()+">(";for(let a=0;a<this.arrayValue.length;a++)a>0&&(r+=", "),r+=this.arrayValue[a].formatToWGSL(e,0);return r+=")",r}}class zg extends me{constructor(){super()}}class Gg extends me{constructor(){super()}}class va extends me{constructor(){super()}static parse(e){if(e.peekToken(0).Type==x.CONTINUE&&e.peekToken(1).Type==x.SEMICOLON)return e.skipToken(2),new va;throw"Error parsing continue: Unexpected character"}formatToWGSL(e,t){let r="",s=t<=0?"":"    ".repeat(t);return r+=s+"continue",r}}class _s extends me{constructor(e){super(),o(this,"value"),this.value=e}static parse(e){if(e.peekToken(0).Type==x.RETURN){e.skipToken(1);let t=ie.parse(e);return e.peekToken(0).Type==x.SEMICOLON&&e.skipToken(1),new _s(t)}throw"Error parsing return expression: Unexpected character"}formatToWGSL(e,t){let r="",s=t<=0?"":"    ".repeat(t);return r+=s+"return "+this.value.formatToWGSL(e,0),r}}class lr extends me{constructor(e,t,r){super(),o(this,"op"),o(this,"leftValue"),o(this,"rightValue"),this.op=e,this.leftValue=t,this.rightValue=r}formatToWGSL(e,t){let r="",s=t<=0?"":"    ".repeat(t);if(this.op.Literal=="++"||this.op.Literal=="--")if(this.leftValue!=null){let a=this.leftValue.formatToWGSL(e,0);r+=s+a+" = "+a+" "+this.op.Literal[0]+" 1"}else{let a=this.rightValue.formatToWGSL(e,0);r+=s+a+" = "+a+" "+this.op.Literal[0]+" 1"}else this.leftValue!=null?r+=s+this.leftValue.formatToWGSL(e,0)+this.op.Literal:r+=s+this.op.Literal+this.rightValue.formatToWGSL(e,0);return r}}class Ai extends me{constructor(e,t,r){super(),o(this,"op"),o(this,"leftValue"),o(this,"rightValue"),this.op=e,this.leftValue=t,this.rightValue=r}formatToWGSL(e,t){let r="",s=t<=0?"":"    ".repeat(t);return r+=s+this.leftValue.formatToWGSL(e,0)+" "+this.op.Literal+" "+this.rightValue.formatToWGSL(e,0),r}}class xu extends me{constructor(e,t,r){super(),o(this,"condition"),o(this,"expression1"),o(this,"expression2"),this.condition=e,this.expression1=t,this.expression2=r}static parse(e){throw"Error parsing ternary operation expression: Unexpected character"}formatToWGSL(e,t){return""}}class xs extends me{constructor(e,t){super(),o(this,"leftValue"),o(this,"rightValue"),this.leftValue=e,this.rightValue=t}static parse(e){if(e.peekToken(0).Type==x.IDENT&&e.peekToken(1).Type==x.DOT&&e.peekToken(2).Type==x.IDENT){let t=new ri(e.peekToken(0).Literal),r=new ri(e.peekToken(2).Literal);return e.skipToken(3),new xs(t,r)}throw"Error parsing selection expression: Unexpected character"}formatToWGSL(e,t){return(t<=0?"":"    ".repeat(t))+this.leftValue.formatToWGSL(e,0)+"."+this.rightValue.formatToWGSL(e,0)}}class Wi extends me{constructor(e,t){super(),o(this,"leftValue"),o(this,"indexValue"),this.leftValue=e,this.indexValue=t}static parse(e){if(e.peekToken(0).Type==x.IDENT&&e.peekToken(1).Type==x.LEFTMEDI){let t=new ri(e.peekToken(0).Literal);e.skipToken(2);let r=ie.parse(e);e.peekToken(0).Type==x.RIGHTMEDI&&e.skipToken(1);let s=new Wi(t,r);for(;e.peekToken(0).Type==x.LEFTMEDI;)e.skipToken(1),r=ie.parse(e),e.peekToken(0).Type==x.RIGHTMEDI&&e.skipToken(1),s=new Wi(s,r);return s}throw"Error parsing index expression: Unexpected character"}formatToWGSL(e,t){return(t<=0?"":"    ".repeat(t))+this.leftValue.formatToWGSL(e,0)+"["+this.indexValue.formatToWGSL(e,0)+"]"}}class Gt extends me{constructor(){super()}static parse(e){if(e.peekToken(0).Type==x.LEFTBIG){e.skipToken(1);let t=new Gt;for(let r=1;r>0&&e.peekToken(0).Type!=x.EOF;){let s=e.peekToken(0);if(s.Type==x.LEFTBIG){r++,e.skipToken(1);continue}if(s.Type==x.RIGHTBIG){r--,e.skipToken(1);continue}if(s.Type==x.SEMICOLON){e.skipToken(1);continue}if(s.isDataType()&&e.peekToken(1).Type==x.IDENT){t.addNode(Te.parse(e));continue}if(s.Type==x.CONST&&e.peekToken(1).isDataType()&&e.peekToken(2).Type==x.IDENT){t.addNode(Te.parse(e));continue}else if(s.Type==x.IDENT&&e.peekToken(1).Type==x.ASSIGN){t.addNode(ie.parse(e)),e.peekToken(0).Type==x.SEMICOLON&&e.skipToken(1);continue}else if(s.Type==x.IDENT&&e.peekToken(1).Type==x.LEFTMEDI){let a=Wi.parse(e);if(e.peekToken(0).Type==x.ASSIGN){let n=e.peekToken(0);e.skipToken(1);let l=ie.parse(e);e.peekToken(0).Type==x.RIGHTMEDI&&e.skipToken(1),t.addNode(new Ai(n,a,l));continue}t.addNode(a);continue}else if(s.Type==x.IDENT&&e.peekToken(1).Type==x.DOT){let a=ie.parse(e);t.addNode(a);continue}else if(s.Type==x.IDENT&&e.peekToken(1).isAssignOperation()){let a=e.peekToken(1),n=new ri(s.Literal);e.skipToken(2);let l=ie.parse(e);e.peekToken(0).Type==x.SEMICOLON&&e.skipToken(1),t.addNode(new Ai(a,n,l));continue}else if(s.Type==x.IDENT&&(e.peekToken(1).Type==x.INC||e.peekToken(1).Type==x.DEC)&&e.peekToken(2).Type==x.SEMICOLON){let a=e.peekToken(1);t.addNode(new lr(a,new ri(s.Literal),void 0)),e.skipToken(3);continue}else if(s.Type==x.RETURN){t.addNode(_s.parse(e));continue}else if(s.Type==x.CONTINUE){t.addNode(va.parse(e));continue}else if(s.Type==x.WHILE){t.addNode(Xi.parse(e));continue}else if(s.Type==x.FOR){t.addNode(Yi.parse(e));continue}else if(s.Type==x.IF){t.addNode(Gi.parse(e));continue}else if(s.Type==x.IDENT&&e.peekToken(1).Type==x.LEFTSAMLL){t.addNode(Hi.parse(e)),e.peekToken(0).Type==x.SEMICOLON&&e.skipToken(0);continue}throw"Error parsing block: Unexpected symbol("+s.Literal+")"}return t}throw"Error parsing block: Unexpected symbol"}}class ya extends me{constructor(e,t){super(),o(this,"type"),o(this,"qualifier"),this.type=t,this.qualifier=e}static parse(e){if(e.peekToken(0).Type==x.PRECISION&&e.peekToken(1).Type==x.IDENT&&e.peekToken(2).isBuiltinType()){let t=new ya(e.peekToken(1).Literal,e.peekToken(2).Literal);return e.skipToken(3),e.peekToken(0).Type==x.SEMICOLON&&e.skipToken(1),t}throw"Error parsing precision qualifier: Unexpected character"}formatToWGSL(e,t){return""}}class vs extends me{constructor(){super(),o(this,"scope",""),o(this,"qualifier",new Map)}addQualifier(e,t=""){this.qualifier.set(e,t)}static parse(e){if(e.peekToken(0).Type==x.LAYOUT&&e.peekToken(1).Type==x.LEFTSAMLL){let t=new vs;e.skipToken(2);do if(e.peekToken(0).Type==x.IDENT){if(e.peekToken(1).Type==x.ASSIGN&&e.peekToken(2).Type==x.LITERAL){let s=e.peekToken(0).Literal,a=e.peekToken(2).Literal;if(t.addQualifier(s,a),e.skipToken(3),e.peekToken(0).Type==x.COMMA){e.skipToken(1);continue}let n=e.peekToken(0);n.Line=0}else if(e.peekToken(1).Type==x.RIGHTSAMLL){let s=e.peekToken(0).Literal;t.addQualifier(s,""),e.skipToken(1);break}else if(e.peekToken(1).Type==x.COMMA){let s=e.peekToken(0).Literal;t.addQualifier(s,""),e.skipToken(2);continue}}while(e.peekToken(0).Type!=x.RIGHTSAMLL);if(e.peekToken(0).Type==x.RIGHTSAMLL&&e.skipToken(1),t.scope=e.peekToken(0).Literal,e.skipToken(1),e.peekToken(0).Type==x.SEMICOLON)return e.skipToken(1),t;if(e.peekToken(0).isBuiltinType()&&e.peekToken(1).Type==x.IDENT&&e.peekToken(2).Type==x.SEMICOLON){let r=new Te(e.peekToken(0).Literal,e.peekToken(1).Literal);return t.addNode(r),e.skipToken(3),t}else if(e.peekToken(0).Type==x.IDENT&&e.peekToken(1).Type==x.LEFTBIG){let r=oi.parse(e);return t.addNode(r),e.peekToken(0).Type==x.IDENT&&e.peekToken(1).Type==x.SEMICOLON&&(r.addNode(new Te(r.name,e.peekToken(0).Literal)),e.skipToken(2)),t}else throw"Error parsing layout qualifier type: Unexpected symbol("+e.peekToken(0).Literal+")"}throw"Error parsing layout qualifier: Unexpected symbol"}formatToWGSL(e,t){let r="";if(this.qualifier.size==1&&this.qualifier.has("location"))r+="@location("+this.qualifier.get("location")+") ";else if(this.qualifier.size==2&&this.qualifier.has("set")&&this.qualifier.has("binding"))r+="@group("+this.qualifier.get("set")+") @binding("+this.qualifier.get("binding")+") ";else if(this.qualifier.size>=1&&this.qualifier.has("binding"))r+="@group(0) @binding("+this.qualifier.get("binding")+") ";else if(this.qualifier.size==1&&this.qualifier.has("push_constant"))r+="@push_constant ";else if(this.qualifier.size>=1&&this.qualifier.has("local_size_x"))r+="@workgroup_size(",r+=this.qualifier.get("local_size_x")+", ",r+=this.qualifier.has("local_size_y")?this.qualifier.get("local_size_y")+", ":"1, ",r+=this.qualifier.has("local_size_z")?this.qualifier.get("local_size_z")+"":"1",r+=")";else if(this.nodes.length<=0)return"";let s=this.nodes[0];if(s instanceof Te){switch(s.type){case"sampler":case"texture2D":r+="var ";break;default:this.scope=="buffer"?e.stage=="compute"?r+="var<storage, read_write> ":r+="var<storage, read> ":r+="var<"+this.scope+"> ";break}e.addIdentifier(s.name,s.name),r+=s.name+": "+St(s.type)+`;\r
`}else if(s instanceof oi){if(this.scope=="buffer"?e.stage=="compute"?r+="var<storage, read_write> ":r+="var<storage, read> ":r+="var<"+this.scope+"> ",s.nodes.length<=0){let a="unif"+e.layoutUniformCount.toString();for(;e.hasIdentifier(a);)e.layoutUniformCount++,a="unif"+e.layoutUniformCount.toString();for(let n of s.fields)e.addIdentifier(n.name,a+"."+n.name);r+=a+": "+s.name+`;\r
`,e.layoutUniformCount++}else{let a=s.nodes[0];r+=a.name+": "+a.type+`;\r
`}return r}return r}}function St(i){switch(i){case"int":return"i32";case"int[]":return"array<i32>";case"uint":return"u32";case"uint[]":return"array<u32>";case"float":return"f32";case"float[]":return"array<f32>";case"vec2":return"vec2<f32>";case"vec3":return"vec3<f32>";case"vec4":return"vec4<f32>";case"vec2[]":return"array<vec2<f32>>";case"vec3[]":return"array<vec3<f32>>";case"vec4[]":return"array<vec4<f32>>";case"ivec2":return"vec2<i32>";case"ivec3":return"vec3<i32>";case"ivec4":return"vec4<i32>";case"ivec2[]":return"array<vec2<i32>>";case"ivec3[]":return"array<vec3<i32>>";case"ivec4[]":return"array<vec4<i32>>";case"mat2":return"mat2x2<f32>";case"mat2x2":return"mat2x2<f32>";case"mat2x3":return"mat2x3<f32>";case"mat2x4":return"mat2x4<f32>";case"mat2[]":return"array<mat2x2<f32>>";case"mat2x2[]":return"array<mat2x2<f32>>";case"mat2x3[]":return"array<mat2x3<f32>>";case"mat2x4[]":return"array<mat2x4<f32>>";case"mat3":return"mat3x3<f32>";case"mat3x2":return"mat3x2<f32>";case"mat3x3":return"mat3x3<f32>";case"mat3x4":return"mat3x4<f32>";case"mat3[]":return"array<mat3x3<f32>>";case"mat3x2[]":return"array<mat3x2<f32>>";case"mat3x3[]":return"array<mat3x3<f32>>";case"mat3x4[]":return"array<mat3x4<f32>>";case"mat4":return"mat4x4<f32>";case"mat4x2":return"mat4x2<f32>";case"mat4x3":return"mat4x3<f32>";case"mat4x4":return"mat4x4<f32>";case"mat4[]":return"array<mat4x4<f32>>";case"mat4x2[]":return"array<mat4x2<f32>>";case"mat4x3[]":return"array<mat4x3<f32>>";case"mat4x4[]":return"array<mat4x4<f32>>";case"texture2D":return"texture_2d<f32>"}return i}class vu{constructor(e){o(this,"_lexer"),o(this,"_rootNode"),this._lexer=e,this._rootNode=new me,this.parse()}get lexer(){return this._lexer}parse(){for(;this.peekToken(0).Type!==x.EOF;){if(this.peekToken(0).Type==x.SEMICOLON){this.skipToken(1);continue}let e=this.parseStatement();e!==null&&this._rootNode.addNode(e)}}parseStatement(){let e=this.peekToken();if(e.Type==x.LAYOUT&&this.peekToken(1).Type==x.LEFTSAMLL)return vs.parse(this._lexer);if(e.Type==x.STRUCT)return this.skipToken(1),oi.parse(this._lexer);if((e.isBuiltinType()||e.Type==x.VOID)&&this.peekToken(1).Type==x.IDENT&&this.peekToken(2).Type==x.LEFTSAMLL)return _a.parse(this._lexer);if(e.Type==x.CONST&&this.peekToken(1).isDataType())return Te.parse(this._lexer);if(e.isDataType()&&this.peekToken(1).Type==x.IDENT)return Te.parse(this._lexer);if(e.Type==x.OUT&&this.peekToken(1).isDataType()&&this.peekToken(2).Type==x.IDENT)return Te.parse(this._lexer);if(e.Type==x.PRECISION)return ya.parse(this._lexer);throw"Error parsing statement: Unexpected character"}skipToken(e){this._lexer.skipToken(e)}peekToken(e=0){return this._lexer.peekToken(e)}getNextToken(){return this._lexer.GetNextToken()}get ASTRoot(){return this._rootNode}}class Ks{static convertGLSL(e){var t=new mu(e),r=new pu(t),s=new vu(r),a=new Au(s);return a.generateWGSL()}}o(Ks,"VertexShader","VertexShader"),o(Ks,"FragmentShader","FragmentShader");class Oo{constructor(){o(this,"setID",0),o(this,"bindingID",0),o(this,"name",""),o(this,"type","")}}class No{constructor(){o(this,"name",""),o(this,"type",""),o(this,"locationID",0),o(this,"builtinName","")}isBuiltinAttribute(){return this.builtinName!=""}}class yu{constructor(){o(this,"uniformInfo",[]),o(this,"inputAttribute",[]),o(this,"outputAttribute",[]),o(this,"sourceCode","")}}var Ut=(i=>(i[i.vertex=0]="vertex",i[i.fragment=1]="fragment",i[i.computer=2]="computer",i))(Ut||{});class Cu{constructor(){o(this,"blendMode",xe.NONE),o(this,"depthCompare",vt.less),o(this,"depthWriteEnabled",!0),o(this,"frontFace","ccw"),o(this,"cullMode",ui.back),o(this,"topology",Ms.triangle_list),o(this,"depthBias",10),o(this,"useLight",!1),o(this,"useProbe",!1),o(this,"acceptGI",!1),o(this,"acceptShadow",!1),o(this,"castShadow",!1),o(this,"castReflection",!1),o(this,"receiveEnv",!1),o(this,"renderLayer",1e3),o(this,"renderOrder",2e3),o(this,"unclippedDepth",!1),o(this,"transparent",!1),o(this,"multisample",0),o(this,"label"),o(this,"useZ",!0),o(this,"splitTexture",!1),o(this,"alphaCutoff"),o(this,"useFragDepth",!1)}setFromMapValues(e){e.has("blendMode")&&(this.blendMode=this.convertBlendMode(e.get("blendMode"))),e.has("depthCompare")&&(this.depthCompare=e.get("depthCompare")),e.has("depthWriteEnabled")&&(this.depthWriteEnabled=e.get("depthWriteEnabled")),e.has("frontFace")&&(this.frontFace=e.get("frontFace")),e.has("cullMode")&&(this.cullMode=e.get("cullMode")),e.has("topology")&&(this.topology=e.get("topology")),e.has("depthBias")&&(this.depthBias=e.get("depthBias")),e.has("useLight")&&(this.useLight=e.get("useLight")),e.has("useProbe")&&(this.useProbe=e.get("useProbe")),e.has("acceptGI")&&(this.acceptGI=e.get("acceptGI")),e.has("acceptShadow")&&(this.acceptShadow=e.get("acceptShadow")),e.has("castShadow")&&(this.castShadow=e.get("castShadow")),e.has("receiveEnv")&&(this.receiveEnv=e.get("receiveEnv")),e.has("renderLayer")&&(this.renderLayer=e.get("renderLayer")),e.has("renderOrder")&&(this.renderOrder=e.get("renderOrder")),e.has("unclippedDepth")&&(this.unclippedDepth=e.get("unclippedDepth")),e.has("multisample")&&(this.multisample=e.get("multisample")),e.has("label")&&(this.label=e.get("label")),e.has("useZ")&&(this.useZ=e.get("useZ"))}convertBlendMode(e){switch(e){case"ABOVE":return xe.ABOVE;case"ALPHA":return xe.ALPHA;case"NORMAL":return xe.NORMAL;case"ADD":return xe.ADD;case"BELOW":return xe.BELOW;case"ERASE":return xe.ERASE;case"MUL":return xe.MUL;case"SCREEN":return xe.SCREEN;case"DIVD":return xe.DIVD;case"SOFT_ADD":return xe.SOFT_ADD}return xe.NONE}}class wu extends Jt{constructor(){super(),o(this,"uniformNodes",[]),o(this,"_onChange",!0),this.bufferType=Mt.MaterialDataUniformGPUBuffer}initDataUniform(e){this.uniformNodes=e;let t=0;for(const r in e){const s=e[r];s||console.error(r,"is empty"),t+=s.size*4}t=Math.floor(t/256+1)*256,this.createBuffer(GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,t/4);for(const r in e){const s=e[r];s||console.error(r,"is empty");let a=this.memory.allocation_node(s.size*4);s.memoryInfo=a,s.bindOnChange=()=>this.onChange()}}onChange(){this._onChange=!0}apply(){if(this.uniformNodes.length!=0&&this._onChange){for(const e in this.uniformNodes)this.uniformNodes[e].update();super.apply(),this._onChange=!1}}}class Ot{static init(){this.renderShaderModulePool=new Map,this.renderShader=new Map}}o(Ot,"renderShaderModulePool"),o(Ot,"renderShader");class Js{static getSharePipeline(e){let t=this.pipelineMap.get(e);return t||null}static setSharePipeline(e,t){this.pipelineMap.set(e,t)}}o(Js,"pipelineMap",new Map);class We extends Ka{constructor(e,t){super(),o(this,"useRz",!1),o(this,"vsName"),o(this,"fsName"),o(this,"shaderState"),o(this,"textures"),o(this,"pipeline"),o(this,"bindGroupLayouts"),o(this,"materialDataUniformBuffer"),o(this,"envMap"),o(this,"prefilterMap"),o(this,"_sourceVS"),o(this,"_sourceFS"),o(this,"_destVS"),o(this,"_destFS"),o(this,"_vsShaderModule"),o(this,"_fsShaderModule"),o(this,"_textureGroup",-1),o(this,"_textureChange",!1),o(this,"_groupsShaderReflectionVarInfos"),o(this,"_cacheEntries"),this.vsName=e.toLowerCase(),this.fsName=t.toLowerCase(),this.vsName in N||console.error("Shader Not Register, Please Register Shader!",this.vsName),this.fsName in N||console.error("Shader Not Register, Please Register Shader!",this.fsName),N[this.vsName]&&(this._sourceVS=N[this.vsName]),N[this.fsName]&&(this._sourceFS=N[this.fsName]),this.textures={},this.bindGroups=[],this.shaderState=new Cu,this.materialDataUniformBuffer=new wu,this.materialDataUniformBuffer.visibility=GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,this._bufferDic.set("global",this.materialDataUniformBuffer),this._bufferDic.set("materialUniform",this.materialDataUniformBuffer)}get renderOrder(){return this.shaderState.renderOrder}set renderOrder(e){this.shaderState.renderOrder!=e&&(this._valueChange=!0),this.shaderState.renderOrder=e}get doubleSide(){return this.shaderState.cullMode==ui.none}set doubleSide(e){let t=e?ui.none:this.cullMode;this.shaderState.cullMode!=t&&(this._valueChange=!0),this.shaderState.cullMode=t}get cullMode(){return this.shaderState.cullMode}set cullMode(e){this.shaderState.cullMode!=e&&(this._valueChange=!0),this.shaderState.cullMode=e}get frontFace(){return this.shaderState.frontFace}set frontFace(e){this.shaderState.frontFace!=e&&(this._valueChange=!0),this.shaderState.frontFace=e}get depthBias(){return this.shaderState.depthBias}set depthBias(e){this.shaderState.depthBias!=e&&(this._valueChange=!0),this.shaderState.depthBias=e}get topology(){return this.shaderState.topology}set topology(e){this.shaderState.topology!=e&&(this._valueChange=!0),this.shaderState.topology=e}get blendMode(){return this.shaderState.blendMode}set blendMode(e){this.shaderState.blendMode!=e&&(this._valueChange=!0,e!=xe.NORMAL&&e!=xe.NONE&&(this.renderOrder=3e3)),this.shaderState.blendMode=e}get depthCompare(){return this.shaderState.depthCompare}set depthCompare(e){this.shaderState.depthCompare!=e&&(this._valueChange=!0),this.shaderState.depthCompare=e}setShaderEntry(e="",t=""){this.vsEntryPoint=e,this.fsEntryPoint=t}setUniform(e,t){super.setUniform(e,t),this.materialDataUniformBuffer.onChange()}setTexture(e,t){t&&this.textures[e]!=t&&(this.textures[e]&&this.textures[e].unBindStateChange(this),this._textureChange=!0,this.textures[e]=t,e=="envMap"?this.envMap=t:e=="prefilterMap"&&(this.prefilterMap=t),t.bindStateChange(()=>{this._textureChange=!0},this))}get baseColor(){return this.getUniform("baseColor")}set baseColor(e){this.setUniform("baseColor",e)}getTexture(e){return this.textures[e]}genRenderPipeline(e,t){let r=this.createGroupLayouts();this.createPipeline(e,t,r)}reBuild(e,t){this.compileShader(Ut.vertex,this._destVS,t),this.compileShader(Ut.fragment,this._destFS,t),this.genRenderPipeline(e,t)}apply(e,t,r){this.materialDataUniformBuffer.apply(),this._textureChange&&this._textureGroup!=-1&&(this._textureChange=!1,this.genGroups(this._textureGroup,this.shaderReflection.groups,!0)),this._valueChange&&(this._shaderChange&&(this.preCompile(e),this._shaderChange=!1),this.shaderVariant=ct.genRenderShaderVariant(this),this.reBuild(e,t),this._valueChange=!1,r&&r())}preCompile(e){this.preDefine(e),this.preCompileShader(Ut.vertex,this._sourceVS.concat()),this.preCompileShader(Ut.fragment,this._sourceFS.concat()),this.genReflection()}applyPostDefine(e,t){return t.outAttachments.length>1?(this.defineValue.USE_WORLDPOS=!0,this.defineValue.USEGBUFFER=!0):(this.defineValue.USE_WORLDPOS=!1,this.defineValue.USEGBUFFER=!1),ut.parse(e,this.defineValue)}setBindGroup(e,t){this.bindGroups[e]=t}checkBuffer(e,t){}preCompileShader(e,t,r){let s=t;if(s.indexOf("version ")!=-1){var a=Ks.convertGLSL(s);s=a.sourceCode}for(const n in this.constValues)if(Object.prototype.hasOwnProperty.call(this.constValues,n)){const l=this.constValues[n];s=s.replaceAll(`&${n}`,l.toString())}switch(e){case Ut.vertex:this._destVS=s;break;case Ut.fragment:this._destFS=s;break}}compileShader(e,t,r){let s=t;s=this.applyPostDefine(s,r);let a=t;for(let l in this.defineValue)a+=`${l}=${this.defineValue[l]},`;let n=Ot.renderShaderModulePool.get(a);switch(n||(s=this.applyPostDefine(s,r),n=S.device.createShaderModule({label:e==Ut.vertex?this.vsName:this.fsName,code:s}),n.getCompilationInfo().then(l=>{l.messages.length>0&&(console.log(s),console.log(l))}),Ot.renderShaderModulePool.set(a,n)),e){case Ut.vertex:this._vsShaderModule=n,this._destVS=s;break;case Ut.fragment:this._fsShaderModule=n,this._destFS=s;break}}getGroupLayout(e,t){let r=[];for(let s=0;s<t.length;s++){const a=t[s];if(a)if(a.varType=="uniform"){this._bufferDic.has(a.varName)||console.error(`not set ${a.varName} buffer`);let n=this._bufferDic.get(a.varName).visibility,l={binding:a.binding,visibility:n,buffer:{type:"uniform"}};r.push(l)}else if(a.varType=="storage-read"){this._bufferDic.has(a.varName)||console.error(`not set ${a.varName} buffer`);let n=this._bufferDic.get(a.varName).visibility,l={binding:a.binding,visibility:n,buffer:{type:"read-only-storage"}};r.push(l)}else if(a.varType=="var")switch(a.dataType){case"sampler":{let n=a.varName.replace("Sampler",""),l=this.textures[n]?this.textures[n]:A.res.redTexture,h={binding:a.binding,visibility:l.visibility,sampler:l.samplerBindingLayout};r.push(h),this._textureGroup=e}break;case"sampler_comparison":{let n=a.varName.replace("Sampler",""),l=this.textures[n]?this.textures[n]:A.res.redTexture,h={binding:a.binding,visibility:l.visibility,sampler:l.sampler_comparisonBindingLayout};r.push(h),this._textureGroup=e}break;case"texture_2d<f32>":case"texture_2d_array<f32>":case"texture_cube<f32>":case"texture_depth_2d":case"texture_depth_2d_array":case"texture_depth_cube":case"texture_depth_cube_array":{let n=this.textures[a.varName]?this.textures[a.varName]:A.res.redTexture,l={binding:a.binding,visibility:n.visibility,texture:n.textureBindingLayout};r.push(l),this._textureGroup=e,se.getInstance().attached(n,this)}break;case"texture_external":{let n=this.textures[a.varName]?this.textures[a.varName]:A.res.redTexture,l={binding:a.binding,visibility:n.visibility,externalTexture:{}};r.push(l),this._textureGroup=e,se.getInstance().attached(n,this)}break;default:{let n=this.textures[a.varName]?this.textures[a.varName]:A.res.redTexture,l={binding:a.binding,visibility:n.visibility,texture:n.textureBindingLayout};r.push(l),this._textureGroup=e,se.getInstance().attached(n,this)}break}else{debugger;console.error("bind group can't empty")}}return r}genGroups(e,t,r=!1){if(!this.bindGroups[e]||r){const s=t[e];let a=[];for(let l=0;l<s.length;l++){const h=s[l];if(h){if(h.varType=="uniform"){let u=this._bufferDic.get(h.varName);if(u){if(u.bufferType==Mt.MaterialDataUniformGPUBuffer){let f=[];for(let d=0;d<h.dataFields.length;d++){const p=h.dataFields[d];this.uniforms[p.name]||console.error(`shader-${this.vsName}:${this.fsName} ${p.name}is empty`),f.push(this.uniforms[p.name])}this.materialDataUniformBuffer.initDataUniform(f)}let c={binding:h.binding,resource:{buffer:u.buffer,offset:0,size:u.memory.shareDataBuffer.byteLength}};a.push(c),this.checkBuffer(h.varName,u)}else console.error(`shader${this.vsName}-${this.fsName}`,`buffer ${h.varName} is missing!`)}else if(h.varType=="storage-read"){let u=this._bufferDic.get(h.varName);if(u){let c={binding:h.binding,resource:{buffer:u.buffer,offset:0,size:u.memory.shareDataBuffer.byteLength}};a.push(c),this.checkBuffer(h.varName,u)}else console.error(`buffer ${h.varName} is missing!`)}else if(h.varType=="var")if(h.dataType=="sampler"){let u=h.varName.replace("Sampler",""),c=this.textures[u];if(c||(c=A.res.blackTexture,this.setTexture(u,c)),c){let f={binding:h.binding,resource:c.gpuSampler};a.push(f)}else console.error(`shader${this.vsName}-${this.fsName}`,`texture ${h.varName} is missing! `)}else if(h.dataType=="sampler_comparison"){let u=h.varName.replace("Sampler",""),c=this.textures[u];if(c){let f={binding:h.binding,resource:c.gpuSampler_comparison};a.push(f)}else console.error(`shader${this.vsName}-${this.fsName}`,`texture ${h.varName} is missing! `)}else{let u=this.textures[h.varName];if(u||(u=A.res.whiteTexture,this.setTexture(h.varName,u)),u){let c={binding:h.binding,resource:u.getGPUView()};a.push(c)}else console.error(`shader${this.vsName}-${this.fsName}`,`texture ${h.varName} is missing! `)}}}let n=S.device.createBindGroup({layout:this.bindGroupLayouts[e],entries:a});this.bindGroups[e]=n}}createPipeline(e,t,r){let s=e,a=this.shaderState,n=t.outAttachments;if(t.outColor!=-1){let u=n[t.outColor];a.blendMode!=xe.NONE?u.blend=no.getBlend(a.blendMode):delete u.blend}let l={label:this.vsName+"|"+this.fsName,layout:r,primitive:{topology:a.topology,cullMode:a.cullMode,frontFace:a.frontFace},vertex:void 0};this.vsEntryPoint!=""&&(l.vertex={module:this._vsShaderModule,entryPoint:this.vsEntryPoint,buffers:s.vertexBuffer.vertexBufferLayouts}),this.fsEntryPoint!=""&&(l.fragment={module:this._fsShaderModule,entryPoint:this.fsEntryPoint,targets:n}),a.multisample>0&&(l.multisample={count:a.multisample}),(t.zPreTexture||t.depthTexture)&&(a.blendMode!=xe.NONE,A.setting.render.zPrePass&&t.zPreTexture&&a.useZ?l.depthStencil={depthWriteEnabled:!1,depthCompare:vt.less,format:t.zPreTexture.format}:l.depthStencil={depthWriteEnabled:a.depthWriteEnabled,depthCompare:a.depthCompare,format:t.depthTexture.format});let h=Js.getSharePipeline(this.shaderVariant);h?this.pipeline=h:(this.pipeline=w.createPipeline(l),Js.setSharePipeline(this.shaderVariant,this.pipeline))}createGroupLayouts(){this._groupsShaderReflectionVarInfos=[];let e=this.shaderReflection;this.bindGroupLayouts=[Hr.getGlobalDataBindGroupLayout()];for(let r=1;r<e.groups.length;r++){let s=e.groups[r];if(s){let a=this.getGroupLayout(r,s);this._groupsShaderReflectionVarInfos[r]=s;let n=S.device.createBindGroupLayout({entries:a,label:`vs${this.vsName} fs${this.fsName} ${s.length}`});this.bindGroupLayouts[r]=n}else console.error("can't set empty group!",r)}let t=S.device.createPipelineLayout({bindGroupLayouts:this.bindGroupLayouts});return this._groupsShaderReflectionVarInfos[0],this._groupsShaderReflectionVarInfos[1]&&this.genGroups(1,this._groupsShaderReflectionVarInfos),this._groupsShaderReflectionVarInfos[2]&&this.genGroups(2,this._groupsShaderReflectionVarInfos),this._groupsShaderReflectionVarInfos[3]&&this.genGroups(3,this._groupsShaderReflectionVarInfos),t}preDefine(e){let t=e.hasAttribute(Y.joints0),r=e.hasAttribute(Y.a_morphPositions_0),s=e.hasAttribute(Y.TANGENT),a=e.hasAttribute(Y.color),n=this.shaderState.acceptGI,l=this.shaderState.useLight;this.defineValue.USE_SKELETON=t,this.defineValue.USE_MORPHTARGETS=r,"USE_TANGENT"in this.defineValue||(this.defineValue.USE_TANGENT=s),this.defineValue.USE_GI=n,this.defineValue.USE_CASTSHADOW=this.shaderState.castShadow,this.defineValue.USE_SHADOWMAPING=this.shaderState.acceptShadow,this.defineValue.USE_LIGHT=l,this.defineValue.USE_VERTXCOLOR=a,A.setting.pick.mode=="pixel"&&(this.defineValue.USE_WORLDPOS=!0),A.setting.gi.enable?this.defineValue.USEGI=!0:this.defineValue.USEGI=!1,A.setting.render.debug&&(this.defineValue.USE_DEBUG=!0,this.defineValue.DEBUG_CLUSTER=!0),this.shaderState.useLight?this.defineValue.USE_LIGHT=!0:this.defineValue.USE_LIGHT=!1,A.setting.render.useLogDepth?(this.defineValue.USE_LOGDEPTH=!0,this.shaderState.useFragDepth=!0):this.defineValue.USE_LOGDEPTH=!1,this.shaderState.useFragDepth?this.defineValue.USE_OUTDEPTH=!0:this.defineValue.USE_OUTDEPTH=!1,this.defineValue.USE_PCF_SHADOW=A.setting.shadow.type=="PCF",this.defineValue.USE_HARD_SHADOW=A.setting.shadow.type=="HARD",this.defineValue.USE_SOFT_SHADOW=A.setting.shadow.type=="SOFT",this.defineValue.USE_CSM=lt.Cascades>1,this.defineValue.USE_IES_PROFILE=Bi.use}genReflection(){this.shaderVariant=ct.genRenderShaderVariant(this);let e=ct.poolGetReflection(this.shaderVariant);if(e)this.shaderReflection=e;else{let t=ut.parse(this._destVS,this.defineValue);t=ut.parse(t,this.defineValue),ct.getShaderReflection2(t,this);let r=ut.parse(this._destFS,this.defineValue);r=ut.parse(r,this.defineValue),ct.getShaderReflection2(r,this),ct.final(this)}this.shaderState.splitTexture=this.shaderReflection.useSplit}destroy(e){for(const t in this.textures)if(Object.prototype.hasOwnProperty.call(this.textures,t)){const r=this.textures[t];if(se.getInstance().detached(r,this),e&&!se.getInstance().hasReference(r))r.destroy(e);else{r.destroy(!1);let s=se.getInstance().getReference(r),a=[];s.forEach((n,l)=>{"name"in n?a.push(n.name):a.push("NaN")})}}this.bindGroups.length=0,this.shaderState=null,this.textures=null,this.pipeline=null,this.bindGroupLayouts=null,this._sourceVS=null,this._sourceFS=null,this._destVS=null,this._destFS=null,this._vsShaderModule=null,this._fsShaderModule=null,this.materialDataUniformBuffer.destroy(e),this.materialDataUniformBuffer=null}static destroyShader(e){Ot.renderShader.has(e)&&(Ot.renderShader.get(e).destroy(),Ot.renderShader.delete(e))}static getShader(e){return Ot.renderShader.get(e)}static createShader(e,t){let r=new We(e,t);return Ot.renderShader.set(r.instanceID,r),r.instanceID}}class _i{constructor(){o(this,"name"),o(this,"instanceID"),o(this,"enable",!0),o(this,"_defaultPass"),o(this,"_renderPasses"),o(this,"_depthCompare",vt.less),this._renderPasses=new Map}get depthCompare(){return this._depthCompare}set depthCompare(e){this._depthCompare=e,this._defaultPass.depthCompare=e}get defaultPass(){return this._defaultPass}set defaultPass(e){this._defaultPass=e,this.addPass(re.COLOR,e)}get doubleSide(){return this._defaultPass.doubleSide}set doubleSide(e){this._defaultPass.doubleSide=e}get castShadow(){return this.defaultPass.shaderState.castShadow}set castShadow(e){let t=this.defaultPass;t.shaderState.castShadow=e}get blendMode(){return this.defaultPass.blendMode}set blendMode(e){let t=this.defaultPass;t.blendMode=e}get transparent(){return this.defaultPass.shaderState.transparent}set transparent(e){let t=this.defaultPass;t.shaderState.transparent=e,e&&(t.renderOrder=3e3)}get cullMode(){return this.defaultPass.cullMode}set cullMode(e){let t=this.defaultPass;t.cullMode=e}hasPass(e){return this._renderPasses.has(e)}getPass(e){return this._renderPasses.get(e)}getAllPass(){return this._renderPasses.get(re.COLOR)}addPass(e,t,r=-1){this._renderPasses.has(e)||this._renderPasses.set(e,[]);let s=this._renderPasses.get(e);return e==re.COLOR&&s.length==0&&(this._defaultPass=t),s.indexOf(t)!=-1||(r==-1?s.push(t):s.splice(r,-1,t)),s}removePass(e,t){if(this._renderPasses.has(e)){let r=this._renderPasses.get(e);t<r.length&&r.splice(t,1)}}clone(){return null}destroy(e){for(const t of this._renderPasses){let r=t[1];for(const s of r)for(const a in s.textures)a.indexOf("defaultOri")==-1&&s.textures[a].destroy(e)}}}class os extends _i{constructor(){super()}setDefault(){let e=this.defaultPass;e.setUniformFloat("shadowBias",35e-5),e.setUniformVector4("transformUV1",new j(0,0,1,1)),e.setUniformVector4("transformUV2",new j(0,0,1,1)),e.setUniformColor("baseColor",new z),e.setUniformColor("emissiveColor",new z(1,1,1)),e.setUniformVector4("materialF0",new j(.04,.04,.04,1)),e.setUniformFloat("envIntensity",1),e.setUniformFloat("normalScale",1),e.setUniformFloat("roughness",1),e.setUniformFloat("metallic",0),e.setUniformFloat("ao",1),e.setUniformFloat("roughness_min",0),e.setUniformFloat("roughness_max",1),e.setUniformFloat("metallic_min",0),e.setUniformFloat("metallic_max",1),e.setUniformFloat("emissiveIntensity",0),e.setUniformFloat("alphaCutoff",0),e.setUniformFloat("ior",1.5),e.setUniformFloat("clearcoatFactor",0),e.setUniformFloat("clearcoatRoughnessFactor",0),e.setUniformColor("clearcoatColor",new z(1,1,1)),e.setUniformFloat("clearcoatWeight",0)}get baseMap(){return this.defaultPass.getTexture("baseMap")}set baseMap(e){this.defaultPass.setTexture("baseMap",e)}get baseColor(){return this.defaultPass.getUniform("baseColor")}set baseColor(e){this.defaultPass.setUniformColor("baseColor",e)}get normalMap(){return this.defaultPass.getTexture("normalMap")}set normalMap(e){this.defaultPass.setTexture("normalMap",e)}get doubleSide(){return this.defaultPass.doubleSide}set doubleSide(e){this.defaultPass.doubleSide=e}get alphaCutoff(){return this.defaultPass.shaderState.alphaCutoff}set alphaCutoff(e){this.defaultPass.setDefine("USE_ALPHACUT",!0),this.defaultPass.shaderState.alphaCutoff=e,this.defaultPass.setUniform("alphaCutoff",e)}get emissiveColor(){return this.defaultPass.getUniform("emissiveColor")}set emissiveColor(e){this.defaultPass.setUniform("emissiveColor",e)}get emissiveIntensity(){return this.defaultPass.getUniform("emissiveIntensity")}set emissiveIntensity(e){this.defaultPass.setUniform("emissiveIntensity",e)}get uvTransform_1(){return this.defaultPass.uniforms.transformUV1.vector4}set uvTransform_1(e){this.defaultPass.setUniformVector4("transformUV1",e)}get uvTransform_2(){return this.defaultPass.uniforms.transformUV2.vector4}set uvTransform_2(e){this.defaultPass.setUniformVector4("transformUV2",e)}get depthWriteEnabled(){return this.defaultPass.shaderState.depthWriteEnabled}set depthWriteEnabled(e){this.defaultPass.shaderState.depthWriteEnabled=e}get materialF0(){return this.defaultPass.uniforms.materialF0.vector4}set materialF0(e){this.defaultPass.setUniformVector4("materialF0",e)}get roughness(){return this.defaultPass.uniforms.roughness.value}set roughness(e){this.defaultPass.setUniformFloat("roughness",e)}get metallic(){return this.defaultPass.uniforms.metallic.value}set metallic(e){this.defaultPass.setUniformFloat("metallic",e)}get ao(){return this.defaultPass.uniforms.ao.value}set ao(e){this.defaultPass.setUniformFloat("ao",e)}get metallic_min(){return this.defaultPass.uniforms.metallic_min.value}set metallic_min(e){this.defaultPass.setUniformFloat("metallic_min",e)}get metallic_max(){return this.defaultPass.uniforms.metallic_max.value}set metallic_max(e){this.defaultPass.setUniformFloat("metallic_max",e)}get roughness_min(){return this.defaultPass.uniforms.roughness_min.value}set roughness_min(e){this.defaultPass.setUniformFloat("roughness_min",e)}get roughness_max(){return this.defaultPass.uniforms.roughness_max.value}set roughness_max(e){this.defaultPass.setUniformFloat("roughness_max",e)}get normalScale(){return this.defaultPass.uniforms.normalScale.value}set normalScale(e){this.defaultPass.setUniformFloat("normalScale",e)}get maskMap(){return this.defaultPass.textures.maskMap}set maskMap(e){this.defaultPass.setDefine("USE_MR",!0),this.defaultPass.setTexture("maskMap",e)}set aoMap(e){e&&(this.defaultPass.setTexture("aoMap",e),e!=A.res.whiteTexture&&this.defaultPass.setDefine("USE_AOTEX",!0))}get aoMap(){return this.defaultPass.textures.aoMap}set clearCoatRoughnessMap(e){e&&(console.log("USE_CLEARCOAT_ROUGHNESS"),this.defaultPass.setTexture("clearCoatRoughnessMap",e),this.defaultPass.setDefine("USE_CLEARCOAT_ROUGHNESS",!0))}get clearCoatRoughnessMap(){return this.defaultPass.textures.clearCoatRoughnessMap}get brdfLUT(){return this.defaultPass.textures.brdfLUT}set brdfLUT(e){this.defaultPass.setTexture("brdfLUT",e),this.defaultPass.setTexture("brdflutMap",e)}get emissiveMap(){return this.defaultPass.textures.emissiveMap}set emissiveMap(e){this.defaultPass.setTexture("emissiveMap",e)}set envIntensity(e){this.defaultPass.setUniformFloat("envIntensity",e)}get envIntensity(){return this.defaultPass.uniforms.envIntensity.value}set ior(e){this.defaultPass.setUniformFloat("ior",e)}get ior(){return this.defaultPass.uniforms.ior.value}useCleanCoat(){this.defaultPass.setDefine("USE_CLEARCOAT",!0)}set clearcoatFactor(e){this.defaultPass.setUniformFloat("clearcoatFactor",e),this.useCleanCoat()}get clearcoatFactor(){return this.defaultPass.uniforms.clearcoatFactor.value}set clearcoatRoughnessFactor(e){this.defaultPass.setUniformFloat("clearcoatRoughnessFactor",e),this.useCleanCoat()}get clearcoatRoughnessFactor(){return this.defaultPass.uniforms.clearcoatRoughnessFactor.value}set clearcoatWeight(e){this.defaultPass.setUniformFloat("clearcoatWeight",e),this.useCleanCoat()}get clearcoatWeight(){return this.defaultPass.uniforms.clearcoatWeight.value}set clearcoatColor(e){this.defaultPass.setUniformColor("clearcoatColor",e),this.useCleanCoat()}get clearcoatColor(){return this.defaultPass.uniforms.clearcoatColor.color}}class yi extends os{constructor(){super();let e=new We("PBRLItShader","PBRLItShader");this.defaultPass=e,e.setShaderEntry("VertMain","FragMain");let t=e.shaderState;t.acceptShadow=!0,t.castShadow=!0,t.receiveEnv=!0,t.acceptGI=!0,t.useLight=!0;let r=A.res.getTexture("BRDFLUT");this.brdfLUT=r,e.setDefine("USE_BRDF",!0),this.setDefault(),this.baseMap=A.res.whiteTexture,this.normalMap=A.res.normalTexture,this.emissiveMap=A.res.blackTexture,this.alphaCutoff=.5}clone(){let e=new yi,t=e.defaultPass;return t.setUniform("shadowBias",this.defaultPass.getUniform("shadowBias")),t.setUniform("transformUV1",this.defaultPass.getUniform("transformUV1")),t.setUniform("transformUV2",this.defaultPass.getUniform("transformUV2")),t.setUniform("baseColor",this.defaultPass.getUniform("baseColor")),t.setUniform("emissiveColor",this.defaultPass.getUniform("emissiveColor")),t.setUniform("materialF0",this.defaultPass.getUniform("materialF0")),t.setUniform("envIntensity",this.defaultPass.getUniform("envIntensity")),t.setUniform("normalScale",this.defaultPass.getUniform("normalScale")),t.setUniform("roughness",this.defaultPass.getUniform("roughness")),t.setUniform("metallic",this.defaultPass.getUniform("metallic")),t.setUniform("ao",this.defaultPass.getUniform("ao")),t.setUniform("roughness_min",this.defaultPass.getUniform("roughness_min")),t.setUniform("roughness_max",this.defaultPass.getUniform("roughness_max")),t.setUniform("metallic_min",this.defaultPass.getUniform("metallic_min")),t.setUniform("metallic_max",this.defaultPass.getUniform("metallic_max")),t.setUniform("emissiveIntensity",this.defaultPass.getUniform("emissiveIntensity")),t.setUniform("alphaCutoff",this.defaultPass.getUniform("alphaCutoff")),t.setUniform("ior",this.defaultPass.getUniform("ior")),t.setUniform("clearcoatFactor",this.defaultPass.getUniform("clearcoatFactor")),t.setUniform("clearcoatRoughnessFactor",this.defaultPass.getUniform("clearcoatRoughnessFactor")),t.setUniform("clearcoatColor",this.defaultPass.getUniform("clearcoatColor")),t.setUniform("clearcoatWeight",this.defaultPass.getUniform("clearcoatWeight")),t.setTexture("baseMap",this.defaultPass.getTexture("baseMap")),t.setTexture("normalMap",this.defaultPass.getTexture("normalMap")),t.setTexture("emissiveMap",this.defaultPass.getTexture("emissiveMap")),t.setTexture("aoMap",this.defaultPass.getTexture("aoMap")),t.setTexture("maskMap",this.defaultPass.getTexture("maskMap")),e}}class Fo extends Xt{constructor(){super(...arguments),o(this,"textData",""),o(this,"source_vertices"),o(this,"source_normals"),o(this,"source_tangents"),o(this,"source_textureCoords"),o(this,"matLibs"),o(this,"geometrys"),o(this,"activeGeo"),o(this,"facesMaterialsIndex"),o(this,"mtl"),o(this,"mtlUrl")}async parseString(e){return this.source_vertices=[],this.source_normals=[],this.source_tangents=[],this.source_textureCoords=[],this.matLibs={},this.geometrys={},this.textData=e,await Promise.all([this.parserOBJ(),this.loadMTL()]),this.parser_mesh(),"null"}applyVector2(e,t,r){t[e]&&t[e].length>0?(r.push(t[e][0]),r.push(t[e][1])):(r.push(0),r.push(0))}applyVector3(e,t,r){r.push(t[e][0]),r.push(t[e][1]),r.push(t[e][2])}applyVector4(e,t,r){r.push(t[e][0]),r.push(t[e][1]),r.push(t[e][2]),r.push(t[e][3])}async loadMTL(){let t=await new ht().loadTxt(this.baseUrl+this.mtlUrl),r=t.data,s,a=r.split(`\r
`);for(let h=0;h<a.length;h++){let u=a[h];var n=u.indexOf("#");n!=-1&&(u=u.substring(0,n)),u=u.trim();var l=u.split(/\s+/);l[0]==="newmtl"?(s={name:l[1]},this.matLibs[l[1]]=s):l[0].indexOf("map_")!=-1?(s[l[0]]=l[1],s.textures||(s.textures=[l[l.length-1]]),s.textures.push(l[l.length-1])):l.length==2?s[l[0]]=Number(l[1]):l.length==3?s[l[0]]=[Number(l[1]),Number(l[2])]:l.length==4&&(s[l[0]]=[Number(l[1]),Number(l[2]),Number(l[3])])}for(const h in this.matLibs){const u=this.matLibs[h];if(u.textures&&u.textures.length>0)for(let c=0;c<u.textures.length;c++){const f=it.normalizePath(this.baseUrl+u.textures[c]);await A.res.loadTexture(f)}}return t=null,!0}async load_textures(){}parserLine(e){var t=e.indexOf("#");if(t!=-1){if(e.indexOf("# object")!=-1){var r=e.split(/\s+/);let d=r[1],p=r[2];this.activeGeo={type:d,name:p[1],source_mat:"",source_faces:[]},this.geometrys[p]=this.activeGeo}e=e.substring(0,t)}e=e.trim();var r=e.split(/\s+/);if(r[0]==="v"){var s=[Number(r[1]),Number(r[2]),Number(r[3]),r[4]?1:Number(r[4])];this.source_vertices.push(s)}else if(r[0]==="vt"){var a=[Number(r[1]),Number(r[2]),r[3]?1:Number(r[3])];this.source_textureCoords.push(a)}else if(r[0]==="vn"){var n=[Number(r[1]),Number(r[2]),Number(r[3])];this.source_normals.push(n)}else if(r[0]==="f"){for(var l={indices:[],texture:[],normal:[]},h=1;h<r.length;++h){var u=r[h].indexOf("//"),c=r[h].split(/\W+/);u>0?(l.indices.push(c[0]),l.normal.push(c[1])):c.length===1?l.indices.push(c[0]):c.length===2?(l.indices.push(c[0]),l.texture.push(c[1])):c.length===3&&(l.indices.push(c[0]),l.texture.push(c[1]),l.normal.push(c[2]))}this.activeGeo.source_faces.push(l)}else r[0]==="usemtl"?this.activeGeo.source_mat=r[1]:r[0]==="mtllib"&&(this.mtlUrl=r[1])}async parserOBJ(){let e=this.textData.split(`\r
`);for(let t=0;t<e.length;t++){const r=e[t];this.parserLine(r)}return this.textData="",!0}async parser_mesh(){for(const e in this.geometrys){const t=this.geometrys[e];t.vertex_arr=[],t.normal_arr=[],t.uv_arr=[],t.indeice_arr=[];let r=0;for(let a=0;a<t.source_faces.length;a++){const n=t.source_faces[a];let l=parseInt(n.indices[0])-1,h=parseInt(n.indices[1])-1,u=parseInt(n.indices[2])-1,c=parseInt(n.normal[0])-1,f=parseInt(n.normal[1])-1,d=parseInt(n.normal[2])-1,p=parseInt(n.texture[0])-1,m=parseInt(n.texture[1])-1,_=parseInt(n.texture[2])-1;if(this.applyVector3(l,this.source_vertices,t.vertex_arr),this.applyVector3(c,this.source_normals,t.normal_arr),this.applyVector2(p,this.source_textureCoords,t.uv_arr),t.indeice_arr[r]=r++,this.applyVector3(h,this.source_vertices,t.vertex_arr),this.applyVector3(f,this.source_normals,t.normal_arr),this.applyVector2(m,this.source_textureCoords,t.uv_arr),t.indeice_arr[r]=r++,this.applyVector3(u,this.source_vertices,t.vertex_arr),this.applyVector3(d,this.source_normals,t.normal_arr),this.applyVector2(_,this.source_textureCoords,t.uv_arr),t.indeice_arr[r]=r++,n.indices.length>3){let v=parseInt(n.indices[3])-1,y=parseInt(n.normal[3])-1,C=parseInt(n.texture[3])-1;this.applyVector3(l,this.source_vertices,t.vertex_arr),this.applyVector3(c,this.source_normals,t.normal_arr),this.applyVector2(p,this.source_textureCoords,t.uv_arr),t.indeice_arr[r]=r++,this.applyVector3(u,this.source_vertices,t.vertex_arr),this.applyVector3(d,this.source_normals,t.normal_arr),this.applyVector2(_,this.source_textureCoords,t.uv_arr),t.indeice_arr[r]=r++,this.applyVector3(v,this.source_vertices,t.vertex_arr),this.applyVector3(y,this.source_normals,t.normal_arr),this.applyVector2(C,this.source_textureCoords,t.uv_arr),t.indeice_arr[r]=r++}}let s=new te;for(const a in this.geometrys){const n=this.geometrys[a];let l=new tt;l.setIndices(new Uint32Array(n.indeice_arr)),l.setAttribute(Y.position,new Float32Array(n.vertex_arr)),l.setAttribute(Y.normal,new Float32Array(n.normal_arr)),l.setAttribute(Y.uv,new Float32Array(n.uv_arr)),l.setAttribute(Y.TEXCOORD_1,new Float32Array(n.uv_arr)),l.addSubGeometry({indexStart:0,indexCount:n.indeice_arr.length,vertexStart:0,index:0});let h=new yi,u=this.matLibs[n.source_mat];h.baseMap=A.res.getTexture(it.normalizePath(this.baseUrl+u.map_Kd));let c=new te,f=c.addComponent(ce);f.geometry=l,f.material=h,s.addChild(c)}this.data=s}}verification(){if(this.data)return!0;throw new Error("Method not implemented.")}}o(Fo,"format","text");let bu=`
    struct ImageSize {
        srcWidth: i32,
            srcHeight : i32,
                dstWidth : i32,
                    dstHeight : i32,
    };

    @group(0) @binding(0) var<uniform>size : ImageSize;
    @group(0) @binding(1) var inputTexture: texture_2d<f32>;
    @group(0) @binding(2) var outputTexture: texture_storage_2d<rgba8unorm, write>;

    @compute @workgroup_size(8, 8, 1)
    fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {
        var uv: vec2<f32> = vec2<f32>(f32(GlobalInvocationID.x) / f32(size.dstWidth), f32(GlobalInvocationID.y) / f32(size.dstHeight));
        uv = uv * vec2<f32>(f32(size.srcWidth), f32(size.srcHeight));
        var dstId: vec2<i32> = vec2<i32>(i32(GlobalInvocationID.x), i32(GlobalInvocationID.y));
        var srcId: vec2<i32> = vec2<i32>(i32(GlobalInvocationID.x * 2u), i32(GlobalInvocationID.y * 2u));
        textureStore(outputTexture, dstId, textureLoad(inputTexture, srcId, 0));
    }
`,Su=`
    struct ImageSize {
        srcWidth: i32,
            srcHeight : i32,
                dstWidth : i32,
                    dstHeight : i32,
    };

    @group(0) @binding(0) var<uniform>size : ImageSize;
    @group(0) @binding(1) var inputTexture: texture_2d<f32>;
    @group(0) @binding(2) var outputTexture: texture_storage_2d<rgba8unorm, write>;

    fn repeat_i32(id: i32, max: i32) -> i32 {
        var ret = id;
        if (id < 0) {
            ret = max + id;
        }
        if (id >= max) {
            ret = id - max;
        }
        return ret;
    }

    fn clamp_i32(id: i32, max: i32) -> i32 {
        var ret = id;
        if (id < 0) {
            ret = 0;
        }
        if (id >= max) {
            ret = max - 1;
        }
        return ret;
    }

    fn blur(idx: u32) -> vec4 < f32 > {
        var id: vec2<i32>;
        id.y = i32(idx) / size.srcWidth;
        id.x = i32(idx) - i32(id.y) * size.srcWidth;
        var _BlurSpread: i32 = 1;
        var result = vec4<f32>(0.0, 0.0, 0.0, 0.0);
        let g: array < f32, 3u > = array<f32, 3u > (0.4026, 0.2442, 0.0545);
        var uv: vec2<i32>;
        for(var h: i32 = 0; h< 5; h = h + 1) {
        let offsetU: i32 = (h - 2) * _BlurSpread;
        uv.x = id.x + offsetU;
        uv.x = clamp_i32(uv.x, size.srcWidth);
        for (var v: i32 = 0; v < 5; v = v + 1) {
            let offsetV: i32 = (v - 2) * _BlurSpread;
            uv.y = id.y + offsetV;
            uv.y = clamp(uv.y, 0, size.srcHeight);
            let weightU: i32 = abs(h - 2);
            let weightV: i32 = abs(v - 2);
            let resultWeight: f32 = g[weightU] * g[weightV];
            var colorf32: vec4<f32> = textureLoad(inputTexture, uv, 0);
            let sampleColor: vec4<f32> = vec4<f32>(colorf32 * resultWeight);
            result = result + sampleColor;
        }
    }

    return result;
    }

    @compute @workgroup_size(8, 8, 1)
    fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {
        var uv: vec2<f32> = vec2<f32>(f32(GlobalInvocationID.x) / f32(size.dstWidth), f32(GlobalInvocationID.y) / f32(size.dstHeight));
        uv = uv * vec2<f32>(f32(size.srcWidth), f32(size.srcHeight));
        let srcIdx = i32(uv.y) * size.srcWidth + i32(uv.x);
        var dstId: vec2<i32> = vec2<i32>(i32(GlobalInvocationID.x), i32(GlobalInvocationID.y));
        textureStore(outputTexture, dstId, blur(u32(srcIdx)));
    }
`;class Iu{static blurImageFromTexture(e,t,r,s){const a=S.device;let n=s?Su:bu;const l=a.createComputePipeline({layout:"auto",compute:{module:a.createShaderModule({code:n}),entryPoint:"main"}}),h=4*4,u=a.createBuffer({size:h,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});a.queue.writeBuffer(u,0,new Uint32Array([e.width,e.height,t,r]));const c=a.createTexture({size:[t,r,1],mipLevelCount:1,format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC|GPUTextureUsage.RENDER_ATTACHMENT,label:"blurImageFromTexture"});let f=[{binding:0,resource:{buffer:u,size:4*4}},{binding:1,resource:e.gpuTexture.createView({format:"rgba8unorm",dimension:"2d",baseMipLevel:0,mipLevelCount:1})},{binding:2,resource:c.createView({format:"rgba8unorm",dimension:"2d",baseMipLevel:0,mipLevelCount:1})}];const d=a.createBindGroup({layout:l.getBindGroupLayout(0),entries:f}),p=w.beginCommandEncoder(),m=p.beginComputePass();return m.setPipeline(l),m.setBindGroup(0,d),m.dispatchWorkgroups(Math.floor(t/8),Math.floor(r/8)),m.end(),w.endCommandEncoder(p),u.destroy(),c}}class Zs extends at{constructor(){super(4,4),o(this,"width",4),o(this,"height",4),o(this,"depthOrArrayLayers",6),o(this,"visibility",GPUShaderStage.FRAGMENT),o(this,"textureBindingLayout",{viewDimension:"cube",multisampled:!1}),o(this,"samplerBindingLayout",{type:"filtering"}),this.addressModeU=Bt.clamp_to_edge,this.addressModeV=Bt.clamp_to_edge,this.addressModeW=Bt.clamp_to_edge,this.magFilter=this.minFilter="linear",this.mipmapFilter="linear",this.visibility=GPUShaderStage.FRAGMENT}createTextureDescriptor(e,t,r,s,a=GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT,n=1){this.width=e,this.height=t,this.format=s,this.usage=a,this.textureDescriptor={size:{width:e,height:t,depthOrArrayLayers:6},mipLevelCount:r,format:s,usage:a,dimension:"2d"},n>1?this.viewDescriptor={dimension:"cube-array"}:this.viewDescriptor={dimension:this.textureBindingLayout.viewDimension}}}const Eu=class{static createFace(i,e,t,r){const s=S.device;this.pipeline==null&&(this.pipeline=s.createComputePipeline({layout:"auto",compute:{module:s.createShaderModule({code:Eu.createCube}),entryPoint:"main"}}));const a=this.pipeline,n=4*4;this.configBuffer||(this.configBuffer=s.createBuffer({size:n,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST})),s.queue.writeBuffer(this.configBuffer,0,new Uint32Array([i,0,0,0])),this.blurSettingBuffer||(this.blurSettingBuffer=s.createBuffer({size:n,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST})),s.queue.writeBuffer(this.blurSettingBuffer,0,new Float32Array([0,0,0,0]));let l=[{binding:0,resource:{buffer:this.configBuffer,size:4*4}},{binding:1,resource:t.getGPUView()},{binding:2,resource:r.getGPUView()}];const h=s.createBindGroup({layout:a.getBindGroupLayout(0),entries:l}),u=w.beginCommandEncoder(),c=u.beginComputePass();c.setPipeline(a),c.setBindGroup(0,h),c.dispatchWorkgroups(e/8,e/8),c.end(),w.endCommandEncoder(u)}};let hr=Eu;o(hr,"createCube",`

struct SettingUniform {
  faceIndex : i32,
  srcHeight : i32,
  dstWidth : i32,
  dstHeight : i32
};

@group(0) @binding(0) var<uniform> settingUniform : SettingUniform;
@group(0) @binding(1) var inputTex : texture_2d<f32>;
@group(0) @binding(2) var outTex : texture_storage_2d<rgba8unorm, write>;

@compute @workgroup_size(8, 8, 1)
fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {
  let coord = vec2<i32>(GlobalInvocationID.xy);
  
  let outTexSize = textureDimensions(outTex).xy;
  let outTexel = 1.0 / vec2<f32>(outTexSize - 1);
  
  let uv_0 = vec2<f32>(coord) * outTexel;
  var oc = samplePixel(settingUniform.faceIndex, uv_0);
  textureStore(outTex, coord, oc);
}

fn samplePixel(face:i32, uv01:vec2<f32>) -> vec4<f32> {
    let rectangle_v2_f32 = round(vec2<f32>(0.25, 0.33333) * vec2<f32>(textureDimensions(inputTex).xy));
    let rectangle = vec2<i32>(rectangle_v2_f32);
    
    var offsetIndex = vec2<i32>(0);
    if(face == 0){
        offsetIndex.x = 2;
        offsetIndex.y = 1;
    }else if(face == 1){
        offsetIndex.x = 0;
        offsetIndex.y = 1;
    }else if(face == 2){
        offsetIndex.x = 1;
        offsetIndex.y = 0;
    }else if(face == 3){
        offsetIndex.x = 1;
        offsetIndex.y = 2;
    }else if(face == 4){
        offsetIndex.x = 1;
        offsetIndex.y = 1;
    }else if(face == 5){
        offsetIndex.x = 3;
        offsetIndex.y = 1;
    }
    
    let coordOffset = rectangle * offsetIndex;
    let coordIndex = vec2<i32>(vec2<f32>(rectangle - 1) * uv01);
    var oc = textureLoad(inputTex, coordOffset + coordIndex, 0);
    return oc;
}
`),o(hr,"configBuffer",null),o(hr,"blurSettingBuffer",null),o(hr,"pipeline");class ko extends Zs{constructor(){super(),o(this,"_images"),o(this,"_url"),this.useMipmap=!0}generateImages(e){let t=S.device;this.width=this.height=32,"width"in e[0]&&(this.width=this.height=e[0].width);let r=Math.min(this.width,this.height);for(this.mipmapCount=1;r>16;)r/=2,this.mipmapCount++;this.textureBindingLayout.viewDimension="cube",this.samplerBindingLayout.type="filtering",this.createTextureDescriptor(this.width,this.height,this.mipmapCount,this.format),this.textureDescriptor.size={width:this.width,height:this.height,depthOrArrayLayers:6},this.textureDescriptor.dimension="2d",this.gpuTexture=t.createTexture(this.textureDescriptor);let s=[],a=s,n=this.width,l=this.height;if(e[0]instanceof at){for(let h=0;h<6;h++){let u=e[h];s[h]=u.getGPUTexture()}this.uploadMipmapGPUTexture(0,this.width,this.width,s)}else{this.uploadBaseImages(this.width,e);for(let h=0;h<6;h++){let u=new ii(!1);u.format=this.format,u.source=e[h],s[h]=u.getGPUTexture()}}for(let h=1;h<this.mipmapCount;h++){a=s,s=[];let u={width:n,height:l,gpuTexture:null};n=n/2,l=l/2;for(let c=0;c<6;c++)u.gpuTexture=a[c],s[c]=Iu.blurImageFromTexture(u,n,l,!1);this.uploadMipmapGPUTexture(h,n,l,s)}this.gpuSampler=t.createSampler(this)}uploadBaseImages(e,t){let r=S.device;const s=w.beginCommandEncoder();for(let a=0;a<6;a++)r.queue.copyExternalImageToTexture({source:t[a]},{texture:this.gpuTexture,mipLevel:0,origin:{x:0,y:0,z:a}},{width:e,height:e,depthOrArrayLayers:1});w.endCommandEncoder(s)}uploadMipmapGPUTexture(e,t,r,s){const a=w.beginCommandEncoder();for(let n=0;n<6;n++)a.copyTextureToTexture({texture:s[n],mipLevel:0,origin:{x:0,y:0,z:0}},{texture:this.gpuTexture,mipLevel:e,origin:{x:0,y:0,z:n}},{width:t,height:r,depthOrArrayLayers:1});w.endCommandEncoder(a)}get images(){return this._images}set images(e){if(this._images=e,this._images[0]instanceof HTMLImageElement){let t=function(n,l){l.decode().then(async()=>{r[n]=await createImageBitmap(l),s--,s==0&&a.generateImages(r)})},r=[],s=6,a=this;for(let n=0;n<6;n++)t(n,this._images[n])}else(this._images instanceof HTMLCanvasElement||this._images instanceof ImageBitmap)&&this.generateImages(this._images)}async load(e){this._url=e;let t=6,r=[];this.format=G.rgba8unorm;let s=this;async function a(n,l){const h=document.createElement("img");if(h.src=l,h.setAttribute("crossOrigin",""),await h.decode(),r[n]=await createImageBitmap(h),t--,t==0)return s.generateImages(r),!0}for(let n=0;n<6;n++)await a(n,e[n]);return!0}async loadStd(e){this._url=e,this.format=G.rgba8unorm;const t=document.createElement("img");t.src=e,t.setAttribute("crossOrigin",""),await t.decode();let r=new ii(!1);r.name=it.getURLName(e),r.format="rgba8unorm",r.source=await createImageBitmap(t);let s=Math.round(Math.log2(r.width/4));s=Math.pow(2,s),this.width=this.height=s;let a=[];for(let n=0;n<6;n++){let l=new oe(s,s,this.format,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_SRC|GPUTextureUsage.TEXTURE_BINDING);l.name="face "+n,a.push(l),hr.createFace(n,this.width,r,l)}return this.generateImages(a),!0}}var Bu=(i=>(i[i.Left=0]="Left",i[i.Right=1]="Right",i[i.Bottom=2]="Bottom",i[i.Top=3]="Top",i[i.Back=4]="Back",i[i.Front=5]="Front",i))(Bu||{});class zo{static getRotationToFace(e){let t=q.identity().clone(),r=new g,s=new V().identity(),a=new g;switch(e){case 3:r.set(0,-1,0),a.set(0,0,-1);break;case 2:r.set(0,1,0),a.set(0,0,1);break;case 1:r.set(1,0,0),a.set(0,1,0);break;case 0:r.set(-1,0,0),a.set(0,1,0);break;case 4:r.set(0,0,-1),a.set(0,1,0);break;case 5:return q.identity()}return s.lookAt(new g,r,a),t.setFromRotationMatrix(s),t}}let Tu=`
  struct ImageSize {
    srcWidth : i32,
    srcHeight : i32,
    dstWidth : i32,
    dstHeight : i32
  };

  @group(0) @binding(0) var<uniform> size : ImageSize;
  @group(0) @binding(1) var<storage,read_write> faceRotation: array<vec4<f32>>;
  @group(0) @binding(2) var inputTexSampler : sampler;
  @group(0) @binding(3) var inputTex : texture_2d<f32>;

  @group(1) @binding(0) var outputBuffer0 : texture_storage_2d_array<rgba16float, write>;

  fn SampleSphericalMap(v: vec3<f32>) -> vec2<f32> {
      var uv:vec2<f32> = vec2<f32>(atan2(v.z, v.x), asin(v.y));
      //uv = (uv * (vec2<f32>(0.1590999960899353, 0.3183000087738037) + vec2<f32>(0.0010000000474974513)));
      uv = uv * vec2<f32>(0.1590999960899353, 0.3183000087738037);
      uv = uv + vec2<f32>(0.5);
      uv = clamp(uv, vec2<f32>(0.0), vec2<f32>(1.0));
      return uv;
  }


  fn applyQuaternion(position:vec3<f32>, q:vec4<f32>) -> vec3<f32>{
      let x:f32 = position.x;
      let y:f32 = position.y;
      let z:f32 = position.z;

      let qx:f32 = q.x;
      let qy:f32 = q.y;
      let qz:f32 = q.z;
      let qw:f32 = q.w;

      let ix:f32 = qw * x + qy * z - qz * y;
      let iy:f32 = qw * y + qz * x - qx * z;
      let iz:f32 = qw * z + qx * y - qy * x;
      let iw:f32 = -qx * x - qy * y - qz * z;

      var ret: vec3<f32>;
      ret.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
      ret.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
      ret.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;

      return ret;
  }

  fn convertIdToDir3(uv_i32:vec2<i32>, quaternion:vec4<f32>) -> vec3<f32>{
      var uv_f32:vec2<f32> = vec2<f32>(uv_i32.xy);
      var halfSize:f32 = f32(size.dstWidth / 2) - 0.5;
      var worldDirection:vec3<f32> = vec3<f32>(uv_f32.x - halfSize, uv_f32.y - halfSize, -halfSize);
      worldDirection = normalize(worldDirection);
      worldDirection = applyQuaternion(worldDirection, quaternion);
      return worldDirection;
  }

  @compute @workgroup_size(8, 8, 1)
  fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {
    let coord = vec2<i32>(GlobalInvocationID.xy);
    let quaternion = faceRotation[GlobalInvocationID.z];
    var worldDirection:vec3<f32> = convertIdToDir3(coord, quaternion);
    let uv_f32:vec2<f32> = SampleSphericalMap(worldDirection);
    let oc = textureSampleLevel(inputTex, inputTexSampler, uv_f32 , 0.0);
    textureStore(outputBuffer0, coord, i32(GlobalInvocationID.z), oc);
  }
`,Mu=`
  struct ImageSize {
    srcWidth : i32,
    srcHeight : i32,
    dstWidth : i32,
    dstHeight : i32
  };

  @group(0) @binding(0) var<uniform> size : ImageSize;
  @group(0) @binding(1) var<storage, read> tex_in: array<vec4<f32>>;
  @group(0) @binding(2) var outputBuffer : texture_storage_2d<rgba16float, write>;

  @compute @workgroup_size(8, 8, 1)
  fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {
    let fragCoord = vec2<i32>(i32(GlobalInvocationID.x), i32(GlobalInvocationID.y));
    var oc:vec4<f32> = tex_in[fragCoord.y * size.srcWidth + fragCoord.x] / 256.0;
    var e = pow(2.0, oc.w * 255.0 - 128.0);
    oc = oc * e;
    oc = scaleByThreshold(oc, 40.0);
    textureStore(outputBuffer, fragCoord , vec4<f32>(oc.xyz, 1.0) );
  }

  fn scaleByThreshold(color:vec4<f32>, threshold:f32) -> vec4<f32>{
    var oc = color;
    let brightness = length(vec3<f32>(oc.xyz));
    var scale = brightness / threshold;
    if(scale > 1.0){
        scale = 1.0 / pow(scale, 0.7);
        oc = oc * scale;
    }
    oc.a = 1.0;
    return oc;
  }
`;const It=class{static convertRGBE2RGBA(i,e){const t=S.device,r=t.createComputePipeline({layout:"auto",compute:{module:t.createShaderModule({code:Mu}),entryPoint:"main"}}),s=t.createBuffer({size:4*4,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});t.queue.writeBuffer(s,0,new Uint32Array([i.width,i.height,i.width,i.height]));const a=t.createBuffer({size:e.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC});t.queue.writeBuffer(a,0,e);let n=[{binding:0,resource:{buffer:s,size:4*4}},{binding:1,resource:{buffer:a,size:e.byteLength}},{binding:2,resource:i.getGPUView()}];const l=t.createBindGroup({layout:r.getBindGroupLayout(0),entries:n}),h=w.beginCommandEncoder(),u=h.beginComputePass();u.setPipeline(r),u.setBindGroup(0,l),u.dispatchWorkgroups(Math.floor(i.width/8),Math.floor(i.height/8)),u.end(),w.endCommandEncoder(h),s.destroy()}static makeTextureCube(i,e,t){const r=S.device;It.makeFaceTexturePipeline||(It.makeFaceTexturePipeline=r.createComputePipeline({layout:"auto",compute:{module:r.createShaderModule({code:Tu}),entryPoint:"main"}}));const s=It.makeFaceTexturePipeline,a=4*4;It.configBuffer||(It.configBuffer=r.createBuffer({size:a,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST})),r.queue.writeBuffer(It.configBuffer,0,new Uint32Array([i.width,i.height,e,e]));const n=4*6;if(!It.quaternionBuffer){It.quaternionBuffer=r.createBuffer({size:n*4*6,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST});let p=new Float32Array(4*6);for(let m=0;m<6;m++){let _=zo.getRotationToFace(m);p[m*4+0]=_.x,p[m*4+1]=_.y,p[m*4+2]=_.z,p[m*4+3]=_.w}r.queue.writeBuffer(It.quaternionBuffer,0,p)}let l=[{binding:0,resource:{buffer:It.configBuffer,size:4*4}},{binding:1,resource:{buffer:It.quaternionBuffer,size:n*4}},{binding:2,resource:i.gpuSampler},{binding:3,resource:i.getGPUView()}],h=[{binding:0,resource:t}];const u=r.createBindGroup({layout:s.getBindGroupLayout(0),entries:l}),c=r.createBindGroup({layout:s.getBindGroupLayout(1),entries:h}),f=w.beginCommandEncoder(),d=f.beginComputePass();d.setPipeline(s),d.setBindGroup(0,u),d.setBindGroup(1,c),d.dispatchWorkgroups(e/8,e/8,6),d.end(),w.endCommandEncoder(f)}};let Di=It;o(Di,"makeFaceTexturePipeline"),o(Di,"configBuffer"),o(Di,"quaternionBuffer");class Go extends at{constructor(){super(32,32,null),this.isHDRTexture=!0}create(e=32,t=32,r=null,s=!0){this.width=e,this.height=t;let a=S.device;const n=2,l=e*4*n;let h=r;this.format=G.rgba16float,this.useMipmap=s,this.updateTextureDescription(),this.updateGPUTexture();const u=a.createBuffer({size:h.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC});a.queue.writeBuffer(u,0,h);const c=w.beginCommandEncoder();return c.copyBufferToTexture({buffer:u,bytesPerRow:l},{texture:this.getGPUTexture()},{width:e,height:t,depthOrArrayLayers:1}),w.endCommandEncoder(c),this.useMipmap||(this.samplerBindingLayout.type="filtering",this.textureBindingLayout.sampleType="float"),this.gpuSampler=a.createSampler(this),this}async load(e,t){return(await new ht().load(e,$s,t)).getHDRTexture()}}const Du=new Float32Array(1),Qg=new Int32Array(Du.buffer);let ur=function(i){Du[0]=i;const e=Qg[0];let t=e>>16&32768,r=e>>12&2047;const s=e>>23&255;return s<103?t:s>142?(t|=31744,t|=(s==255?1:0)&&e&8388607,t):s<114?(r|=2048,t|=(r>>114-s)+(r>>113-s&1),t):(t|=s-112<<10|r>>1,t+=r&1,t)};var Pu=(i=>(i[i.RGBE_RETURN_FAILURE=-1]="RGBE_RETURN_FAILURE",i[i.rgbe_read_error=1]="rgbe_read_error",i[i.rgbe_write_error=2]="rgbe_write_error",i[i.rgbe_format_error=3]="rgbe_format_error",i[i.rgbe_memory_error=4]="rgbe_memory_error",i))(Pu||{});class Qo{constructor(){o(this,"valid"),o(this,"string"),o(this,"comments"),o(this,"programtype"),o(this,"format"),o(this,"gamma"),o(this,"exposure"),o(this,"width"),o(this,"height")}}class $s extends Xt{constructor(){super(...arguments),o(this,"_rgbeArray"),o(this,"_width"),o(this,"_height"),o(this,"_RGBE_RETURN_FAILURE",-1),o(this,"_parserType",G.rgba8uint)}parseBuffer(e){let t,r=new Uint8Array(e);r.pos=0;const s=this.paserHeader(r);if(s instanceof Qo){const a=this._width=s.width,n=this._height=s.height;let l=this.parserPixel(r.subarray(r.pos),a,n);if(l instanceof Uint8Array){switch(this._rgbeArray=l,this._parserType){}return this.data=t,t}}return null}verification(){if(this.data&&this.data instanceof at)return!0;if(this._rgbeArray)return!0;throw new Error("Method not implemented.")}getTexture(){return this.data}getCubeTexture(){let e=this._width/4;return new ea().createFromHDRData(e,{width:this._width,height:this._height,array:this._rgbeArray})}getHDRTexture(){return new Go().create(this._width,this._height,this._rgbeArray)}parseError(e,t){switch(e){case 1:console.error("Read Error: "+(t||""));break;case 2:console.error("Write Error: "+(t||""));break;case 3:console.error("Bad File Format: "+(t||""));break;default:case 4:console.error("Error: "+(t||""))}return-1}parserBlock(e,t,r){t=t||1024;let a=e.pos,n=-1,l=0,h="",u=String.fromCharCode.apply(null,new Uint16Array(e.subarray(a,a+128)));const c=`
`;for(;0>(n=u.indexOf(c))&&l<t&&a<e.byteLength;)h+=u,l+=u.length,a+=128,u+=String.fromCharCode.apply(null,new Uint16Array(e.subarray(a,a+128)));return-1<n?(r!==!1&&(e.pos+=l+n+1),h+u.slice(0,n)):!1}paserHeader(e){const t=/^#\?(\S+)/,r=/^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,s=/^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,a=/^\s*FORMAT=(\S+)\s*$/,n=/^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,l=new Qo;let h,u;if(e.pos>=e.byteLength||!(h=this.parserBlock(e)))return this.parseError(1,"no header found");if(!(u=h.match(t)))return this.parseError(3,"bad initial token");const c=1,f=2,d=4;for(l.valid|=c,l.programtype=u[1],l.string+=h+`
`;h=this.parserBlock(e),h!==!1;){if(l.string+=h+`
`,h.charAt(0)==="#"){l.comments+=h+`
`;continue}if((u=h.match(r))&&(l.gamma=Math.floor(parseFloat(u[1])*10)/10),(u=h.match(s))&&(l.exposure=Math.floor(parseFloat(u[1])*10)/10),(u=h.match(a))&&(l.valid|=f,l.format=u[1]),(u=h.match(n))&&(l.valid|=d,l.height=parseInt(u[1],10),l.width=parseInt(u[2],10)),l.valid&f&&l.valid&d)break}return l.valid&f?l.valid&d?l:(this.parseError(3,"missing image size specifier"),null):(this.parseError(3,"missing format specifier"),null)}parserPixel(e,t,r){const s=t;if(s<8||s>32767||e[0]!==2||e[1]!==2||e[2]&128)return new Uint8Array(e);if(s!==(e[2]<<8|e[3]))return this.parseError(3,"wrong scanline width");const a=new Uint8Array(4*t*r);if(!a.length)return this.parseError(4,"unable to allocate buffer space");let n=0,l=0;const h=4*s,u=new Uint8Array(4),c=new Uint8Array(h);let f=r;for(;f>0&&l<e.byteLength;){if(l+4>e.byteLength)return this.parseError(1,"");if(u[0]=e[l++],u[1]=e[l++],u[2]=e[l++],u[3]=e[l++],u[0]!=2||u[1]!=2||(u[2]<<8|u[3])!=s)return this.parseError(3,"bad rgbe scanline format");let d=0,p;for(;d<h&&l<e.byteLength;){p=e[l++];const _=p>128;if(_&&(p-=128),p===0||d+p>h)return this.parseError(3,"bad scanline data");if(_){const v=e[l++];for(let y=0;y<p;y++)c[d++]=v}else c.set(e.subarray(l,l+p),d),d+=p,l+=p}const m=s;for(let _=0;_<m;_++){let v=0;a[n]=c[_+v],v+=s,a[n+1]=c[_+v],v+=s,a[n+2]=c[_+v],v+=s,a[n+3]=c[_+v],n+=4}f--}return a}rbgeToFloat(e,t,r,s){const a=e[t+3],n=Math.pow(2,a-128)/255;r[s+0]=e[t+0]*n,r[s+1]=e[t+1]*n,r[s+2]=e[t+2]*n,r[s+3]=1}rbgeToHalfFloat(e,t,r,s){const a=e[t+3],n=Math.pow(2,a-128)/255;r[s+0]=ur(e[t+0]*n),r[s+1]=ur(e[t+1]*n),r[s+2]=ur(e[t+2]*n),r[s+3]=ur(1)}}o($s,"format","bin");let Ru=`
    struct ImageSize {
        srcWidth : i32,
        srcHeight : i32,
        dstWidth : i32,
        dstHeight : i32
    };
    
    @group(0) @binding(0) var<uniform> size : ImageSize;
    @group(0) @binding(1) var<storage,read_write> faceRotation: array<vec4<f32>>;
    @group(0) @binding(2) var inputTexSampler : sampler;
    @group(0) @binding(3) var inputTex : texture_2d<f32>;
    
    @group(1) @binding(0) var<uniform> blurSetting : vec4<f32>;
    @group(1) @binding(1) var outputBuffer0 : texture_storage_2d_array<rgba16float, write>;
    
    var<private> PI: f32 = 3.14159265359;
    
    fn applyQuaternion(position:vec3<f32>, q:vec4<f32>) -> vec3<f32>{
        let x:f32 = position.x;
        let y:f32 = position.y;
        let z:f32 = position.z;
    
        let qx:f32 = q.x;
        let qy:f32 = q.y;
        let qz:f32 = q.z;
        let qw:f32 = q.w;
    
        let ix:f32 = qw * x + qy * z - qz * y;
        let iy:f32 = qw * y + qz * x - qx * z;
        let iz:f32 = qw * z + qx * y - qy * x;
        let iw:f32 = -qx * x - qy * y - qz * z;
    
        var ret: vec3<f32>;
        ret.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
        ret.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
        ret.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    
        return ret;
    }
    
    fn convertIdToDir3(uv_i32:vec2<i32>, quaternion:vec4<f32>) -> vec3<f32>{
        var uv_f32:vec2<f32> = vec2<f32>(uv_i32.xy);
        var halfSize:f32 = f32(size.dstWidth / 2);
        var worldDirection:vec3<f32> = vec3<f32>(uv_f32.x - halfSize, uv_f32.y - halfSize, -halfSize);
        worldDirection = normalize(worldDirection);
        worldDirection = applyQuaternion(worldDirection, quaternion);
        return worldDirection;
    }
    
    fn VanDerCorpus(n0:u32, base0:u32) -> f32
    {
        var n = n0;
        var base = base0;
        var invBase:f32 = 1.0 / f32(base);
        var denom:f32   = 1.0;
        var result:f32  = 0.0;
    
        for(var i:u32 = 0u; i < 32u; i = i + 1u)
        {
            if(n > 0u)
            {
                denom   = f32(n) % 2.0;
                result = result + denom * invBase;
                invBase = invBase / 2.0;
                n       = u32(f32(n) / 2.0);
            }
        }
    
        return result;
    }
    
    fn HammersleyNoBitOps(i:u32, N:u32) -> vec2<f32>
    {
        return vec2(f32(i)/f32(N), VanDerCorpus(i, 2u));
    }
    
    fn hammersley( i : u32 ,  N : u32 ) -> vec2<f32>
    {
        // Radical inverse based on http://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html
        var bits = (i << 16u) | (i >> 16u);
        bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);
        bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);
        bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);
        bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);
        var rdi = f32(bits) * 2.3283064365386963e-10;
        return vec2<f32>(f32(i) /f32(N), rdi);
    }
    
    fn ImportanceSampleGGX( Xi:vec2<f32>, N:vec3<f32>, roughness:f32) ->vec3<f32>
    {
        var a = roughness*roughness;
    
        var phi = 2.0 * PI * Xi.x;
        var cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a*a - 1.0) * Xi.y));
        var sinTheta = sqrt(1.0 - cosTheta*cosTheta);
    
        // from spherical coordinates to cartesian coordinates
        var H:vec3<f32>;
        H.x = cos(phi) * sinTheta;
        H.y = sin(phi) * sinTheta;
        H.z = cosTheta;
    
        // from tangent-space vector to world-space sample vector
        var up:vec3<f32>;
        if(abs(N.z) < 0.999)
        {
            up = vec3<f32>(0.0, 0.0, 1.0);
        }
        else
        {
            up = vec3<f32>(1.0, 0.0, 0.0);
        }
        var tangent:vec3<f32>  = normalize(cross(up, N));
        var bitangent:vec3<f32> = cross(N, tangent);
        var sampleVec:vec3<f32> = tangent * H.x + bitangent * H.y + N * H.z;
        return normalize(sampleVec);
    }
    
    fn multiSample(localPos:vec3<f32>, roughness:f32) -> vec4<f32>
    {
        var N: vec3<f32> = normalize(localPos);
        var R: vec3<f32> = N;
        var V: vec3<f32> = R;
    
        let SAMPLE_COUNT:u32 = 1024u;
        var totalWeight:f32 = 0.0;
        var prefilteredColor:vec3<f32> = vec3<f32>(0.0, 0.0, 0.0);
        for(var i:u32 = 0u; i < SAMPLE_COUNT; i = i + 1u)
        {
            var Xi:vec2<f32> = hammersley(i, SAMPLE_COUNT);
            var H :vec3<f32> = ImportanceSampleGGX(Xi, N, roughness);
            var L :vec3<f32> = normalize(2.0 * dot(V, H) * H - V);
    
            var NdotL:f32 = max(dot(N, L), 0.0);
            if(NdotL > 0.0)
            {
                var att = 1.0 ;//( f32(SAMPLE_COUNT - i) / f32(SAMPLE_COUNT)) ;
    
                prefilteredColor = prefilteredColor + sampleColor(L).rgb * NdotL;
                prefilteredColor = prefilteredColor * att ;
                totalWeight      = totalWeight + NdotL;
            }
        }
        prefilteredColor = prefilteredColor / totalWeight;
    
        return vec4<f32>(prefilteredColor, 1.0);
    }
    
    fn SampleSphericalMap(v: vec3<f32>) -> vec2<f32> {
        var uv:vec2<f32> = vec2<f32>(atan2(v.z, v.x), asin(v.y));
        //uv = (uv * (vec2<f32>(0.1590999960899353, 0.3183000087738037) + vec2<f32>(0.0010000000474974513)));
        uv = uv * vec2<f32>(0.1590999960899353, 0.3183000087738037);
        uv = uv + vec2<f32>(0.5);
        uv = clamp(uv, vec2<f32>(0.0), vec2<f32>(1.0));
        return uv;
    }
    
    fn sampleColor(d:vec3<f32>) -> vec4<f32>
    {
        let uv_f32:vec2<f32> = SampleSphericalMap(d);
        let oc = textureSampleLevel(inputTex, inputTexSampler, uv_f32 , 0.0);
        //let dir = vec3<f32>(-d.x, -d.y, d.z);
        //var oc:vec4<f32> = textureSampleLevel(cubeMap, cubeMapSampler, dir, 0.0);
        return oc;
    }
    
    @compute @workgroup_size(8, 8, 1)
    fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {
        let coord = vec2<i32>(GlobalInvocationID.xy);
        let quaternion = faceRotation[GlobalInvocationID.z];
        var worldDirection:vec3<f32> = convertIdToDir3(coord, quaternion);
        var oc:vec4<f32> = multiSample(worldDirection, blurSetting.x);
        textureStore(outputBuffer0, coord, i32(GlobalInvocationID.z), oc);
    }

`;class cr{static importantSample(e,t,r,s){const a=S.device;this.pipeline==null&&(this.pipeline=a.createComputePipeline({layout:"auto",compute:{module:a.createShaderModule({code:Ru}),entryPoint:"main"}}));const n=this.pipeline,l=4*4;this.configBuffer||(this.configBuffer=a.createBuffer({size:l,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST})),a.queue.writeBuffer(this.configBuffer,0,new Uint32Array([e.width,e.height,t,t]));const h=4*6;if(!this.quaternionBuffer){this.quaternionBuffer=a.createBuffer({size:h*4*6,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST});let v=new Float32Array(4*6);for(let y=0;y<6;y++){let C=zo.getRotationToFace(y);v[y*4+0]=C.x,v[y*4+1]=C.y,v[y*4+2]=C.z,v[y*4+3]=C.w}a.queue.writeBuffer(this.quaternionBuffer,0,v)}this.blurSettingBuffer||(this.blurSettingBuffer=a.createBuffer({size:l,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST})),a.queue.writeBuffer(this.blurSettingBuffer,0,new Float32Array([r,0,0,0]));const u=e.erpTexture;let c=[{binding:0,resource:{buffer:this.configBuffer,size:4*4}},{binding:1,resource:{buffer:this.quaternionBuffer,size:h*4}},{binding:2,resource:u.gpuSampler},{binding:3,resource:u.getGPUView()}],f=[{binding:0,resource:{buffer:this.blurSettingBuffer,size:4*4}},{binding:1,resource:s}];const d=a.createBindGroup({layout:n.getBindGroupLayout(0),entries:c}),p=a.createBindGroup({layout:n.getBindGroupLayout(1),entries:f}),m=w.beginCommandEncoder(),_=m.beginComputePass();_.setPipeline(n),_.setBindGroup(0,d),_.setBindGroup(1,p),_.dispatchWorkgroups(t/8,t/8,6),_.end(),w.endCommandEncoder(m)}}o(cr,"configBuffer",null),o(cr,"quaternionBuffer",null),o(cr,"blurSettingBuffer",null),o(cr,"pipeline");class Vo{constructor(e){o(this,"faceTextureRef"),o(this,"_texture"),this._texture=e,this.faceTextureRef={}}uploadTexture(e,t){let r=this.getGpuSource(e);return Di.makeTextureCube(t,this._texture.width,r.v),this}uploadErpTexture(e){let t=this.getGpuSource(0);return Di.makeTextureCube(e,this._texture.width,t.v),this.generateMipmap(e),this}getGpuSource(e){let t=this.faceTextureRef[e];return t||(t={t:this._texture.getGPUTexture(),v:this._texture.getGPUTexture().createView({format:this._texture.format,dimension:"2d-array",baseMipLevel:e,mipLevelCount:1,arrayLayerCount:6})},this.faceTextureRef[e]=t),t}generateMipmap(e){let t=1;for(;t<this._texture.mipmapCount;)this.generateMipmapAtLevel(t,e),t++}generateMipmapAtLevel(e,t,r=3){let s=this._texture.width/Math.pow(2,e),a={width:s,height:s,erpTexture:t},n=(e+1)/this._texture.mipmapCount;n=Math.pow(n,r);let l=this.getGpuSource(e);cr.importantSample(a,s,n,l.v)}}class ea extends Zs{constructor(){super(),o(this,"_url"),o(this,"_faceData"),this.useMipmap=!0,this.format=G.rgba16float,this.isHDRTexture=!0,this._faceData=new Vo(this)}createFromHDRData(e,t){let r=new oe(t.width,t.height,G.rgba16float,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING),s=new Float32Array(t.array);return Di.convertRGBE2RGBA(r,s),this.createFromTexture(e,r),this}createFromTexture(e,t){this.width=this.height=e,this.textureBindingLayout.viewDimension="cube";let r=this.width;for(this.mipmapCount=1;r>16;)r/=2,this.mipmapCount++;return this.createTextureDescriptor(e,e,this.mipmapCount,this.format),this.textureDescriptor.size={width:e,height:e,depthOrArrayLayers:6},this.textureDescriptor.dimension="2d",this.gpuSampler=S.device.createSampler(this),this._faceData.uploadErpTexture(t),this}async load(e,t){return this._url=e,(await new ht().load(e,$s,t)).getCubeTexture()}}function Lu(i){return new TextDecoder().decode(i)}class ta{constructor(e,t,r,s){o(this,"buffer"),o(this,"binOffset"),o(this,"binLength"),o(this,"header"),this.buffer=e,this.binOffset=t+r,this.binLength=s;let a=null;if(r!==0){const n=new Uint8Array(e,t,r);a=JSON.parse(Lu(n))}else a={};this.header=a}getKeys(){return Object.keys(this.header)}getData(e,t,r=null,s=null){const a=this.header;if(!(e in a))return null;const n=a[e];if(n instanceof Object){if(Array.isArray(n))return n;{const{buffer:l,binOffset:h,binLength:u}=this,c=n.byteOffset||0,f=n.type||s,d=n.componentType||r;if("type"in n&&s&&n.type!==s)throw new Error("FeatureTable: Specified type does not match expected type.");let p;switch(f){case"SCALAR":p=1;break;case"VEC2":p=2;break;case"VEC3":p=3;break;case"VEC4":p=4;break;default:throw new Error(`FeatureTable : Feature type not provided for "${e}".`)}let m;const _=h+c,v=t*p;switch(d){case"BYTE":m=new Int8Array(l,_,v);break;case"UNSIGNED_BYTE":m=new Uint8Array(l,_,v);break;case"SHORT":m=new Int16Array(l,_,v);break;case"UNSIGNED_SHORT":m=new Uint16Array(l,_,v);break;case"INT":m=new Int32Array(l,_,v);break;case"UNSIGNED_INT":m=new Uint32Array(l,_,v);break;case"FLOAT":m=new Float32Array(l,_,v);break;case"DOUBLE":m=new Float64Array(l,_,v);break;default:throw new Error(`FeatureTable : Feature component type not provided for "${e}".`)}if(_+v*m.BYTES_PER_ELEMENT>h+u)throw new Error("FeatureTable: Feature data read outside binary body length.");return m}}else return n}}class Ho extends ta{constructor(e,t,r,s,a){super(e,r,s,a),o(this,"batchSize"),this.batchSize=t}getData(e,t=null,r=null){return super.getData(e,this.batchSize,t,r)}}function Yo(i){let e;if(i instanceof DataView?e=i:e=new DataView(i),String.fromCharCode(e.getUint8(0))==="{")return null;let t="";for(let r=0;r<4;r++)t+=String.fromCharCode(e.getUint8(r));return t}class Uu{async parse(e){const t=new DataView(e),r=Yo(t);console.assert(r==="b3dm");const s=t.getUint32(4,!0);console.assert(s===1);const a=t.getUint32(8,!0);console.assert(a===e.byteLength);const n=t.getUint32(12,!0),l=t.getUint32(16,!0),h=t.getUint32(20,!0),u=t.getUint32(24,!0),c=28,f=new ta(e,c,n,l),d=c+n+l,p=new Ho(e,f.getData("BATCH_LENGTH"),d,h,u),m=d+h+u,_=new Uint8Array(e,m,a-m);return{version:s,featureTable:f,batchTable:p,glbBytes:_}}}const ia=class extends Uu{constructor(){super(),o(this,"adjustmentTransform"),o(this,"gltfBuffer"),this.adjustmentTransform=new V().identity(),ia.tempMatrix||(ia.tempMatrix=new V().identity())}async parse(i){const e=await super.parse(i);this.gltfBuffer=e.glbBytes.slice().buffer;let r=await new jo().parseBinary(this.gltfBuffer),{batchTable:s,featureTable:a}=e;const n=a.getData("RTC_CENTER");n&&(r.x+=n[0],r.y+=n[1],r.z+=n[2]);let l=r.getComponent(Oe);l.updateWorldMatrix();let h=ia.tempMatrix;h.compose(l.localPosition,l.localRotQuat,l.localScale),h.multiply(this.adjustmentTransform);let u=h.decompose(yt.QUATERNION);return l.localRotQuat.copyFrom(u[1]),l.localRotQuat=l.localRotQuat,l.localPosition.copyFrom(u[0]),l.localPosition=l.localPosition,l.localScale.copyFrom(u[2]),l.localScale=l.localScale,l.updateWorldMatrix(),r.batchTable=s,r.featureTable=a,r}static decodeText(i){if(typeof TextDecoder<"u")return new TextDecoder().decode(i);let e="";for(let t=0,r=i.length;t<r;t++)e+=String.fromCharCode(i[t]);try{return decodeURIComponent(escape(e))}catch{return e}}};let Pi=ia;o(Pi,"tempMatrix");class Xo extends Xt{async parseBuffer(e){let t=new Pi;t.adjustmentTransform=this.userData,this.data=await t.parse(e)}verification(){if(this.data)return!0;throw new Error("Method not implemented.")}}o(Xo,"format","bin");const Ou="glTF",ns=12,Nu={JSON:1313821514,BIN:5130562},Wo={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_IOR:"KHR_materials_ior",KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:"KHR_materials_pbrSpecularGlossiness",KHR_MATERIALS_SHEEN:"KHR_materials_sheen",KHR_MATERIALS_SPECULAR:"KHR_materials_specular",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_MATERIALS_VOLUME:"KHR_materials_volume",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression"};class Fu{constructor(e){o(this,"name"),o(this,"content"),o(this,"body"),o(this,"header"),this.name=Wo.KHR_BINARY_GLTF,this.content=null,this.body=null;const t=new DataView(e,0,ns);if(this.header={magic:Pi.decodeText(new Uint8Array(e.slice(0,4))),version:t.getUint32(4,!0),length:t.getUint32(8,!0)},this.header.magic!==Ou)throw new Error("GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("GLTFLoader: Legacy binary file detected.");const r=this.header.length-ns,s=new DataView(e,ns);let a=0;for(;a<r;){const n=s.getUint32(a,!0);a+=4;const l=s.getUint32(a,!0);if(a+=4,l===Nu.JSON){const h=new Uint8Array(e,ns+a,n);this.content=Pi.decodeText(h)}else if(l===Nu.BIN){const h=ns+a;this.body=e.slice(h,h+n)}a+=n}if(this.content===null)throw new Error("GLTFLoader: JSON content not found.")}}class jo{constructor(){o(this,"_binary")}async parseBinary(e){this._binary=e;const t=Pi.decodeText(new Uint8Array(this._binary,0,4)),r={};let s,a;if(t===Ou){try{a=r[Wo.KHR_BINARY_GLTF]=new Fu(this._binary)}catch{return}s=r[Wo.KHR_BINARY_GLTF].content}else s=Pi.decodeText(new Uint8Array(this._binary));const n=JSON.parse(s);return await this.parseGLB(n,a.body)}async parseGLB(e,t){return await new qs().parseJsonAndBuffer(e,t)}}class ku{async parse(e){const t=new DataView(e),r=Yo(t);console.assert(r==="i3dm");const s=t.getUint32(4,!0);console.assert(s===1);const a=t.getUint32(8,!0);console.assert(a===e.byteLength);const n=t.getUint32(12,!0),l=t.getUint32(16,!0),h=t.getUint32(20,!0),u=t.getUint32(24,!0);t.getUint32(28,!0);const c=32,f=new ta(e,c,n,l),d=c+n+l,p=new Ho(e,f.getData("INSTANCES_LENGTH"),d,h,u),m=d+h+u,_=new Uint8Array(e,m,a-m);return{version:s,featureTable:f,batchTable:p,glbBytes:_}}}class zu extends te{constructor(e,t,r){super(),o(this,"_geometry"),o(this,"_material"),o(this,"_instanceList"),this._geometry=e,this._material=t,this._instanceList=[];for(let s=0;s<r;s++){let a,n=new te;a=n.addComponent(ce),a.geometry=this._geometry,a.material=this._material,this.addChild(n),this._instanceList.push(n)}}setMatrixAt(e,t){let r=this._instanceList[e],s=t.decompose(yt.QUATERNION),a=r.transform;return a.localRotQuat.copyFrom(s[1]),a.localRotQuat=a.localRotQuat,a.localPosition.copyFrom(s[0]),a.localPosition=a.localPosition,a.localScale.copyFrom(s[2]),a.localScale=a.localScale,this}}const rt=class extends ku{constructor(){super(),o(this,"adjustmentTransform"),o(this,"_gltfBuffer"),rt.tempFwd||(rt.tempFwd=new g),rt.tempUp||(rt.tempUp=new g),rt.tempRight||(rt.tempRight=new g),rt.tempPos||(rt.tempPos=new g),rt.tempQuat||(rt.tempQuat=new q),rt.tempSca||(rt.tempSca=new g),rt.tempMat||(rt.tempMat=new V),this.adjustmentTransform=new V().identity()}async parse(i){const e=await super.parse(i);this._gltfBuffer=e.glbBytes.slice().buffer;let r=await new jo().parseBinary(this._gltfBuffer),{batchTable:s,featureTable:a}=e;const n=this.adjustmentTransform,l=a.getData("INSTANCES_LENGTH"),h=a.getData("POSITION",l,"FLOAT","VEC3"),u=a.getData("NORMAL_UP",l,"FLOAT","VEC3"),c=a.getData("NORMAL_RIGHT",l,"FLOAT","VEC3"),f=a.getData("SCALE_NON_UNIFORM",l,"FLOAT","VEC3"),d=a.getData("SCALE",l,"FLOAT","SCALAR"),p=new Map,m=[];r.traverse(y=>{let C;if(C=y?y.getComponent(ce):null,C){const{geometry:B,material:T}=C,M=new zu(B,T,l);M.localPosition=M.localPosition.copy(y.localPosition),M.localRotation=M.localRotation.copy(y.localRotation),M.localScale=M.localScale.copy(y.localScale),m.push(M),p.set(y,M)}});const _=new g;for(let y=0;y<l;y++)_.x+=h[y*3+0]/l,_.y+=h[y*3+1]/l,_.z+=h[y*3+2]/l;p.forEach((y,C)=>{const B=C.parent?C.parentObject:null;B&&(B.removeChild(C),B.addChild(y),y.transform.updateWorldMatrix(),y.transform.worldMatrix.transformVector4(_,y.localPosition))});const v=rt;for(let y=0;y<l;y++){v.tempMat.identity(),v.tempPos.set(h[y*3+0]-_.x,h[y*3+1]-_.y,h[y*3+2]-_.z),u?(v.tempUp.set(u[y*3+0],u[y*3+1],u[y*3+2]),v.tempRight.set(c[y*3+0],c[y*3+1],c[y*3+2]),v.tempRight.crossProduct(v.tempUp,v.tempFwd).normalize(),v.tempMat.makeBasis(v.tempRight,v.tempUp,v.tempFwd),v.tempQuat.setFromRotationMatrix(v.tempMat)):v.tempQuat.set(0,0,0,1),d?v.tempSca.setScalar(d[y]):f?v.tempSca.set(f[y*3+0],f[y*3+1],f[y*3+2]):v.tempSca.set(1,1,1),v.tempMat.compose(v.tempPos,v.tempQuat,v.tempSca),v.tempMat.multiplyMatrices(v.tempMat,n);for(let C=0,B=m.length;C<B;C++)m[C].setMatrixAt(y,v.tempMat)}return r.batchTable=s,r.featureTable=a,r}};let si=rt;o(si,"tempFwd"),o(si,"tempUp"),o(si,"tempRight"),o(si,"tempPos"),o(si,"tempQuat"),o(si,"tempSca"),o(si,"tempMat");class qo extends Xt{async parseBuffer(e){let t=new si;t.adjustmentTransform=this.userData,this.data=await t.parse(e)}verification(){if(this.data)return!0;throw new Error("Method not implemented.")}}o(qo,"format","bin");class ra extends Zs{constructor(){super(),o(this,"_faceData"),o(this,"_url"),this.useMipmap=!0,this.format=G.rgba16float,this._faceData=new Vo(this)}get ldrImageUrl(){return this._url}async load(e,t){this._url=e;let r=new ii(!1);return await r.load(e,t),this.createFromLDRTexture(r),this}createFromLDRTexture(e){let t=Math.log2(e.width/4);return t=Math.pow(2,Math.round(t)),this.createFromTexture(t,e),this}createFromTexture(e,t){this.width=this.height=e,this.textureBindingLayout.viewDimension="cube";let r=this.width;for(this.mipmapCount=1;r>16;)r/=2,this.mipmapCount++;return this.createTextureDescriptor(e,e,this.mipmapCount,this.format),this.textureDescriptor.size={width:e,height:e,depthOrArrayLayers:6},this.textureDescriptor.dimension="2d",this.gpuSampler=S.device.createSampler(this),this._faceData.uploadErpTexture(t),this}}let Gu=`
var<private>PI: f32 = 3.141592653589793;

// fn saturate( x : f32 ) -> f32 {
//     return clamp(x, 0.0, 1.0);
// }

fn hammersley(i : u32, N : u32) -> vec2<f32>
{
    // Radical inverse based on http://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html
    var bits = (i << 16u) | (i >> 16u);
    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);
    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);
    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);
    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);
    var rdi = f32(bits) * 2.3283064365386963e-10;
    return vec2<f32>(f32(i) / f32(N), rdi);
}

fn G_Smith(NoV: f32, NoL : f32, roughness : f32) -> f32
{
    var k = (roughness * roughness) / 2.0;
    var GGXL = NoL / (NoL * (1.0 - k) + k);
    var GGXV = NoV / (NoV * (1.0 - k) + k);
    return GGXL * GGXV;
}

fn V_SmithGGXCorrelated(NoV: f32, NoL : f32, roughness : f32) -> f32
{
    var a2 = pow(roughness, 4.0);
    var GGXV = NoL * sqrt(NoV * NoV * (1.0 - a2) + a2);
    var GGXL = NoV * sqrt(NoL * NoL * (1.0 - a2) + a2);
    return 0.5 / (GGXV + GGXL);
}


// Based on Karis 2014
fn importanceSampleGGX(Xi: vec2<f32>, roughness: f32, N: vec3<f32>) -> vec3<f32>
{
    var a = roughness * roughness;
    // Sample in spherical coordinates
    var Phi = 2.0 * PI * Xi.x;
    var CosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a * a - 1.0) * Xi.y));
    var SinTheta = sqrt(1.0 - CosTheta * CosTheta);
    // Construct tangent space vector
    var H: vec3<f32>;
    H.x = SinTheta * cos(Phi);
    H.y = SinTheta * sin(Phi);
    H.z = CosTheta;

    // Tangent to world space
    var UpVector = vec3<f32>(1.0, 0.0, 0.0);
    if (abs(N.z) < 0.999) {
        UpVector = vec3<f32>(0.0, 0.0, 1.0);
    }
    var TangentX = normalize(cross(UpVector, N));
    var TangentY = cross(N, TangentX);
    return TangentX * H.x + TangentY * H.y + N * H.z;
}


// Karis 2014
fn integrateBRDF(roughness: f32, NoV: f32) -> vec2<f32>
{
    var V: vec3<f32>;
    V.x = sqrt(1.0 - NoV * NoV); // sin
    V.y = 0.0;
    V.z = NoV; // cos

    // N points straight upwards for this integration
    var N = vec3<f32>(0.0, 0.0, 1.0);

    var A = 0.0;
    var B = 0.0;
    var numSamples = 1024u;

    for (var i = 0u; i < numSamples; i += 1u) {
        var Xi = hammersley(i, numSamples);
        // Sample microfacet direction
        var H = importanceSampleGGX(Xi, roughness, N);

        // Get the light direction
        var L = 2.0 * dot(V, H) * H - V;

        var NoL = saturate(dot(N, L));
        var NoH = saturate(dot(N, H));
        var VoH = saturate(dot(V, H));

        if (NoL > 0.0) {
            var V_pdf = V_SmithGGXCorrelated(NoV, NoL, roughness) * VoH * NoL / NoH;
            var Fc = pow(1.0 - VoH, 5.0);
            A += (1.0 - Fc) * V_pdf;
            B += Fc * V_pdf;
        }
    }

    return 4.0 * vec2<f32>(A, B) / f32(numSamples);
}

@group(0) @binding(0) var brdflutTexture: texture_storage_2d<rgba8unorm, write>;
@compute @workgroup_size(8, 8, 1)
// fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(local_invocation_id) local_invocation_id : vec3<u32> ){
fn CsMain(@builtin(global_invocation_id) global_invocation_id : vec3<u32>){
    var fragCoord = vec2<u32>(global_invocation_id.x, global_invocation_id.y);

    var fragColor = vec4<f32>(0.0);
    // Output to screen
    var res = integrateBRDF(f32(fragCoord.y + 1u) / 256.0, f32(fragCoord.x + 1u) / 256.0);
    fragColor = vec4<f32>(res.x, res.y, 0.0, 1.0);

    textureStore(brdflutTexture, vec2<i32>(fragCoord.xy), fragColor);
}
`;class Qu{constructor(){o(this,"compute"),this.compute=new be(Gu)}generateBRDFLUTTexture(){let e=new oe(256,256,G.rgba8unorm,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING);this.compute.setStorageTexture("brdflutTexture",e),this.compute.workerSizeX=256/8,this.compute.workerSizeY=256/8;let t=w.beginCommandEncoder();return w.computeCommand(t,[this.compute]),w.endCommandEncoder(t),e}}class Vu extends at{constructor(){super(...arguments),o(this,"_dataBuffer")}create(e,t,r,s=!1){let a=S.device;const n=Math.ceil(e*4/256)*256;this.format=G.rgba8unorm,this.mipmapCount=Math.floor(s?Math.log2(e):1),this.createTextureDescriptor(e,t,this.mipmapCount,this.format);const l=this._dataBuffer=a.createBuffer({size:r.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC});a.queue.writeBuffer(l,0,r);const h=w.beginCommandEncoder();return h.copyBufferToTexture({buffer:l,bytesPerRow:n},{texture:this.getGPUTexture()},{width:e,height:t,depthOrArrayLayers:1}),w.endCommandEncoder(h),s&&Ht.webGPUGenerateMipmap(this),this}updateTexture(e,t,r){let s=S.device;const a=Math.ceil(e*4/256)*256;this.mipmapCount=Math.floor(Math.log2(e)),this._dataBuffer&&this._dataBuffer.destroy(),this._dataBuffer=null;const n=this._dataBuffer=s.createBuffer({size:r.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC});s.queue.writeBuffer(n,0,r);const l=w.beginCommandEncoder();l.copyBufferToTexture({buffer:n,bytesPerRow:a},{texture:this.getGPUTexture()},{width:e,height:t,depthOrArrayLayers:1}),w.endCommandEncoder(l),this.gpuSampler=s.createSampler(this),this.mipmapCount>1&&Ht.webGPUGenerateMipmap(this)}}class fr{constructor(e){o(this,"id"),o(this,"guiTexture"),o(this,"uvRec",new j(0,0,1,1)),o(this,"uvBorder",new j(0,0,0,0)),o(this,"offsetSize",new j(0,0,4,4)),o(this,"borderSize",new j(0,0,0,0)),o(this,"trimSize",new Z),o(this,"isSliced",!1),o(this,"height",4),o(this,"width",4),o(this,"xadvance",0),o(this,"xoffset",0),o(this,"yoffset",0),this.guiTexture=e||A.res.defaultGUITexture}}const Ko=class{constructor(i){o(this,"_staticId",-1),o(this,"dynamicId",-1),o(this,"texture"),o(this,"width",1),o(this,"height",1),i||(i=A.res.whiteTexture),this.texture=i,Ko._maxUid++,this._staticId=Ko._maxUid,this.init()}get staticId(){return this._staticId}init(){this.dynamicId=-1,this.width=this.texture.width,this.height=this.texture.height}};let dr=Ko;o(dr,"_maxUid",-1);class Vg{constructor(){o(this,"fntCache",{}),o(this,"fntData",{})}addFontData(e,t,r){this.fntData[`${e}${t}`]=r}getFontData(e,t){return this.fntData[`${e}${t}`]}addFnt(e,t,r,s){let a=`${e}${t}`;this.fntCache[a]||(this.fntCache[a]={}),this.fntCache[a][r]=s}getFnt(e,t,r){let s=`${e}${t}`,a=this.fntCache[s];return a?a[r]:this.fntCache[" "]}}let gr=new Vg;class Hu{constructor(){o(this,"face",""),o(this,"size",0),o(this,"bold",!1),o(this,"italic",!1),o(this,"stretchH",0),o(this,"spacing",""),o(this,"outline",0),o(this,"lineHeight",0),o(this,"base",0),o(this,"scaleW",0),o(this,"scaleH",0),o(this,"pages",0),o(this,"packed",0),o(this,"alphaChnl",0),o(this,"redChnl",0),o(this,"greenChnl",0),o(this,"blueChnl",0),o(this,"count",0),o(this,"fontPage",[]),o(this,"fontChar",{})}}class Yu{constructor(){o(this,"id",0),o(this,"file","")}}class Xu{constructor(){o(this,"id",-1),o(this,"x",0),o(this,"y",0),o(this,"width",0),o(this,"height",0),o(this,"xoffset",0),o(this,"yoffset",0),o(this,"xadvance",0),o(this,"page",0),o(this,"chnl",0)}}const Ri=class extends Xt{static parseSprite(i,e){for(const t in e.fontChar)if(Object.prototype.hasOwnProperty.call(e.fontChar,t)){const r=e.fontChar[t];let s=new fr;s.id=r.id.toString(),s.offsetSize.set(0,0,r.width,r.height),s.trimSize.set(r.width,r.height),s.width=r.width,s.height=r.height,s.xadvance=r.xadvance,s.xoffset=r.xoffset,s.yoffset=r.yoffset,s.guiTexture=i[r.page],s.uvRec.set(r.x/e.scaleW,(e.scaleH-(r.y+r.height))/e.scaleH,r.width/e.scaleW,r.height/e.scaleH),gr.addFnt(e.face,e.size,s.id,s)}}verification(){if(this.data)return!0;throw new Error("Method not implemented.")}async parseString(i){let e=this.getNewLine(i),t=i,r=new Hu;t.trim().split(e).forEach((s,a)=>{if(a<2)Ri.readLineProperty(s,r);else if(a<r.pages+2){let n=new Yu;Ri.readLineProperty(s,n),r.fontPage.push(n)}else if(a<r.pages+3)Ri.readLineProperty(s,r);else if(r.count>0){let n=new Xu;Ri.readLineProperty(s,n),r.fontChar[n.id]=n,r.count--}}),t="",this.data=r,await this.loadFontTextures()}getNewLine(i){return i.indexOf(`\r
`)!=-1?`\r
`:i.indexOf("\r")!=-1?"\r":`
`}async loadFontTextures(){let i=[],e=this.data;for(const t of e.fontPage){let r=this.baseUrl+t.file;await A.res.loadTexture(r,null,!0);let s=A.res.getTexture(r),a=new dr(s);i.push(a)}Ri.parseSprite(i,e),e.fontChar[" "]||Ri.insertSpaceChar(e,i[0])}static insertSpaceChar(i,e){let t=new fr,r=i.size*.5,s=i.lineHeight*.5;t.id=" ",t.offsetSize.set(0,0,i.size,i.size),t.trimSize.set(r,s),t.width=r,t.height=s,t.xadvance=0,t.xoffset=0,t.yoffset=0,t.guiTexture=e,t.uvRec.set(0,0,1e-6,1e-6),gr.addFnt(i.face,i.size,t.id,t)}static readLineProperty(i,e){i.trim().split(" ").forEach((t,r)=>{let s=t.split("=");if(s.length>1){let a=s[0],n=s[1];Object.prototype.hasOwnProperty.call(e,a)&&(n.indexOf('"')==-1?e[a]=parseFloat(s[1]):e[a]=n.replace('"',"").replace('"',""))}})}};let Jo=Ri;o(Jo,"format","text");function Hg(i,e){let t=new fr;return t.id=i,t.offsetSize.set(0,0,e.width,e.height),t.trimSize.set(e.width,e.height),t.width=e.width,t.height=e.height,t.xadvance=0,t.xoffset=0,t.yoffset=0,t.guiTexture=new dr(e),t.uvRec.set(0,0,1,1),e.isVideoTexture||(e.flipY=!0),t}function Wu(i,e,t){let r=new fr;r.guiTexture=i,r.id=e,r.uvRec.copyFrom(t.textureRect),r.trimSize.x=t.textureRect.z,r.trimSize.y=t.textureRect.w,r.offsetSize.x=t.textureRectOffset.x,r.offsetSize.y=t.textureRectOffset.y,r.offsetSize.z=t.size.x,r.offsetSize.w=t.size.y,r.width=t.size.x,r.height=t.size.y;let s=1/i.width,a=1/i.height;r.uvRec.set(r.uvRec.x*s,r.uvRec.y*a,r.uvRec.z*s,r.uvRec.w*a);let n=.1;return t.border.x<=n&&t.border.y<=n&&t.border.z<=n&&t.border.x<=n?r.isSliced=!1:(r.borderSize.copyFrom(t.border),r.uvBorder.copyFrom(t.border),r.uvBorder.x-=t.textureRectOffset.x,r.uvBorder.y-=t.textureRectOffset.y,r.uvBorder.z=t.border.z-(t.size.x-t.textureRect.z-t.textureRectOffset.x),r.uvBorder.w=t.border.w-(t.size.y-t.textureRect.w-t.textureRectOffset.y),r.uvBorder.x/=t.textureRect.z,r.uvBorder.z/=t.textureRect.z,r.uvBorder.y/=t.textureRect.w,r.uvBorder.w/=t.textureRect.w,r.isSliced=!0),r}class ju{constructor(e){o(this,"_spriteMap",new Map),o(this,"_spriteList",[]),o(this,"textureSize",new Z),o(this,"name"),this.textureSize.set(e.x,e.y)}setTexture(e,t,r){let s=Wu(e,t,r);return this._spriteMap.set(s.id,s),this._spriteList.push(s),s}getSprite(e){return this._spriteMap.get(e)}get spriteList(){return this._spriteList}}class Zo extends Xt{constructor(){super(...arguments),o(this,"_json"),o(this,"_texture")}async parseString(e){this._json=JSON.parse(e);let t=this.userData.replace(".json",".png");this._texture=await A.res.loadTexture(t,null,!0),this.data={json:this._json,texture:this._texture},this.parseAtlas()}verification(){if(this.data)return!0;throw new Error("verify failed.")}parseAtlas(){let e=new ju(this._json.size),t=new dr(this._texture),r=this._json.atlas;for(const s in r)e.setTexture(t,s,r[s]);A.res.addAtlas(this.baseUrl,e),this.data=e}}o(Zo,"format","text");class qu{constructor(){o(this,"_texturePool"),o(this,"_materialPool"),o(this,"_prefabPool"),o(this,"_gltfPool"),o(this,"_atlasList"),o(this,"normalTexture"),o(this,"maskTexture"),o(this,"whiteTexture"),o(this,"blackTexture"),o(this,"redTexture"),o(this,"blueTexture"),o(this,"greenTexture"),o(this,"yellowTexture"),o(this,"grayTexture"),o(this,"defaultSky"),o(this,"defaultGUITexture"),o(this,"defaultGUISprite"),this._texturePool=new Map,this._materialPool=new Map,this._prefabPool=new Map,this._gltfPool=new Map,this._atlasList=new Map,this.initDefault()}getGltf(e){return this._gltfPool.get(e)}addTexture(e,t){this._texturePool.set(e,t)}getTexture(e){return this._texturePool.get(e)}addMat(e,t){return this._materialPool.set(e,t)}getMat(e){return this._materialPool.get(e)}addPrefab(e,t){this._prefabPool.set(e,t)}getPrefab(e){return this._prefabPool.get(e).instantiate()}addAtlas(e,t){t.name=e,this._atlasList.set(e,t)}getAtlas(e){return this._atlasList.get(e)}getGUISprite(e){for(let t of this._atlasList.values()){let r=t.getSprite(e);if(r)return r}return null}async loadGltf(e,t){if(this._prefabPool.has(e))return this._prefabPool.get(e);let r,s=e.substring(e.lastIndexOf(".")).toLowerCase(),a=new ht;s==".gltf"?r=await a.load(e,Ke,t):r=await a.load(e,qs,t);let n=r.data;return this._prefabPool.set(e,n),this._gltfPool.set(e,r.gltf),n}async loadObj(e,t){if(this._prefabPool.has(e))return this._prefabPool.get(e);let r,s=e.substring(e.lastIndexOf(".")).toLowerCase(),a=new ht;s==".obj"&&(r=await a.load(e,Fo,t));let n=r.data;return this._prefabPool.set(e,n),n}async loadB3DM(e,t,r){if(this._prefabPool.has(e))return this._prefabPool.get(e);let n=(await new ht().load(e,Xo,t,r)).data;return this._prefabPool.set(e,n),n}async loadI3DM(e,t,r){if(this._prefabPool.has(e))return this._prefabPool.get(e);let n=(await new ht().load(e,qo,t,r)).data;return this._prefabPool.set(e,n),n}async loadTexture(e,t,r){if(this._texturePool.has(e))return this._texturePool.get(e);let s=new ii;return s.flipY=r,await s.load(e,t),this._texturePool.set(e,s),s}async loadHDRTexture(e,t){if(this._texturePool.has(e))return this._texturePool.get(e);let r=new Go;return r=await r.load(e,t),this._texturePool.set(e,r),r}async loadHDRTextureCube(e,t){if(this._texturePool.has(e))return this._texturePool.get(e);let r=new ea;return r=await r.load(e,t),this._texturePool.set(e,r),r}async loadLDRTextureCube(e,t){if(this._texturePool.has(e))return this._texturePool.get(e);let r=new ra;return r=await r.load(e,t),this._texturePool.set(e,r),r}async loadTextureCubeMaps(e){let t=e[0];if(this._texturePool.has(t))return this._texturePool.get(t);let r=new ko;return await r.load(e),this._texturePool.set(e[0],r),r}async loadTextureCubeStd(e,t){if(this._texturePool.has(e))return this._texturePool.get(e);let r=new ko;return await r.loadStd(e),r}async loadJSON(e,t){return await new ht().loadJson(e,t).then(async r=>r).catch(r=>{console.log(r)})}async loadFont(e,t,r){let a=await new ht().load(e,Jo,t,r),n=a.data;return gr.addFontData(n.face,n.size,n),a.data}async loadAtlas(e,t){return(await new ht().load(e,Zo,t,e)).data}createTexture(e,t,r,s,a,n,l){let h=32,u=32,c=new Uint8Array(h*u*4);this.fillColor(c,e,t,r,s,a,n);let f=new Vu;return f.name=l,f.create(16,16,c,!0),l&&this.addTexture(l,f),f}fillColor(e,t,r,s,a,n,l){for(let h=0;h<t;h++)for(let u=0;u<r;u++){let c=u*t+h;e[c*4+0]=s,e[c*4+1]=a,e[c*4+2]=n,e[c*4+3]=l}}initDefault(){this.normalTexture=this.createTexture(32,32,255*.5,255*.5,255,255,"default-normalTexture"),this.maskTexture=this.createTexture(32,32,255,255*.5,0,255,"default-maskTexture"),this.whiteTexture=this.createTexture(32,32,255,255,255,255,"default-whiteTexture"),this.blackTexture=this.createTexture(32,32,0,0,0,255,"default-blackTexture"),this.redTexture=this.createTexture(32,32,255,0,0,255,"default-redTexture"),this.blueTexture=this.createTexture(32,32,0,0,255,255,"default-blueTexture"),this.greenTexture=this.createTexture(32,32,0,255,0,255,"default-greenTexture"),this.yellowTexture=this.createTexture(32,32,0,255,255,255,"default-yellowTexture"),this.grayTexture=this.createTexture(32,32,128,128,128,255,"default-grayTexture");let t=new Qu().generateBRDFLUTTexture(),r=t.name="BRDFLUT";this.addTexture(r,t),this.defaultSky=new ea,this.defaultSky.createFromTexture(128,this.blackTexture),se.getInstance().attached(this.defaultSky,this),se.getInstance().attached(t,this),se.getInstance().attached(this.normalTexture,this),se.getInstance().attached(this.maskTexture,this),se.getInstance().attached(this.whiteTexture,this),se.getInstance().attached(this.blackTexture,this),se.getInstance().attached(this.redTexture,this),se.getInstance().attached(this.blueTexture,this),se.getInstance().attached(this.greenTexture,this),se.getInstance().attached(this.yellowTexture,this),se.getInstance().attached(this.grayTexture,this),this.defaultGUITexture=new dr(this.whiteTexture),this.defaultGUISprite=new fr(this.defaultGUITexture),this.defaultGUISprite.trimSize.set(4,4)}}class ye{}o(ye,"pixelRatio",1),o(ye,"solution",new Z(1600,1280)),o(ye,"quadMaxCountForWorld",256),o(ye,"quadMaxCountForView",2048),o(ye,"SortOrderStartWorld",7e3),o(ye,"SortOrderStartView",8e3),o(ye,"SortOrderCanvasSpan",1e4);var Nt=(i=>(i[i.View=0]="View",i[i.World=2]="World",i))(Nt||{}),pr=(i=>(i[i.Simple=0]="Simple",i[i.Sliced=1]="Sliced",i[i.Tiled=2]="Tiled",i[i.Filled=3]="Filled",i))(pr||{}),xi=(i=>(i[i.None=0]="None",i[i.BillboardY=9]="BillboardY",i[i.BillboardXYZ=10]="BillboardXYZ",i))(xi||{});class A{static get frameRate(){return this._frameRate}static set frameRate(e){this._frameRate=e,this._frameRateValue=1/e,e>=360&&(this._frameRateValue=0)}static get size(){return S.presentationSize}static get aspect(){return S.aspect}static get width(){return S.windowWidth}static get height(){return S.windowHeight}static async init(e={}){console.log("Engine Version",Hf),this.divB=document.createElement("div"),this.divB.style.position="absolute",this.divB.style.zIndex="999",this.divB.style.color="#FFFFFF",this.divB.style.top="150px",document.body.appendChild(this.divB),this.setting={...this.setting,...e.engineSetting},await ee.init(V.allocCount),await S.init(e.canvasConfig),N.init(),Ot.init(),pe.init(),Fe.init(),Ve.init(),this.res=new qu,this._beforeRender=e.beforeRender,this._renderLoop=e.renderLoop,this._lateRender=e.lateRender,this.inputSystem=new In,this.inputSystem.initCanvas(S.canvas)}static startRenderView(e){this.renderJobs||(this.renderJobs=new Map),this.views=[e];let t=new wo(e);return this.renderJobs.set(e,t),t.addPost(new uo),t.start(),this.resume(),t}static startRenderViews(e){this.renderJobs||(this.renderJobs=new Map),this.views=e;for(let t=0;t<e.length;t++){const r=e[t];let s=new wo(r);this.renderJobs.set(r,s),s.addPost(new uo),s.start()}this.resume()}static getRenderJob(e){return this.renderJobs.get(e)}static pause(){this._requestAnimationFrameID!=0&&(cancelAnimationFrame(this._requestAnimationFrameID),this._requestAnimationFrameID=0)}static resume(){this._requestAnimationFrameID=requestAnimationFrame(e=>this.render(e))}static render(e){this._deltaTime=e-this._time,this._time=e,this._frameRateValue>0?(this._frameTimeCount+=this._deltaTime*.001,this._frameTimeCount>=this._frameRateValue*.95&&(this._frameTimeCount=0,this.updateFrame(e))):this.updateFrame(e),this.resume()}static updateGUIPixelRatio(e,t){let r=ye.solution.x/ye.solution.y,s=e/t;r<s?ye.pixelRatio=t/ye.solution.y:ye.pixelRatio=e/ye.solution.x}static updateFrame(e){he.delta=e-he.time,he.time=e,he.frame+=1,So.tick(he.delta);let t=this.views,r=0;for(r=0;r<t.length;r++){const n=t[r];n.scene.waitUpdate(),n.camera.resetPerspective(S.aspect)}this.updateGUIPixelRatio(S.canvas.clientWidth,S.canvas.clientHeight),this._beforeRender&&this._beforeRender();for(const n of ae.componentsBeforeUpdateList){let l=n[0],h=n[1];for(const u of h){let c=u[0],f=u[1];c.enable&&f(l)}}let s=S.device.createCommandEncoder();for(const n of ae.componentsComputeList){let l=n[0],h=n[1];for(const u of h){let c=u[0],f=u[1];c.enable&&f(l,s)}}S.device.queue.submit([s.finish()]);for(const n of ae.componentsUpdateList){let l=n[0],h=n[1];for(const u of h){let c=u[0],f=u[1];c.enable&&f(l)}}this._renderLoop&&this._renderLoop(),ee.updateAllContinueTransform(0,V.useCount,16),pe.modelMatrixBindGroup.writeBuffer(V.useCount*16),this.renderJobs.forEach((n,l)=>{n.renderFrame()});for(const n of ae.componentsLateUpdateList){let l=n[0],h=n[1];for(const u of h){let c=u[0],f=u[1];c.enable&&f(l)}}this._lateRender&&this._lateRender()}}o(A,"res"),o(A,"inputSystem"),o(A,"views"),o(A,"_frameRateValue",0),o(A,"_frameRate",360),o(A,"_frameTimeCount",0),o(A,"_deltaTime",0),o(A,"_time",0),o(A,"_beforeRender"),o(A,"_renderLoop"),o(A,"_lateRender"),o(A,"_requestAnimationFrameID",0),o(A,"Engine3D"),o(A,"divB"),o(A,"setting",{occlusionQuery:{enable:!0,debug:!1},pick:{enable:!0,mode:"bound",detail:"mesh"},render:{debug:!1,renderPassState:4,renderState_left:5,renderState_right:5,renderState_split:.5,quadScale:1,hdrExposure:1.5,debugQuad:-1,maxPointLight:1e3,maxDirectLight:4,maxSportLight:1e3,drawOpMin:0,drawOpMax:Number.MAX_SAFE_INTEGER,drawTrMin:0,drawTrMax:Number.MAX_SAFE_INTEGER,zPrePass:!1,useLogDepth:!1,gi:!1,postProcessing:{globalFog:{debug:!1,enable:!1,fogType:0,fogHeightScale:.1,start:400,end:10,density:.02,ins:.5,skyFactor:.5,skyRoughness:.4,overrideSkyFactor:.8,fogColor:new z(112/255,61/255,139/255,1),falloff:.7,rayLength:200,scatteringExponent:2.7,dirHeightLine:10},ssao:{enable:!1,radius:.15,bias:-.1,aoPower:2,debug:!0},outline:{enable:!1,strength:1,groupCount:4,outlinePixel:2,fadeOutlinePixel:4,textureScale:.7,useAddMode:!1,debug:!0},taa:{enable:!1,jitterSeedCount:8,blendFactor:.1,sharpFactor:.6,sharpPreBlurFactor:.5,temporalJitterScale:.13,debug:!0},gtao:{enable:!1,darkFactor:1,maxDistance:5,maxPixel:50,rayMarchSegment:6,multiBounce:!1,usePosFloat32:!0,blendColor:!0,debug:!0},ssr:{enable:!1,pixelRatio:1,fadeEdgeRatio:.2,rayMarchRatio:.5,fadeDistanceMin:600,fadeDistanceMax:2e3,roughnessThreshold:.5,powDotRN:.2,mixThreshold:.1,debug:!0},bloom:{enable:!1,blurX:4,blurY:4,strength:.25,exposure:1,radius:1.3,luminosityThreshold:.98,debug:!1},fxaa:{enable:!1},depthOfView:{enable:!1,iterationCount:3,pixelOffset:1,near:150,far:300}}},shadow:{enable:!0,type:"HARD",pointShadowBias:.002,shadowSize:1024,pointShadowSize:1024,shadowSoft:.005,needUpdate:!0,autoUpdate:!0,updateFrameRate:2,csmMargin:.1,csmScatteringExp:.7,csmAreaScale:.4,debug:!1},gi:{enable:!1,offsetX:0,offsetY:0,offsetZ:0,probeSpace:64,probeXCount:4,probeYCount:2,probeZCount:4,probeSize:32,probeSourceTextureSize:2048,octRTMaxSize:2048,octRTSideSize:16,maxDistance:64*1.73,normalBias:.25,depthSharpness:1,hysteresis:.98,lerpHysteresis:.01,irradianceChebyshevBias:.01,rayNumber:144,irradianceDistanceBias:32,indirectIntensity:1,ddgiGamma:2.2,bounceIntensity:.025,probeRoughness:1,realTimeGI:!1,debug:!1,autoRenderProbe:!1},sky:{type:"HDRSKY",sky:null,skyExposure:1,defaultFar:65536,defaultNear:1},light:{maxLight:4096},material:{materialChannelDebug:!1,materialDebug:!1}}),o(A,"renderJobs");let Yg=`
#include "GlobalUniform"

struct UniformData {
  radius: f32 ,
  bias: f32,
  aoPower: f32 ,
  blurSize: f32 ,
};

// @group(0) @binding(0) var<uniform> standUniform: GlobalUniform;
@group(0) @binding(0) var<uniform> uniformData: UniformData;
@group(0) @binding(1) var colorMap : texture_2d<f32>;
// @group(0) @binding(2) var ssaoMapSampler : sampler;
@group(0) @binding(2) var ssaoMap : texture_2d<f32>;
@group(0) @binding(3) var outTex : texture_storage_2d<rgba16float, write>;

@compute @workgroup_size( 8 , 8 )
fn CsMain( @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
{
  var fragCoord = vec2<i32>( globalInvocation_id.xy );

  var texSize = vec2<f32>(textureDimensions(ssaoMap).xy);
  var texCoord = vec2<f32>(fragCoord) / texSize ;

  let blurSize = i32(uniformData.blurSize);

  var result = vec4<f32>(0.0) ;
  var ii = 0.0 ;
  for (var i = -2; i < 2 ; i+=1) {
     for (var j = -2; j < 2 ; j+=1) {
        var offset = vec2<i32>( i , j ) ;
        result += textureLoad(ssaoMap, fragCoord + offset, 0 );
        // result += textureSampleLevel(ssaoMap,ssaoMapSampler, vec2<f32>( fragCoord + offset) / texSize , 0.0 );
        ii += 1.0 ;
     }
  }
  var fResult = result.r / ii ;
  var color = textureLoad(colorMap, fragCoord , 0 );
  textureStore(outTex, fragCoord , vec4(color.rgb * fResult,1.0) );
}
`,Ku=`
#include "GlobalUniform"

  struct BlurSetting{
    near: f32,
    far: f32,
    pixelOffset: f32,
  }

  @group(0) @binding(0) var<uniform> standUniform: GlobalUniform;
  @group(0) @binding(1) var<uniform> blurSetting: BlurSetting;

  @group(0) @binding(2) var positionBufferTex : texture_2d<f32>;
  @group(0) @binding(3) var normalBufferTex : texture_2d<f32>;
  @group(0) @binding(4) var inTexSampler : sampler;
  @group(0) @binding(5) var inTex : texture_2d<f32>;
  @group(0) @binding(6) var outTex : texture_storage_2d<rgba16float, write>;

  var<private> cameraPosition: vec3<f32>;
  var<private> texSize: vec2<u32>;
  var<private> fragCoord: vec2<i32>;
  var<private> texelSize: vec2<f32>;

  @compute @workgroup_size( 8 , 8 , 1 )
  fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
  {
    fragCoord = vec2<i32>( globalInvocation_id.xy );
    texSize = textureDimensions(inTex).xy;
    texelSize = 1.0 / vec2<f32>(texSize - 1);
    if(fragCoord.x >= i32(texSize.x) || fragCoord.y >= i32(texSize.y)){
        return;
    }
    cameraPosition = vec3<f32>(standUniform.cameraWorldMatrix[3].xyz);
    let wPosition:vec3<f32> = textureLoad(positionBufferTex, fragCoord , 0).xyz;
    var distance = length(wPosition - cameraPosition);
    var oc:vec4<f32> = textureLoad(inTex, fragCoord, 0);
    if(distance > blurSetting.near){
        let normal = textureLoad(normalBufferTex, fragCoord, 0);
        var pixelScale = 0.5;
        if(normal.w > 0.5){
            distance = min(distance, blurSetting.far);
            pixelScale = (distance - blurSetting.near) / (blurSetting.far - blurSetting.near);
        }
        oc = mixBlurColor(oc, fragCoord, blurSetting.pixelOffset, pixelScale);
    }
    textureStore(outTex, fragCoord, oc);
  }

  fn mixBlurColor(orginColor:vec4<f32>, coord:vec2<i32>, pixelOffset:f32, scale:f32) -> vec4<f32> {

    let uv = vec2<f32>(coord);
    var uv0 = (uv + scale * vec2<f32>( pixelOffset,  pixelOffset)) * texelSize;
    var uv1 = (uv + scale * vec2<f32>(-pixelOffset,  pixelOffset)) * texelSize;
    var uv2 = (uv + scale * vec2<f32>(-pixelOffset, -pixelOffset)) * texelSize;
    var uv3 = (uv + scale * vec2<f32>( pixelOffset, -pixelOffset)) * texelSize;

    uv0.x = processUVEdge(uv0.x);
    uv0.y = processUVEdge(uv0.y);
    uv1.x = processUVEdge(uv1.x);
    uv1.y = processUVEdge(uv1.y);
    uv2.x = processUVEdge(uv2.x);
    uv2.y = processUVEdge(uv2.y);
    uv3.x = processUVEdge(uv3.x);
    uv3.y = processUVEdge(uv3.y);

    var ob = vec4<f32>(0.0);
    ob += textureSampleLevel(inTex, inTexSampler, uv0, 0.0);
    ob += textureSampleLevel(inTex, inTexSampler, uv1, 0.0);
    ob += textureSampleLevel(inTex, inTexSampler, uv2, 0.0);
    ob += textureSampleLevel(inTex, inTexSampler, uv3, 0.0);
    return mix(orginColor, ob * 0.25, scale);
  }

  fn processUVEdge(v: f32) -> f32{
      var value = v;
      if(value < 0.0){
        value = - value;
      }else if(value > 1.0){
        value = 2.0 - value;
      }
      return value;
  }
`,Ju=`
    #include "GlobalUniform"
    
    struct GTAO{
      maxDistance: f32,
      maxPixel: f32,
      darkFactor: f32,
      rayMarchSegment: f32,
      cameraNear: f32,
      cameraFar: f32,
      multiBounce: f32,
      blendColor: f32,
    }

    @group(0) @binding(1) var<uniform> gtaoData: GTAO;
    @group(0) @binding(2) var<storage, read_write> directions : array<vec2<f32>>;
    @group(0) @binding(3) var<storage, read_write> aoBuffer : array<f32>;

    @group(0) @binding(4) var posTex : texture_2d<f32>;
    @group(0) @binding(5) var normalTex : texture_2d<f32>;
    @group(0) @binding(6) var inTex : texture_2d<f32>;
    @group(0) @binding(7) var outTex : texture_storage_2d<rgba16float, write>;
    
    var<private> texSize: vec2<u32>;
    var<private> fragCoord: vec2<i32>;
    var<private> wPosition: vec3<f32>;
    var<private> wNormal: vec4<f32>;
    var<private> maxPixelScaled: f32;
    
    @compute @workgroup_size( 8 , 8 , 1 )
    fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
    {
      fragCoord = vec2<i32>( globalInvocation_id.xy );
      texSize = textureDimensions(inTex).xy;
      if(fragCoord.x >= i32(texSize.x) || fragCoord.y >= i32(texSize.y)){
          return;
      }
      wNormal = textureLoad(normalTex, fragCoord, 0);
      var oc = textureLoad(inTex, fragCoord, 0);
      let index = fragCoord.x + fragCoord.y * i32(texSize.x);
      let lastFactor = aoBuffer[index];
      var newFactor = 0.0;
      if(wNormal.w < 0.5){//sky
          
      }else{
          wPosition = textureLoad(posTex, fragCoord, 0).xyz;
          let ndc = globalUniform.projMat * globalUniform.viewMat * vec4<f32>(wPosition, 1.0);
          let ndcZ = ndc.z / ndc.w;
          maxPixelScaled = calcPixelByNDC(ndcZ);
          newFactor = rayMarch();
      }
      
      var factor:f32 = mix(lastFactor, newFactor, 0.6);
      aoBuffer[index] = factor;
      factor = blurFactor(factor);
      factor = saturate(1.0 - factor * gtaoData.darkFactor);
      var gtao = vec3<f32>(factor);
      if(gtaoData.multiBounce > 0.5){
          gtao = MultiBounce(factor, oc.xyz);
      }
      
      var outColor = gtao;
      if(gtaoData.blendColor > 0.5){
          outColor = oc.xyz * gtao;
      }
      textureStore(outTex, fragCoord , vec4<f32>(outColor, oc.w));
    }
    
    fn MultiBounce(AO:f32, Albedo:vec3<f32>) -> vec3<f32>
    {
        var A = 2 * Albedo - 0.33;
        var B = -4.8 * Albedo + 0.64;
        var C = 2.75 * Albedo + 0.69;
        return max(vec3<f32>(AO), ((AO * A + B) * AO + C) * AO);
    }
    
    fn calcPixelByNDC(ndcZ:f32) -> f32{
      let nearAspect = gtaoData.cameraNear / (gtaoData.cameraFar - gtaoData.cameraNear);
      let aspect = (1.0 + nearAspect) / (ndcZ + nearAspect);
      var viewPortMax = min(f32(texSize.x), f32(texSize.y));
      var maxPixel = min(viewPortMax, gtaoData.maxPixel * aspect);
      maxPixel = max(0.1, maxPixel);
      return maxPixel;
    }
    
    fn blurFactor(centerFactor:f32) -> f32{
      var coord0 = clamp(fragCoord + vec2<i32>(1, 0) , vec2<i32>(0), vec2<i32>(texSize - 1));
      var coord1 = clamp(fragCoord + vec2<i32>(-1, 0), vec2<i32>(0), vec2<i32>(texSize - 1));
      var coord2 = clamp(fragCoord + vec2<i32>(0, 1) , vec2<i32>(0), vec2<i32>(texSize - 1));
      var coord3 = clamp(fragCoord + vec2<i32>(0, -1), vec2<i32>(0), vec2<i32>(texSize - 1));
      var index0 = coord0.x + coord0.y * i32(texSize.x);
      var index1 = coord1.x + coord1.y * i32(texSize.x);
      var index2 = coord2.x + coord2.y * i32(texSize.x);
      var index3 = coord3.x + coord3.y * i32(texSize.x);
      let factor0:f32 = aoBuffer[index0];
      let factor1:f32 = aoBuffer[index1];
      let factor2:f32 = aoBuffer[index2];
      let factor3:f32 = aoBuffer[index3];
      var factor = 0.25 * (factor0 + factor1 + factor2 + factor3);
      factor = mix(factor, centerFactor, 0.8);
      return factor;
    }
    
    fn rayMarch() -> f32{
      let originNormal = normalize(vec3<f32>(wNormal.xyz) * 2.0 - 1.0);
      let stepPixel = maxPixelScaled / gtaoData.rayMarchSegment;
      var weight:f32 = 0.0;
      var totalWeight:f32 = 0.1;
      for(var i:i32 = 0; i < 8; i += 1){
          let dirVec2 = directions[i];
          for(var j:f32 = 1.1; j < maxPixelScaled; j += stepPixel){
              var sampleCoord = vec2<i32>(dirVec2 * j) + fragCoord;
              if(sampleCoord.x >= 0 && sampleCoord.y >= 0 
                && sampleCoord.x < i32(texSize.x) 
                && sampleCoord.y < i32(texSize.y) )
              {
                totalWeight += 1.0;
                let samplePosition = textureLoad(posTex, sampleCoord, 0).xyz;
                let distanceVec2 = samplePosition - wPosition;
                let distance = length(distanceVec2);
                if(distance < gtaoData.maxDistance && distance > 1.0){
                  let sampleDir = normalize(distanceVec2);
                  var factor = saturate(dot(sampleDir, originNormal) - 0.1);
                  factor *= 1.0 - distance / gtaoData.maxDistance;
                  weight += factor;
                }
              }
          }
      }
      weight /= totalWeight;
      return weight;
    }
  `,Zu=`

    #include "GlobalUniform"
    struct LightData {
      index:f32,
      lightType:i32,
      radius:f32,
      linear:f32,
      
      position:vec3<f32>,
      lightMatrixIndex:f32,

      direction:vec3<f32>,
      quadratic:f32,

      lightColor:vec3<f32>,
      intensity:f32,

      innerCutOff :f32,
      outerCutOff:f32,
      range :f32,
      castShadow:i32,

      lightTangent:vec3<f32>,
      ies:f32,
    };

    struct Uniforms {
      matrix : array<mat4x4<f32>>
    };

    struct CacheGodRay {
      pos:vec3<f32>,
      value:f32,
    };

    struct GodRayUniform{
      intensity: f32,
      rayMarchCount: f32,
      viewPortWidth: f32,
      viewPortHeight: f32,

      blendColor: f32,
      scatteringExponent: f32,
    }

    @group(0) @binding(1) var<uniform> godRayUniform: GodRayUniform;
    @group(0) @binding(2) var posTex : texture_2d<f32>;
    @group(0) @binding(3) var normalTex : texture_2d<f32>;
    @group(0) @binding(4) var inTex : texture_2d<f32>;
    @group(0) @binding(5) var outTex : texture_storage_2d<rgba16float, write>;
    @group(0) @binding(6) var shadowMapSampler : sampler_comparison;
    @group(0) @binding(7) var shadowMap : texture_depth_2d_array;

    @group(1) @binding(0)
    var<storage,read> lightBuffer: array<LightData>;
    @group(1) @binding(1)
    var<storage, read> models : Uniforms;

    @group(2) @binding(0) var<storage, read_write> historyGodRayData: array<CacheGodRay>;
    
    struct ShadowStruct{
      directShadowVisibility:f32,
      pointShadows:array<f32,8>,
     }

    var<private> viewDirection: vec3<f32> ;
    var<private> texSize: vec2<u32>;
    var<private> fragCoord: vec2<i32>;
    var<private> wPosition: vec3<f32>;
    var<private> wNormal: vec4<f32>;
    var<private> directLight: LightData;
    var<private> shadowStrut: ShadowStruct ;

    const csmCount:i32 = ${lt.Cascades} ;
    fn directShadowMaping(P:vec3<f32>, N:vec3<f32>, shadowBias: f32)  {
      let enableCSM:bool = globalUniform.enableCSM > 0.5;
      var light = lightBuffer[0];
      var visibility = 1.0;
      var shadowIndex = i32(light.castShadow);
      if (shadowIndex >= 0 ) {
        var shadowMatrix:mat4x4<f32>;
        if(enableCSM && csmCount > 1){
          for(var csm:i32 = 0; csm < csmCount; csm ++){
            var csmShadowBias = globalUniform.csmShadowBias[csm];
            shadowMatrix = globalUniform.csmMatrix[csm];
            let csmShadowResult = directShadowMapingIndex(light, shadowMatrix, P, N, csm, csmShadowBias);
            if(csmShadowResult.y < 0.5){
              visibility = csmShadowResult.x;
              break;
            }
          }
        }else{
          shadowMatrix = globalUniform.shadowMatrix[shadowIndex];
          visibility = directShadowMapingIndex(light, shadowMatrix, P, N, shadowIndex, shadowBias).x;
        }
      }
      shadowStrut.directShadowVisibility = visibility;
    }
    
    fn directShadowMapingIndex(light:LightData, matrix:mat4x4<f32>, P:vec3<f32>, N:vec3<f32>, depthTexIndex:i32, shadowBias:f32) -> vec2<f32>
    {
      var visibility = 1.0;
      var isOutSideArea:f32 = 1.0;
      var shadowPosTmp = matrix * vec4<f32>(P.xyz, 1.0);
      var shadowPos = shadowPosTmp.xyz / shadowPosTmp.w;
      var varying_shadowUV = shadowPos.xy * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5, 0.5);
      if (varying_shadowUV.x <= 1.0
        && varying_shadowUV.x >= 0.0
        && varying_shadowUV.y <= 1.0
        && varying_shadowUV.y >= 0.0
        && shadowPosTmp.z <= 1.0
        && shadowPosTmp.z >= 0.0)
      {
        isOutSideArea = 0.0;
        var uvOnePixel = 1.0 / vec2<f32>(globalUniform.shadowMapSize);
        var NoL = abs(dot(N, normalize(light.direction)));
        var bias = shadowBias / max(NoL, 0.000001);
        visibility = textureSampleCompareLevel(shadowMap, shadowMapSampler, varying_shadowUV, depthTexIndex, shadowPos.z - bias);
        visibility += 0.001;
      }
      return vec2<f32>(visibility, isOutSideArea);
    }

    @compute @workgroup_size( 8 , 8 , 1 )
    fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
    {
      fragCoord = vec2<i32>( globalInvocation_id.xy );

      texSize = textureDimensions(inTex).xy;
      if(fragCoord.x >= i32(texSize.x) || fragCoord.y >= i32(texSize.y)){
          return;
      }
      wNormal = textureLoad(normalTex, fragCoord, 0);
      var oc = textureLoad(inTex, fragCoord, 0);
      var outColor = oc.xyz;
      directLight = lightBuffer[0] ;
      if(directLight.castShadow >= 0){
        let index = fragCoord.x + fragCoord.y * i32(texSize.x);
        var historyData = historyGodRayData[index];
        let lightColor = directLight.lightColor;
        
        var godRayFactor = 0.0;
        if(wNormal.w > 0.5){
          //not sky
          let lightPos = models.matrix[u32(directLight.lightMatrixIndex)][3].xyz;
          wPosition = textureLoad(posTex, fragCoord, 0).xyz;
          viewDirection = normalize(globalUniform.CameraPos - wPosition) ;
          godRayFactor = rayMarch();
          godRayFactor = updateGodRay(historyData, godRayFactor);
        }
        historyData.pos = wPosition;
        historyData.value = godRayFactor;
        historyGodRayData[index] = historyData;

        outColor = oc.xyz + vec3<f32>(godRayFactor * godRayUniform.intensity * lightColor);
      }
      textureStore(outTex, fragCoord , vec4<f32>(outColor, oc.w));
    }

    fn updateGodRay(historyData:CacheGodRay, newFactor:f32) -> f32 {
      var changeFactor = 0.2;
      if(length(historyData.pos - wPosition) > 0.01){
        changeFactor = 0.4;
      }
      var factor = mix(historyData.value, newFactor, changeFactor);
      
      let pixelOffset = 1 + i32(globalUniform.frame) % 3;
      let coordRange = vec2<i32>(texSize);
      let coordIndex0 = getCoordIndex(fragCoord.x + pixelOffset, fragCoord.y - pixelOffset, coordRange);
      let coordIndex1 = getCoordIndex(fragCoord.x - pixelOffset, fragCoord.y - pixelOffset, coordRange);
      let coordIndex2 = getCoordIndex(fragCoord.x, fragCoord.y + pixelOffset * 2, coordRange);

      let oldOC0 = historyGodRayData[coordIndex0].value;
      let oldOC1 = historyGodRayData[coordIndex1].value;
      let oldOC2 = historyGodRayData[coordIndex2].value;

      let opRound = (oldOC0 + oldOC1 + oldOC2) * 0.3333333;
      factor = mix(opRound, factor, 0.5);

      return factor;
    }

    fn getCoordIndex(x0:i32, y0:i32, size:vec2<i32>) -> i32{
      let x = clamp(x0, 0, size.x - 1);
      let y = clamp(y0, 0, size.y - 1);
      return y * size.x + x;
    }
    
    
    fn rayMarch() -> f32{
      var godRayFactor = 0.0;
      let L = normalize(directLight.direction);
      let rayMarchCount = godRayUniform.rayMarchCount;
      if(godRayUniform.blendColor > 0.5){
        let eyePosition = globalUniform.CameraPos;
        var samplePosition = eyePosition;
        var lastSamplePosition = eyePosition;
        
        var frameOffset = f32(i32(globalUniform.frame) % 4);
        frameOffset *= 0.25;
        var N = normalize(wNormal.xyz);
        for(var i:f32 = 1.0; i < rayMarchCount; i += 1.0){
          var t = (i + frameOffset) / rayMarchCount;
          lastSamplePosition = samplePosition;
          samplePosition = mix(eyePosition, wPosition, t * t);

          // var shadowVisibility = directionShadowMapping(samplePosition, globalUniform.shadowBias);
          directShadowMaping(samplePosition.xyz, N, globalUniform.shadowBias);
          var shadowVisibility = shadowStrut.directShadowVisibility;
          if(shadowVisibility > 0.5){
            var stepFactor = calcGodRayValue(samplePosition, L, viewDirection);
            stepFactor *= length(lastSamplePosition - samplePosition);
            godRayFactor += stepFactor;
          }
        }
        godRayFactor /= length(wPosition - eyePosition);
      }
      return godRayFactor;
    }

    fn calcGodRayValue(pos:vec3<f32>, L:vec3<f32>, V:vec3<f32>) -> f32{
      var halfLoV = normalize(L + V);
      var LoV = saturate(dot(V,halfLoV));
      LoV = pow(LoV, godRayUniform.scatteringExponent);
      var distance = length(pos - globalUniform.CameraPos) / (globalUniform.far);
      distance = 1.0 - saturate(distance);
      distance *= distance;
      return LoV * distance;
    }
  `,$u=`
    @group(0) @binding(0) var textureR : texture_2d<f32>;
    @group(0) @binding(1) var textureG : texture_2d<f32>;
    @group(0) @binding(2) var textureB : texture_2d<f32>;
    @group(0) @binding(3) var textureA : texture_2d<f32>;
    @group(0) @binding(4) var outTex : texture_storage_2d<rgba8unorm, write>;

    @compute @workgroup_size(8, 8, 1)
    fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {
        let size = textureDimensions(outTex);
        let fragCoord : vec2<i32> = vec2<i32>(GlobalInvocationID.xy); 
        var uv:vec2<f32>;
        uv.x = f32(fragCoord.x)/f32(size.x);
        uv.y = f32(fragCoord.y)/f32(size.y);
        var oc:vec4<f32> = textureSampleLevel(atlasTexture, atlasTextureSampler, targetUV, 0.0);

        let sizeR = textureDimensions(textureR);
        let sizeG = textureDimensions(textureG);
        let sizeB = textureDimensions(textureB);
        let sizeA = textureDimensions(textureA);
        
        var tr = textureLoad(textureR, vec2<i32>(uv * sizeR) , 0 ) ;
        var tg = textureLoad(textureG, vec2<i32>(uv * sizeG) , 0 ) ;
        var tb = textureLoad(textureB, vec2<i32>(uv * sizeB) , 0 ) ;
        var ta = textureLoad(textureA, vec2<i32>(uv * sizeA) , 0 ) ;

        let color = vec4<f32>(tr,tg,tb,ta);
        textureStore(outTex, fragCoord , vec4(color));
    }

`,ec=`
   struct OutlineSettingData{
      strength: f32,
      useAddMode: f32,
      outlinePixel: f32,
      fadeOutlinePixel: f32,
      lowTexWidth: f32,
      lowTexHeight: f32,
      slot0: f32,
      slot1: f32,
   }

   @group(0) @binding(0) var<uniform> outlineSetting: OutlineSettingData;
   @group(0) @binding(1) var inTex : texture_2d<f32>;
   @group(0) @binding(2) var lowTexSampler : sampler;
   @group(0) @binding(3) var lowTex : texture_2d<f32>;
   @group(0) @binding(4) var outlineTex : texture_storage_2d<rgba16float, write>;
   
   var<private> texSize: vec2<u32>;
   var<private> fragCoord: vec2<i32>;

   @compute @workgroup_size( 8 , 8 , 1 )
   fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
   {
      fragCoord = vec2<i32>( globalInvocation_id.xy );
      texSize = textureDimensions(outlineTex).xy;
      if(fragCoord.x >= i32(texSize.x) || fragCoord.y >= i32(texSize.y)){
         return;
      }

      var uv01 = vec2<f32>(fragCoord) / (vec2<f32>(texSize) - 1.0);
      var offset = vec2<f32>(texSize) / vec2<f32>(outlineSetting.lowTexWidth, outlineSetting.lowTexHeight);
      offset = 0.5 * offset / (vec2<f32>(texSize) - 1.0);
      uv01 += offset;
      var outLineColor = textureSampleLevel(lowTex, lowTexSampler, uv01, 0.0);

      outLineColor.x *= outlineSetting.strength;
      outLineColor.y *= outlineSetting.strength;
      outLineColor.z *= outlineSetting.strength;

      var inColor = textureLoad(inTex, fragCoord, 0);
      var blendColor:vec3<f32> = vec3<f32>(0.0);
      if(outlineSetting.useAddMode > 0.5){
         blendColor = inColor.xyz + outLineColor.xyz * outLineColor.w;
      }else{
         blendColor = mix(inColor.xyz, outLineColor.xyz, outLineColor.w);
      }
      textureStore(outlineTex, fragCoord, vec4<f32>(blendColor, inColor.w));
   }

`,tc=`
  struct OutlineSettingData{
    strength: f32,
    useAddMode: f32,
    outlinePixel: f32,
    fadeOutlinePixel: f32,
    lowTexWidth: f32,
    lowTexHeight: f32,
    slot0: f32,
    slot1: f32,
  }

  struct OutlineSlotData{
    color: vec3<f32>,
    count: f32,
  }

  struct OutlineWeightData{
    slotIndex:f32,
    outerSlotIndex:f32,
    entityIndex:f32,
    weight:f32
  }

  struct OutlineEntities{
    list: array<f32, 16u>,
  }

  @group(0) @binding(0) var<uniform> outlineSetting: OutlineSettingData;
  @group(0) @binding(1) var<storage, read_write> slotsBuffer : array<OutlineSlotData>;
  @group(0) @binding(2) var<storage, read_write> weightBuffer : array<OutlineWeightData>;
  @group(0) @binding(3) var<storage, read_write> entitiesBuffer : array<OutlineEntities>;
  @group(0) @binding(4) var indexTexture : texture_2d<f32>;

  var<private> texSize: vec2<u32>;
  var<private> lowSize: vec2<i32>;
  var<private> fragCoord: vec2<i32>;
  var<private> fragCoordLow: vec2<i32>;
  var<private> coordIndex: i32;

  var<private> fragOutline: OutlineWeightData;

  @compute @workgroup_size( 8 , 8 , 1 )
  fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
  {
    fragCoordLow = vec2<i32>( globalInvocation_id.xy );
    texSize = textureDimensions(indexTexture).xy;
    lowSize = vec2<i32>(i32(outlineSetting.lowTexWidth), i32(outlineSetting.lowTexHeight));
    let scaleValue = f32(texSize.x) / f32(lowSize.x);
    fragCoord.x = i32(f32(fragCoordLow.x) * scaleValue);
    fragCoord.y = i32(f32(fragCoordLow.y) * scaleValue);

    if(fragCoord.x >= i32(texSize.x) || fragCoord.y >= i32(texSize.y)){
        return;
    }
    if(fragCoordLow.x >= lowSize.x || fragCoordLow.y >= lowSize.y){
        return;
    }
    
    coordIndex = fragCoordLow.x + fragCoordLow.y * lowSize.x;
    fragOutline = weightBuffer[coordIndex];
    var wPos = textureLoad(indexTexture, fragCoord, 0 ) ;
    
    fragOutline.entityIndex = round(wPos.w);
    fragOutline.slotIndex = -1.0;
    fragOutline.outerSlotIndex = -1.0;
    fragOutline.weight = 0.0;
    
    if(fragOutline.entityIndex >= 0.0){
      fragOutline.slotIndex = f32(matchOutlineSlot());
    }
    weightBuffer[coordIndex] = fragOutline;
  }

  fn matchOutlineSlot() -> i32
  {
    for(var i:i32 = 0; i < 8; i ++){
        var slotData:OutlineSlotData = slotsBuffer[i];
        var entities:array<f32, 16u> = entitiesBuffer[i].list;
        let count:i32 = i32(slotData.count);
        for(var j:i32 = 0; j < count; j ++){
            var outlineIndex = entities[j];
            if(abs(fragOutline.entityIndex - outlineIndex) < 0.1){ 
                return i;
            }
        }
    }
    return -1;
  }
`,ic=`
    struct OutlineSettingData{
        strength: f32,
        useAddMode: f32,
        outlinePixel: f32,
        fadeOutlinePixel: f32,
        lowTexWidth: f32,
        lowTexHeight: f32,
        slot0: f32,
        slot1: f32,
    }
    
    struct OutlineSlotData{
        color: vec3<f32>,
        count: f32,
    }
    
    struct OutlineWeightData{
        slotIndex:f32,
        outerSlotIndex:f32,
        entityIndex:f32,
        weight:f32
    }

    @group(0) @binding(0) var<uniform> outlineSetting: OutlineSettingData;
    @group(0) @binding(1) var<storage, read_write> slotsBuffer : array<OutlineSlotData>;
    @group(0) @binding(2) var<storage, read_write> weightBuffer : array<OutlineWeightData>;
    @group(0) @binding(3) var<storage, read_write> oldOutlineColor : array<vec4<f32>>;
    @group(0) @binding(4) var lowTex : texture_storage_2d<rgba16float, write>;
    
    var<private> texSize: vec2<u32>;
    var<private> fragCoord: vec2<i32>;
    var<private> coordIndex: i32;
    var<private> fragOutline: OutlineWeightData;
    
    @compute @workgroup_size( 8 , 8 , 1 )
    fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
    {
        fragCoord = vec2<i32>( globalInvocation_id.xy );
        texSize = textureDimensions(lowTex).xy;
        if(fragCoord.x >= i32(texSize.x) || fragCoord.y >= i32(texSize.y)){
            return;
        }
        
        coordIndex = fragCoord.x + fragCoord.y * i32(texSize.x);
        fragOutline = weightBuffer[coordIndex];
        
        var newOC = vec4<f32>(0.0);
        
        calcOutline();
        let outerSlotIndex:i32 = i32(round(fragOutline.outerSlotIndex));
        if(outerSlotIndex >= 0){
            let outLineColor = slotsBuffer[outerSlotIndex].color;
            newOC = vec4<f32>(outLineColor, fragOutline.weight);
        }
        
        let coordIndex0 = fragCoord.x + 1 + (fragCoord.y + 1) * i32(texSize.x);
        let coordIndex1 = fragCoord.x - 1 + (fragCoord.y + 1) * i32(texSize.x);
        let coordIndex2 = fragCoord.x + (fragCoord.y - 1) * i32(texSize.x);

        let oldOC = oldOutlineColor[coordIndex];
        let oldOC0 = oldOutlineColor[coordIndex0];
        let oldOC1 = oldOutlineColor[coordIndex1];
        let oldOC2 = oldOutlineColor[coordIndex2];
        
        newOC = mix((oldOC + oldOC0 + oldOC1 + oldOC2) * 0.25, newOC, 0.5);
        oldOutlineColor[coordIndex] = newOC;
        textureStore(lowTex, fragCoord, newOC);
    }
    
    fn calcOutline()
    {
        let outlinePixel = outlineSetting.outlinePixel;
        let pixelRadius = outlinePixel + outlineSetting.fadeOutlinePixel;
        let minX = max(0.0, f32(fragCoord.x) - pixelRadius);
        let maxX = min(f32(texSize.x), f32(fragCoord.x) + pixelRadius);
        let minY = max(0.0, f32(fragCoord.y) - pixelRadius);
        let maxY = min(f32(texSize.y), f32(fragCoord.y) + pixelRadius);
        var coordTemp_f32 = vec2<f32>(0.0);
        var coordCurrent_f32 = vec2<f32>(fragCoord);
        var tempCoordIndex = 0;
        var tempWeightData: OutlineWeightData;
        for(var x:f32 = minX; x < maxX; x += 1.0){
            for(var y:f32 = minY; y < maxY; y += 1.0){
                coordTemp_f32.x = x;
                coordTemp_f32.y = y;
                let distanceToOuter = length(coordTemp_f32 - coordCurrent_f32);
                if(distanceToOuter < pixelRadius){
                    var coord_i32 = vec2<i32>(coordTemp_f32);
                    tempCoordIndex = coord_i32.x + coord_i32.y * i32(texSize.x);
                    tempWeightData = weightBuffer[tempCoordIndex];
                    let outlineGap = abs(tempWeightData.slotIndex - fragOutline.slotIndex);
                    if(outlineGap > 0.1){
                        if(tempWeightData.slotIndex > fragOutline.slotIndex){
                            if(abs(tempWeightData.slotIndex - fragOutline.outerSlotIndex) < 0.1){
                                fragOutline.weight = max(fragOutline.weight, calcWeight(pixelRadius, distanceToOuter, outlinePixel));
                                fragOutline.outerSlotIndex = tempWeightData.slotIndex;
                                weightBuffer[tempCoordIndex] = tempWeightData;
                            }else if(tempWeightData.slotIndex > fragOutline.outerSlotIndex){
                                fragOutline.weight = calcWeight(pixelRadius, distanceToOuter, outlinePixel);
                                fragOutline.outerSlotIndex = tempWeightData.slotIndex;
                                weightBuffer[tempCoordIndex] = tempWeightData;
                            }
                        }
                    }
                }
            }
        }
    }
    
    fn calcWeight(totalRadius:f32, distance:f32, innerRadius:f32) -> f32{
        if(distance < innerRadius){
            return 1.0;
        }
        var ret = 1.0 - (distance - innerRadius)  / (totalRadius - innerRadius);

        return ret;
    }
`,rc=`

    #include "GlobalUniform"

    struct PickResult{
        pick_meshID:f32,
        pick_meshID2:f32,
        pick_UV:vec2<f32>,
        pick_Position:vec4<f32>,
        pick_Normal:vec4<f32>,
        pick_Tangent:vec4<f32>,
    }

    //@group(0) @binding(0) var<uniform> globalUniform: GlobalUniform;
    @group(0) @binding(1) var<storage,read_write> outBuffer: PickResult;
    @group(0) @binding(2) var visibleMap : texture_2d<f32>;

    @compute @workgroup_size( 1 )
    fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
    {
    var result:PickResult ;
    // result.pick_meshID
    let texSize = textureDimensions(visibleMap).xy;
    let screenPoint = vec2<f32>(globalUniform.mouseX/globalUniform.windowWidth,globalUniform.mouseY/globalUniform.windowHeight);

    let mouseUV = screenPoint * vec2<f32>(texSize.xy); 
    let info = textureLoad(visibleMap, vec2<i32>(mouseUV) , 0);

    outBuffer.pick_meshID = f32(info.w) ;
    outBuffer.pick_meshID2 = f32(info.w) ;
    outBuffer.pick_Tangent = vec4<f32>(2.0,2.0,2.0,2.0) ;
    outBuffer.pick_UV = vec2<f32>(globalUniform.mouseX,globalUniform.mouseY) ;
    outBuffer.pick_Position = vec4<f32>(info.xyzw) ;
    outBuffer.pick_Normal = vec4<f32>(info.xyzw) ;
    }
`,Xg=`
#include "GlobalUniform"
  struct UniformData {
    radius: f32 ,
    bias: f32,
    aoPower: f32 ,
    blurSize: f32 ,
  };

  @group(0) @binding(0) var<uniform> standUniform: GlobalUniform;
  @group(0) @binding(1) var<uniform> uniformData: UniformData;
  @group(0) @binding(2) var<storage,read> sampleData: array<vec4<f32>>;

  // @group(0) @binding(3) var colorMap : texture_2d<f32>;
  @group(0) @binding(3) var positionMap : texture_2d<f32>;
  @group(0) @binding(4) var normalMap : texture_2d<f32>;

  @group(0) @binding(5) var noiseMapSampler: sampler;
  @group(0) @binding(6) var noiseMap : texture_2d<f32>;

  @group(0) @binding(7) var outTex : texture_storage_2d<rgba16float, write>;

  var<private> kernelSize: i32 = 32 ;

  @compute @workgroup_size( 8 , 8 )
  fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
  {
    var fragCoord = vec2<i32>( globalInvocation_id.xy );

    var texSize = textureDimensions(positionMap).xy;
    var texCoord = vec2<f32>(fragCoord) / vec2<f32>(texSize);

    var fragColor = vec4<f32>(1.0);

    var viewMat = standUniform.viewMat  ;
    // var color = textureLoad(colorMap, fragCoord , 0 ) ;
    var wPos = textureLoad(positionMap, fragCoord , 0 ) ;

    var fragPosition = viewMat * vec4<f32>(wPos.xyz,1.0);
    fragPosition = vec4(fragPosition.xyz / fragPosition.w,1.0) ;

    var texNormal = textureLoad(normalMap, fragCoord , 0 ) ;
    var sampleNormal = texNormal.xyz ;
    sampleNormal = sampleNormal * 2.0 - 1.0;
    var fragNormal = viewMat * vec4<f32>((sampleNormal.xyz),0.0);

    var pes = vec2<f32>(texSize.xy) / 4.0 ;
    var noiseTex:vec4<f32> = textureSampleLevel(noiseMap, noiseMapSampler, texCoord * pes , 0.0);
    var randomVec  = (viewMat * vec4<f32>(normalize(noiseTex.xyz),0.0)).xyz;

    var tangent = normalize(randomVec - fragNormal.xyz * dot(randomVec , fragNormal.xyz));
    var bTangent = cross(fragNormal.xyz, tangent) + 0.0001 ;
    var tbn = mat3x3<f32>(tangent, bTangent, fragNormal.xyz);

    var offset:vec4<f32>;
    var samplePos :vec3<f32>;
    var offsetPosition:f32;
    var sample_depth_v:vec4<f32>;
    var occlusion:f32 = 0.0;
    var rangeCheck:f32 = 0.0 ;
    var radius:f32 = uniformData.radius * 32.0 * fragPosition.z ;

    for(var i:i32 = 0; i < 32 ; i = i + 1 ){
      samplePos  = (tbn * sampleData[i].xyz ) ;
      samplePos  = fragPosition.xyz + samplePos * radius ;

      offset = vec4(samplePos, 1.0);
      offset = standUniform.projMat * offset;

      var off = offset.xyz / offset.w;
      off = (off.xyz * 0.5 ) + 0.5 ;
      off.y = 1.0 - off.y ;
      var offsetUV = vec2<i32>(off.xy * vec2<f32>(texSize.xy));

      sample_depth_v = textureLoad(positionMap, offsetUV.xy , 0 ) ;
      sample_depth_v = vec4<f32>((viewMat * vec4<f32>(sample_depth_v.xyz,1.0)).xyz,1.0);
      offsetPosition = sample_depth_v.z / sample_depth_v.w ;

      rangeCheck = smoothstep(0.0, 1.0, radius / abs(offsetPosition - fragPosition.z ));
      // rangeCheck = smoothstep(0.0, 1.0, radius / uniformData.bias);

      var a = 1.0 ;
      if(offsetPosition >= (samplePos.z + uniformData.bias)){
        a = 0.0 ;
      }
      a = a * rangeCheck ;
      occlusion = occlusion + a ;
    }

    occlusion = 1.0 - ( occlusion / f32(kernelSize) * texNormal.w );
    occlusion = pow(occlusion, uniformData.aoPower) ;

    // color = color * occlusion ;

    textureStore(outTex, fragCoord , vec4(occlusion));
  }
`,sc=`
@group(0) @binding(0) var<storage, read_write> rayTraceBuffer : array<RayTraceRetData>;
  @group(0) @binding(1) var colorMap : texture_2d<f32>;
  @group(0) @binding(2) var ssrMapSampler : sampler;
  @group(0) @binding(3) var ssrMap : texture_2d<f32>;
  @group(0) @binding(4) var outTex : texture_storage_2d<rgba16float, write>;

  var<private> colorTexSize: vec2<u32>;
  var<private> ssrTexSize: vec2<u32>;
  var<private> fragCoord: vec2<i32>;
  var<private> ssrCoord: vec2<i32>;

  struct RayTraceRetData{
    skyColor:vec3<f32>,
    roughness:f32,

    hitCoord:vec2<f32>,
    alpha:f32,
    fresnel:f32,
  }
  
  @compute @workgroup_size( 8 , 8 , 1 )
  fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
  {
    fragCoord = vec2<i32>( globalInvocation_id.xy );
    colorTexSize = textureDimensions(colorMap).xy;
    ssrTexSize = textureDimensions(ssrMap).xy;
    if(fragCoord.x >= i32(colorTexSize.x) || fragCoord.y >= i32(colorTexSize.y)){
        return;
    }
    let scale:f32 = f32(ssrTexSize.x) / f32(colorTexSize.x);
    ssrCoord = vec2<i32>(vec2<f32>(fragCoord.xy) * scale);
    let index = ssrCoord.x + ssrCoord.y * i32(ssrTexSize.x);
    let hitData = rayTraceBuffer[index];
    var color = textureLoad(colorMap, fragCoord , 0);
    var uv01 = vec2<f32>(f32(fragCoord.x), f32(fragCoord.y));
    uv01 = uv01 / vec2<f32>(colorTexSize - 1);
    
    var ssrColor = textureSampleLevel(ssrMap, ssrMapSampler, uv01, 0.0);
    var tc = mix(color, ssrColor, hitData.fresnel) ;
    var outColor = tc ;
    outColor.a = color.a ; 
    textureStore(outTex, fragCoord , outColor );
  }

`,ac=`
  struct SSRUniformData {
    ssrBufferSizeX: f32,
    ssrBufferSizeY: f32,
    colorMapSizeX: f32,
    colorMapSizeY: f32,

    fadeEdgeRatio: f32,
    rayMarchRatio: f32,
    fadeDistanceMin: f32,
    fadeDistanceMax: f32,
    
    mixThreshold: f32,
    roughnessThreshold: f32,
    reflectionRatio: f32,
    powDotRN: f32,

    randomSeedX: f32,
    randomSeedY: f32,
    slot1: f32,
    slot2: f32,
  };

  struct RayTraceRetData{
    skyColor:vec3<f32>,
    roughness:f32,

    hitCoord:vec2<f32>,
    alpha:f32,
    fresnel:f32,
  }

  @group(0) @binding(0) var<uniform> ssrUniform: SSRUniformData;
  @group(0) @binding(1) var<storage, read_write> rayTraceBuffer : array<RayTraceRetData>;
  @group(0) @binding(2) var<storage, read_write> ssrColorData : array<vec4<f32>>;
  @group(0) @binding(3) var<storage, read_write> historyPosition : array<vec4<f32>>;

  @group(0) @binding(4) var colorMap: texture_2d<f32>;
  @group(0) @binding(5) var outTex : texture_storage_2d<rgba16float, write>;

  var<private> ssrBufferCoord: vec2<i32>;
  var<private> colorTexSize: vec2<i32>;
  var<private> bufferData: RayTraceRetData;
  var<private> ssrBufferSize: vec2<i32>;
  var<private> coordIndex: i32;

  @compute @workgroup_size( 8 , 8 , 1 )
  fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
  {
    ssrBufferCoord = vec2<i32>( globalInvocation_id.xy );
    ssrBufferSize = vec2<i32>(i32(ssrUniform.ssrBufferSizeX), i32(ssrUniform.ssrBufferSizeY));
    colorTexSize = vec2<i32>(i32(ssrUniform.colorMapSizeX), i32(ssrUniform.colorMapSizeY));

    if(ssrBufferCoord.x >= ssrBufferSize.x || ssrBufferCoord.y >= ssrBufferSize.y){
        return;
    }

    coordIndex = ssrBufferCoord.x + ssrBufferCoord.y * ssrBufferSize.x;
    bufferData = rayTraceBuffer[coordIndex];
    var oc = vec4<f32>(0.0, 0.0, 0.0, -1.0);
    
    var mixFactor = historyPosition[coordIndex].w;
    
    if(bufferData.alpha >= 0.0 && bufferData.roughness < ssrUniform.roughnessThreshold){
      let roughness = clamp(bufferData.roughness, 0.0, 1.0);
      let prefilterColor = bufferData.skyColor;
      var ssrColor = textureLoad(colorMap, vec2<i32>(bufferData.hitCoord), 0);
      ssrColor.w = bufferData.alpha;
      oc = ssrColor;
    }
    let skyColor = vec4<f32>(bufferData.skyColor, 1.0);
    oc = mix(oc, skyColor, 1.0 - bufferData.alpha);
    
    let lastColor = ssrColorData[coordIndex];
    var newColor = mix(oc, lastColor, mixFactor);
    newColor.w = oc.w;
    
    ssrColorData[coordIndex] = newColor;
    
    textureStore(outTex, ssrBufferCoord , newColor);
  }
`,oc=`
  #include "GlobalUniform"

  struct SSRUniformData {
    ssrBufferSizeX: f32,
    ssrBufferSizeY: f32,
    colorMapSizeX: f32,
    colorMapSizeY: f32,

    fadeEdgeRatio: f32,
    rayMarchRatio: f32,
    fadeDistanceMin: f32,
    fadeDistanceMax: f32,
    
    mixThreshold: f32,
    roughnessThreshold: f32,
    reflectionRatio: f32,
    powDotRN: f32,

    randomSeedX: f32,
    randomSeedY: f32,
    slot1: f32,
    slot2: f32,
  };

  struct HitData{
    hitPos:vec3<f32>,
    hitNormal:vec3<f32>,
    fadeAlpha:vec4<f32>,
    hitCoord:vec2<i32>,
    hitResult:i32,
    hitSky:i32,
  };

  struct RayTraceRetData{
    skyColor:vec3<f32>,
    roughness:f32,

    hitCoord:vec2<f32>,
    alpha:f32,
    fresnel:f32,
  }

  @group(0) @binding(0) var<uniform> standUniform: GlobalUniform;
  @group(0) @binding(1) var<uniform> ssrUniform: SSRUniformData;
  @group(0) @binding(2) var<storage, read_write> rayTraceBuffer : array<RayTraceRetData>;
  @group(0) @binding(4) var<storage, read_write> historyPosition : array<vec4<f32>>;

  @group(0) @binding(5) var zBufferTexture : texture_2d<f32>;
  @group(0) @binding(6) var normalBufferTex : texture_2d<f32>;
  @group(0) @binding(7) var materialBufferTex : texture_2d<f32>;
  @group(0) @binding(8) var prefilterMapSampler: sampler;
  @group(0) @binding(9) var prefilterMap: texture_cube<f32>;

  var<private> rayOrigin: vec3<f32>;
  var<private> rayDirection: vec3<f32>;
  var<private> cameraPosition: vec3<f32>;
  var<private> reflectionDir: vec3<f32>;
  var<private> colorTexSize: vec2<i32>;
  var<private> fragCoordColor: vec2<i32>;
  var<private> ssrBufferCoord: vec2<i32>;
  var<private> ssrBufferSize: vec2<i32>;
  var<private> hitData: HitData;
  var<private> rayTraceRet: RayTraceRetData;
  var<private> worldPosition: vec3<f32>;
  var<private> worldNormal: vec3<f32>;
  var<private> roughness: f32;
  var<private> fresnel: f32;

  var<private> historyPos: vec3<f32>;
  var<private> coordIndex: i32;

  var <private> PI: f32 = 3.14159;

  @compute @workgroup_size( 8 , 8 , 1 )
  fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
  {
    ssrBufferCoord = vec2<i32>( globalInvocation_id.xy);
    ssrBufferSize = vec2<i32>(i32(ssrUniform.ssrBufferSizeX), i32(ssrUniform.ssrBufferSizeY));
    if(ssrBufferCoord.x >= ssrBufferSize.x || ssrBufferCoord.y >= ssrBufferSize.y){
        return;
    }
    coordIndex = ssrBufferCoord.x + ssrBufferCoord.y * ssrBufferSize.x;

    colorTexSize = vec2<i32>(i32(ssrUniform.colorMapSizeX), i32(ssrUniform.colorMapSizeY));
    fragCoordColor = convertColorCoordFromSSRCoord(ssrBufferCoord);

    hitData.fadeAlpha = vec4<f32>(0.0);
    hitData.hitCoord = vec2<i32>(0);
    hitData.hitResult = 0;
    hitData.hitNormal = vec3<f32>(0.0, 1.0, 0.0);
    hitData.hitSky = 1;

    worldPosition = textureLoad(zBufferTexture, fragCoordColor , 0).xyz;
    historyPos = historyPosition[coordIndex].xyz;
    
    var mixFactor = 0.2;
    if(length(historyPos - worldPosition) < ssrUniform.mixThreshold){
        mixFactor = 0.9;
    }
    historyPosition[coordIndex] = vec4<f32>(worldPosition, mixFactor);
    
    let normal_v4 = textureLoad(normalBufferTex, fragCoordColor , 0);
    worldNormal = normalize(vec3<f32>(normal_v4.xyz) * 2.0 - 1.0);
    let materialData = textureLoad(materialBufferTex, fragCoordColor , 0 );
    let roughness = materialData.g * (1.0 - materialData.b);
    fresnel = (1.0 - roughness) * ssrUniform.reflectionRatio;

    cameraPosition = vec3<f32>(standUniform.cameraWorldMatrix[3].xyz);
    rayOrigin = vec3<f32>(worldPosition.xyz);

    rayDirection = normalize(vec3<f32>(worldPosition.xyz - cameraPosition));
    
    var randomSeed = fract(ssrUniform.randomSeedX + worldPosition.x);
    rand_seed.x = randomSeed;
    rand_seed.y = fract(ssrUniform.randomSeedY + worldPosition.y + worldPosition.z);
    randomSeed = rand();
    
    let normalRandom = makeRandomDirection(worldNormal, u32(randomSeed * 256.0), 256, roughness);
    
    reflectionDir = normalize(reflect(rayDirection, normalRandom));

    if(normal_v4.w > 0.5 && roughness < ssrUniform.roughnessThreshold){
      let uvOrigin = vec2<f32>(f32(fragCoordColor.x), f32(fragCoordColor.y));
      let rayMarchPosition = rayOrigin + reflectionDir * 100.0;
      var uvRayMarch = standUniform.projMat * (standUniform.viewMat * vec4<f32>(rayMarchPosition, 1.0));
      var uvOffset = (vec2<f32>(uvRayMarch.xy / uvRayMarch.w) + 1.0) * 0.5;
      uvOffset.y = 1.0 - uvOffset.y;
      uvOffset = uvOffset * vec2<f32>(colorTexSize - 1) - uvOrigin;
      uvOffset = normalize(uvOffset);

      rayTrace(uvOffset);
      if(hitData.hitResult == 1){
          hidingArtifact();
          rayTraceRet.alpha = hitData.fadeAlpha.x * hitData.fadeAlpha.y * hitData.fadeAlpha.z * hitData.fadeAlpha.w;
          if(hitData.hitSky == 1){
            rayTraceRet.alpha = 0.0;
          }
      }else{
        rayTraceRet.alpha = 0.0;
      }
      rayTraceRet.skyColor = getSkyColor();
    }else{
      rayTraceRet.alpha = -1.0;
      rayTraceRet.skyColor = vec3<f32>(0.0);
    }

    rayTraceRet.roughness = roughness;
    rayTraceRet.fresnel = fresnel;
    rayTraceRet.hitCoord = vec2<f32>(hitData.hitCoord);

    let index:i32 = ssrBufferCoord.x + ssrBufferCoord.y * ssrBufferSize.x;
    rayTraceBuffer[index] = rayTraceRet;
  }

  fn makeRandomDirection(srcDirection:vec3<f32>, i:u32, SAMPLE_COUNT:u32, roughness:f32) -> vec3<f32>
  {
    var N: vec3<f32> = normalize(srcDirection);
    var Xi:vec2<f32> = hammersley(i, SAMPLE_COUNT);
    return ImportanceSampleGGX(Xi, N, roughness);
  }

  fn hammersley( i : u32 ,  N : u32 ) -> vec2<f32>
  {
    // Radical inverse based on http://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html
    var bits = (i << 16u) | (i >> 16u);
    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);
    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);
    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);
    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);
    var rdi = f32(bits) * 2.3283064365386963e-10;
    return vec2<f32>(f32(i) /f32(N), rdi);
  }

  fn ImportanceSampleGGX( Xi:vec2<f32>, N:vec3<f32>, roughness:f32) ->vec3<f32>
  {
    var a = roughness*roughness;

    var phi = 2.0 * PI * Xi.x;
    var cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a*a - 1.0) * Xi.y));
    var sinTheta = sqrt(1.0 - cosTheta*cosTheta);

    // from spherical coordinates to cartesian coordinates
    var H:vec3<f32>;
    H.x = cos(phi) * sinTheta;
    H.y = sin(phi) * sinTheta;
    H.z = cosTheta;

    // from tangent-space vector to world-space sample vector
  var up:vec3<f32>;
    if(abs(N.z) < 0.999)
    {
        up = vec3<f32>(0.0, 0.0, 1.0);
    }
    else
    {
        up = vec3<f32>(1.0, 0.0, 0.0);
    }
  var tangent:vec3<f32>  = normalize(cross(up, N));
  var bitangent:vec3<f32> = cross(N, tangent);
  var sampleVec:vec3<f32> = tangent * H.x + bitangent * H.y + N * H.z;
  return normalize(sampleVec);
  }

  var<private> rand_seed :vec2<f32> = vec2<f32>(0.0);
  fn rand() -> f32 {
    rand_seed.x = fract(cos(dot(rand_seed, vec2<f32>(23.14077926, 232.61690225))) * 136.8168);
    rand_seed.y = fract(cos(dot(rand_seed, vec2<f32>(54.47856553, 345.84153136))) * 534.7645);
    return rand_seed.y;
  }

  fn getSkyColor() -> vec3<f32>{
    let calcRoughness = clamp(roughness, 0.0, 1.0);
    let MAX_REFLECTION_LOD  = f32(textureNumLevels(prefilterMap)) ;
    var prefilterColor = textureSampleLevel(prefilterMap, prefilterMapSampler, reflectionDir, calcRoughness * MAX_REFLECTION_LOD);
    return LinearToGammaSpace(vec3<f32>(prefilterColor.xyz)) * standUniform.skyExposure;
  }

  fn LinearToGammaSpace(linRGB: vec3<f32>) -> vec3<f32> {
      var linRGB1 = max(linRGB, vec3<f32>(0.0));
      linRGB1 = pow(linRGB1, vec3<f32>(0.4166666567325592));
      return max(((1.0549999475479126 * linRGB1) - vec3<f32>(0.054999999701976776)), vec3<f32>(0.0));
  }

  fn convertColorCoordFromSSRCoord(coord:vec2<i32>) -> vec2<i32>{
    let color_ssr_ratio = ssrUniform.colorMapSizeX / ssrUniform.ssrBufferSizeX;
    let targetCoord = vec2<f32>(coord) * color_ssr_ratio;
    return vec2<i32>(targetCoord);
  }

  fn hidingArtifact(){
    let texSizeF32 = vec2<f32>(f32(colorTexSize.x), f32(colorTexSize.y));
    let halfTexSizeF32 = texSizeF32 * 0.5;

    //near screen edge
    var distance2Center = abs(vec2<f32>(f32(hitData.hitCoord.x), f32(hitData.hitCoord.y)) - halfTexSizeF32);
    let halfEdgeSize:f32 = min(texSizeF32.x, texSizeF32.y) * clamp(0.01, ssrUniform.fadeEdgeRatio, 1.0) * 0.5;
    var distance2Edge = min(vec2<f32>(halfEdgeSize), halfTexSizeF32 - distance2Center);
    var ratioXY = distance2Edge / halfEdgeSize;
    hitData.fadeAlpha.x = sqrt(ratioXY.x * ratioXY.y);

    //back face hit
    var backFaceBias = max(0.0, dot(hitData.hitNormal, -reflectionDir));
    hitData.fadeAlpha.y = pow(backFaceBias, max(0.0001, ssrUniform.powDotRN));

    //screen distance ratio
    let maxLength = max(f32(colorTexSize.x), f32(colorTexSize.y)) * ssrUniform.rayMarchRatio;
    let screenPointer = hitData.hitCoord - fragCoordColor;
    var screenDistance = length(vec2<f32>(f32(screenPointer.x), f32(screenPointer.y)));
    screenDistance = clamp(screenDistance / maxLength, 0.0, 1.0);
    hitData.fadeAlpha.z = 1.0 - screenDistance;

    //position distance ratio
    var fadeDistance = length(vec3<f32>(hitData.hitPos - cameraPosition));
    var dFar = ssrUniform.fadeDistanceMax;
    var dNear = ssrUniform.fadeDistanceMin;
    dFar = max(1.0, dFar);
    dNear = clamp(dNear, 0.001, dFar - 0.001);
    fadeDistance = clamp(fadeDistance, dNear, dFar);
    fadeDistance = (fadeDistance - dNear) / (dFar - dNear);
    hitData.fadeAlpha.w = 1.0 - fadeDistance;
  }

  fn rayTrace(rayMarchDir:vec2<f32>){
    let stepLength = 4.0;
    let maxLength = max(f32(colorTexSize.x), f32(colorTexSize.y)) * ssrUniform.rayMarchRatio;
    for(var i:f32 = 1.0; i < maxLength; i = i + stepLength){
        let offsetFloat32 = i * rayMarchDir;
        var uv = fragCoordColor + vec2<i32>(i32(offsetFloat32.x), i32(offsetFloat32.y));
        let hitRet = rayInterestScene(uv);
        if(hitRet > 0){
          hitData.hitResult = hitRet;
          break;
        }
    }
    if(hitData.hitResult == 1){
        let fromUV = hitData.hitCoord;
        for(var i:f32 = -stepLength; i <= 0.0; i = i + 1.0){
          let offsetFloat32 = i * rayMarchDir;
          var uv = fromUV + vec2<i32>(i32(offsetFloat32.x), i32(offsetFloat32.y));
          let hitRet = rayInterestScene(uv);
          if(hitRet == 1){
            let WN = textureLoad(normalBufferTex, hitData.hitCoord , 0 );
            if(WN.w > 0.5){
                hitData.hitSky = 0;
            }
            let normal = vec3<f32>(WN.xyz) * 2.0 - 1.0;
            hitData.hitNormal = normalize(vec3<f32>(normal.xyz));
            break;
          }
        }
    }
  }

  fn rayInterestScene(uv:vec2<i32>) -> i32 {
    if(uv.x < 0 || uv.y < 0 || uv.x >= colorTexSize.x || uv.y >= colorTexSize.y){
      return 2;
    }else{
      let hitPos = textureLoad(zBufferTexture, uv , 0 );
      let testDir = normalize(vec3<f32>(hitPos.xyz - rayOrigin));
      let cosValue = dot(reflectionDir, testDir);

      if(cosValue > 0.9996){
        let cross1 = cross(reflectionDir, -rayDirection);
        let cross2 = cross(reflectionDir, testDir);
        if(dot(cross1, cross2) > 0.0){
          hitData.hitPos = vec3<f32>(hitPos.xyz);
          hitData.hitCoord = uv;
          return 1;
        }
      }
    }
    return 0;
  }
`,nc=`
    @group(0) @binding(0) var<storage, read_write> preColor : array<vec4<f32>>;
    @group(0) @binding(1) var preColorTex : texture_storage_2d<rgba16float, write>;

    var<private> texSize: vec2<u32>;
    var<private> fragCoord: vec2<i32>;
    var<private> coordIndex: i32;
    
    @compute @workgroup_size( 8 , 8 , 1 )
    fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
    {
      fragCoord = vec2<i32>( globalInvocation_id.xy );
      texSize = textureDimensions(preColorTex).xy;
      if(fragCoord.x >= i32(texSize.x) || fragCoord.y >= i32(texSize.y)){
          return;
      }
      coordIndex = fragCoord.x + fragCoord.y * i32(texSize.x);
      textureStore(preColorTex, fragCoord , preColor[coordIndex]);
    }
 `,lc=`
    struct TAAData{
      preProjMatrix: mat4x4<f32>,
      preViewMatrix: mat4x4<f32>,
      jitterFrameIndex: f32,
      blendFactor: f32,
      sharpFactor: f32,
      sharpPreBlurFactor: f32,
      jitterX: f32,
      jitterY: f32,
      slot0: f32,
      slot1: f32,
    }
    @group(0) @binding(0) var<uniform> taaData: TAAData;
    @group(0) @binding(1) var inTex : texture_2d<f32>;
    @group(0) @binding(2) var outTex : texture_storage_2d<rgba16float, write>;

    var<private> texSize: vec2<u32>;
    var<private> fragCoord: vec2<i32>;

    @compute @workgroup_size( 8 , 8 , 1 )
    fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
    {
      fragCoord = vec2<i32>( globalInvocation_id.xy );
      texSize = textureDimensions(outTex).xy;
      if(fragCoord.x >= i32(texSize.x) || fragCoord.y >= i32(texSize.y)){
          return;
      }
      
      let c0 = textureLoad(inTex, vec2<i32>(fragCoord.x, fragCoord.y - 1), 0);
      let c1 = textureLoad(inTex, vec2<i32>(fragCoord.x, fragCoord.y + 1), 0);
      let c2 = textureLoad(inTex, vec2<i32>(fragCoord.x - 1, fragCoord.y), 0);
      let c3 = textureLoad(inTex, vec2<i32>(fragCoord.x + 1, fragCoord.y), 0);
      
      var roundColor = (c0 + c1 + c2 + c3) * 0.25;
      let originColor = textureLoad(inTex, fragCoord, 0);
      let blurColor = mix(roundColor, originColor, taaData.sharpPreBlurFactor);
      var oc = (originColor - blurColor * taaData.sharpFactor) / (1.0 - taaData.sharpFactor);
      oc = clamp(oc, vec4<f32>(0.0), oc);
      textureStore(outTex, fragCoord , oc);
    }
`,hc=`
#include "GlobalUniform"

struct TAAData{
  preProjMatrix: mat4x4<f32>,
  preViewMatrix: mat4x4<f32>,
  jitterFrameIndex: f32,
  blendFactor: f32,
  sharpFactor: f32,
  sharpPreBlurFactor: f32,
  jitterX: f32,
  jitterY: f32,
  slot0: f32,
  slot1: f32,
}

@group(0) @binding(0) var<uniform> standUniform: GlobalUniform;
@group(0) @binding(1) var<uniform> taaData: TAAData;
@group(0) @binding(2) var<storage, read_write> preColorBuffer : array<vec4<f32>>;

@group(0) @binding(3) var preColorTexSampler : sampler;
@group(0) @binding(4) var preColorTex : texture_2d<f32>;
@group(0) @binding(5) var posTex : texture_2d<f32>;
@group(0) @binding(6) var inTexSampler : sampler;
@group(0) @binding(7) var inTex : texture_2d<f32>;
@group(0) @binding(8) var outTex : texture_storage_2d<rgba16float, write>;

var<private> texSize: vec2<u32>;
var<private> fragCoord: vec2<i32>;
var<private> coordIndex: i32;
var<private> color_min: vec4<f32>;
var<private> color_max: vec4<f32>;
var<private> color_avg: vec4<f32>;
var<private> re_proj_uv01: vec2<f32>;
var<private> FLT_EPS:f32 = 5.960464478e-8;  // 2^-24, machine epsilon: 1 + EPS = 1 (half of the ULP for 1.0f)

@compute @workgroup_size( 8 , 8 , 1 )
fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
{
  fragCoord = vec2<i32>( globalInvocation_id.xy );
  texSize = textureDimensions(inTex).xy;
  if(fragCoord.x >= i32(texSize.x) || fragCoord.y >= i32(texSize.y)){
      return;
  }
  let frame = standUniform.frame;
  coordIndex = fragCoord.x + fragCoord.y * i32(texSize.x);
  
  let oc = blendColor();
  preColorBuffer[coordIndex] = oc;
  textureStore(outTex, fragCoord , oc);
}

fn blendColor() -> vec4<f32>
{
  var preCoord = fragCoord;
  var mixWeight = 1.0;
  re_proj_uv01 = vec2<f32>(0.0);
  var reProjectionCoord:vec2<f32> = vec2<f32>(fragCoord);
  //var jitterUVOffset = 0.5 * vec2<f32>(taaData.jitterX, -taaData.jitterY);
  if(taaData.jitterFrameIndex > 0.5){
      var wPos = textureLoad(posTex, fragCoord, 0);
      let ndc = taaData.preProjMatrix * (taaData.preViewMatrix * vec4<f32>(wPos.xyz, 1.0));
      re_proj_uv01 = vec2<f32>(ndc.x, -ndc.y) / ndc.w;
      re_proj_uv01 = (re_proj_uv01 + 1.0) * 0.5;
      
      if(re_proj_uv01.x >= 0.0 && re_proj_uv01.x <= 1.0 && re_proj_uv01.y >= 0.0 && re_proj_uv01.y <= 1.0){
          mixWeight = taaData.blendFactor;
          //reProjectionCoord = re_proj_uv01 + jitterUVOffset;
          reProjectionCoord.x = re_proj_uv01.x * f32(texSize.x - 1);
          reProjectionCoord.y = re_proj_uv01.y * f32(texSize.y - 1);
          preCoord = vec2<i32>(reProjectionCoord);
      }else{ 
          //outside of screen
          mixWeight = 1.0;
      }
  }
  
  var curUV01 = vec2<f32>(fragCoord) / vec2<f32>(texSize - 1);
  //curUV01 += jitterUVOffset;
  
  let curColor = textureSampleLevel(inTex, inTexSampler, curUV01, 0.0);
  
  let preIndex = preCoord.x + preCoord.y * i32(texSize.x);
  var preColor = textureSampleLevel(preColorTex, preColorTexSampler, re_proj_uv01, 0.0);
  
  //minmax9(fragCoord);
  minmax4(fragCoord);
  
  preColor = clip_aabb(color_min.xyz, color_max.xyz, color_avg, preColor);
  var outColor = mix(preColor, curColor, mixWeight);

  return outColor;
}

fn clampCoord(coord0:vec2<i32>) -> vec2<i32>{
  return clamp(coord0, vec2<i32>(0), vec2<i32>(texSize - 1));
}

fn minmax4(coord:vec2<i32>) {
      let uv0 = clampCoord(vec2<i32>(coord.x - 1, coord.y));
      let uv1 = clampCoord(vec2<i32>(coord.x, coord.y - 1));
      let uv2 = clampCoord(vec2<i32>(coord.x, coord.y + 1));
      let uv3 = clampCoord(vec2<i32>(coord.x + 1, coord.y));
      
      let c0 = textureLoad(inTex, uv0, 0);
      let c1 = textureLoad(inTex, uv1, 0);
      let c2 = textureLoad(inTex, uv2, 0);
      let c3 = textureLoad(inTex, uv3, 0);
      
      color_min = min(c0, min(c1, min(c2, c3)));
      color_max = max(c0, max(c1, max(c2, c3)));
      color_avg = (c0 + c1 + c2 + c3) * 0.25;
  }
  
 fn minmax9(coord:vec2<i32>) {
      let uv0 = clampCoord(vec2<i32>(coord.x - 1, coord.y - 1));
      let uv1 = clampCoord(vec2<i32>(coord.x - 1, coord.y));
      let uv2 = clampCoord(vec2<i32>(coord.x - 1, coord.y + 1));
      let uv3 = clampCoord(vec2<i32>(coord.x, coord.y - 1));
      let uv4 = clampCoord(vec2<i32>(coord.x, coord.y));
      let uv5 = clampCoord(vec2<i32>(coord.x, coord.y + 1));
      let uv6 = clampCoord(vec2<i32>(coord.x + 1, coord.y - 1));
      let uv7 = clampCoord(vec2<i32>(coord.x + 1, coord.y));
      let uv8 = clampCoord(vec2<i32>(coord.x + 1, coord.y + 1));
      
      let ctl = textureLoad(inTex, uv0, 0);
      let ctc = textureLoad(inTex, uv1, 0);
      let ctr = textureLoad(inTex, uv2, 0);
      let cml = textureLoad(inTex, uv3, 0);
      let cmc = textureLoad(inTex, uv4, 0);
      let cmr = textureLoad(inTex, uv5, 0);
      let cbl = textureLoad(inTex, uv6, 0);
      let cbc = textureLoad(inTex, uv7, 0);
      let cbr = textureLoad(inTex, uv8, 0);
      
      color_min = min(ctl, min(ctc, min(ctr, min(cml, min(cmc, min(cmr, min(cbl, min(cbc, cbr))))))));
      color_max = max(ctl, max(ctc, max(ctr, max(cml, max(cmc, max(cmr, max(cbl, max(cbc, cbr))))))));
      color_avg = (ctl + ctc + ctr + cml + cmc + cmr + cbl + cbc + cbr) / 9.0;
  }
  
  fn clip_aabb(aabb_max:vec3<f32>, aabb_min:vec3<f32>, color_avg:vec4<f32>, input_texel:vec4<f32>) -> vec4<f32>
  {
      var p_clip:vec3<f32> = 0.5 * (aabb_max + aabb_min);
      var e_clip:vec3<f32> = 0.5 * (aabb_max - aabb_min) + FLT_EPS;
      var v_clip:vec4<f32> = input_texel - vec4<f32>(p_clip, color_avg.w);
      var v_unit:vec3<f32> = v_clip.xyz / e_clip;
      var a_unit:vec3<f32> = abs(v_unit);
      var ma_unit:f32 = max(a_unit.x, max(a_unit.y, a_unit.z));

      if (ma_unit > 1.0){
          return vec4<f32>(p_clip, color_avg.w) + v_clip / ma_unit;
      }else{
          return input_texel;
      }
  }`,uc=`
#include "WorldMatrixUniform"
#include "GlobalUniform"

struct VertexOutput {
    @location(0) fragUV: vec2<f32>,
    @builtin(position) member: vec4<f32>
};

#if USE_MORPHTARGETS
    ${Le.getMorphTargetShaderBinding(2,1)}
#endif

#if USE_SKELETON
    ${Or.groupBindingAndFunctions(2,1)} 
#endif

var<private> worldMatrix: mat4x4<f32>;

struct VertexAttributes{
  @builtin(instance_index) index : u32,
  @location(0) position: vec3<f32>,
  @location(1) normal: vec3<f32>,
  @location(2) uv: vec2<f32>,
  @location(3) TEXCOORD_1: vec2<f32>,

  #if USE_TANGENT
      @location(4) TANGENT: vec4<f32>,
      #if USE_SKELETON
          @location(5) joints0: vec4<f32>,
          @location(6) weights0: vec4<f32>,
          #if USE_JOINT_VEC8
          @location(7) joints1: vec4<f32>,
          @location(8) weights1: vec4<f32>,
      #endif
      #elseif USE_MORPHTARGETS
          ${Le.getMorphTargetAttr(5)}
      #endif
  #elseif USE_SKELETON
      @location(4) joints0: vec4<f32>,
      @location(5) weights0: vec4<f32>,
      #if USE_JOINT_VEC8
      @location(6) joints1: vec4<f32>,
      @location(7) weights1: vec4<f32>,
      #endif
  #elseif USE_MORPHTARGETS
     ${Le.getMorphTargetAttr(4)}
  #endif
}



@vertex
fn main(vertex:VertexAttributes) -> VertexOutput {
    worldMatrix = models.matrix[vertex.index];
    let shadowMatrix: mat4x4<f32> = globalUniform.projMat * globalUniform.viewMat ;
    var vertexPosition = vertex.position.xyz;
    var vertexNormal = vertex.normal.xyz;

    #if USE_MORPHTARGETS
     ${Le.getMorphTargetCalcVertex()}    
    #endif

    #if USE_SKELETON
        #if USE_JOINT_VEC8
          worldMatrix *= getSkeletonWorldMatrix_8(vertex.joints0, vertex.weights0, vertex.joints1, vertex.weights1);
        #else
          worldMatrix *= getSkeletonWorldMatrix_4(vertex.joints0, vertex.weights0);
        #endif
    #endif

    var worldPos = worldMatrix * vec4<f32>(vertexPosition, 1.0) ;
    var vPos = shadowMatrix * worldPos;

    return VertexOutput(vertex.uv, vPos );  
}
`,cc=`
#include "WorldMatrixUniform"
#include "GlobalUniform"

struct VertexOutput {
    @location(0) fragUV: vec2<f32>,
    @location(1) worldPos: vec3<f32>,
    @builtin(position) member: vec4<f32>
};

#if USE_MORPHTARGETS
    ${Le.getMorphTargetShaderBinding(2,1)}
##endif
 
#if USE_SKELETON
    ${Or.groupBindingAndFunctions(2,1)} 
#endif

var<private> worldMatrix: mat4x4<f32>;

struct VertexAttributes{
  @builtin(instance_index) index : u32,
  @location(0) position: vec3<f32>,
  @location(1) normal: vec3<f32>,
  @location(2) uv: vec2<f32>,
  @location(3) TEXCOORD_1: vec2<f32>,

  #if USE_TANGENT
      @location(4) TANGENT: vec4<f32>,
      #if USE_SKELETON
          @location(5) joints0: vec4<f32>,
          @location(6) weights0: vec4<f32>,
          #if USE_JOINT_VEC8
          @location(7) joints1: vec4<f32>,
          @location(8) weights1: vec4<f32>,
      #endif
      #elseif USE_MORPHTARGETS
         ${Le.getMorphTargetAttr(5)}
      #endif
  #elseif USE_SKELETON
      @location(4) joints0: vec4<f32>,
      @location(5) weights0: vec4<f32>,
      #if USE_JOINT_VEC8
      @location(6) joints1: vec4<f32>,
      @location(7) weights1: vec4<f32>,
      #endif
  #elseif USE_MORPHTARGETS
      ${Le.getMorphTargetAttr(4)}
  #endif
}

@vertex
fn main(vertex:VertexAttributes) -> VertexOutput {
    worldMatrix = models.matrix[vertex.index];
    let shadowMatrix: mat4x4<f32> = globalUniform.projMat * globalUniform.viewMat ;
    var vertexPosition = vertex.position.xyz;

    #if USE_MORPHTARGETS
        ${Le.getMorphTargetCalcVertex()}
    #endif

    #if USE_SKELETON
        #if USE_JOINT_VEC8
          worldMatrix *= getSkeletonWorldMatrix_8(vertex.joints0, vertex.weights0, vertex.joints1, vertex.weights1);
        #else
          worldMatrix *= getSkeletonWorldMatrix_4(vertex.joints0, vertex.weights0);
        #endif
    #endif

    var worldPos = worldMatrix * vec4<f32>(vertexPosition, 1.0) ;
    var vPos = shadowMatrix * worldPos;
    return VertexOutput(vertex.uv, worldPos.xyz , vPos ); 
}
`,fc=`
    #if USE_ALPHACUT
      @group(1) @binding(0)
      var baseMapSampler: sampler;
      @group(1) @binding(1)
      var baseMap: texture_2d<f32>;
    #endif

    struct FragmentOutput {
      @location(0) o_Target: vec4<f32>,
      @builtin(frag_depth) out_depth: f32
    };

    struct MaterialUniform {
      lightWorldPos: vec3<f32>,
      cameraFar: f32,
    };

    @group(2) @binding(0)
    var<uniform> materialUniform: MaterialUniform;

    @fragment
    fn main(@location(0) fragUV: vec2<f32> , @location(1) worldPos:vec3<f32> ) -> FragmentOutput {
        var distance = length(worldPos.xyz - materialUniform.lightWorldPos ) ;
        distance = distance / materialUniform.cameraFar ;
        var fragOut:FragmentOutput; 

      #if USE_ALPHACUT
        let Albedo = textureSample(baseMap,baseMapSampler,fragUV);
        if(Albedo.w > 0.5){
          fragOut = FragmentOutput(vec4<f32>(0.0),distance);
        }
      #else
        fragOut = FragmentOutput(vec4<f32>(0.0),distance);
      #endif
      
        return fragOut ;
    }
`,dc=`
    #if USE_ALPHACUT
      @group(1) @binding(0)
      var baseMapSampler: sampler;
      @group(1) @binding(1)
      var baseMap: texture_2d<f32>;
    #endif

    struct FragmentOutput {
      @location(0) o_Target: vec4<f32>,
      @builtin(frag_depth) out_depth: f32
    };

    struct MaterialUniform {
      lightWorldPos: vec3<f32>,
      cameraFar: f32,
    };

    @group(2) @binding(0)
    var<uniform> materialUniform: MaterialUniform;

    @fragment
    fn main(@location(0) fragUV: vec2<f32> , @location(1) clipPos:vec3<f32> ) -> FragmentOutput {
        // var distance = length(worldPos.xyz - materialUniform.lightWorldPos ) ;
        // distance = distance / materialUniform.cameraFar ;
        var fragOut:FragmentOutput; 

      // #if USE_ALPHACUT
      //   let Albedo = textureSample(baseMap,baseMapSampler,fragUV);
      //   if(Albedo.w > 0.5){
      //     fragOut = FragmentOutput(vec4<f32>(0.0),distance);
      //   }
      // #else
      //   fragOut = FragmentOutput(vec4<f32>(0.0),distance);
      // #endif
      
        return fragOut ;
    }
`,Wg=`
#include "GlobalUniform"

struct RenderBound{
    index:f32,
}

struct Uniforms {
    matrix : array<mat4x4<f32>>
};

//@group(0) @binding(0) var<uniform> globalUniform: GlobalUniform;
@group(0) @binding(1) var<storage, read> models : Uniforms;
@group(0) @binding(2) var<storage, read> planes: array<vec4<f32>,7>;
@group(0) @binding(3) var<storage, read> cullingList: array<RenderBound>;
@group(0) @binding(4) var<storage,read_write> outBuffer: array<f32>;


var<private> boundPoints : array<vec4<f32>,8> ;   

fn IsInClipSpace( coord : vec4<f32> ) -> bool {
    return -coord.w <= coord.x && coord.x <= coord.w
        && -coord.w <= coord.y && coord.y <= coord.w
        && -coord.w <= coord.z && coord.z <= coord.w;
}

fn IsOutsideThePlane( plane: vec4<f32>, pointPosition : vec3<f32> ) -> bool{
    if(dot(plane.xyz, pointPosition) + plane.w > 0.0){
        return true;
    }
    return false;
}

fn containsBox( size:vec3<f32> , center:vec3<f32> ) -> f32 {
    var c = 0.0 ;
    var d = 0.0 ;

    var r = max(size.x, size.y);
    var sr = max(r , size.z);
    var scx = center.x;
    var scy = center.y;
    var scz = center.z;

    for(var p:i32 = 0; p < 6 ; p = p + 1 ){
        var plane = planes[p];
        d = plane.x * scx + plane.y * scy + plane.z * scz + plane.w;
        if (d <= -sr) {
        return 0.0;
        }
        if (d > sr) {
        c+=1.0;
        }
    }

    if( c >= 6.0 ){
        return 2.0 ;
    }else{
        return 1.0 ;
    }
}

@compute @workgroup_size( 128 )
fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
{
    let id = globalInvocation_id.x ;
    if(id + 1u > u32(planes[6].x) ){
        outBuffer[id] = f32(0.0); 
        return ;
    }

    let renderBound = cullingList[id];
    let boundID = i32(renderBound.index) ;
    var plane = planes[0];

    let worldMatrix = models.matrix[boundID];
    let projMat = globalUniform.projMat ;

    let const_boundMin : vec3<f32> = vec3<f32>(-0.5,-0.5,-0.5) ;   
    let const_boundMax : vec3<f32> = vec3<f32>(0.5,0.5,0.5) ;   

    let boundMin = worldMatrix * vec4<f32>(const_boundMin, 1.0);
    let boundMax = worldMatrix * vec4<f32>(const_boundMax, 1.0);

    let size = abs( boundMax.xyz - boundMin.xyz ) * 0.65 ;
    let center = worldMatrix[3].xyz ;

    var isIn :f32 = 0.0 ;

    isIn = containsBox(size,center);

    outBuffer[id] = f32(isIn); 
}
`,$o=`
#include "Common_vert"
#include "FragmentVarying"
#include "GlobalUniform"

struct FragmentOutput {
    @location(0) o_Position: vec4<f32>,
    @location(1) o_Normal: vec4<f32>,
    @location(2) o_Color: vec4<f32>
};

struct MaterialUniform {
    baseColor: vec4<f32>,
    emissiveColor: vec4<f32>,
    emissiveIntensity: f32,
    normalScale: f32,
    alphaCutoff: f32
};

@group(2) @binding(0)
var<uniform> materialUniform: MaterialUniform;

@group(1) @binding(auto)
var baseMapSampler: sampler;
@group(1) @binding(auto)
var baseMap: texture_2d<f32>;

@group(1) @binding(auto)
var normalMapSampler: sampler;
@group(1) @binding(auto)
var normalMap: texture_2d<f32>;

@group(1) @binding(auto)
var emissiveMapSampler: sampler;
@group(1) @binding(auto)
var emissiveMap: texture_2d<f32>;

fn vert(inputData:VertexAttributes) -> VertexOutput {
    ORI_Vert(inputData) ;
    return ORI_VertexOut ;
}

var<private> ORI_FragmentOutput: FragmentOutput;
var<private> ORI_VertexVarying: FragmentVarying;

@fragment
fn FragMain(vertex_varying:FragmentVarying) -> FragmentOutput {
    ORI_VertexVarying = vertex_varying;
    var texColor = textureSample(baseMap, baseMapSampler, ORI_VertexVarying.fragUV0.xy );

    var emissive = textureSample(emissiveMap, emissiveMapSampler, ORI_VertexVarying.fragUV0.xy ).rgb ;
    let intensity = materialUniform.emissiveIntensity * materialUniform.emissiveColor.a ;
    emissive = emissive.rgb * materialUniform.emissiveColor.rgb ;
    emissive = convertToHDRRGB(emissive,intensity);

    if (materialUniform.alphaCutoff-texColor.w > 0.0) {
        discard ;
    }

    var o_Position = vec4<f32>(ORI_VertexVarying.vWorldPos.xyz,emissive.r) ;
    var o_Normal = vec4<f32>((ORI_VertexVarying.vWorldNormal.xyz * 0.5 + 0.5 ),emissive.g) ;
    var o_Color = vec4<f32>((texColor * materialUniform.baseColor).rgb , emissive.b )  ;
    return FragmentOutput(o_Position,o_Normal,vec4<f32>(o_Color));
}

fn convertToHDRRGB( color : vec3<f32> , ins:f32 ) -> vec3<f32> {
    var hdrColor = vec3<f32>(0.0,0.0,0.0);
    hdrColor.r = color.r * pow(2.4, ins);
    hdrColor.g = color.g * pow(2.4, ins);
    hdrColor.b = color.b * pow(2.4, ins);
    return hdrColor;
}
`,gc=`
#include "GlobalUniform"

struct uniformData {
    exposure: f32,
    roughness: f32
};

struct FragmentOutput {
    @location(0) o_Position: vec4<f32>,
    @location(1) o_Normal: vec4<f32>,
    @location(2) o_Color: vec4<f32>
};

@group(1) @binding(4)
var baseMapSampler: sampler;
@group(1) @binding(5)
var baseMap: texture_cube<f32>;

@group(2) @binding(0)
var<uniform> global: uniformData;

fn LinearToGammaSpace(linRGB: vec3<f32>) -> vec3<f32> {
    var linRGB1: vec3<f32>;
    linRGB1 = linRGB;
    linRGB1 = max(linRGB1, vec3<f32>(0.0, 0.0, 0.0));
    linRGB1.x = pow(linRGB1.x, 0.4166666567325592);
    linRGB1.y = pow(linRGB1.y, 0.4166666567325592);
    linRGB1.z = pow(linRGB1.z, 0.4166666567325592);
    return max(((1.0549999475479126 * linRGB1) - vec3<f32>(0.054999999701976776)), vec3<f32>(0.0));
}

@fragment
fn main(@location(0) fragUV: vec2<f32>, @location(1) vWorldPos: vec4<f32>, @location(2) vWorldNormal: vec3<f32>) -> FragmentOutput {
    let maxLevel: u32 = textureNumLevels(baseMap);
    let textureColor:vec3<f32> = textureSampleLevel(baseMap, baseMapSampler, normalize(vWorldPos.xyz), global.roughness * f32(maxLevel) ).xyz;
    let o_Color = 0.618 * vec4<f32>(LinearToGammaSpace(textureColor) * globalUniform.skyExposure , 1.0);
    let o_Normal = vec4(vWorldNormal,1.0) ;
    let o_Position = vec4<f32>(vWorldPos.xyz,100000.0) ;
    return FragmentOutput(o_Position,o_Normal,o_Color);
}
`,pc=`
    @group(0) @binding(0) var<storage,read_write> visibleBuffer: array<f32>;
    @group(0) @binding(1) var zBufferTexture : texture_2d<f32>;

    @compute @workgroup_size(8, 8, 1)
    fn CsMain( @builtin(global_invocation_id) globalInvocation_id : vec3<u32> ) {
        var fragCoord = vec2<i32>( globalInvocation_id.xy );
        let md = textureLoad(zBufferTexture,fragCoord,0);

        let meshID = i32(floor( md.w + 0.1 ));
        if (meshID >= 0) {
            visibleBuffer[meshID] = 1.0 ;
        }
    }
`,mc=`
    #include "GlobalUniform"
    #include "MathShader"
    struct FragmentOutput {
        @location(0) o_Target: vec4<f32>,
        @builtin(frag_depth) out_depth: f32
    };
   

    @fragment
    fn main(@location(0) vID: f32, @location(1) vPos:vec3<f32> ,  @location(2) vClipPos: vec4<f32> ,  @builtin(position) fragCoord : vec4<f32>) -> FragmentOutput {
        var op = vec4<f32>( vPos, vID);
        let d = log2Depth(fragCoord.z+0.00001,globalUniform.near,globalUniform.far);
        return FragmentOutput(op,d);
    }
`,Ac=`
    #include "GlobalUniform"
    #include "MathShader"
    struct VertexOutput {
        @location(0) vID: f32 ,
        @location(1) vPos: vec3<f32> ,
        @location(2) vClipPos: vec4<f32> ,
        @builtin(position) member: vec4<f32>
    };

    struct Uniforms {
        matrix : array<mat4x4<f32>>
    };

    @group(0) @binding(1)
    var<storage, read> models : Uniforms;

    var<private> worldMatrix: mat4x4<f32>;

    #if USE_MORPHTARGETS
        ${Le.getMorphTargetShaderBinding(1,0)}
    #endif

    #if USE_SKELETON
        ${Or.groupBindingAndFunctions(1,0)}
    #endif

    @vertex
    fn main(
        @builtin(instance_index) index : u32,
        @location(0) position: vec3<f32>,
        @location(1) normal: vec3<f32>,
        @location(2) uv: vec2<f32>,
        @location(3) TEXCOORD_1: vec2<f32>,

    #if USE_TANGENT
        @location(4) TANGENT: vec4<f32>,
        #if USE_SKELETON
            @location(5) joints0: vec4<f32>,
            @location(6) weights0: vec4<f32>,
            #if USE_JOINT_VEC8
                @location(7) joints1: vec4<f32>,
                @location(8) weights1: vec4<f32>,
            #endif
        #elseif USE_MORPHTARGETS
            ${Le.getMorphTargetAttr(5)}
        #endif
    #elseif USE_SKELETON
        @location(4) joints0: vec4<f32>,
        @location(5) weights0: vec4<f32>,
        #if USE_JOINT_VEC8
            @location(6) joints1: vec4<f32>,
            @location(7) weights1: vec4<f32>,
        #endif
    #elseif USE_MORPHTARGETS
        ${Le.getMorphTargetAttr(4)}
    #endif
    ) -> VertexOutput {
    worldMatrix = models.matrix[index];

    var vertexPosition = position;
    var vertexNormal = normal;
    #if USE_MORPHTARGETS
        ${Le.getMorphTargetCalcVertex()}
    #endif

    #if USE_SKELETON
        #if USE_JOINT_VEC8
            worldMatrix *= getSkeletonWorldMatrix_8(joints0, weights0, joints1, weights1);
        #else
            worldMatrix *= getSkeletonWorldMatrix_4(joints0, weights0);
        #endif
    #endif

        
        let wPos = worldMatrix * vec4<f32>(vertexPosition.xyz, 1.0);
        var fixProjMat = globalUniform.projMat ;
        var rzMatrix : mat4x4<f32> ;
        rzMatrix[0] = vec4<f32>(1.0,0.0,0.0,0.0) ; 
        rzMatrix[1] = vec4<f32>(0.0,1.0,0.0,0.0) ; 
        rzMatrix[2] = vec4<f32>(0.0,0.0,1.0,0.0) ; 
        rzMatrix[3] = vec4<f32>(0.0,0.0,0.0,1.0) ; 
        var clipPos:vec4<f32> = fixProjMat * globalUniform.viewMat * (wPos) ;

        // let d = log2Depth(clipPos.z * (globalUniform.far - globalUniform.near),globalUniform.near,globalUniform.far) ;
        return VertexOutput(f32(index) , wPos.xyz,clipPos, clipPos);
    }

    fn depthToLinear01(depth:f32) -> f32 {
        let a = 1.0 / (globalUniform.near - globalUniform.far);
        return (globalUniform.near*globalUniform.far*a) / (depth + globalUniform.far * a) ;
    }
`,_c=`
    struct LightData {
        index:f32,
        lightType:i32,
        radius:f32,
        linear:f32,
        
        position:vec3<f32>,
        lightMatrixIndex:f32,

        direction:vec3<f32>,
        quadratic:f32,

        lightColor:vec3<f32>,
        intensity:f32,

        innerCutOff :f32,
        outerCutOff:f32,
        range :f32,
        castShadow:i32,

        lightTangent:vec3<f32>,
        ies:f32,
    };

    const PointLightType = 1;
    const DirectLightType = 2;
    const SpotLightType = 3;

    struct ClusterBox {
        minPoint:vec4<f32>,
        maxPoint:vec4<f32>
    };

    struct LightIndex {
            count:f32,
            start:f32,
            empty0:f32,
            empty1:f32,
    };

    struct ClustersUniform {
        clusterTileX:f32,
        clusterTileY:f32,
        clusterTileZ:f32,
        numLights:f32,
        maxNumLightsPerCluster:f32,
        near:f32,
        far:f32,
        screenWidth:f32,
        screenHeight:f32,
        clusterPix:f32, 
    };

    @group(2) @binding(1)
    var<storage,read> lightBuffer: array<LightData>;
    @group(2) @binding(2)
    var<uniform> clustersUniform : ClustersUniform;
    @group(2) @binding(3)
    var<storage,read> lightAssignBuffer : array<f32>;
    @group(2) @binding(4)
    var<storage,read> assignTable : array<LightIndex>;
    #if DEBUG_CLUSTER
        @group(2) @binding(5)
        var<storage,read> clusterBuffer : array<ClusterBox>;
    #endif

    fn getLight( index:i32 ) -> LightData {
        let lightId = i32(lightAssignBuffer[index]);
        var lightData = lightBuffer[lightId];
        return lightData ;
    }

    fn linearTo01Depth(depth : f32) -> f32 {
        return (globalUniform.far ) * globalUniform.near / fma(depth, globalUniform.near-globalUniform.far, globalUniform.far);
    }

    fn getClusterId3() -> vec3<u32> {
        let z = linearTo01Depth(ORI_VertexVarying.fragCoord.z) ; 

        let sliceScale = f32(clustersUniform.clusterTileZ) / log2(globalUniform.far / globalUniform.near);
        let sliceBias = -(f32(clustersUniform.clusterTileZ) * log2(globalUniform.near) / log2(globalUniform.far / globalUniform.near));
        let zTile = u32(max(log2(z) * sliceScale + sliceBias, 0.0));

        var screenUV = ORI_VertexVarying.fragCoord.xy / vec2<f32>( globalUniform.windowWidth , globalUniform.windowHeight );
        let i = u32(floor(screenUV.x * clustersUniform.clusterTileX)) ;
        let j = u32(floor(screenUV.y * clustersUniform.clusterTileY) );

        return vec3<u32>(i,j,zTile);
    }

    fn getCluster() -> LightIndex {
        let tile = getClusterId3();
        let id = tile.x +
            tile.y * u32(clustersUniform.clusterTileX) +
            tile.z * u32(clustersUniform.clusterTileX) * u32(clustersUniform.clusterTileY);
        return assignTable[id];
    }

    fn getClusterIndex() -> u32 {
        let tile = getClusterId3();
        let id = tile.x +
            tile.y * u32(clustersUniform.clusterTileX) +
            tile.z * u32(clustersUniform.clusterTileX) * u32(clustersUniform.clusterTileY);
        return id;
    }
`,xc=`
    #include "WorldMatrixUniform"
    #include "GlobalUniform"

    struct VertexOutput {
        @location(0) fragUV: vec2<f32>,
            @builtin(position) member: vec4<f32>
    };

    @vertex
    fn main(@builtin(instance_index) index : u32, @location(0) position: vec3<f32>, @location(1) TEXCOORD_1: vec2<f32>) -> VertexOutput {
        let id = u32(index);
        let worldMatrix = models.matrix[id];

        let screenPos = vec2(((TEXCOORD_1 * 2.0) - vec2<f32>(1.0))) * 0.5 ; 
        return VertexOutput(TEXCOORD_1, vec4<f32>(screenPos, 0.0, 1.0));
    }
`,vc=`
#version 450

layout(location = 0) in vec2 fragUV;

layout(location = 0) out vec4 o_Target;

layout(set = 0, binding = 0) uniform ConstUniform {
    mat4 projMat;
    mat4 viewMat;
    mat4 shadowMatrix;
    mat4 cameraWorldMatrix;
    mat4 pvMatrixInv;
    float frame;
    float time;
    float delta;
    float shadowBias;
    float skyExposure;
    float renderPassState;
    float quadScale;

};

layout(set = 2, binding = 0) uniform sampler baseMapSampler;
layout(set = 2, binding = 1) uniform texture2D baseMap;
layout(set = 3, binding = 0) uniform MaterialDataUniform {
    vec4 color;
};

void main() {
        vec2 uv = fragUV.xy;
    uv.y = 1.0 - uv.y;
        vec4 colorTexture = texture(sampler2D(baseMap, baseMapSampler), uv * quadScale) * color;
    o_Target = vec4(colorTexture.rgb, colorTexture.a);

    if (o_Target.r <= 0.5 && o_Target.g <= 0.5 && o_Target.b <= 0.5) {
        discard;
    }
    // float gamma     = 2.2;
    // float exposure  = 1.0;
    // float pureWhite = 1.0;

    // float luminance = dot(colorTexture.rgb, vec3(0.2126, 0.7152, 0.0722));
    // float mappedLuminance = (luminance * (1.0 + luminance/(pureWhite*pureWhite))) / (1.0 + luminance);

    // // Scale color by ratio of average luminances.
    // vec3 mappedColor = (mappedLuminance / luminance) * colorTexture.rgb;

    // // Gamma correction.
    // o_Target = vec4(pow(o_Target.rgb, vec3(1.0/gamma)), 1.0);
};
`,jg=`
#version 450
layout(location = 0) in vec3 position;
layout(location = 1) in vec3 normal;
layout(location = 2) in vec2 uv;

layout(location = 0) out vec2 fragUV;
layout(location = 1) out vec4 vWorldPos;
layout(location = 2) out vec3 vWorldNormal;

layout(set = 0, binding = 0) 
uniform ConstUniform {
    mat4 projMat;
    mat4 viewMat;
    mat4 shadowMatrix;
};

layout(set = 1, binding = 0) 
buffer Uniforms {
    mat4[] modeMat;
};

 mat4 inverse( in mat4 m ){
    return mat4(
        m[0][0], m[1][0], m[2][0], 0.0,
        m[0][1], m[1][1], m[2][1], 0.0,
        m[0][2], m[1][2], m[2][2], 0.0,
        -dot(m[0].xyz,m[3].xyz),
        -dot(m[1].xyz,m[3].xyz),
        -dot(m[2].xyz,m[3].xyz),
        1.0 );
}

void main(){
    fragUV = uv;
    mat4 modelMat = modeMat[gl_InstanceID]; 
    mat4 vm = viewMat * modelMat;
	mat3 normalMatrix = mat3(vm[0].xyz,vm[1].xyz,vm[2].xyz);
	vec3 eNormal = normalize( normalMatrix * normal );
    
    vWorldPos = modelMat * vec4(position.xyz,1.0) ;

    mat4 fixedViewMat = viewMat ;
    fixedViewMat[3] = vec4(0.0,0.0,-8.0,1.0);
    vec4 mvPosition = modelMat * vec4( position.xyz, 1.0 );
    gl_Position = projMat * fixedViewMat * mvPosition;
}

`,qg=`
#version 450

layout(location = 0) in vec2 fragUV;
layout(location = 1) in vec4 vWorldPos;
layout(location = 2) in vec3 vWorldNormal;

layout(location = 0) out vec4 o_Target;

layout(set = 2, binding = 0) 
uniform sampler baseMapSampler;
layout(set = 2, binding = 1) 
uniform texture2D baseMap;

layout(set = 3, binding = 0) uniform uniformData {
    vec3 eyesPos;
    float exposure;
    float roughness;
};

vec3 LinearToGammaSpace(in vec3 linRGB)
{
    vec3 _linRGB = vec3(linRGB) ;
    _linRGB = max(linRGB, vec3(0.0, 0.0, 0.0));
    _linRGB.r = pow(linRGB.r,0.416666667);
    _linRGB.g = pow(linRGB.g,0.416666667);
    _linRGB.b = pow(linRGB.b,0.416666667);
    return max(1.055 * _linRGB - 0.055, vec3(0.0));
}

void main(){
    int maxMipLevel = textureQueryLevels(baseMap, fragUV).x ;
    vec4 textureColor = textureCubeLod( sampler2D(baseMap, baseMapSampler), normalize(vWorldPos.xyz), roughness * float(maxMipLevel) ) ;
    o_Target = vec4(LinearToGammaSpace(textureColor.rgb),1.0) * exposure ;
}

`,Kg=`
#version 450

layout(location = 0) in vec2 fragUV;

layout(location = 0) out vec4 o_Target;

layout(set = 0, binding = 0) uniform ConstUniform {
    mat4 projMat;
    mat4 viewMat;
    mat4 shadowMatrix;
    mat4 cameraWorldMatrix ;
    mat4 pvMatrixInv ;
    float frame;
    float time;
    float detail;
    float shadowBias;
    float skyExposure;
    float renderPassState;
    float quadScale;
    float intensity;
};

layout(set = 2, binding = 0) uniform sampler baseMapSampler;
layout(set = 2, binding = 1) uniform texture2D baseMap;

layout(set = 2, binding = 2) uniform sampler lutMapSample;
layout(set = 2, binding = 3) uniform texture2D lutMap;

layout(set = 3, binding = 0) uniform UniformData{
    float intensity ;
};

void main() {
    vec2 uv = fragUV.xy;
    uv.y = 1.0 - uv.y;
    vec4 col = texture(sampler2D(baseMap, baseMapSampler), uv * quadScale);
    // vec3 col = vec3(pow(base.xyz,vec3(1.0/2.2)));

    float Bcolor = col.b * 63.0;
	vec2 quad1;
    quad1.y = floor(floor(Bcolor) / 8.0);
    quad1.x = floor(Bcolor) - (quad1.y * 8.0);

    vec2 quad2;
    quad2.y = floor(ceil(Bcolor) / 8.0);
    quad2.x = ceil(Bcolor) - (quad2.y * 8.0);

    const float tmp = (0.125-(0.5/512.0)) ;
    const float tmp2 = 0.5/512.0 ;

    vec2 uv1;
    vec2 uv2;
	uv1.x = ((quad1.x)*0.125)+ tmp2 + (tmp* col.r);
	uv1.y = (((quad1.y)*0.125) + tmp2 + (tmp* col.g));

	uv2.x = ((quad2.x)*0.125)+ tmp2 + (tmp* col.r);
	uv2.y = (((quad2.y)*0.125)+ tmp2 + (tmp* col.g));

    vec4 color1 = texture(sampler2D(lutMap, lutMapSample), uv1);
    vec4 color2 = texture(sampler2D(lutMap, lutMapSample), uv2);

    vec4 newColor = mix(color1, color2, fract(Bcolor));
    // vec3 outC = pow(newColor.xyz,vec3(2.2));

    o_Target = vec4(newColor.rgb, col.a );
    // o_Target = vec4(1.0);
}
`;class en{}o(en,"Ori_AllShader",`
        #include "Common_vert"
        #include "Common_frag"
        #include "BxDF_frag"

        fn vert(inputData:VertexAttributes) -> VertexOutput {
            ORI_Vert(inputData) ;
            return ORI_VertexOut ;
        }

        fn frag(){
            ORI_ShadingInput.BaseColor = materialUniform.baseColor ;
            ORI_ShadingInput.Roughness = materialUniform.roughness  ;
            ORI_ShadingInput.Metallic = materialUniform.metallic ;
            ORI_ShadingInput.Specular = 0.5 ;
            ORI_ShadingInput.AmbientOcclusion = materialUniform.ao ;
            ORI_ShadingInput.EmissiveColor = vec4<f32>(0.0);

            ORI_ShadingInput.Normal = ORI_VertexVarying.vWorldNormal.rgb ;

            #if USE_SHADOWMAPING
                useShadow();
            #endif

            BxDFShading();
        }
    `);let yc=`
    #include "Common_vert"
    #include "Common_frag"
    #include "UnLit_frag"
    #include "Irradiance_frag"
    #include "MathShader"
    
    struct MaterialUniform {
      probeUniform:vec4<f32>,
    };

    @group(2) @binding(0)
    var<uniform> materialUniform: MaterialUniform;

    var<private> probeID: i32 ;
    var<private> debugType: i32 ;
    
    fn vert(inputData:VertexAttributes) -> VertexOutput {
        ORI_Vert(inputData) ;
        return ORI_VertexOut ;
    }

    fn frag(){
        probeID = i32(materialUniform.probeUniform.x);
        debugType = i32(materialUniform.probeUniform.y);
        if(debugType == 0){
            ORI_ShadingInput.BaseColor = debugProbe(probeID);
        }else if(debugType == 1){
            ORI_ShadingInput.BaseColor = getIrradiance();
        }else if(debugType == 2){
            ORI_ShadingInput.BaseColor = debugProbeDepth(probeID);
        }
        UnLit();
    }
    `,Cc=`
    #include "Common_vert"
    #include "Common_frag"
    #include "UnLit_frag"
    #include "UnLitMaterialUniform_frag"

    // @group(1) @binding(auto)
    // var noes_MapSampler: sampler;
    // @group(1) @binding(auto)
    // var noes_Map: texture_2d<f32>;

    @group(1) @binding(auto)
    var splitTexture_MapSampler: sampler;
    @group(1) @binding(auto)
    var splitTexture_Map: texture_2d<f32>;

    fn vert(inputData:VertexAttributes) -> VertexOutput {
        ORI_Vert(inputData) ;
        return ORI_VertexOut ;
    }

    fn frag(){
        var screenUV = ORI_VertexVarying.fragPosition.xy / ORI_VertexVarying.fragPosition.w;
        screenUV = (screenUV.xy + 1.0) * 0.5;
        screenUV.y = 1.0 - screenUV.y;

        screenUV.x = clamp(sin(screenUV.x * 1.0),0.0,1.0) ;
        screenUV.y = clamp(sin(screenUV.y * 1.0),0.0,1.0) ;
        // screenUV.y = cos(ORI_VertexVarying.fragPosition.y/7.15);

        let frameMap = textureSample(splitTexture_Map,splitTexture_MapSampler,screenUV);
        // let noesMap = textureSample(noes_Map,noes_MapSampler,screenUV);

        ORI_ShadingInput.BaseColor = vec4<f32>( frameMap.rgb , 1.0) ;
        UnLit();
    }
`,wc=`
    #include "Common_vert"
    #include "Common_frag"
    #include "ClusterLight"
    #include "UnLit_frag"
    #include "UnLitMaterialUniform_frag"

    @group(1) @binding(0)
    var baseMapSampler: sampler;
    @group(1) @binding(1)
    var baseMap: texture_2d<f32>;

    fn vert(inputData:VertexAttributes) -> VertexOutput {
        ORI_Vert(inputData) ;
        return ORI_VertexOut ;
    }

    fn frag(){
        var transformUV1 = materialUniform.transformUV1;
        var transformUV2 = materialUniform.transformUV2;

        var uv = transformUV1.zw * ORI_VertexVarying.fragUV0 + transformUV1.xy; 
        let baseColor = textureSample(baseMap,baseMapSampler,uv) ;
        if(baseColor.w < 0.5){
            discard ;
        }

        var lightColor = vec4<f32>(0.0);
        let lightIndex = getCluster();
        let start = max(lightIndex.start, 0.0);
        let count = max(lightIndex.count, 0.0);
        let end = max(start + count , 0.0);
        for(var i:i32 = i32(start) ; i < i32(end); i += 1 )
        {
          let light = getLight(i32(i));
  
          switch (light.lightType) {
            case PointLightType: {
            }
            case DirectLightType: {
                var normal = ORI_VertexVarying.vWorldNormal ;
                let intensity = (light.intensity/10.0);
                let att = max(dot(normal,-light.direction),0.0) * intensity ;
                lightColor += baseColor * att * 0.5 + baseColor * 0.5 ; 
                // lightColor = baseColor * 0.5; 
            }
            case SpotLightType: {
            }
            default: {
            }
          }
        }
        
        ORI_ShadingInput.BaseColor = lightColor * materialUniform.baseColor ;
        ORI_ShadingInput.BaseColor.w = 1.0 ;
        UnLit();

        // let n = globalUniform.near ;
        // let f = globalUniform.far ;
        // let z = ORI_VertexVarying.fragCoord.z ;
        // ORI_FragmentOutput.out_depth = z * (n/(f-n)) ;
    }
`,Jg=`
    #include "Common_vert"
    #include "Common_frag"
    #include "UnLit_frag"

    @group(1) @binding(0)
    var baseMapSampler: sampler;
    @group(1) @binding(1)
    var baseMap: texture_2d<f32>;


    struct MaterialUniform {
        baseColor:vec4<f32>,
        lineWeight:f32
    };

    @group(2) @binding(0)
    var<uniform> materialUniform: MaterialUniform;

    fn vert(vertex:VertexAttributes) -> VertexOutput {
        var vertexPosition = vertex.position;
        var vertexNormal = vertex.normal;

                #if USE_MORPHTARGETS
                    vertexPosition = vertexPosition * morphTargetData.morphBaseInfluence + vertex.a_morphPositions_0 * morphTargetData.morphInfluence0;
                    #if USE_MORPHNORMALS
                        vertexNormal = vertexNormal * morphTargetData.morphBaseInfluence + vertex.a_morphNormals_0 * morphTargetData.morphInfluence0;
                    #endif
                #endif

                #if USE_SKELETON
                    #if USE_JOINT_VEC8
                        let skeletonNormal = getSkeletonWorldMatrix_8(vertex.joints0, vertex.weights0, vertex.joints1, vertex.weights1);
                        ORI_MATRIX_M *= skeletonNormal ;
                        // vertexNormal = vec4<f32>(vec4<f32>(vertexNormal,0.0) * skeletonNormal).xyz; 
                    #else
                        let skeletonNormal = getSkeletonWorldMatrix_4(vertex.joints0, vertex.weights0);
                        ORI_MATRIX_M *= skeletonNormal ;
                        // vertexNormal = vec4<f32>(vec4<f32>(vertexNormal,0.0) * skeletonNormal).xyz; 
                    #endif
                #endif


                #if USE_TANGENT
                    ORI_VertexOut.varying_Tangent = vertex.TANGENT ;
                #endif

                ORI_NORMALMATRIX = transpose(inverse( mat3x3<f32>(ORI_MATRIX_M[0].xyz,ORI_MATRIX_M[1].xyz,ORI_MATRIX_M[2].xyz) ));

                let worldNormal = normalize(ORI_NORMALMATRIX * vertexNormal.xyz) ;

                vertexPosition = vertexPosition + worldNormal * materialUniform.lineWeight ;

                var worldPos = (ORI_MATRIX_M * vec4<f32>(vertexPosition.xyz, 1.0));
                var viewPosition = ORI_MATRIX_V * worldPos;
                var clipPosition = ORI_MATRIX_P * viewPosition ;

                ORI_VertexOut.varying_UV0 = vertex.uv.xy ;
                ORI_VertexOut.varying_UV1 = vertex.TEXCOORD_1.xy;
                ORI_VertexOut.varying_ViewPos = viewPosition / viewPosition.w;
                ORI_VertexOut.varying_Clip = clipPosition ;
                ORI_VertexOut.varying_WPos = worldPos ;
                ORI_VertexOut.varying_WPos.w = f32(vertex.index);
                ORI_VertexOut.varying_WNormal = worldNormal ;
                ORI_VertexOut.member = clipPosition ;


        return ORI_VertexOut ;
    }

    fn frag(){
        let color = textureSample(baseMap,baseMapSampler,ORI_VertexVarying.fragUV0) ;
        ORI_ShadingInput.BaseColor = color * materialUniform.baseColor ;
        ORI_ShadingInput.Roughness = 0.5  ;
        ORI_ShadingInput.Metallic = 0.5 ;
        ORI_ShadingInput.Specular = 0.5 ;
        ORI_ShadingInput.AmbientOcclusion = 1.0 ;
        ORI_ShadingInput.EmissiveColor = vec4<f32>(0.0);
        ORI_ShadingInput.Normal = ORI_VertexVarying.vWorldNormal.rgb ;
        UnLit();
    }
`,Zg=`
        #include "Common_vert"
        #include "Common_frag"
        #include "BxDF_frag"

        @group(1) @binding(auto)
        var rtColorTex: texture_2d<f32>;

        @group(1) @binding(auto)
        var baseMapSampler: sampler;
        @group(1) @binding(auto)
        var baseMap: texture_2d<f32>;

        @group(1) @binding(auto)
        var normalMapSampler: sampler;
        @group(1) @binding(auto)
        var normalMap: texture_2d<f32>;

        @group(1) @binding(auto)
        var displaceMapSampler: sampler;
        @group(1) @binding(auto)
        var displaceMap: texture_2d<f32>;

        @group(1) @binding(auto)
        var aoMapSampler: sampler;
        @group(1) @binding(auto)
        var aoMap: texture_2d<f32>;
 
        @group(1) @binding(auto)
        var reflectMapSampler: sampler;
        @group(1) @binding(auto)
        var reflectMap: texture_2d<f32>;

        fn vert(inputData:VertexAttributes) -> VertexOutput {
            ORI_Vert(inputData) ;
            // let displaceDimensions = textureDimensions(displaceMap) ;
            // let displace = textureGather(0,displaceMap,displaceMapSampler,inputData.uv) ;
            // ORI_VertexOut.member.y += displace.r * 10.0;
            return ORI_VertexOut ;
        }

        fn frag(){
            var screenUV = ORI_VertexVarying.fragPosition.xy / ORI_VertexVarying.fragPosition.w;
            screenUV = (screenUV.xy + 1.0) * 0.5;
            screenUV.y = 1.0 - screenUV.y;

            let FrameMap = textureSample(rtColorTex,baseMapSampler,screenUV);

            let Albedo = textureSample(baseMap,baseMapSampler,ORI_VertexVarying.fragUV0);
            var Normal = textureSample(normalMap,normalMapSampler,ORI_VertexVarying.fragUV0).rgb ;
            Normal.y = 1.0 - Normal.y ;
            let Displace = textureSample(displaceMap,displaceMapSampler,ORI_VertexVarying.fragUV0).rgb ;
            let Ao = textureSample(aoMap,aoMapSampler,ORI_VertexVarying.fragUV0).r ;
            let ReflectMap = 1.0 - textureSample(reflectMap,reflectMapSampler,ORI_VertexVarying.fragUV0).r ;

            ORI_ShadingInput.BaseColor = FrameMap * materialUniform.baseColor * vec4<f32>(LinearToGammaSpace(Albedo.rgb),1.0);
            ORI_ShadingInput.Roughness = ReflectMap * materialUniform.roughness  ;
            ORI_ShadingInput.Metallic = materialUniform.metallic ;
            ORI_ShadingInput.Specular = 0.5 ;
            ORI_ShadingInput.AmbientOcclusion = Ao * materialUniform.ao ;
            ORI_ShadingInput.EmissiveColor = vec4<f32>(0.0);

            let normal = unPackRGNormal(Normal,Displace.r*materialUniform.normalScale,1.0) ;
            ORI_ShadingInput.Normal = normal ;

            BxDFShading();
        }
    `,bc=`
        #include "Common_vert"
        #include "Common_frag"
        #include "UnLit_frag"

        @group(1) @binding(auto) var pointShadowMapSampler: sampler;
        @group(1) @binding(auto) var pointShadowMap: texture_depth_cube ;

        struct MaterialUniform {
            center: vec3<f32>,
        };
      
        @group(2) @binding(0)
        var<uniform> materialUniform: MaterialUniform;

        fn vert(inputData:VertexAttributes) -> VertexOutput {
            ORI_Vert(inputData) ;
            return ORI_VertexOut ;
        }
 
        fn frag(){

            var center = materialUniform.center ; 

            var dir = normalize(ORI_VertexVarying.vWorldPos.xyz - center) ;
            var depth = textureSample(pointShadowMap,pointShadowMapSampler,dir.xyz) ;
            depth = depth * globalUniform.far ;

            ORI_ShadingInput.BaseColor = vec4<f32>(depth*255.0,0.0,0.0,1.0)  ;
            UnLit();
        }
    `,tn=`
    #include "Common_vert"
    #include "Common_frag"
    #include "UnLit_frag"
    #include "UnLitMaterialUniform_frag"

    @group(1) @binding(0)
    var baseMapSampler: sampler;
    @group(1) @binding(1)
    var baseMap: texture_2d<f32>;

    fn vert(inputData:VertexAttributes) -> VertexOutput {
        ORI_Vert(inputData) ;
        return ORI_VertexOut ;
    }

    fn frag(){
        var transformUV1 = materialUniform.transformUV1;
        var transformUV2 = materialUniform.transformUV2;

        var uv = transformUV1.zw * ORI_VertexVarying.fragUV0 + transformUV1.xy; 
        let color = textureSample(baseMap,baseMapSampler,uv) ;
        if(color.w < 0.5){
            discard ;
        }
        
        ORI_ShadingInput.BaseColor = color * materialUniform.baseColor ;
        UnLit();
    }
`,$g=`
    struct MaterialUniform{
       #if USE_BRDF
        #include "PhysicMaterialUniform_frag"
       #endif

       #if USE_ColorLit
       #endif

       #if USE_UnLit
       #endif
    }

    @group(2) @binding(0)
    var<uniform> materialUniform: MaterialUniform;
`,Sc=`
    #include "MathShader"

    fn buildMatrix3x3() -> mat3x3<f32>{
        var mat3 = mat3x3<f32>(
            1.0,0.0,0.0,
            0.0,1.0,0.0,
            0.0,0.0,1.0,
        );
        return mat3 ;
    }

    fn buildMatrix4x4() -> mat4x4<f32>{
        var mat4 = mat4x4<f32>(
            1.0,0.0,0.0,0.0,
            0.0,1.0,0.0,0.0,
            0.0,0.0,1.0,0.0,
            0.0,0.0,0.0,1.0,
        );
        return mat4 ;
    }

    fn buildRotateXMat3(rad:f32) -> mat3x3<f32>{
        var xrot = mat3x3<f32>(
            1.0,0.0,0.0,
            0.0,cos(rad),-sin(rad),
            0.0,sin(rad),cos(rad)
        );
        return xrot;
    }

    fn buildRotateXMat4(rad:f32,x:f32,y:f32,z:f32) -> mat4x4<f32>{
        var xrot = mat4x4<f32>(
            1.0,0.0,0.0,0.0,
            0.0,cos(rad),-sin(rad),0.0,
            0.0,sin(rad),cos(rad),0.0,
            x,y,z,1.0,
        );
        return xrot;
    }

    fn buildRotateXYZMat4(radX:f32,radY:f32,radZ:f32,x:f32,y:f32,z:f32) -> mat4x4<f32>{
        var xRot = mat4x4<f32>(
            1.0,0.0,0.0,0.0,
            0.0,cos(radX),-sin(radX),0.0,
            0.0,sin(radX),cos(radX),0.0,
            0.0,0.0,0.0,1.0,
        );
        var yRot = mat4x4<f32>(
            cos(radY),0.0,sin(radY),0.0,
            0.0,1.0,0.0,0.0,
            -sin(radY),0.0,cos(radY),0.0,
            0.0,0.0,0.0,1.0,
        );
        var zRot = mat4x4<f32>(
            cos(radZ),-sin(radZ),0.0,0.0,
            sin(radZ), cos(radZ),0.0,0.0,
            0.0,0.0,1.0,0.0,
            0.0,0.0,0.0,1.0,
        );
        var fMat = xRot * yRot * zRot ;
        fMat[3].x = x;
        fMat[3].y = y;
        fMat[3].z = z;
        return fMat;
    }

    fn buildRotateYMat3(rad:f32) -> mat3x3<f32>{
        var yrot = mat3x3<f32>(
            cos(rad),0.0,sin(rad),
            0.0,1.0,0.0,
            -sin(rad),0.0,cos(rad)
        );
        return yrot ;
    }

    fn buildRotateZ(rad:f32) -> mat3x3<f32>{
        var zrot = mat3x3<f32>(
            cos(rad),-sin(rad),0.0,
            sin(rad), cos(rad),0.0,
            0.0,0.0,1.0
        );
        return zrot;
    }

    // fn buildRotateXMat4(rad:f32) -> mat4x4<f32>{
    //     var xrot = mat4x4<f32>(
    //         1.0,0.0,0.0,0.0,
    //         0.0,cos(rad),-sin(rad),0.0,
    //         0.0,sin(rad),cos(rad),0.0,
    //         0.0,0.0,0.0,1.0);
    //     return xrot;
    // }

    fn bulidTranslateMat4(x:f32,y:f32,z:f32) -> mat4x4<f32>{
        var trans = mat4x4<f32>(
            1.0,0.0,0.0,0.0,
            0.0,1.0,0.0,0.0,
            0.0,0.0,1.0,0.0,
            x,y,z,1.0);
        return trans;
    }

`,Ic=`
    struct FragmentOutput {
        @location(0) o_Target: vec4<f32>
    };

    var<private> varying_uv: vec2<f32>;
    @group(1) @binding(0)
    var baseMapSampler: sampler;
    @group(1) @binding(1)
    var baseMap: texture_2d<f32>;

    struct MaterialUniform{
        u_texel: vec2<f32>,
        u_strength: f32,
    }

    @group(2) @binding(0)
    var<uniform> materialUniform: MaterialUniform;


    fn LinearToGammaSpace(linRGB0: vec3<f32>) -> vec3<f32> {
        var linRGB = max(linRGB0, vec3(0.0, 0.0, 0.0));
        linRGB.r = pow(linRGB.r,0.416666667);
        linRGB.g = pow(linRGB.g,0.416666667);
        linRGB.b = pow(linRGB.b,0.416666667);
        return max(1.055 * linRGB - 0.055, vec3(0.0, 0.0, 0.0));
    }

    fn texture2D( uv:vec2<f32> , offset:vec2<f32> ) -> vec4<f32> {
        return textureSample(baseMap, baseMapSampler, uv.xy + offset ).rgba ;
    }

    @fragment
    fn main(@location(0) fragUV: vec2<f32>) -> FragmentOutput {
        var v_vTexcoord = fragUV ;
        // v_vTexcoord.x = 1.0 - v_vTexcoord.x ;
        v_vTexcoord.y = 1.0 - v_vTexcoord.y ;

        var reducemul = 1.0 / 8.0;
        var reducemin = 1.0 / 128.0;

        var basecol = texture2D(v_vTexcoord , vec2<f32>(0.0)).rgba;
        var baseNW = texture2D(v_vTexcoord , -materialUniform.u_texel).rgb;
        var baseNE = texture2D(v_vTexcoord , vec2<f32>(materialUniform.u_texel.x, -materialUniform.u_texel.y)).rgb;
        var baseSW = texture2D(v_vTexcoord , vec2<f32>(-materialUniform.u_texel.x, materialUniform.u_texel.y)).rgb;
        var baseSE = texture2D(v_vTexcoord , materialUniform.u_texel ).rgb;

        // var gray = vec3<f32>(0.299, 0.587, 0.114);
        var gray = vec3<f32>(0.213, 0.715, 0.072);
        var monocol = dot(basecol.rgb, gray);
        var monoNW = dot(baseNW, gray);
        var monoNE = dot(baseNE, gray);
        var monoSW = dot(baseSW, gray);
        var monoSE = dot(baseSE, gray);

        var monomin = min(monocol, min(min(monoNW, monoNE), min(monoSW, monoSE)));
        var monomax = max(monocol, max(max(monoNW, monoNE), max(monoSW, monoSE)));

        var dir = vec2<f32>(-((monoNW + monoNE) - (monoSW + monoSE)), ((monoNW + monoSW) - (monoNE + monoSE)));
        var dirreduce = max((monoNW + monoNE + monoSW + monoSE) * reducemul * 0.25, reducemin);
        var dirmin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirreduce);
        dir = min(vec2<f32>(materialUniform.u_strength), max(vec2<f32>(-materialUniform.u_strength), dir * dirmin)) * materialUniform.u_texel;

        var resultA = 0.5 * (texture2D(v_vTexcoord , dir * -0.166667).rgb  +
                            texture2D(v_vTexcoord , dir * 0.166667).rgb);
        var resultB = resultA * 0.5 + 0.25 * (texture2D( v_vTexcoord , dir * -0.5).rgb +
                                            texture2D( v_vTexcoord , dir * 0.5).rgb);
        var monoB = dot(resultB.rgb, gray);
        
        var color:vec3<f32> ;
        if(monoB < monomin || monoB > monomax) {
            color = resultA ;//* v_vColour;
        } else {
            color = resultB ;//* v_vColour;
        }
        return FragmentOutput(vec4<f32>(color.rgb,basecol.a));
    }
`,Ec=`
struct FragmentOutput {
    @location(0) o_Target: vec4<f32>
};

${Ts}

#include "FastMathShader" 
 
struct LightData {
    index:f32,
    lightType:i32,
    radius:f32,
    linear:f32,
    
    position:vec3<f32>,
    lightMatrixIndex:f32,

    direction:vec3<f32>,
    quadratic:f32,

    lightColor:vec3<f32>,
    intensity:f32,

    innerCutOff :f32,
    outerCutOff:f32,
    range :f32,
    castShadow:i32,

    lightTangent:vec3<f32>,
    ies:f32,
};

struct UniformData {
    fogColor : vec4<f32>,
    fogType : f32 ,
    fogHeightScale : f32 , 
    start: f32,
    end: f32,
    density : f32 ,
    ins : f32 ,
    falloff : f32 ,
    rayLength : f32 ,
    scatteringExponent : f32 ,
    dirHeightLine : f32 ,
    skyFactor: f32,
    skyRoughness: f32,
    overrideSkyFactor: f32,
    isSkyHDR: f32
};

@group(1) @binding(0)
var positionMapSampler: sampler;
@group(1) @binding(1)
var positionMap: texture_2d<f32>;

@group(1) @binding(2)
var colorMapSampler: sampler;
@group(1) @binding(3)
var colorMap: texture_2d<f32>;

@group(1) @binding(4)
var normalMapSampler: sampler;
@group(1) @binding(5)
var normalMap: texture_2d<f32>;

@group(1) @binding(6)
var prefilterMapSampler: sampler;
@group(1) @binding(7)
var prefilterMap: texture_cube<f32>;


@group(2) @binding(0)
var<uniform> global : UniformData;
var<private> varying_uv: vec2<f32>;

@group(2) @binding(1)
var<storage,read> lightBuffer: array<LightData>;

var<private> texPosition: vec4<f32>;
var<private> texNormal: vec4<f32>;
var<private> texColor: vec4<f32>;

fn LinearToGammaSpace(linRGB: vec3<f32>) -> vec3<f32>
{
    var linRGB1 = max(linRGB, vec3<f32>(0.0));
    linRGB1 = pow(linRGB1, vec3<f32>(0.4166666567325592));
    return max(((1.0549999475479126 * linRGB1) - vec3<f32>(0.054999999701976776)), vec3<f32>(0.0));
}

fn getSkyColor(worldPosition:vec3<f32>, skyRoughness:f32, isHDRTexture:bool) -> vec3<f32>
{
    let cameraPosition = vec3<f32>(globalUniform.cameraWorldMatrix[3].xyz);
    let rayDirection = normalize(vec3<f32>(worldPosition.xyz - cameraPosition));
    let calcRoughness = clamp(skyRoughness, 0.0, 1.0);
    let MAX_REFLECTION_LOD  = f32(textureNumLevels(prefilterMap)) ;
    var prefilterColor = textureSampleLevel(prefilterMap, prefilterMapSampler, rayDirection, calcRoughness * MAX_REFLECTION_LOD);
    if(isHDRTexture){
        prefilterColor = vec4<f32>(LinearToGammaSpace(vec3<f32>(prefilterColor.xyz)), prefilterColor.w);
    }
    return prefilterColor.xyz * globalUniform.skyExposure;
}

@fragment
fn main(@location(0) fragUV: vec2<f32>, @builtin(position) coord: vec4<f32>) -> FragmentOutput {
    var texCoord = vec2<f32>(fragUV.x, 1.0 - fragUV.y);
    texPosition = textureSample(positionMap, positionMapSampler, texCoord) ;
    texNormal = textureSample(normalMap, normalMapSampler, texCoord) ;
    texColor = textureSample(colorMap, colorMapSampler, texCoord) ;
  
    var opColor = vec3<f32>(0.0);
    if(texNormal.w <= 0.5){
        //for sky
        if(global.overrideSkyFactor > 0.01){
            opColor = blendSkyColor();
        }else{
            opColor = texColor.xyz;
        }
    }else{
        //for ground
        var fogFactor = calcFogFactor();
        if(global.skyFactor > 0.01 || global.overrideSkyFactor > 0.01){
            opColor = blendGroundColor(fogFactor);
        }else{
            opColor = mix(texColor.rgb, global.fogColor.xyz, fogFactor);
        }

        let sunLight = lightBuffer[0] ;
        var inScatteringValue = inScatterIng(sunLight.direction, texPosition.xyz, sunLight.lightColor);
        opColor += inScatteringValue;
    }
    return FragmentOutput(vec4<f32>(opColor.xyz, texColor.a));
}

fn calcFogFactor() -> f32 
{
    var cameraPos = globalUniform.cameraWorldMatrix[3].xyz  ;
    let dis = distance(cameraPos, texPosition.xyz);
    var heightFactor = computeFog(dis) + cFog(-texPosition.y);
    return clamp(global.ins * heightFactor,0.0,1.0);
}

    
fn blendGroundColor(fogFactor:f32) -> vec3<f32>
{
    var skyColorBlur = getSkyColor(texPosition.xyz, global.skyRoughness, global.isSkyHDR > 0.5);
    let skyFactor = clamp(global.skyFactor - global.overrideSkyFactor * 0.5, 0.0, 1.0);
    var fogColor = mix(global.fogColor.xyz, skyColorBlur, skyFactor);
    return mix(texColor.rgb, fogColor.rgb, fogFactor);
}

fn blendSkyColor() -> vec3<f32>
{
    let overrideSkyFactor = sqrt(global.overrideSkyFactor);
    var skyColorBlur = getSkyColor(texPosition.xyz, overrideSkyFactor * 0.3, global.isSkyHDR > 0.5);
    return mix(global.fogColor.xyz, skyColorBlur, 1.0 - overrideSkyFactor);
}


fn computeFog(z:f32) -> f32 
{
    var fog = 0.0;
    if( global.fogType < 0.5 ){
        fog = (global.end - z) / (global.end - global.start);
    }else if(global.fogType < 1.5 ){
        fog = exp2(-global.density * z);
    }else if(global.fogType == 2.5 ){
        fog = global.density * z;
        fog = exp2(-fog * fog);
    }
    return max(fog,0.0);
}

  fn cFog(y:f32) -> f32 
  {
     let fogDensity = global.density * exp(global.fogHeightScale * y);
     let fogFactor = (1.0 - exp2(-global.falloff)) / global.falloff ;
     let fog = fogDensity * fogFactor * max(global.rayLength - global.start, 0.0); 
     return max(fog,0.0);
  }

  fn inScatterIng(sunDir:vec3<f32>, worldPos:vec3<f32>, sunColor:vec3<f32>) -> vec3<f32> 
  {
    let viewDir = normalize(globalUniform.CameraPos.xyz - worldPos.xyz) ;
    let VoL = saturate(dot(viewDir,sunDir)) ;
    var scatter = pow(VoL,global.scatteringExponent);
    scatter *= (1.0-saturate(exp2(-global.dirHeightLine)));
    return vec3<f32>(scatter*sunColor);
  }

`;class rn{}o(rn,"cs",`
    #include 'ColorUtil'
    struct UniformData {
        width: f32,
        height: f32,
        sunU: f32,
        sunV: f32,
        eyePos: f32,
        sunRadius: f32,         // = 500.0;
        sunRadiance: f32,       // = 20.0;
        mieG: f32,              // = 0.76;
        mieHeight: f32,         // = 1200;
        sunBrightness: f32,     // = 1.0;
        displaySun: f32,        // > 0.5: true
        skyColor: vec4<f32>,        // sky color
      };

      @group(0) @binding(0) var<uniform> uniformBuffer: UniformData;
      @group(0) @binding(1) var outTexture : texture_storage_2d<rgba16float, write>;

      var<private> uv01: vec2<f32>;
      var<private> fragCoord: vec2<i32>;
      var<private> texSizeF32: vec2<f32>;

      var<private> PI:f32 = 3.1415926535;
      var<private> PI_2:f32 = 0.0;
      var<private> EPSILON:f32 = 0.0000001;
      var<private> SAMPLES_NUMS:i32 = 16;

      var<private> transmittance:vec3<f32>;
      var<private> insctrMie:vec3<f32>;
      var<private> insctrRayleigh:vec3<f32>;

      @compute @workgroup_size( 8 , 8 , 1 )
      fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
      {
        fragCoord = vec2<i32>(globalInvocation_id.xy);
        texSizeF32 = vec2<f32>( uniformBuffer.width, uniformBuffer.height);
        uv01 = vec2<f32>(globalInvocation_id.xy) / texSizeF32;
        uv01.y = 1.0 - uv01.y - EPSILON;
        PI_2 = PI * 2.0;
        textureStore(outTexture, fragCoord , mainImage(uv01));//vec4(uv01, 0.0, 1.0));
      }

      struct ScatteringParams
      {
        sunRadius:f32,
        sunRadiance:f32,

        mieG:f32,
        mieHeight:f32,

        rayleighHeight:f32,

        waveLambdaMie:vec3<f32>,
        waveLambdaOzone:vec3<f32>,
        waveLambdaRayleigh:vec3<f32>,

        earthRadius:f32,
        earthAtmTopRadius:f32,
        earthCenter:vec3<f32>,
      }

      fn ComputeSphereNormal(coord:vec2<f32>, phiStart:f32, phiLength:f32, thetaStart:f32, thetaLength:f32) -> vec3<f32>
      {
        var normal:vec3<f32>;
        normal.x = -sin(thetaStart + coord.y * thetaLength) * sin(phiStart + coord.x * phiLength);
        normal.y = -cos(thetaStart + coord.y * thetaLength);
        normal.z = -sin(thetaStart + coord.y * thetaLength) * cos(phiStart + coord.x * phiLength);
        return normalize(normal);
      }

      fn ComputeRaySphereIntersection(position:vec3<f32>, dir:vec3<f32>, center:vec3<f32>, radius:f32) -> vec2<f32>
      {
        var origin:vec3<f32> = position - center;
        var B = dot(origin, dir);
        var C = dot(origin, origin) - radius * radius;
        var D = B * B - C;

        var minimaxIntersections:vec2<f32>;
        if (D < 0.0)
        {
          minimaxIntersections = vec2<f32>(-1.0, -1.0);
        }
        else
        {
          D = sqrt(D);
          minimaxIntersections = vec2<f32>(-B - D, -B + D);
        }

        return minimaxIntersections;
      }

      fn ComputeWaveLambdaRayleigh(lambda: vec3<f32>) -> vec3<f32>
      {
        var n:f32 = 1.0003;
        var N:f32 = 2.545E25;
        var pn:f32 = 0.035;
        var n2:f32 = n * n;
        var pi3:f32 = PI * PI * PI;
        var rayleighConst:f32 = (8.0 * pi3 * pow(n2 - 1.0,2.0)) / (3.0 * N) * ((6.0 + 3.0 * pn) / (6.0 - 7.0 * pn));
        return vec3<f32>(rayleighConst) / (lambda * lambda * lambda * lambda);
      }

      fn ComputePhaseMie(theta: f32, g:f32) -> f32
      {
        var g2 = g * g;
        return (1.0 - g2) / pow(1.0 + g2 - 2.0 * g * saturate(theta), 1.5) / (4.0 * PI);
      }

      fn ComputePhaseRayleigh(theta: f32) -> f32
      {
        var theta2 = theta * theta;
        return (theta2 * 0.75 + 0.75) / (4.0 * PI);
      }

      fn ChapmanApproximation(X: f32, h: f32, cosZenith: f32) -> f32
      {
        var c = sqrt(X + h);
        var c_exp_h = c * exp(-h);

        if (cosZenith >= 0.0)
        {
          return c_exp_h / (c * cosZenith + 1.0);
        }
        else
        {
          var x0 = sqrt(1.0 - cosZenith * cosZenith) * (X + h);
          var c0 = sqrt(x0);

          return 2.0 * c0 * exp(X - x0) - c_exp_h / (1.0 - c * cosZenith);
        }
      }

      fn GetOpticalDepthSchueler(h: f32, H: f32, earthRadius: f32, cosZenith: f32) -> f32
      {
        return H * ChapmanApproximation(earthRadius / H, h / H, cosZenith);
      }

      fn GetTransmittance(setting: ScatteringParams, L:vec3<f32>, V: vec3<f32>) -> vec3<f32>
      {
        var ch = GetOpticalDepthSchueler(L.y, setting.rayleighHeight, setting.earthRadius, V.y);
        return exp(-(setting.waveLambdaMie + setting.waveLambdaRayleigh) * ch);
      }

      fn ComputeOpticalDepth(setting: ScatteringParams, samplePoint: vec3<f32>, V: vec3<f32>, L: vec3<f32>, neg: f32) -> vec2<f32>
      {
        var rl = length(samplePoint);
        var h = rl - setting.earthRadius;
        var r: vec3<f32> = samplePoint / rl;

        var cos_chi_sun = dot(r, L);
        var cos_chi_ray = dot(r, V * neg);

        var opticalDepthSun = GetOpticalDepthSchueler(h, setting.rayleighHeight, setting.earthRadius, cos_chi_sun);
        var opticalDepthCamera = GetOpticalDepthSchueler(h, setting.rayleighHeight, setting.earthRadius, cos_chi_ray) * neg;

        return vec2<f32>(opticalDepthSun, opticalDepthCamera);
      }

      fn AerialPerspective(setting:ScatteringParams, start: vec3<f32>, end: vec3<f32>, V: vec3<f32>, L: vec3<f32>, infinite:i32)
      {
        var inf_neg:f32 = 1.0;
        if( infinite == 0){
          inf_neg = -1.0;
        }

        var sampleStep: vec3<f32> = (end - start) / f32(SAMPLES_NUMS);
        var samplePoint: vec3<f32> = end - sampleStep;
        var sampleLambda: vec3<f32> = setting.waveLambdaMie + setting.waveLambdaRayleigh + setting.waveLambdaOzone;

        var sampleLength:f32 = length(sampleStep);

        var scattering:vec3<f32> = vec3<f32>(0.0);
        var lastOpticalDepth:vec2<f32> = ComputeOpticalDepth(setting, end, V, L, inf_neg);

        for (var i:i32 = 1; i < SAMPLES_NUMS; i = i + 1)
        {
          var opticalDepth: vec2<f32> = ComputeOpticalDepth(setting, samplePoint, V, L, inf_neg);

          var segment_s: vec3<f32> = exp(-sampleLambda * (opticalDepth.x + lastOpticalDepth.x));
          var segment_t: vec3<f32> = exp(-sampleLambda * (opticalDepth.y - lastOpticalDepth.y));

          transmittance *= segment_t;

          scattering = scattering * segment_t;
          scattering += exp(-(length(samplePoint) - setting.earthRadius) / setting.rayleighHeight) * segment_s;

          lastOpticalDepth = opticalDepth;
          samplePoint = samplePoint - sampleStep;
        }

        insctrMie = scattering * setting.waveLambdaMie * sampleLength;
        insctrRayleigh = scattering * setting.waveLambdaRayleigh * sampleLength;
      }

      fn ComputeSkyboxChapman(setting: ScatteringParams, eye:vec3<f32>, V:vec3<f32>, L:vec3<f32>) -> f32
      {
        var neg:i32 = 1;
        var outerIntersections: vec2<f32> = ComputeRaySphereIntersection(eye, V, setting.earthCenter, setting.earthAtmTopRadius);
        if (outerIntersections.y < 0.0){
          return 0.0;
        }
        var innerIntersections: vec2<f32> = ComputeRaySphereIntersection(eye, V, setting.earthCenter, setting.earthRadius);
        if (innerIntersections.x > 0.0)
        {
          neg = 0;
          outerIntersections.y = innerIntersections.x;
        }

        let eye0 = eye - setting.earthCenter;

        var start : vec3<f32> = eye0 + V * max(0.0, outerIntersections.x);
        var end : vec3<f32>= eye0 + V * outerIntersections.y;

        AerialPerspective(setting, start, end, V, L, neg);

        //bool intersectionTest = innerIntersections.x < 0.0 && innerIntersections.y < 0.0;
        //return intersectionTest ? 1.0 : 0.0;

        if(innerIntersections.x < 0.0 && innerIntersections.y < 0.0){
          return 1.0;
        }
        return 0.0;
      }

      fn ComputeSkyInscattering(setting: ScatteringParams, eye: vec3<f32>, V: vec3<f32>, L: vec3<f32>) -> vec4<f32>
      {
        transmittance = vec3<f32>(1.0);
        insctrMie = vec3<f32>(0.0);
        insctrRayleigh = vec3<f32>(0.0);
        var intersectionTest:f32 = ComputeSkyboxChapman(setting, eye, V, L);

        var phaseTheta = dot(V, L);
        var phaseMie = ComputePhaseMie(phaseTheta, setting.mieG);
        var phaseRayleigh = ComputePhaseRayleigh(phaseTheta);
        var phaseNight = 1.0 - saturate(transmittance.x * EPSILON);

        var insctrTotalMie: vec3<f32> = insctrMie * phaseMie;
        var insctrTotalRayleigh: vec3<f32> = insctrRayleigh * phaseRayleigh;

        var sky: vec3<f32> = (insctrTotalMie + insctrTotalRayleigh) * setting.sunRadiance;
        if(uniformBuffer.displaySun > 0.5){
          var angle:f32 = saturate((1.0 - phaseTheta) * setting.sunRadius);
          var cosAngle:f32 = cos(angle * PI * 0.5);
          var edge:f32 = 0.0;
          if(angle >= 0.9){
            edge = smoothstep(0.9, 1.0, angle);
          }

          var limbDarkening: vec3<f32> = GetTransmittance(setting, -L, V);
          limbDarkening *= pow(vec3<f32>(cosAngle), vec3<f32>(0.420, 0.503, 0.652)) * mix(vec3<f32>(1.0), vec3<f32>(1.2,0.9,0.5), edge) * intersectionTest;
          sky += limbDarkening * uniformBuffer.sunBrightness; 
        }
        return vec4<f32>(sky, phaseNight * intersectionTest);
      }

      fn TonemapACES(x: vec3<f32>) -> vec3<f32>
      {
        var A:f32 = 2.51f;
        var B:f32 = 0.03f;
        var C:f32 = 2.43f;
        var D:f32 = 0.59f;
        var E:f32 = 0.14f;
        return (x * (A * x + B)) / (x * (C * x + D) + E);
      }

      fn noise(uv:vec2<f32>) -> f32
      {
        return fract(dot(sin(vec3<f32>(uv.xyx) * vec3<f32>(uv.xyy) * 1024.0), vec3<f32>(341896.483, 891618.637, 602649.7031)));
      }

      fn mainImage( uv:vec2<f32> ) -> vec4<f32>
      {
        let eyePosition = uniformBuffer.eyePos;
        var sun = vec2<f32>(uniformBuffer.sunU, uniformBuffer.sunV);
        var V: vec3<f32> = ComputeSphereNormal(uv, 0.0, PI_2, 0.0, PI);
        var L: vec3<f32> = ComputeSphereNormal(vec2<f32>(sun.x, sun.y), 0.0, PI_2, 0.0, PI);

        var setting: ScatteringParams;
        setting.sunRadius = uniformBuffer.sunRadius;//500.0;
        setting.sunRadiance = uniformBuffer.sunRadiance;//20.0;
        setting.mieG = uniformBuffer.mieG;//0.76;
        setting.mieHeight = uniformBuffer.mieHeight;// 1200.0;
        setting.rayleighHeight = 8000.0;
        setting.earthRadius = 6360000.0;
        setting.earthAtmTopRadius = 6420000.0;
        setting.earthCenter = vec3<f32>(0, -setting.earthRadius, 0);
        setting.waveLambdaMie = vec3<f32>(0.0000002);

        // wavelength with 680nm, 550nm, 450nm
        setting.waveLambdaRayleigh = ComputeWaveLambdaRayleigh(vec3<f32>(0.000000680, 0.000000550, 0.000000450));

        // see https://www.shadertoy.com/view/MllBR2
        setting.waveLambdaOzone = vec3<f32>(1.36820899679147, 3.31405330400124, 0.13601728252538)* 0.0000006 * 2.504;

        var eye:vec3<f32> = vec3<f32>(0,eyePosition,0);
        var sky0:vec4<f32> = ComputeSkyInscattering(setting, eye, V, L);
        var sky = vec3<f32>(sky0.rgb);

        sky = TonemapACES(sky.rgb * 2.0);
        sky = pow(sky.rgb, vec3<f32>(1.0/1.2)); // gamma

        var fragColor:vec4<f32> = vec4<f32>((sky.rgb), 1.0);
        return fragColor;
      }
    `);class Bc{constructor(){o(this,"sunRadius",500),o(this,"sunRadiance",11),o(this,"mieG",.76),o(this,"mieHeight",1200),o(this,"eyePos",1500),o(this,"sunX",.71),o(this,"sunY",.56),o(this,"sunBrightness",1),o(this,"displaySun",!0),o(this,"defaultTextureCubeSize",512),o(this,"defaultTexture2DSize",1024),o(this,"skyColor",new z(1,1,1,1))}}class Tc extends ra{constructor(e){return super(),o(this,"_internalTexture"),o(this,"_cubeSize"),o(this,"setting"),this.setting=e,this._cubeSize=e.defaultTextureCubeSize,this._internalTexture=new ep(e.defaultTexture2DSize,e.defaultTexture2DSize*.5),this._internalTexture.update(this.setting),this.createFromTexture(this._cubeSize,this._internalTexture),this}get texture2D(){return this._internalTexture}apply(){return this._internalTexture.update(this.setting),this._faceData.uploadErpTexture(this._internalTexture),this}}class ep extends oe{constructor(e,t){super(e,t,G.rgba16float,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING),o(this,"_computeShader"),o(this,"_uniformBuffer"),this.initCompute(e,t)}initCompute(e,t){this._uniformBuffer=new Dt(16*4),this._uniformBuffer.apply(),this._computeShader=new be(rn.cs),this._computeShader.setUniformBuffer("uniformBuffer",this._uniformBuffer),this._computeShader.setStorageTexture("outTexture",this),this._computeShader.workerSizeX=e/8,this._computeShader.workerSizeY=t/8}update(e){this._uniformBuffer.setFloat("width",this.width),this._uniformBuffer.setFloat("height",this.height),this._uniformBuffer.setFloat("sunU",e.sunX),this._uniformBuffer.setFloat("sunV",e.sunY),this._uniformBuffer.setFloat("eyePos",e.eyePos),this._uniformBuffer.setFloat("sunRadius",e.sunRadius),this._uniformBuffer.setFloat("sunRadiance",e.sunRadiance),this._uniformBuffer.setFloat("mieG",e.mieG),this._uniformBuffer.setFloat("mieHeight",e.mieHeight),this._uniformBuffer.setFloat("sunBrightness",e.sunBrightness),this._uniformBuffer.setFloat("displaySun",e.displaySun?1:0),this._uniformBuffer.setColor("skyColor",e.skyColor),this._uniformBuffer.apply();let t=w.beginCommandEncoder();return w.computeCommand(t,[this._computeShader]),w.endCommandEncoder(t),this}}class Mc extends _i{constructor(){super();let e=new We("sky_vs_frag_wgsl","sky_fs_frag_wgsl");this.defaultPass=e,e.setUniformVector3("eyesPos",new g),e.setUniformFloat("exposure",1),e.setUniformFloat("roughness",0);let t=e.shaderState;t.frontFace="cw",t.cullMode=ui.back,t.depthWriteEnabled=!1,t.depthCompare=vt.less}set baseMap(e){this.defaultPass.setTexture("baseMap",e);const t="IS_HDR_SKY";this.defaultPass.defineValue[t]!=e?.isHDRTexture&&this.defaultPass.setDefine(t,!!e?.isHDRTexture)}get baseMap(){return this.defaultPass.getTexture("baseMap")}set envMap(e){}set shadowMap(e){}get exposure(){return A.setting.sky.skyExposure}set exposure(e){A.setting.sky.skyExposure=e}get roughness(){return this.defaultPass.uniforms.roughness.value}set roughness(e){"roughness"in this.defaultPass.uniforms&&(this.defaultPass.uniforms.roughness.value=e)}}class ls extends tt{constructor(e,t,r,s,a,n,l){super(),o(this,"shape_vertices",[]),o(this,"shape_indices",[]),o(this,"radius"),o(this,"widthSegments"),o(this,"heightSegments"),o(this,"phiStart"),o(this,"phiLength"),o(this,"thetaStart"),o(this,"thetaLength"),this.radius=e,this.widthSegments=t,this.heightSegments=r,this.phiStart=s,this.phiLength=a,this.thetaStart=n,this.thetaLength=l,this.buildGeometry()}buildGeometry(){var e,t,r=0;let s=this.heightSegments,a=this.widthSegments,n=this.radius;var l=(s+1)*(a+1);let h=new Float32Array(l*3),u=new Float32Array(l*3),c=new Float32Array(l*2),f=new Uint16Array(a*s*2*3),d=0,p=0,m=0;for(t=0;t<=s;++t){var _=Math.PI*t/s,v=-n*Math.cos(_),y=n*Math.sin(_);for(e=0;e<=a;++e){var C=2*Math.PI*e/a,B=y*Math.cos(C),T=y*Math.sin(C),M=1/Math.sqrt(B*B+T*T+v*v);if(h[d++]=B,h[d++]=T,h[d++]=v,u[p++]=B*M,u[p++]=T*M,u[p++]=v*M,c[m++]=e/a,c[m++]=t/s,e>0&&t>0){var D=(a+1)*t+e,P=(a+1)*t+e-1,L=(a+1)*(t-1)+e-1,I=(a+1)*(t-1)+e;t==s?(f[r++]=D,f[r++]=L,f[r++]=I):t==1?(f[r++]=D,f[r++]=P,f[r++]=L):(f[r++]=D,f[r++]=P,f[r++]=L,f[r++]=D,f[r++]=L,f[r++]=I)}}}this.setIndices(f),this.setAttribute(Y.position,h),this.setAttribute(Y.normal,u),this.setAttribute(Y.uv,c),this.setAttribute(Y.TEXCOORD_1,c),this.addSubGeometry({indexStart:0,indexCount:f.length,vertexStart:0,index:0}),this.bounds=new Be(g.ZERO,new g(this.radius*2,this.radius*2,this.radius*2))}}class sa extends ce{constructor(){super(...arguments),o(this,"skyMaterial")}init(){super.init(),this.castShadow=!1,this.castGI=!0,this.addRendererMask(Ue.Sky),this.alwaysRender=!0,this.object3D.bound=new Be(g.ZERO.clone(),g.MAX),this.geometry=new ls(A.setting.sky.defaultFar,20,20),this.skyMaterial||(this.skyMaterial=new Mc)}onEnable(){this._readyPipeline?(this.castNeedPass(),!this._inRenderer&&this.transform.scene3D&&(Q.instance.sky=this,this._inRenderer=!0)):this.initPipeline()}onDisable(){this._inRenderer&&this.transform.scene3D&&(this._inRenderer=!1,Q.instance.sky=null)}renderPass2(e,t,r,s,a,n=!1){super.renderPass2(e,t,r,s,a,n)}set map(e){this.skyMaterial.baseMap=e,this.skyMaterial.name==null&&(this.skyMaterial.name="skyMaterial"),this.material=this.skyMaterial}get map(){return this.skyMaterial.baseMap}get exposure(){return this.skyMaterial.exposure}set exposure(e){this.skyMaterial&&(this.skyMaterial.exposure=e)}get roughness(){return this.skyMaterial.roughness}set roughness(e){this.skyMaterial&&(this.skyMaterial.roughness=e)}}class tp{constructor(){o(this,"rotateX"),o(this,"rotateY"),o(this,"sunX"),o(this,"sunY"),this.reset()}reset(){return this.rotateX=this.rotateY=this.sunX=this.sunY=Number.MAX_VALUE,this}isRotateChange(e,t){return Math.abs(this.rotateX-e)>=.001||Math.abs(this.rotateY-t)>=.001}isSkyChange(e,t){return Math.abs(this.sunX-e)>=.001||Math.abs(this.sunY-t)>=.001}save(e,t,r,s){return this.sunX=e,this.sunY=t,this.rotateX=r,this.rotateY=s,this}}class ip extends sa{constructor(){super(...arguments),o(this,"_atmosphericScatteringSky"),o(this,"_onChange",!0),o(this,"_relatedTransform"),o(this,"_historyData")}get sunX(){return this._atmosphericScatteringSky.setting.sunX}set sunX(e){this._atmosphericScatteringSky.setting.sunX!=e&&(this._atmosphericScatteringSky.setting.sunX=e,this._onChange=!0)}get sunY(){return this._atmosphericScatteringSky.setting.sunY}set sunY(e){this._atmosphericScatteringSky.setting.sunY!=e&&(this._atmosphericScatteringSky.setting.sunY=e,this._onChange=!0)}get eyePos(){return this._atmosphericScatteringSky.setting.eyePos}set eyePos(e){this._atmosphericScatteringSky.setting.eyePos!=e&&(this._atmosphericScatteringSky.setting.eyePos=e,this._onChange=!0)}get sunRadius(){return this._atmosphericScatteringSky.setting.sunRadius}set sunRadius(e){this._atmosphericScatteringSky.setting.sunRadius!=e&&(this._atmosphericScatteringSky.setting.sunRadius=e,this._onChange=!0)}get sunRadiance(){return this._atmosphericScatteringSky.setting.sunRadiance}set sunRadiance(e){this._atmosphericScatteringSky.setting.sunRadiance!=e&&(this._atmosphericScatteringSky.setting.sunRadiance=e,this._onChange=!0)}get sunBrightness(){return this._atmosphericScatteringSky.setting.sunBrightness}set sunBrightness(e){this._atmosphericScatteringSky.setting.sunBrightness!=e&&(this._atmosphericScatteringSky.setting.sunBrightness=e,this._onChange=!0)}get displaySun(){return this._atmosphericScatteringSky.setting.displaySun}set displaySun(e){this._atmosphericScatteringSky.setting.displaySun!=e&&(this._atmosphericScatteringSky.setting.displaySun=e,this._onChange=!0)}init(){super.init(),this._historyData=new tp,this._atmosphericScatteringSky=new Tc(new Bc);let e=this.transform.view3D,t=this.transform.scene3D;this.map=this._atmosphericScatteringSky,t.envMap=this._atmosphericScatteringSky,this.onUpdate(e)}start(e){let t=this.transform.scene3D;this.map=this._atmosphericScatteringSky,t.envMap=this._atmosphericScatteringSky,super.start()}get relativeTransform(){return this._relatedTransform}set relativeTransform(e){this._relatedTransform=e,this._historyData.reset()}onUpdate(e){this._relatedTransform&&(this._relatedTransform.rotationZ=0,this._historyData.isRotateChange(this._relatedTransform.rotationX,this._relatedTransform.rotationY)?(this.sunX=(this._relatedTransform.rotationY+90)/360,this.sunY=this._relatedTransform.rotationX/180+.5):this._historyData.isSkyChange(this.sunX,this.sunY)&&(this._relatedTransform.rotationY=this.sunX*360-90,this._relatedTransform.rotationX=(this.sunY-.5)*180),this._historyData.save(this.sunX,this.sunY,this._relatedTransform.rotationX,this._relatedTransform.rotationY)),this._onChange&&(this._onChange=!1,this._atmosphericScatteringSky.apply())}destroy(e){super.destroy(e),this._atmosphericScatteringSky.destroy(),this._atmosphericScatteringSky=null,this._onChange=null}}class ys extends Ee{constructor(){super(),o(this,"type"),o(this,"camera"),o(this,"_cameraPosition"),this._cameraPosition=new g}onUpdate(){this.enable&&this.transform.view3D.camera&&this.updateBillboardMatrix()}updateBillboardMatrix(){let e=this.transform.view3D.camera;this._cameraPosition.copyFrom(e.transform.back),this.type==xi.BillboardXYZ||this.type==xi.BillboardY&&(this._cameraPosition.y=0),this._cameraPosition.normalize(),this._cameraPosition.add(this.object3D.localPosition,this._cameraPosition),this.transform.lookAt(this.object3D.localPosition,this._cameraPosition,e.transform.up)}cloneTo(e){let t=e.addComponent(ys);t.type=this.type}}var mr=(i=>(i[i.None=0]="None",i[i.Box=1]="Box",i[i.Capsule=2]="Capsule",i[i.Sphere=3]="Sphere",i[i.Mesh=4]="Mesh",i))(mr||{});const Li=class{constructor(){o(this,"_center"),o(this,"_size"),o(this,"_halfSize"),o(this,"_shapeType",0),Li.v3_help_0||(Li.v3_help_0=new g),Li.helpMatrix||(Li.helpMatrix=new V),Li.helpRay||(Li.helpRay=new ci),this._center=new g,this._size=new g,this._halfSize=new g}get shapeType(){return this._shapeType}setFromCenterAndSize(i,e){return i&&this._center.copy(i),e&&this._size.copy(e),this}get center(){return this._center}set center(i){this._center.copy(i)}get size(){return this._size}set size(i){this._size.copy(i),this._halfSize.copy(i).multiplyScalar(.5)}get halfSize(){return this._halfSize}rayPick(i,e){return null}};let Xe=Li;o(Xe,"v3_help_0"),o(Xe,"helpMatrix"),o(Xe,"helpRay");class Dc extends Xe{constructor(){super(),o(this,"_pickRet"),o(this,"box"),this._shapeType=mr.Box,this.box=new Be(new g,new g)}rayPick(e,t){this.box.setFromCenterAndSize(this.center,this.size);let s=Xe.helpMatrix;s.copyFrom(t).invert();let a=Xe.helpRay.copy(e);a.applyMatrix(s);let n=a.intersectBox(this.box,Xe.v3_help_0);return n?(this._pickRet||(this._pickRet={intersectPoint:new g,distance:0}),this._pickRet.intersectPoint=n,this._pickRet.distance=g.distance(a.origin,Xe.v3_help_0),this._pickRet):null}}class rp extends Ee{constructor(){super(),o(this,"_shape"),this._shape=new Dc}start(){A.setting.pick.mode=="pixel"&&this.transform.scene3D.view.pickFire.mouseEnableMap.set(this.transform.worldMatrix.index,this)}onEnable(e){ae.bindEnablePick(e,this,null)}onDisable(e){ae.unBindEnablePick(e,this)}get shape(){return this._shape}set shape(e){this._shape=e}rayPick(e){return this._enable?this._shape.rayPick(e,this.transform.worldMatrix):null}beforeDestroy(e){A.setting.pick.mode=="pixel"&&this.transform.scene3D.view.pickFire.mouseEnableMap.delete(this.transform.worldMatrix.index),super.beforeDestroy(e)}}var Pc=(i=>(i[i.PingPong=0]="PingPong",i[i.Repeat=1]="Repeat",i[i.Clamp=2]="Clamp",i))(Pc||{});class sn{constructor(e=0,t=0){o(this,"serializedVersion","2"),o(this,"time"),o(this,"value"),o(this,"inSlope",0),o(this,"outSlope",0),o(this,"tangentMode",0),this.time=e,this.value=t}unSerialized(e){this.serializedVersion=e.serializedVersion,this.time=e.time,this.value=e.value,this.tangentMode=e.tangentMode,this.inSlope=e.inSlope=="Infinity"?NaN:e.inSlope,this.outSlope=e.outSlope=="Infinity"?NaN:e.outSlope}unSerialized2(e){this.serializedVersion=e.serializedVersion,this.time=e.time,this.value=e.value,this.tangentMode=e.tangentMode,this.inSlope=e.inTangent=="Infinity"?NaN:e.inTangent,this.outSlope=e.outTangent=="Infinity"?NaN:e.outTangent}}class an{constructor(){o(this,"index"),o(this,"time"),o(this,"timeEnd"),o(this,"coeff",[])}}class aa{constructor(e,t=1,r=1){if(o(this,"_totalTime",1),o(this,"_cache",new an),o(this,"_cacheOut",{lhsIndex:0,rhsIndex:0}),o(this,"_InvalidateCache",!1),o(this,"curve",[]),o(this,"serializedVersion"),o(this,"preWarpMode"),o(this,"postWarpMode"),o(this,"rotationOrder"),e)for(let s=0;s<e.length;s++){const a=e[s];this.addKeyFrame(a)}this.preWarpMode=t,this.postWarpMode=r}get totalTime(){return this._totalTime}get first(){return this.curve[0]}get last(){return this.curve[this.curve.length-1]}addKeyFrame(e){this.curve.indexOf(e)==-1&&this.curve.push(e),this.calcTotalTime()}removeKeyFrame(e){let t=this.curve.indexOf(e);t!=-1&&this.curve.splice(t,1),this.calcTotalTime()}calculateCacheData(e,t,r,s=0){let a=this.curve,n=a[t],l=a[r];e.index=t,e.time=n.time+s,e.timeEnd=l.time+s,e.index=t;let h,u,c,f,d,p,m;h=l.time-n.time,h=Math.max(h,1e-4),c=l.value-n.value,u=1/(h*h),f=n.outSlope,d=l.inSlope,p=f*h,m=d*h,e.coeff[0]=(p+m-c-c)*u/h,e.coeff[1]=(c+c+c-p-p-m)*u,e.coeff[2]=f,e.coeff[3]=n.value,this.setupStepped(e.coeff,n,l)}getValue(e){return e=this.wrapTime(e),this.findCurve(e,this._cacheOut),this.calculateCacheData(this._cache,this._cacheOut.lhsIndex,this._cacheOut.rhsIndex,0),this.evaluateCache(this._cache,e)}getKeyCount(){return this.curve.length}getKey(e){return this.curve[e]}unSerialized(e){this.preWarpMode=e.m_PreInfinity,this.postWarpMode=e.m_PostInfinity,this.rotationOrder=e.m_RotationOrder;let t=e.m_Curve.length;for(let r=0;r<t;r++)this.curve[r]=new sn,this.curve[r].unSerialized(e.m_Curve[r.toString()]);return this.calcTotalTime(),this}unSerialized2(e){this.preWarpMode=e.preWrapMode,this.postWarpMode=e.postWrapMode;let t=e.keyFrames||e.keys,r=t.length;for(let s=0;s<r;s++)this.curve[s]=new sn,this.curve[s].unSerialized2(t[s.toString()]);return this.calcTotalTime(),this}wrapTime(e){let t=this.curve,r=t[0].time,s=t[t.length-1].time;return e<r?this.preWarpMode==2?e=r:this.preWarpMode==0?e=Ja(e,r,s):e=Za(e,r,s):e>s&&(this.postWarpMode==2?e=s:this.postWarpMode==0?e=Ja(e,r,s):e=Za(e,r,s)),e}evaluateCache(e,t){let r=t-e.time;return r*(r*(r*e.coeff[0]+e.coeff[1])+e.coeff[2])+e.coeff[3]}findCurve(e,t){let r=this.curve;for(let s=1;s<r.length;s++){let a=r[s-1],n=r[s];a.time<=e&&n.time>e&&(t.lhsIndex=s-1,t.rhsIndex=s)}}setupStepped(e,t,r){(isNaN(t.outSlope)||isNaN(r.inSlope))&&(e[0]=0,e[1]=0,e[2]=0,e[3]=t.value)}invalidateCache(){this._InvalidateCache=!0}calcTotalTime(){let e=0;for(let t of this.curve)e=Math.max(e,t.time);this._totalTime=e}static scaleCurveValue(e,t){if(!e._InvalidateCache)for(let r=0;r<e.curve.length;r++){let s=e.curve[r];s.value*=t,s.inSlope*=t,s.outSlope*=t}e.invalidateCache()}}class Rc extends aa{constructor(){super(),o(this,"attribute",""),o(this,"propertyList"),o(this,"path")}unSerialized(e){let{attribute:t,path:r}=e;return this.attribute=t,this.path=r,this.propertyList=t.split("."),super.unSerialized(e.curve),this}}class Lc{constructor(){o(this,"curve",{})}}var Ar=(i=>(i[i.Default=0]="Default",i[i.Clamp=1]="Clamp",i[i.Once=1]="Once",i[i.Loop=2]="Loop",i[i.PingPong=4]="PingPong",i[i.ClampForever=8]="ClampForever",i))(Ar||{});class sp{constructor(){o(this,"name"),o(this,"objAnimClip"),o(this,"totalTime",0),o(this,"time",0),o(this,"_stopTime",0),o(this,"_loopTime"),o(this,"_wrapMode"),o(this,"_sampleRate")}get wrapMode(){return this._wrapMode||(this._wrapMode=0),this._wrapMode}set wrapMode(e){this._wrapMode=e}parse(e){this.objAnimClip={};let t=e.AnimationClip,{m_Name:r,m_AnimationClipSettings:s,m_WrapMode:a,m_SampleRate:n}=t;this.name=r,this._wrapMode=a,this._sampleRate=n,this._loopTime=s.m_LoopTime;for(const l in t.m_EditorCurves)if(Object.prototype.hasOwnProperty.call(t.m_EditorCurves,l)){const h=t.m_EditorCurves[l];let u=h.attribute,c=new Rc;c.unSerialized(h),this.totalTime=Math.max(this.totalTime,c.totalTime);let f=this.objAnimClip[h.path];f||(f=new Lc,this.objAnimClip[h.path]=f),f.curve[u]=c}}}class Uc{constructor(){o(this,"transform"),o(this,"quaternion"),o(this,"materialColor")}}class Wt{static updatePropertyTag(e,t){e.quaternion||(e.quaternion=this.tag_quaternion[t]),e.transform||(e.transform=this.tag_transform[t]),e.materialColor||(e.materialColor=this.tag_materialColor[t])}}o(Wt,"Property",{"m_LocalPosition.x":"localPosition.x","m_LocalPosition.y":"localPosition.y","m_LocalPosition.z":"localPosition.z","m_LocalRotation.x":"localQuaternion.x","m_LocalRotation.y":"localQuaternion.y","m_LocalRotation.z":"localQuaternion.z","m_LocalRotation.w":"localQuaternion.w","localEulerAnglesRaw.x":"localRotation.x","localEulerAnglesRaw.y":"localRotation.y","localEulerAnglesRaw.z":"localRotation.z","m_LocalEulerAngles.x":"localRotation.x","m_LocalEulerAngles.y":"localRotation.y","m_LocalEulerAngles.z":"localRotation.z","m_LocalScale.x":"localScale.x","m_LocalScale.y":"localScale.y","m_LocalScale.z":"localScale.z","m_Color.r":"materialColor.r","m_Color.g":"materialColor.g","m_Color.b":"materialColor.b","m_Color.a":"materialColor.a","material._Color.r":"materialColor.r","material._Color.g":"materialColor.g","material._Color.b":"materialColor.b","material._Color.a":"materialColor.a","material._UnlitColor.r":"materialColor.r","material._UnlitColor.g":"materialColor.g","material._UnlitColor.b":"materialColor.b","material._UnlitColor.a":"materialColor.a","field of view":"camera3D.fov",m_IsActive:"active",m_Sprite:"sprite",m_FlipX:"flipX",m_FlipY:"flipY"}),o(Wt,"Scale",{"m_LocalPosition.x":1,"m_LocalPosition.y":1,"m_LocalPosition.z":-1,"localEulerAnglesRaw.x":-1,"localEulerAnglesRaw.y":1,"localEulerAnglesRaw.z":1,"m_LocalEulerAngles.x":-1,"m_LocalEulerAngles.y":1,"m_LocalEulerAngles.z":1,"m_LocalRotation.x":1,"m_LocalRotation.y":1,"m_LocalRotation.z":-1,"m_LocalRotation.w":-1,"field of view":1,m_IsActive:1,m_Sprite:1}),o(Wt,"tag_quaternion",{"m_LocalRotation.x":!0,"m_LocalRotation.y":!0,"m_LocalRotation.z":!0,"m_LocalRotation.w":!0}),o(Wt,"tag_materialColor",{"material._Color.r":!0,"material._Color.g":!0,"material._Color.b":!0,"material._Color.a":!0,"material._UnlitColor.r":!0,"material._UnlitColor.g":!0,"material._UnlitColor.b":!0,"material._UnlitColor.a":!0}),o(Wt,"tag_transform",{"m_LocalPosition.x":!0,"m_LocalPosition.y":!0,"m_LocalPosition.z":!0,"m_LocalRotation.x":!0,"m_LocalRotation.y":!0,"m_LocalRotation.z":!0,"m_LocalRotation.w":!0,"localEulerAnglesRaw.x":!0,"localEulerAnglesRaw.y":!0,"localEulerAnglesRaw.z":!0,"m_LocalEulerAngles.x":!0,"m_LocalEulerAngles.y":!0,"m_LocalEulerAngles.z":!0,"m_LocalScale.x":!0,"m_LocalScale.y":!0,"m_LocalScale.z":!0});const on=class{constructor(i){o(this,"_rootObject3D"),o(this,"_animation"),o(this,"_propertyCache"),o(this,"_currentClip"),o(this,"_frame",0),o(this,"_time",0),o(this,"_isPlaying",!0),o(this,"speed",1),o(this,"_propertyTagDic"),this._rootObject3D=i.object3D,this._animation=i,this._propertyTagDic=new Map,this.reset()}reset(){this._propertyCache={},this._propertyTagDic.clear()}get time(){return this._time}get currentClip(){return this._currentClip}play(i,e=!0){this._isPlaying=!0,e&&(this._time=0),i!=this._currentClip&&i&&this.parseAnimClip(i),this._currentClip=i,this.validProperty()}parseAnimClip(i){var e;this.reset();for(const t in i.objAnimClip){let r=i.objAnimClip[t],s=this._rootObject3D,a={};if(t==""?s=this._rootObject3D:s=this._rootObject3D.getObjectByName(t),!s)continue;let n=new Uc;this._propertyTagDic.set(s,n);let l=r.curve;for(const h in l){Wt.updatePropertyTag(n,h);let u=(e=this._propertyCache)[t]||(e[t]={}),c=Wt.Property[h].split("."),f=c[0];if(c.length>1){let d=a[f];d||(d=a[f]=s[f]),u[h]={value:d,property:c[1]}}else u[h]={value:s,property:c[0]}}}return this}stop(){return this._isPlaying=!1,this}toggle(){return this._isPlaying=!this._isPlaying,this}get isPlaying(){return this._isPlaying}update(i,e){if(i=i*.001,e=e*.001,!this._currentClip||this._frame==i||!this._isPlaying)return;this._frame=i;let t=this._time;this._time=this.calcTime(t+e*this.speed),this.validProperty(),this._currentClip.wrapMode!=Ar.Loop&&this._currentClip.wrapMode!=Ar.Default&&(this.speed>0?this._time>=this._currentClip.totalTime:this._time<=0)&&(this._isPlaying=!1,this._animation.statusCall(on.Complete,t,this._time)),this._animation.statusCall(on.Seek,t,this._time)}seek(i){return this._time=this.calcTime(i),this._rootObject3D&&this.validProperty(),this}calcTime(i){return this._currentClip.wrapMode==Ar.Loop||this._currentClip.wrapMode==Ar.Default?i=ro(i,this._currentClip.totalTime):i=K(i,0,this._currentClip.totalTime),i}validProperty(){for(const i in this._currentClip.objAnimClip){let t=this._currentClip.objAnimClip[i].curve;for(const r in t){const s=t[r];let a=this._propertyCache[i][r],n=s.getValue(this._time);r in Wt.Scale&&(n*=Wt.Scale[r]),a.value[a.property]=n}}this._propertyTagDic.forEach((i,e)=>{this.applyProperty(i,e)})}applyProperty(i,e){i.quaternion&&V.getEuler(e.transform.localRotation,e.transform.localRotQuat,!0,"ZYX"),i.transform&&(e.transform.localPosition=e.transform.localPosition,e.transform.localRotation=e.transform.localRotation,e.transform.localScale=e.transform.localScale);let t=e;i.materialColor&&t.notifyMaterialColorChange(0,"baseColor")}};let _r=on;o(_r,"Complete",0),o(_r,"Seek",1);class ap{constructor(){o(this,"clipName"),o(this,"data"),o(this,"time")}}class Ui extends je{constructor(e,t){super(t),o(this,"animation"),o(this,"frame"),this.animation=e}}o(Ui,"SEEK","SEEK"),o(Ui,"COMPLETE","COMPLETE");class An extends Ee{constructor(){super(),o(this,"_animator"),o(this,"_clips",[]),o(this,"defaultClip"),o(this,"autoPlay"),o(this,"_seekEvent"),o(this,"_completeEvent"),o(this,"_keyFrameList"),this._seekEvent=new Ui(this,Ui.SEEK),this._completeEvent=new Ui(this,Ui.COMPLETE),this._keyFrameList={}}registerEventKeyFrame(e){let t=this._keyFrameList[e.clipName];t==null&&(this._keyFrameList[e.clipName]=t=[]),t.push(e)}init(){this._animator=new _r(this)}onUpdate(){this.enable&&this._animator.update(he.time,he.delta)}appendClip(e){this._clips.push(e),this.play(e.name)}statusCall(e,t,r){if(e==_r.Complete)this.eventDispatcher.dispatchEvent(this._completeEvent);else if(e==_r.Seek&&t!=r){let s=this._keyFrameList[this.currentClip.name];if(s)for(let a of s)a.time>t&&a.time<=r&&(this._seekEvent.data=this._seekEvent.frame=a,this.eventDispatcher.dispatchEvent(this._seekEvent))}}set speed(e){this._animator.speed=e}get speed(){return this._animator.speed}stop(){this._animator.stop()}toggle(){this._animator.toggle()}getClip(e){let t;for(let r of this._clips)if(r.name==e){t=r;break}return t}get currentClip(){return this._animator.currentClip}get time(){return this._animator.time}seek(e){this._animator.seek(e)}play(e,t=!0){let r=this.getClip(e);return r?(this._animator.play(r,t),r):null}start(){this.autoPlay&&this.play(this.defaultClip)}copyComponent(e){this.autoPlay=e.autoPlay,this.defaultClip=e.defaultClip;let t=e._clips;for(let r=0,s=t.length;r<s;r++)this.appendClip(t[r]);return this}cloneTo(e){e.addComponent(An).copyComponent(this)}}class op extends Ee{constructor(){super(...arguments),o(this,"_targetRenderers",{}),o(this,"_vec3",new g),o(this,"_matrix4",new V),o(this,"_quaternion",new q)}init(e){let t=this.fetchMorphRenderers(this.object3D);for(const r of t){Tt.hasMask(r.rendererMask,Ue.MorphTarget)&&r.selfCloneMaterials("MORPH_TARGET_UUID");for(const a in r.geometry.morphTargetDictionary){let n=this._targetRenderers[a]||[];n.push(r),this._targetRenderers[a]=n}}}getMorphRenderersByKey(e){return this._targetRenderers[e]}cloneMorphRenderers(){let e={};for(let t in this._targetRenderers)e[t]=this._targetRenderers[t];return e}applyBlendShape(e,t,r=1){if(!e){console.warn("blendShape is null");return}this._vec3.setFromArray(e.transform.transform[3]),this._vec3.multiplyScalar(r),this.object3D.transform.localPosition=this._vec3,this._vec3.setFromArray(e.transform.transform[2]),this._matrix4.copyColFrom(2,this._vec3),this._vec3.setFromArray(e.transform.transform[1]),this._matrix4.copyColFrom(1,this._vec3),this._vec3.setFromArray(e.transform.transform[0]),this._matrix4.copyColFrom(0,this._vec3),this._matrix4.transpose(),this._quaternion.fromMatrix(this._matrix4),this.object3D.localQuaternion=this._quaternion;for(let s in t){let a=this._targetRenderers[s],n=t[s],l=e.texture[n];this.applyMorphTargetInfluence(s,l,a)}}applyMorphTargetInfluence(e,t,r){for(let s of r)s.setMorphInfluence(e,t)}fetchMorphRenderers(e){let t=e.getComponentsInChild(ce),r=[];for(let s of t)s.hasMask(Ue.MorphTarget)&&r.push(s);return r}}class np{constructor(){o(this,"texture"),o(this,"transform")}}class lp{constructor(e,t){o(this,"_computePipeline"),o(this,"_computeBindGroup");let r=S.device;this._computePipeline=r.createComputePipeline({layout:"auto",compute:{module:r.createShaderModule({code:e}),entryPoint:"CsMain"}}),this._computeBindGroup=r.createBindGroup({layout:this._computePipeline.getBindGroupLayout(0),entries:t})}compute(e,t,r,s){let a=e.beginComputePass();return a.setPipeline(this._computePipeline),a.setBindGroup(0,this._computeBindGroup),a.dispatchWorkgroups(t,r,s),a.end(),this}}class hp extends zr{constructor(){super(),o(this,"numJoint"),o(this,"numState"),o(this,"time"),o(this,"weight"),o(this,"argumentsData"),o(this,"_isDirty",!1),o(this,"_argumentsBuffer"),o(this,"_argumentsBufferEntries"),this.allocationMemorySet([{name:"numJoint",data:[0]},{name:"numState",data:[0]},{name:"retain1",data:[0]},{name:"retain2",data:[0]},{name:"time",data:[0,0]},{name:"weight",data:[0,0]}]),this.generateGPUBuffer()}getGPUBuffer(){return this._argumentsBuffer}getGPUBindGroupEntry(){return this._argumentsBufferEntries}updateGPUBuffer(){return this._isDirty&&(this._isDirty=!1,S.device.queue.writeBuffer(this._argumentsBuffer,0,this.shareDataBuffer)),this}allocationMemorySet(e){this.argumentsData={};let t=0;for(let s=0;s<e.length;s++){const a=e[s];t+=a.data.length}this.allocation(t*4);let r=this;for(let s=0;s<e.length;s++){const a=e[s],n=a.name;this.argumentsData[n]=this.allocation_node(a.data.length*4),r[n]=this.argumentsData[n]}}generateGPUBuffer(){let e=S.device;this._argumentsBuffer=e.createBuffer({size:this.shareDataBuffer.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,mappedAtCreation:!1}),this._argumentsBufferEntries={binding:0,resource:{buffer:this._argumentsBuffer,offset:0,size:this.shareDataBuffer.byteLength}}}}class up extends zr{constructor(){super(),o(this,"numJoint"),o(this,"numFrame"),o(this,"retain0"),o(this,"retain1"),o(this,"argumentsData"),o(this,"_isDirty",!1),o(this,"_argumentsBuffer"),o(this,"_argumentsBufferEntries"),this.allocationMemorySet([{name:"numJoint",data:[0]},{name:"numFrame",data:[0]},{name:"retain0",data:[0]},{name:"retain1",data:[0]}]),this.generateGPUBuffer()}getGPUBuffer(){return this._argumentsBuffer}getGPUBindGroupEntry(){return this._argumentsBufferEntries}updateGPUBuffer(){this._isDirty&&(this._isDirty=!1,S.device.queue.writeBuffer(this._argumentsBuffer,0,this.shareDataBuffer))}allocationMemorySet(e){this.argumentsData={};let t=0;for(let s=0;s<e.length;s++){const a=e[s];t+=a.data.length}this.allocation(t*4);let r=this;for(let s=0;s<e.length;s++){const a=e[s],n=a.name;this.argumentsData[n]=this.allocation_node(a.data.length*4),r[n]=this.argumentsData[n]}}generateGPUBuffer(){let e=S.device;this._argumentsBuffer=e.createBuffer({size:this.shareDataBuffer.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,mappedAtCreation:!1}),this._argumentsBufferEntries={binding:0,resource:{buffer:this._argumentsBuffer,offset:0,size:this.shareDataBuffer.byteLength}}}}let cp=`
  ${Bs}

  struct Arguments {
    numJoint: f32,
    numState: f32,
    retain1: f32,
    retain2: f32,
    time: vec2<f32>,
    weight: vec2<f32>,
  };

  struct JointData {
    scale: vec4<f32>,
    rotation: vec4<f32>,
    translation: vec4<f32>,
  };

  @group(0) @binding(0) var<storage, read_write> args: Arguments;
  @group(0) @binding(1) var<storage, read_write> jointsFinalMatrix: array<mat4x4<f32>>;
  @group(0) @binding(2) var<storage, read_write> jointsWorldMatrix: array<mat4x4<f32>>;

  @compute @workgroup_size(1)
  fn CsMain(@builtin(workgroup_id) workgroup_id: vec3<u32>, @builtin(local_invocation_index) local_index: u32) {
    let numJoint = i32(args.numJoint);
    let numState = i32(args.numState);
    let nJointIndex = i32(workgroup_id.x);

    jointsFinalMatrix[nJointIndex] = mixMatrix4x4(jointsWorldMatrix[0 * numJoint + nJointIndex], jointsWorldMatrix[1 * numJoint + nJointIndex], args.time[0]) * args.weight[0];

    for (var i = 1; i < numState; i++) {
      jointsFinalMatrix[nJointIndex] += mixMatrix4x4(jointsWorldMatrix[(i * 2 + 0) * numJoint + nJointIndex], jointsWorldMatrix[(i * 2 + 1) * numJoint + nJointIndex], args.time[i]) * args.weight[i];
    }
  }
`,fp=`
  ${Bs}

  struct Arguments {
    numJoint: f32,
    numFrame: f32,
    retain0: f32,
    retain1: f32,
  };

  struct JointData {
    scale: vec4<f32>,
    rotation: vec4<f32>,
    translation: vec4<f32>,
  };

  @group(0) @binding(0) var<storage, read_write> args: Arguments;
  @group(0) @binding(1) var<storage, read_write> jointsKeyframe: array<JointData>;
  @group(0) @binding(2) var<storage, read_write> jointsWorldMatrix: array<mat4x4<f32>>;
  @group(0) @binding(3) var<storage, read_write> jointsParentIndex: array<f32>;

  @compute @workgroup_size(1)
  fn CsMain(@builtin(workgroup_id) workgroup_id: vec3<u32>, @builtin(local_invocation_index) local_index: u32) {
    let numJoint = i32(args.numJoint);
    let nFrameIndex = i32(workgroup_id.x);
    for (var nJointIndex = 0; nJointIndex < numJoint; nJointIndex++) {
      let dataIndex = nFrameIndex * numJoint + nJointIndex;
      let joint = jointsKeyframe[dataIndex];
      let jointLocalMatrix = MakeMatrix4x4(joint.scale.xyz, joint.rotation, joint.translation.xyz);

      let nParentIndex = i32(jointsParentIndex[nJointIndex]);
      if (nParentIndex < 0) {
        jointsWorldMatrix[dataIndex] = jointLocalMatrix;
      } else {
        jointsWorldMatrix[dataIndex] = jointsWorldMatrix[nFrameIndex * numJoint + nParentIndex] * jointLocalMatrix;
      }
    }
  }
`;class dp extends Ee{constructor(){super(),o(this,"context"),o(this,"gain"),this.context=new AudioContext,this.gain=this.context.createGain(),this.gain.connect(this.context.destination)}start(){}onUpdate(){if(!this.context)return;const e=this.context.listener,t=this.object3D.transform.worldPosition,r=this.object3D.transform.forward,s=this.object3D.transform.up;if(!isNaN(r.x))if(e.positionX){const a=this.context.currentTime;e.positionX.linearRampToValueAtTime(t.x,a),e.positionY.linearRampToValueAtTime(t.y,a),e.positionZ.linearRampToValueAtTime(t.z,a),e.forwardX.linearRampToValueAtTime(r.x,a),e.forwardY.linearRampToValueAtTime(r.y,a),e.forwardZ.linearRampToValueAtTime(r.z,a),e.upX.linearRampToValueAtTime(s.x,a),e.upY.linearRampToValueAtTime(s.y,a),e.upZ.linearRampToValueAtTime(s.z,a)}else e.setPosition(t.x,t.y,t.z),e.setOrientation(r.x,r.y,r.z,s.x,s.y,s.z)}destroy(){this.gain.disconnect(),this.context.close(),super.destroy()}}class hs extends _i{constructor(){super();let e=new We("UnLit","UnLit");this.defaultPass=e,e.setShaderEntry("VertMain","FragMain"),e.setUniformVector4("transformUV1",new j(0,0,1,1)),e.setUniformVector4("transformUV2",new j(0,0,1,1)),e.setUniformColor("baseColor",new z(1,1,1,1)),e.setUniformFloat("alphaCutoff",.5);let t=e.shaderState;t.acceptShadow=!1,t.castShadow=!1,t.receiveEnv=!1,t.acceptGI=!1,t.useLight=!1,this.defaultPass=e,this.baseMap=A.res.whiteTexture}set baseMap(e){this.defaultPass.setTexture("baseMap",e)}get baseMap(){return this.defaultPass.getTexture("baseMap")}set baseColor(e){this.defaultPass.setUniformColor("baseColor",e)}get baseColor(){return this.defaultPass.uniforms.baseColor.color}set envMap(e){}set shadowMap(e){}}class us extends tt{constructor(e=1,t=1,r=1){super(),o(this,"width"),o(this,"height"),o(this,"depth"),this.width=e,this.height=t,this.depth=r,this.initVertex()}initVertex(){let e=this.width/2,t=this.height/2,r=this.depth/2;this.bounds=new Be(g.ZERO.clone(),new g(this.width,this.height,this.depth));let s=new Float32Array([-e,t,r,e,t,r,e,t,-r,-e,t,-r,-e,t,r,e,t,-r,e,-t,r,-e,-t,r,-e,-t,-r,e,-t,-r,e,-t,r,-e,-t,-r,-e,-t,r,-e,t,r,-e,t,-r,-e,-t,-r,-e,-t,r,-e,t,-r,e,t,r,e,-t,r,e,-t,-r,e,t,-r,e,t,r,e,-t,-r,e,t,r,-e,t,r,-e,-t,r,-e,-t,r,e,-t,r,e,t,r,e,-t,-r,-e,-t,-r,-e,t,-r,e,t,-r,e,-t,-r,-e,t,-r]),a=new Float32Array([0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1]),n=new Float32Array([1,1,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,0,0,1,0,1,1,0,0]),l=[0,2,1,3,5,4,6,8,7,9,11,10,12,14,13,15,17,16,18,20,19,21,23,22,24,26,25,27,29,28,30,32,31,33,35,34],h=new Uint16Array(l.reverse());this.setIndices(h),this.setAttribute(Y.position,s),this.setAttribute(Y.normal,a),this.setAttribute(Y.uv,n),this.setAttribute(Y.TEXCOORD_1,n),this.addSubGeometry({indexStart:0,indexCount:l.length,vertexStart:0,index:0})}}class Oc extends Ee{constructor(){super(),o(this,"listener",null),o(this,"context",null),o(this,"gainNode",null),o(this,"source",null),o(this,"_options",{loop:!0,volume:1}),o(this,"playing",!1),o(this,"_currentTime",0),o(this,"_buffer",null)}setLister(e){return this.listener=e,this.context=e.context,this.gainNode=this.context.createGain(),this.gainNode.connect(this.listener.gain),this.context.addEventListener("statechange",()=>{var t,r;((t=this.context)==null?void 0:t.state)==="closed"&&(console.warn("AudioListener removed"),this.stop(),(r=this.gainNode)==null||r.disconnect(),this.listener=null,this.context=null,this.gainNode=null)}),this}async load(e,t={}){var r;Object.assign(this._options,t);let a=await(await fetch(e)).arrayBuffer();this._buffer=await((r=this.context)==null?void 0:r.decodeAudioData(a))}async loadBuffer(e,t={}){var r;Object.assign(this._options,t),this._buffer=await((r=this.context)==null?void 0:r.decodeAudioData(e))}play(){if(!this.context)return console.warn("no audio source yet"),this;if(this.playing)return console.warn("Audio is alredy playing"),this;if(!this._buffer)return console.warn("Audio is not ready"),this;const e=this.context.createBufferSource();return e.buffer=this._buffer,e.loop=this._options.loop,this.source=e,this.connect(),this.source.start(0,this._currentTime),this.setVolume(this._options.volume),this.playing=!0,this}pause(){var e,t,r;return this.playing?(this._currentTime=((e=this.context)==null?void 0:e.currentTime)||0,(t=this.source)==null||t.stop(),(r=this.source)==null||r.disconnect(),this.playing=!1,this):(console.warn("Audio is not playing"),this)}stop(){return this.pause(),this._currentTime=0,this}setVolume(e){var t;return this.context?((t=this.gainNode)==null||t.gain.setTargetAtTime(e,this.context?this.context.currentTime:0,.01),this):(console.warn("no audio source yet"),this)}connect(){var e;(e=this.source)==null||e.connect(this.gainNode)}onUpdate(){super.onUpdate()}destroy(e){var t;this.stop(),(t=this.gainNode)==null||t.disconnect(),super.destroy(e)}}class gp extends Oc{constructor(){super(),o(this,"panner"),o(this,"_helper",!1),o(this,"_thickness",.1),o(this,"_step",16),o(this,"_lines",[])}setLister(e){var t;return super.setLister(e),this.panner=(t=this.context)==null?void 0:t.createPanner(),this.panner.panningModel="HRTF",this.panner.connect(this.gainNode),this}showHelper(e,t){this._helper=!0,e&&(this._thickness=e),t&&(this._step=t);const r=this.panner.coneInnerAngle,s=this.panner.coneOuterAngle,a=(s-r)/2;let n=this.panner.refDistance,l=this.panner.maxDistance,h=new us(1,1,1),u=new hs;u.baseColor=new z(1,0,0);let c=new hs;c.baseColor=new z(0,0,1);let f=new hs;f.baseColor=new z(0,1,0);let d=new hs;d.baseColor=new z(1,1,0);for(let p=0;p<this._step;p++){let m=new te,_=p*s/(this._step-1),v=_<a||_>r+a;{let y=new te,C=y.addComponent(ce);C.geometry=h,C.material=v?c:u,C.castShadow=!1,C.castGI=!1,y.localScale=new g(n,this._thickness,this._thickness),y.x=n/2,m.addChild(y)}{let y=new te,C=y.addComponent(ce);C.geometry=h,C.material=v?d:f,C.castShadow=!1,C.castGI=!1,y.localScale=new g(l,this._thickness/2,this._thickness/2),y.x=l/2,m.addChild(y)}m.rotationY=-90+s/2-_,this.object3D.addChild(m),this._lines.push(m)}}hideHelper(){this._helper=!1;for(let e of this._lines)e.removeAllChild(),e.removeFromParent(),e.destroy();this._lines.length=0}toggleHelper(){this._helper?this.hideHelper():this.showHelper()}updateHeler(){this.hideHelper(),this.showHelper()}get refDistance(){return this.panner.refDistance}set refDistance(e){this.panner.refDistance=e,this._helper&&this.updateHeler()}get rolloffFactor(){return this.panner.rolloffFactor}set rolloffFactor(e){this.panner.rolloffFactor=e}get distanceModel(){return this.panner.distanceModel}set distanceModel(e){this.panner.distanceModel=e}get maxDistance(){return this.panner.maxDistance}set maxDistance(e){this.panner.maxDistance=e,this._helper&&this.updateHeler()}setDirectionalCone(e,t,r){return this.panner.coneInnerAngle=e,this.panner.coneOuterAngle=t,this.panner.coneOuterGain=r,this._helper&&this.updateHeler(),this}connect(){var e;(e=this.source)==null||e.connect(this.panner)}start(){}stop(){return super.stop()}onUpdate(){if(!this.playing)return;const e=this.panner,t=this.object3D.transform.worldPosition,r=this.object3D.transform.forward;if(!isNaN(r.x))if(e.positionX&&this.context){const s=this.context.currentTime;e.positionX.linearRampToValueAtTime(t.x,s),e.positionY.linearRampToValueAtTime(t.y,s),e.positionZ.linearRampToValueAtTime(t.z,s),e.orientationX.linearRampToValueAtTime(r.x,s),e.orientationY.linearRampToValueAtTime(r.y,s),e.orientationZ.linearRampToValueAtTime(r.z,s)}else e.setPosition(t.x,t.y,t.z),e.setOrientation(r.x,r.y,r.z)}destroy(e){this.panner.disconnect(),this.hideHelper(),super.destroy(e)}}class pp{constructor(e=null,t=null){o(this,"_autoUpdate",!0),o(this,"_target"),o(this,"_lookAtObject"),o(this,"_origin",new g(0,0,0)),o(this,"_speed",300),this._target=e,this._lookAtObject=t}get target(){return this._target}set target(e){this._target!=e&&(this._target=e)}get lookAtObject(){return this._lookAtObject}set lookAtObject(e){this._lookAtObject!=e&&(this._lookAtObject=e)}get speed(){return this._speed}set speed(e){this._speed=e}update(){}}class mp extends Ee{constructor(){super(),o(this,"focus"),o(this,"distance",5),o(this,"_camera")}start(){if(this._camera=this.object3D.getOrAddComponent(Zi),!this._camera){console.error("FirstPersonCameraController need camera");return}if(!this.focus){console.error("FirstPersonCameraController need target");return}A.inputSystem.addEventListener(R.POINTER_WHEEL,this.mouseWheel,this),A.inputSystem.addEventListener(R.POINTER_UP,this.mouseUp,this),A.inputSystem.addEventListener(R.POINTER_DOWN,this.mouseDown,this)}mouseDown(e){A.inputSystem.addEventListener(R.POINTER_MOVE,this.mouseMove,this)}mouseUp(e){A.inputSystem.removeEventListener(R.POINTER_MOVE,this.mouseMove,this)}mouseMove(e){let t=this.transform.localRotation;t.y+=e.movementX*.01,t.x+=e.movementY*.01,this.transform.localRotation=t}mouseWheel(e){this.distance+=A.inputSystem.wheelDelta*.1}onUpdate(){let e=new g;this._camera.transform.forward.scaleToRef(this.distance,e);var t=this.focus.transform.worldPosition;this._camera.transform.localPosition=t}destroy(e){A.inputSystem.removeEventListener(R.POINTER_WHEEL,this.mouseWheel,this),A.inputSystem.removeEventListener(R.POINTER_UP,this.mouseUp,this),A.inputSystem.removeEventListener(R.POINTER_DOWN,this.mouseDown,this),super.destroy(e)}}var Je=(i=>(i[i.Key_BackSpace=8]="Key_BackSpace",i[i.Key_Tab=9]="Key_Tab",i[i.Key_Clear=12]="Key_Clear",i[i.Key_Enter=13]="Key_Enter",i[i.Key_Shift_L=16]="Key_Shift_L",i[i.Key_Control_L=17]="Key_Control_L",i[i.Key_Alt_L=18]="Key_Alt_L",i[i.Key_Pause=19]="Key_Pause",i[i.Key_CapsLock=20]="Key_CapsLock",i[i.Key_Escape=21]="Key_Escape",i[i.Key_Esc=27]="Key_Esc",i[i.Key_Space=32]="Key_Space",i[i.Key_Prior=33]="Key_Prior",i[i.Key_Next=34]="Key_Next",i[i.Key_End=35]="Key_End",i[i.Key_Home=36]="Key_Home",i[i.Key_Left=37]="Key_Left",i[i.Key_Up=38]="Key_Up",i[i.Key_Right=39]="Key_Right",i[i.Key_Down=40]="Key_Down",i[i.Key_Select=41]="Key_Select",i[i.Key_Print=42]="Key_Print",i[i.Key_Execute=43]="Key_Execute",i[i.Key_Insert=45]="Key_Insert",i[i.Key_Delete=46]="Key_Delete",i[i.Key_Help=47]="Key_Help",i[i.Key_0=48]="Key_0",i[i.Key_1=49]="Key_1",i[i.Key_2=50]="Key_2",i[i.Key_3=51]="Key_3",i[i.Key_4=52]="Key_4",i[i.Key_5=53]="Key_5",i[i.Key_6=54]="Key_6",i[i.Key_7=55]="Key_7",i[i.Key_8=56]="Key_8",i[i.Key_9=57]="Key_9",i[i.Key_A=65]="Key_A",i[i.Key_B=66]="Key_B",i[i.Key_C=67]="Key_C",i[i.Key_D=68]="Key_D",i[i.Key_E=69]="Key_E",i[i.Key_F=70]="Key_F",i[i.Key_G=71]="Key_G",i[i.Key_H=72]="Key_H",i[i.Key_I=73]="Key_I",i[i.Key_J=74]="Key_J",i[i.Key_K=75]="Key_K",i[i.Key_L=76]="Key_L",i[i.Key_M=77]="Key_M",i[i.Key_N=78]="Key_N",i[i.Key_O=79]="Key_O",i[i.Key_P=80]="Key_P",i[i.Key_Q=81]="Key_Q",i[i.Key_R=82]="Key_R",i[i.Key_S=83]="Key_S",i[i.Key_T=84]="Key_T",i[i.Key_U=85]="Key_U",i[i.Key_V=86]="Key_V",i[i.Key_W=87]="Key_W",i[i.Key_X=88]="Key_X",i[i.Key_Y=89]="Key_Y",i[i.Key_Z=90]="Key_Z",i[i.Key_KP_0=96]="Key_KP_0",i[i.Key_KP_1=97]="Key_KP_1",i[i.Key_KP_2=98]="Key_KP_2",i[i.Key_KP_3=99]="Key_KP_3",i[i.Key_KP_4=100]="Key_KP_4",i[i.Key_KP_5=101]="Key_KP_5",i[i.Key_KP_6=102]="Key_KP_6",i[i.Key_KP_7=103]="Key_KP_7",i[i.Key_KP_8=104]="Key_KP_8",i[i.Key_KP_9=105]="Key_KP_9",i[i.Key_Multiply=106]="Key_Multiply",i[i.Key_Add=107]="Key_Add",i[i.Key_Separator=108]="Key_Separator",i[i.Key_Subtract=109]="Key_Subtract",i[i.Key_Decimal=110]="Key_Decimal",i[i.Key_Divide=111]="Key_Divide",i[i.Key_F1=112]="Key_F1",i[i.Key_F2=113]="Key_F2",i[i.Key_F3=114]="Key_F3",i[i.Key_F4=115]="Key_F4",i[i.Key_F5=116]="Key_F5",i[i.Key_F6=117]="Key_F6",i[i.Key_F7=118]="Key_F7",i[i.Key_F8=119]="Key_F8",i[i.Key_F9=120]="Key_F9",i[i.Key_F10=121]="Key_F10",i[i.Key_F11=122]="Key_F11",i[i.Key_F12=123]="Key_F12",i[i.Key_F13=124]="Key_F13",i[i.Key_F14=125]="Key_F14",i[i.Key_F15=126]="Key_F15",i[i.Key_F16=127]="Key_F16",i[i.Key_F17=128]="Key_F17",i[i.Key_F18=129]="Key_F18",i[i.Key_F19=130]="Key_F19",i[i.Key_F20=131]="Key_F20",i[i.Key_F21=132]="Key_F21",i[i.Key_F22=133]="Key_F22",i[i.Key_F23=134]="Key_F23",i[i.Key_F24=135]="Key_F24",i[i.Key_Num_Lock=136]="Key_Num_Lock",i[i.Key_Scroll_Lock=137]="Key_Scroll_Lock",i))(Je||{});class Ap extends Ee{constructor(){super(),o(this,"moveSpeed",2),o(this,"targetPos",new g(0,0,10)),o(this,"lookAtPos",new g(0,0,0)),o(this,"config",{shiftMoveScale:20}),o(this,"_moveScale",1),o(this,"_dir"),o(this,"_mouseFactory",25),o(this,"_factory",1.5),o(this,"_mouseDown",!1),o(this,"_lastPos"),o(this,"_keyState"),this._lastPos=new g,this._keyState={front:!1,back:!1,left:!1,right:!1,q:!1,e:!1},this.setCamera(new g(0,0,100),new g(0,0,0))}setCamera(e,t){this.targetPos.copyFrom(e),this.lookAtPos.copyFrom(t),this.Reset()}start(){A.inputSystem.addEventListener(R.POINTER_WHEEL,this.mouseWheel,this),A.inputSystem.addEventListener(R.POINTER_UP,this.mouseUp,this),A.inputSystem.addEventListener(R.POINTER_DOWN,this.mouseDown,this),A.inputSystem.addEventListener(Qt.KEY_UP,this.keyUp,this),A.inputSystem.addEventListener(Qt.KEY_DOWN,this.keyDown,this),this.transform.lookAt(this.targetPos,this.lookAtPos)}mouseWheel(e){}keyUp(e){switch(e.keyCode){case Je.Key_W:this._keyState.front=!1;break;case Je.Key_S:this._keyState.back=!1;break;case Je.Key_A:this._keyState.left=!1;break;case Je.Key_D:this._keyState.right=!1;break;case Je.Key_Shift_L:this._moveScale=1;break;case Je.Key_Q:this._keyState.q=!1;break;case Je.Key_E:this._keyState.e=!1;break;case Je.Key_F:this.transform.lookAt(this.targetPos,this.lookAtPos);break}}keyDown(e){switch(e.keyCode){case Je.Key_W:this._keyState.front=!0;break;case Je.Key_S:this._keyState.back=!0;break;case Je.Key_A:this._keyState.left=!0;break;case Je.Key_D:this._keyState.right=!0;break;case Je.Key_Q:this._keyState.q=!0;break;case Je.Key_E:this._keyState.e=!0;break;case Je.Key_Shift_L:this._moveScale=this.config.shiftMoveScale}}Reset(){this._lastPos.x=A.inputSystem.mouseLastX,this._lastPos.y=A.inputSystem.mouseLastY}mouseDown(e){this.Reset(),this._mouseDown=!0}mouseUp(e){this.Reset(),this._mouseDown=!1}get factory(){return this._factory}set factory(e){this._factory=e}get mouseFactory(){return this._mouseFactory}set mouseFactory(e){this._mouseFactory=e}internal(e,t,r){return(t-e)*r}onUpdate(){let e=this.transform,t=K(he.delta,0,.016);if(this._mouseDown&&(e.rotationY-=this.internal(e.rotationY+(A.inputSystem.mouseLastX-this._lastPos.x)*.25,e.rotationY,t*this._mouseFactory),e.rotationX-=this.internal(e.rotationX+(A.inputSystem.mouseLastY-this._lastPos.y)*.25,e.rotationX,t*this._mouseFactory),this.Reset()),this._keyState.front){let r=e.forward;e.x-=this.internal(e.x+r.x*this.moveSpeed*this._moveScale,e.x,t*this._factory),e.y-=this.internal(e.y+r.y*this.moveSpeed*this._moveScale,e.y,t*this._factory),e.z-=this.internal(e.z+r.z*this.moveSpeed*this._moveScale,e.z,t*this._factory)}if(this._keyState.back){let r=e.forward;e.x+=this.internal(e.x+r.x*this.moveSpeed*this._moveScale,e.x,t*this._factory),e.y+=this.internal(e.y+r.y*this.moveSpeed*this._moveScale,e.y,t*this._factory),e.z+=this.internal(e.z+r.z*this.moveSpeed*this._moveScale,e.z,t*this._factory)}if(this._keyState.left){let r=e.left;e.x+=this.internal(e.x+r.x*this.moveSpeed*this._moveScale,e.x,t*this._factory),e.y+=this.internal(e.y+r.y*this.moveSpeed*this._moveScale,e.y,t*this._factory),e.z+=this.internal(e.z+r.z*this.moveSpeed*this._moveScale,e.z,t*this._factory)}if(this._keyState.right){let r=e.left;e.x-=this.internal(e.x+r.x*this.moveSpeed*this._moveScale,e.x,t*this._factory),e.y-=this.internal(e.y+r.y*this.moveSpeed*this._moveScale,e.y,t*this._factory),e.z-=this.internal(e.z+r.z*this.moveSpeed*this._moveScale,e.z,t*this._factory)}this._keyState.q&&(e.y=Ii(e.y,e.y-this.moveSpeed*this._moveScale,t*this._factory)),this._keyState.e&&(e.y=Ii(e.y,e.y+this.moveSpeed*this._moveScale,t*this._factory))}destroy(e){A.inputSystem.removeEventListener(R.POINTER_WHEEL,this.mouseWheel,this),A.inputSystem.removeEventListener(R.POINTER_UP,this.mouseUp,this),A.inputSystem.removeEventListener(R.POINTER_DOWN,this.mouseDown,this),A.inputSystem.removeEventListener(Qt.KEY_UP,this.keyUp,this),A.inputSystem.removeEventListener(Qt.KEY_DOWN,this.keyDown,this),super.destroy(e)}}class Oi{static add(e,t,r){return r||(r=new g),r.x=e.x+t.x,r.y=e.y+t.y,r.z=e.z+t.z,r}static sub(e,t,r){return r||(r=new g),r.x=e.x-t.x,r.y=e.y-t.y,r.z=e.z-t.z,r}static mul(e,t,r){return r||(r=new g),r.x=e.x*t.x,r.y=e.y*t.y,r.z=e.z*t.z,r}static mulScale(e,t,r){return r||(r=new g),r.x=e.x*t,r.y=e.y*t,r.z=e.z*t,r}static div(e,t,r){return r||(r=new g),r.x=e.x/t.x,r.y=e.y/t.y,r.z=e.z/t.z,r}static normalize(e){return e.clone().normalize()}static dot(e,t){let r=g.HELP_0;return r.copyFrom(e),r.dotProduct(t)}static calculateVectorAngle_xz(e,t){return Math.acos((e.x*t.x+e.y*t.y)/Math.sqrt((e.x*e.x+e.y*e.y)*(t.x*t.x+t.y*t.y)))}static distance(e,t){return g.distance(e,t)}static getRandomXYZ(e=-100,t=100){return new g(Math.random()*(t-e)+e,Math.random()*(t-e)+e,Math.random()*(t-e)+e)}static getRandomV3(e=-100,t=100,r,s){return new g(Math.random()*t+e,Math.random()*s+r,Math.random()*t+e)}static sphere(e){let t=e*Math.random(),r=new g(Math.random()*1-.5,Math.random()*1-.5,Math.random()*1-.5);return r.normalize(),r.scaleBy(t),r}static sphereXYZ(e,t,r=1,s=1,a=1){let n=e+(t-e)*Math.random(),l=new g(Math.random()*r-r*.5,Math.random()*s-s*.5,Math.random()*a-a*.5);return l.normalize(),l.scaleBy(n),l}}class _p extends Ee{constructor(){super(),o(this,"camera"),o(this,"minDistance",.1),o(this,"maxDistance",500),o(this,"rollSmooth",15),o(this,"dragSmooth",20),o(this,"wheelSmooth",10),o(this,"wheelStep",.002),o(this,"mouseRightFactor",.5),o(this,"mouseLeftFactor",20),o(this,"smooth",!0),o(this,"_wheelStep",.002),o(this,"_distance",0),o(this,"distance",10),o(this,"_roll",0),o(this,"roll",0),o(this,"_pitch",0),o(this,"pitch",0),o(this,"_currentPos"),o(this,"_targetPos"),o(this,"_mouseLeftDown",!1),o(this,"_mouseRightDown",!1),o(this,"_bottomClamp",89.99),o(this,"_topClamp",-89.99),o(this,"_tempDir",new g),o(this,"_tempPos",new g),this._currentPos=new te,this._targetPos=new te}start(){this.camera=this.object3D.getOrAddComponent(Zi),A.inputSystem.addEventListener(R.POINTER_DOWN,this.onMouseDown,this),A.inputSystem.addEventListener(R.POINTER_MOVE,this.onMouseMove,this),A.inputSystem.addEventListener(R.POINTER_UP,this.onMouseUp,this),A.inputSystem.addEventListener(R.POINTER_WHEEL,this.onMouseWheel,this)}setCamera(e,t,r,s){this.roll=e,this.pitch=t,this.distance=r,this.maxDistance<r*1.5&&(this.maxDistance=r*1.5),s&&this._targetPos.transform.localPosition.copy(s)}focusByBounds(e){let t=Zt.genMeshBounds(e);this.target=t.center}set target(e){this._targetPos.transform.localPosition.copy(e)}get target(){return this._targetPos.transform.localPosition}onMouseWheel(e){this.enable&&(this._wheelStep=this.wheelStep*Oi.distance(this._currentPos.transform.worldPosition,this.camera.transform.worldPosition)/10,this.distance-=A.inputSystem.wheelDelta*this._wheelStep,this.distance=K(this.distance,this.minDistance,this.maxDistance))}onMouseDown(e){if(this.enable)switch(e.mouseCode){case 0:this._mouseLeftDown=!0;break;case 1:break;case 2:this._mouseRightDown=!0;break}}onMouseUp(e){this._mouseLeftDown=!1,this._mouseRightDown=!1}onMouseMove(e){if(this.enable){if(this._mouseRightDown){let t=.25,r=this.camera.transform.forward;Oi.mulScale(r,e.movementY*t*this.camera.aspect,g.HELP_1),this._targetPos.x+=g.HELP_1.x*this.mouseRightFactor,this._targetPos.z+=g.HELP_1.z*this.mouseRightFactor;let s=this.camera.transform.right;Oi.mulScale(s,-e.movementX*t,g.HELP_1),this._targetPos.x-=g.HELP_1.x*this.mouseRightFactor,this._targetPos.z-=g.HELP_1.z*this.mouseRightFactor}this._mouseLeftDown&&(this.roll-=e.movementX*he.delta*.001*this.mouseLeftFactor,this.pitch-=e.movementY*he.delta*.001*this.mouseLeftFactor,this.pitch=K(this.pitch,this._topClamp,this._bottomClamp))}}onBeforeUpdate(e){if(!this.enable)return;let t=K(he.delta,0,.016);this.smooth?(this._currentPos.x+=(this._targetPos.x-this._currentPos.x)*t*this.dragSmooth,this._currentPos.y+=(this._targetPos.y-this._currentPos.y)*t*this.dragSmooth,this._currentPos.z+=(this._targetPos.z-this._currentPos.z)*t*this.dragSmooth,this._distance+=(this.distance-this._distance)*t*this.wheelSmooth,this._roll+=(this.roll-this._roll)*t*this.rollSmooth,this._pitch+=(this.pitch-this._pitch)*t*this.rollSmooth):(this._currentPos.x=this._targetPos.x,this._currentPos.y=this._targetPos.y,this._currentPos.z=this._targetPos.z,this._distance=this.distance,this._roll=this.roll,this._pitch=this.pitch),this._tempDir.set(0,0,1);let r=q.HELP_0;r.fromEulerAngles(this._pitch,this._roll,0),this._tempDir.applyQuaternion(r),this._tempPos=Oi.mulScale(this._tempDir,this._distance,this._tempPos),this._tempPos.add(this._currentPos.transform.localPosition,this._tempPos),this.transform.lookAt(this._tempPos,this._currentPos.transform.localPosition,g.UP),this.camera.lookTarget.copy(this._currentPos.transform.localPosition)}destroy(e){A.inputSystem.removeEventListener(R.POINTER_DOWN,this.onMouseDown,this),A.inputSystem.removeEventListener(R.POINTER_MOVE,this.onMouseMove,this),A.inputSystem.removeEventListener(R.POINTER_UP,this.onMouseUp,this),A.inputSystem.removeEventListener(R.POINTER_WHEEL,this.onMouseWheel,this),super.destroy(e),this.camera=null}}class xp extends Ee{constructor(){super(),o(this,"_camera"),o(this,"autoRotate",!1),o(this,"autoRotateSpeed",.1),o(this,"rotateFactor",.5),o(this,"zoomFactor",.1),o(this,"panFactor",.25),o(this,"_smooth",5),o(this,"_minDistance",1),o(this,"_maxDistance",1e5),o(this,"_maxPolarAngle",90),o(this,"_minPolarAngle",-90),o(this,"_target",new g(0,0,0)),o(this,"_cTarget",new g(0,0,0)),o(this,"_position",new g(0,0,0)),o(this,"_cPosition",new g(0,0,0)),o(this,"_spherical",new vp),o(this,"_isMouseDown",!1),o(this,"_lastMouseX",-1),o(this,"_lastMouseY",-1),o(this,"_isPanning",!1)}get target(){return this._target}set target(e){this._target=e}get smooth(){return this._smooth}set smooth(e){this._smooth=Math.max(e,1)}get minDistance(){return this._minDistance}set minDistance(e){this._minDistance=K(e,2e-6,this._maxDistance)}get maxDistance(){return this._maxDistance}set maxDistance(e){this._maxDistance=K(e,this._minDistance,1/0)}get minPolarAngle(){return this._minPolarAngle}set minPolarAngle(e){this._minPolarAngle=K(e,-90,this._maxPolarAngle)}get maxPolarAngle(){return this._maxPolarAngle}set maxPolarAngle(e){this._maxPolarAngle=K(e,this._minPolarAngle,90)}start(){this._camera=this.object3D.getComponent(Zi),this._position=this.object3D.transform.localPosition.clone(),this._cPosition=this._position.clone(),this._target=this._camera.lookTarget.clone(),this._cTarget=this._target.clone(),this._spherical.setCoords(this._position.x-this._target.x,this._position.y-this._target.y,this._position.z-this._target.z),this._camera.lookAt(this._cPosition,this._cTarget,g.UP),this.addEventListener()}onEnable(){this.addEventListener()}onDisable(){this.removeEventListener()}onUpdate(){let e=this._isPanning?1:this.smooth,t=!1;this._cPosition.equals(this.object3D.transform.localPosition)||(this._position.copyFrom(this.object3D.transform.localPosition),e=1,t=!0),this._cTarget.equals(this._target)||(this._cTarget.copyFrom(this._target),e=1,t=!0),t?this._spherical.setCoords(this._position.x-this._target.x,this._position.y-this._target.y,this._position.z-this._target.z):!this._isMouseDown&&this.autoRotate&&(this._spherical.theta-=this.autoRotateSpeed*Math.PI/180,this.updateCamera());let r=(this._position.x-this._cPosition.x)/e,s=(this._position.y-this._cPosition.y)/e,a=(this._position.z-this._cPosition.z)/e;this._cPosition.x=Math.abs(r)>1e-10?this._cPosition.x+r:this._position.x,this._cPosition.y=Math.abs(s)>1e-10?this._cPosition.y+s:this._position.y,this._cPosition.z=Math.abs(a)>1e-10?this._cPosition.z+a:this._position.z,this._camera.lookAt(this._cPosition,this._cTarget,g.UP)}onWheel(e){e.deltaY=K(e.deltaY,-this._spherical.radius,this._spherical.radius),this._spherical.radius+=e.deltaY*this.zoomFactor,this._spherical.radius=K(this._spherical.radius,this.minDistance,this.maxDistance),this.updateCamera()}onPointerDown(e){this._isMouseDown=!0,this._lastMouseX=e.mouseX,this._lastMouseY=e.mouseY,e.mouseCode===2&&(this._isPanning=!0)}onPointerMove(e){if(!this._isMouseDown||!this.enable)return;let t=e.mouseX,r=e.mouseY;if(e.mouseCode===0&&this._lastMouseX>0&&this._lastMouseY>0){const s=-(t-this._lastMouseX)*this.rotateFactor,a=(r-this._lastMouseY)*this.rotateFactor;this._spherical.theta+=s*Math.PI/180,this._spherical.phi-=a*Math.PI/180,this._spherical.phi=K(this._spherical.phi,this.minPolarAngle,this.maxPolarAngle),this.updateCamera()}else e.mouseCode===2&&(Oi.mulScale(this.object3D.transform.up,e.movementY*this.panFactor*this._camera.aspect,g.HELP_1),this._target.y+=g.HELP_1.y,Oi.mulScale(this.object3D.transform.right,-e.movementX*this.panFactor,g.HELP_1),this._target.x-=g.HELP_1.x,this._target.z-=g.HELP_1.z,this._cTarget.copyFrom(this._target),this.updateCamera());this._lastMouseX=t,this._lastMouseY=r}onPointerUp(e){this._isMouseDown=!1,e.mouseCode===2&&(this._isPanning=!1)}onPointerLeave(){this._isMouseDown=!1,this._isPanning=!1}updateCamera(){this._spherical.makeSafe();let e=this._spherical.getCoords();this._position.set(e.x+this._target.x,e.y+this._target.y,e.z+this._target.z)}addEventListener(){A.inputSystem.addEventListener(R.POINTER_WHEEL,this.onWheel,this),A.inputSystem.addEventListener(R.POINTER_DOWN,this.onPointerDown,this),A.inputSystem.addEventListener(R.POINTER_MOVE,this.onPointerMove,this),A.inputSystem.addEventListener(R.POINTER_UP,this.onPointerUp,this),A.inputSystem.addEventListener(R.POINTER_OUT,this.onPointerLeave,this)}removeEventListener(){A.inputSystem.removeEventListener(R.POINTER_WHEEL,this.onWheel,this),A.inputSystem.removeEventListener(R.POINTER_DOWN,this.onPointerDown,this),A.inputSystem.removeEventListener(R.POINTER_MOVE,this.onPointerMove,this),A.inputSystem.removeEventListener(R.POINTER_UP,this.onPointerUp,this),A.inputSystem.removeEventListener(R.POINTER_OUT,this.onPointerLeave,this)}}class vp{constructor(e=1,t=0,r=0){return o(this,"radius"),o(this,"phi"),o(this,"theta"),o(this,"coords"),this.radius=e,this.phi=t,this.theta=r,this.coords=new g,this}set(e,t,r){return this.radius=e,this.phi=t,this.theta=r,this}makeSafe(){return this.phi=Math.max(2e-4,Math.min(Math.PI-2e-4,this.phi)),this}setFromVector3(e){return this.setCoords(e.x,e.y,e.z)}setCoords(e,t,r){return this.radius=Math.sqrt(e*e+t*t+r*r),this.radius===0?(this.theta=0,this.phi=0):(this.theta=Math.atan2(e,r),this.phi=Math.acos(K(t/this.radius,-1,1))),this}getCoords(){const e=Math.sin(this.phi)*this.radius;return this.coords.x=e*Math.sin(this.theta),this.coords.y=Math.cos(this.phi)*this.radius,this.coords.z=e*Math.cos(this.theta),this.coords}}class yp extends Ee{constructor(){super(),o(this,"focus"),o(this,"_rotation",new g(45,0,0)),o(this,"distance",5),o(this,"_camera")}start(){if(this._camera=this.object3D.getOrAddComponent(Zi),!this._camera){console.error("ThirdPersonCameraController need camera");return}if(!this.focus){console.error("ThirdPersonCameraController need target");return}A.inputSystem.addEventListener(R.POINTER_WHEEL,this.mouseWheel,this),A.inputSystem.addEventListener(R.POINTER_UP,this.mouseUp,this),A.inputSystem.addEventListener(R.POINTER_DOWN,this.mouseDown,this)}mouseDown(e){A.inputSystem.addEventListener(R.POINTER_MOVE,this.mouseMove,this)}mouseUp(e){A.inputSystem.removeEventListener(R.POINTER_MOVE,this.mouseMove,this)}mouseMove(e){this._rotation.y+=e.movementX*.01,this._rotation.x+=e.movementY*.01}mouseWheel(e){this.distance+=A.inputSystem.wheelDelta*.1}onUpdate(){let e=new g;this._camera.transform.forward.scaleToRef(this.distance,e);var t=this.focus.transform.worldPosition;this._camera.transform.localPosition=t.subtract(e)}destroy(e){A.inputSystem.removeEventListener(R.POINTER_WHEEL,this.mouseWheel,this),A.inputSystem.removeEventListener(R.POINTER_UP,this.mouseUp,this),A.inputSystem.removeEventListener(R.POINTER_DOWN,this.mouseDown,this),super.destroy(e)}}var De=(i=>(i[i.NORMAL=0]="NORMAL",i[i.DOWN=1]="DOWN",i[i.OVER=2]="OVER",i[i.DISABLE=3]="DISABLE",i))(De||{});let Cp=Math.PI,Nc=Cp*2;class Qi{constructor(e=1,t=0,r=0,s=1,a=0,n=0){o(this,"a"),o(this,"b"),o(this,"c"),o(this,"d"),o(this,"tx"),o(this,"ty"),this.a=e,this.b=t,this.c=r,this.d=s,this.tx=a,this.ty=n}clone(){return new Qi(this.a,this.b,this.c,this.d,this.tx,this.ty)}concat(e){let t=this.a,r=this.c,s=this.tx;this.a=t*e.a+this.b*e.c,this.b=t*e.b+this.b*e.d,this.c=r*e.a+this.d*e.c,this.d=r*e.b+this.d*e.d,this.tx=s*e.a+this.ty*e.c+e.tx,this.ty=s*e.b+this.ty*e.d+e.ty}copyFrom(e){return this.a=e.a,this.b=e.b,this.c=e.c,this.d=e.d,this.tx=e.tx,this.ty=e.ty,this}identity(){return this.a=this.d=1,this.b=this.c=this.tx=this.ty=0,this}invert(){this._invertInto(this)}rotate(e){if(e=+e,e!==0){e=e*_e;let t=Math.cos(e),r=Math.sin(e),s=this.a,a=this.b,n=this.c,l=this.d,h=this.tx,u=this.ty;this.a=s*t-a*r,this.b=s*r+a*t,this.c=n*t-l*r,this.d=n*r+l*t,this.tx=h*t-u*r,this.ty=h*r+u*t}}scale(e,t){e!==1&&(this.a*=e,this.c*=e,this.tx*=e),t!==1&&(this.b*=t,this.d*=t,this.ty*=t)}setTo(e,t,r,s,a,n){return this.a=e,this.b=t,this.c=r,this.d=s,this.tx=a,this.ty=n,this}transformPoint(e,t,r){let s=this.a*e+this.c*t+this.tx,a=this.b*e+this.d*t+this.ty;return r?(r.setTo(s,a,0,1),r):new g(s,a,0,1)}setTranslate(e,t){this.tx=e,this.ty=t}translate(e,t){this.tx+=e,this.ty+=t}mul(e){let t=this,r=e,s=t.a,a=t.b,n=t.c,l=t.d,h=t.tx,u=t.ty,c=r.a,f=r.b,d=r.c,p=r.d,m=r.tx,_=r.ty;f!==0||d!==0?(this.a=s*c+a*d,this.b=s*f+a*p,this.c=n*c+l*d,this.d=n*f+l*p,this.tx=c*h+d*u+m,this.ty=f*h+p*u+_):(this.a=s*c,this.b=a*p,this.c=n*c,this.d=l*p,this.tx=c*h+m,this.ty=p*u+_)}equals(e){return this.a==e.a&&this.b==e.b&&this.c==e.c&&this.d==e.d&&this.tx==e.tx&&this.ty==e.ty}prepend(e,t,r,s,a,n){let l=this.tx;if(e!=1||t!=0||r!=0||s!=1){let h=this.a,u=this.c;this.a=h*e+this.b*r,this.b=h*t+this.b*s,this.c=u*e+this.d*r,this.d=u*t+this.d*s}return this.tx=l*e+this.ty*r+a,this.ty=l*t+this.ty*s+n,this}append(e){let t=this.a,r=this.b,s=this.c,a=this.d;return(e.a!=1||e.b!=0||e.c!=0||e.d!=1)&&(this.a=e.a*t+e.b*s,this.b=e.a*r+e.b*a,this.c=e.c*t+e.d*s,this.d=e.c*r+e.d*a),this.tx=e.tx*t+e.ty*s+this.tx,this.ty=e.tx*r+e.ty*a+this.ty,this}deltaTransformPoint(e){let t=this,r=t.a*e.x+t.c*e.y,s=t.b*e.x+t.d*e.y;return new g(r,s)}toString(){return"(a="+this.a+", b="+this.b+", c="+this.c+", d="+this.d+", tx="+this.tx+", ty="+this.ty+")"}createBox(e,t,r=0,s=0,a=0){let n=this;if(r!==0){r=r*_e;let l=Math.cos(r),h=Math.sin(r);n.a=l*e,n.b=h*t,n.c=-h*e,n.d=l*t}else n.a=e,n.b=0,n.c=0,n.d=t;n.tx=s,n.ty=a}createGradientBox(e,t,r=0,s=0,a=0){this.createBox(e/1638.4,t/1638.4,r,s+e/2,a+t/2)}_invertInto(e){let t=this.a,r=this.b,s=this.c,a=this.d,n=this.tx,l=this.ty;if(r==0&&s==0){e.b=e.c=0,t==0||a==0?e.a=e.d=e.tx=e.ty=0:(t=e.a=1/t,a=e.d=1/a,e.tx=-t*n,e.ty=-a*l);return}let h=t*a-r*s;if(h==0){e.identity();return}h=1/h;let u=e.a=a*h;r=e.b=-r*h,s=e.c=-s*h,a=e.d=t*h,e.tx=-(u*n+s*l),e.ty=-(r*n+a*l)}getScaleX(){let e=this;if(e.a==1&&e.b==0)return 1;let t=Math.sqrt(e.a*e.a+e.b*e.b);return this.getDeterminant()<0?-t:t}getScaleY(){let e=this;if(e.c==0&&e.d==1)return 1;let t=Math.sqrt(e.c*e.c+e.d*e.d);return this.getDeterminant()<0?-t:t}getSkewX(){return Math.atan2(this.d,this.c)-Math.PI/2}getSkewY(){return Math.atan2(this.b,this.a)}updateScaleAndRotation(e,t,r,s){if((r==0||r==Nc)&&(s==0||s==Nc)){this.a=e,this.b=this.c=0,this.d=t;return}r=r*_e,s=s*_e;let a=Math.cos(r),n=Math.sin(r);r==s?(this.a=a*e,this.b=n*e):(this.a=Math.cos(s)*e,this.b=Math.sin(s)*e),this.c=-n*t,this.d=a*t}preMultiplyInto(e,t){let r=e.a*this.a,s=0,a=0,n=e.d*this.d,l=e.tx*this.a+this.tx,h=e.ty*this.d+this.ty;(e.b!==0||e.c!==0||this.b!==0||this.c!==0)&&(r+=e.b*this.c,n+=e.c*this.b,s+=e.a*this.b+e.b*this.d,a+=e.c*this.a+e.d*this.c,l+=e.ty*this.c,h+=e.tx*this.b),t.a=r,t.b=s,t.c=a,t.d=n,t.tx=l,t.ty=h}$transformBounds(e){let t=this.a,r=this.b,s=this.c,a=this.d,n=this.tx,l=this.ty,h=e.x,u=e.y,c=h+e.width,f=u+e.height,d=t*h+s*u+n,p=r*h+a*u+l,m=t*c+s*u+n,_=r*c+a*u+l,v=t*c+s*f+n,y=r*c+a*f+l,C=t*h+s*f+n,B=r*h+a*f+l,T=0;d>m&&(T=d,d=m,m=T),v>C&&(T=v,v=C,C=T),e.x=Math.floor(d<v?d:v),e.width=Math.ceil((m>C?m:C)-e.x),p>_&&(T=p,p=_,_=T),y>B&&(T=y,y=B,B=T),e.y=Math.floor(p<y?p:y),e.height=Math.ceil((_>B?_:B)-e.y)}getDeterminant(){return this.a*this.d-this.b*this.c}}class Cs extends Ee{constructor(){super(...arguments),o(this,"isGUICanvas",!0),o(this,"index",0)}addChild(e){return this.object3D.addChild(e),this}removeChild(e){return this.object3D.removeChild(e),this}cloneTo(e){e.getOrAddComponent(Cs).copyComponent(this)}copyComponent(e){return e.index=e.index,this}}var Pe=(i=>(i[i.NONE=0]="NONE",i[i.POSITION=1]="POSITION",i[i.SPRITE=2]="SPRITE",i[i.COLOR=4]="COLOR",i[i.MAX=7]="MAX",i))(Pe||{});class nn{constructor(e){o(this,"array"),o(this,"buffer"),this.buffer=new ge(e,0),this.array=new Float32Array(this.buffer.memory.shareDataBuffer)}}class Fc extends tt{constructor(e){super(),o(this,"_attributeUV"),o(this,"_attributeVIndex"),o(this,"_faceIndexes"),o(this,"_uvSize",2),o(this,"_vIndexSize",1),o(this,"_posAttribute"),o(this,"_spriteAttribute"),o(this,"_colorAttribute"),o(this,"_onPositionChange",!0),o(this,"_onSpriteChange",!0),o(this,"_onColorChange",!0),o(this,"maxQuadCount"),this.maxQuadCount=e}updateBounds(e,t){let r=Number.MAX_VALUE*.1;return e=new g(-r,-r,-r),t=new g(r,r,r),this.bounds.setFromMinMax(e,t),this}get vPositionBuffer(){return this._onPositionChange&&(this._posAttribute.buffer.apply(),this._onPositionChange=!1),this._posAttribute.buffer}get vSpriteBuffer(){return this._onSpriteChange&&(this._spriteAttribute.buffer.apply(),this._onSpriteChange=!1),this._spriteAttribute.buffer}get vColorBuffer(){return this._onColorChange&&(this._colorAttribute.buffer.apply(),this._onColorChange=!1),this._colorAttribute.buffer}create(){this.createBuffer(),this.updateBounds();let e=this.maxQuadCount,t=[],r=[];for(let a=0;a<e;a++)t.push(...ai.attUV);for(let a=0,n=this.maxQuadCount*ai.vertexCount;a<n;a++)r[a]=a;this._attributeUV=new Float32Array(ai.vertexCount*e*this._uvSize),this._attributeVIndex=new Float32Array(ai.vertexCount*e*this._vIndexSize),this._attributeUV.set(t,0),this._attributeVIndex.set(r,0);let s=[];for(let a=0;a<e;a++)for(let n=0;n<ai.indecies.length;n++){const l=ai.indecies[n]+a*4;s.push(l)}return this._faceIndexes=new Uint32Array(e*6),this._faceIndexes.set(s,0),this.setIndices(this._faceIndexes),this.setAttribute(Y.uv,this._attributeUV),this.setAttribute(Y.vIndex,this._attributeVIndex),this.addSubGeometry({indexStart:0,indexCount:this._faceIndexes.length,vertexStart:0,index:0}),this}createBuffer(){let e=this.maxQuadCount;this._posAttribute=new nn(e*4),this._spriteAttribute=new nn(e*(4+4+2+2)),this._colorAttribute=new nn(e*4)}fillQuad(e,t){e.dirtyAttributes&Pe.POSITION&&this.fillQuadPosition(e,t),e.dirtyAttributes&Pe.COLOR&&this.fillQuadColor(e,t),e.dirtyAttributes&Pe.SPRITE&&this.fillQuadSprite(e,t)}fillQuadPosition(e,t){kc.setXYZW(this._posAttribute.array,e.z,e.left,e.bottom,e.right,e.top),this._onPositionChange=!0}fillQuadColor(e,t){let r=e.color,s=this._colorAttribute.array;kc.setXYZW(s,e.z,r.r,r.g,r.b,r.a),this._onColorChange=!0}fillQuadSprite(e,t){let r=e.sprite,s=0,a=0;r.isSliced&&e.imageType==pr.Sliced&&(s=r.trimSize.x,s=(t.width-(r.offsetSize.z-r.trimSize.x))/s,a=r.trimSize.y,a=(t.height-(r.offsetSize.w-r.trimSize.y))/a);let n=r.guiTexture.dynamicId,l=r.uvRec,h=r.uvBorder,u=this._spriteAttribute.array,c=(4+4+2+2)*e.z;u[c+0]=l.x,u[c+1]=l.y,u[c+2]=l.z,u[c+3]=l.w,u[c+4]=h.x,u[c+5]=h.y,u[c+6]=h.z,u[c+7]=h.w,u[c+8]=s,u[c+9]=a,u[c+10]=n,u[c+11]=e.visible?1:0,this._onSpriteChange=!0}}class wp{static set(e,t,r,s,...a){let n=t*s+r;for(let l=0,h=a.length;l<h;l++)e[n+l]=a[l]}}class kc extends wp{static setXYZW(e,t,r,s,a,n){this.set(e,t,0,4,r,s,a,n)}static setXYZ(e,t,r,s,a){this.set(e,t,0,4,r,s,a)}static setZ(e,t,r){this.set(e,t,3,4,r)}}class ai{}o(ai,"vertexCount",4),o(ai,"attUV",[0,0,1,0,1,1,0,1]),o(ai,"indecies",[0,1,2,0,2,3]);class zc{constructor(){o(this,"_textureMap",new Map),o(this,"_textureList",[])}build(e,t,r){let s=-1,a=-1;this._textureMap.clear(),this._textureList.length=0;let n=[],l=t.quadMaxCount-1,h;for(let u of e){let c=u.needUpdateQuads;n.length=0;const f=this.collectQuads(u.object3D,n);for(let d of f){d.z=++s;let p=d.sprite.guiTexture;if(!this._textureMap.has(p.staticId)&&(++a,this._textureMap.set(p.staticId,p),p.dynamicId=a,this._textureList[a]=p.texture,a>7)){console.warn("texture Count Exceeded the maximum limit of 7");break}if(d.cacheTextureId!=p.dynamicId&&(d.dirtyAttributes=Pe.MAX,d.cacheTextureId=p.dynamicId),(c||r)&&(d.dirtyAttributes=Pe.MAX),d.dirtyAttributes&Pe.POSITION&&d.applyTransform(u),d.dirtyAttributes&&d.writeToGeometry(t._geometry,u),s==l){h=!0;break}}if(h)break}return t._uiMaterial.setTextures(this._textureList),t._limitVertexCount=(s+1)*4,!h}collectQuads(e,t){t||(t=[]);let r=e.components.values();for(let s of r){let a=s;if(a.isUIShadow||!a.mainQuads)continue;let n=a.getShadowRender();n&&this.push(n.mainQuads,t),this.push(a.mainQuads,t)}return t}push(e,t){e&&e.length>0&&t.push(...e)}}const gt=class{static bindTextureArray(){let i="";for(let e=0;e<7;e++)i+=`
        @group(1) @binding(auto)
        var tex_${e}Sampler: sampler;
        @group(1) @binding(auto)
#if VideoTexture${e}
        var tex_${e}: texture_external;
#else
        var tex_${e}: texture_2d<f32>;
#endif
`;return i}static sampleTexture(i){return`
#if VideoTexture${i}
            let size = textureDimensions(tex_${i}).xy - 1;
            uv.y = 1.0 - uv.y;
            let iuv = vec2<i32>(uv * vec2<f32>(size));
            color = textureLoad(tex_${i}, iuv) ;
#else
            color = textureSampleLevel(tex_${i}, tex_${i}Sampler, uv, 0.0);
#endif        `}};let Ni=gt;o(Ni,"fs",`
        ${Wa}
        ${gt.bindTextureArray()}

        var<private> fragmentOutput: FragmentOutput;
        var<private> uvSlice: vec2<f32>;
        var<private> EPSILON: f32 = 0.001;
        
        fn sliceBorder(uv:f32, scale:f32, border:vec2<f32>) -> f32 
        {
            var s = uv * scale;
            if(s > border.x){
                s -= border.x;
                let centerPartMax = scale - border.x - border.y;
                let centerPartMin = 1.0 - border.x - border.y;
                if(s < centerPartMax){
                    s = border.x + (s / centerPartMax) * centerPartMin;
                }else{
                    s = s - centerPartMax + border.x + centerPartMin;
                }
            }
            return s;
        }

        fn isInsideAlpha(coord:vec2<f32>, rect:vec4<f32>, cornerRadius0:f32, fadeOutSize0:f32) -> f32
        {
            var minX = min(rect.x, rect.z);
            var maxX = max(rect.x, rect.z);
            var minY = min(rect.y, rect.w);
            var maxY = max(rect.y, rect.w);

            var cornerRadius = max(EPSILON, cornerRadius0);

            var center = vec2<f32>(minX + maxX, minY + maxY) * 0.5;
            var extents = vec2<f32>(maxX - minX, maxY - minY) * 0.5;

            cornerRadius = min(extents.x, cornerRadius);
            cornerRadius = min(extents.y, cornerRadius);
            
            var extendsMin = max(vec2<f32>(0.0), extents - cornerRadius);
            
            var toCenter = abs(coord - center);
            var outerDist = toCenter - extents;
            var innerDist = toCenter - extendsMin;
            
            if(innerDist.x <= 0 && innerDist.y <= 0){
                return 1.0;
            }else if(outerDist.x <= 0 && outerDist.y <= 0){
                var fadeOutPercent = clamp(fadeOutSize0, EPSILON, cornerRadius) / cornerRadius;
                innerDist = max(vec2(EPSILON), innerDist);
                var distance = min(cornerRadius, length(innerDist));
                var alpha = 1.0 - distance / cornerRadius;
                alpha /= fadeOutPercent;
                alpha = clamp(alpha, 0.0, 1.0);
                return alpha;
            }
            return 0.0;
        }
        
        @fragment
        fn FragMain( 
            @location(0) vUV: vec2<f32>,
            @location(1) vColor4: vec4<f32>,
            @location(2) vLocalPos: vec2<f32>,
            @location(3) vUvRec: vec4<f32>,
            @location(4) vUvBorder: vec4<f32>,
            @location(5) vUvSlice: vec2<f32>,
            @location(6) vTextureID: f32,
            @builtin(front_facing) face: bool,
            @builtin(position) fragCoord : vec4<f32> 
        ) -> FragmentOutput {

            var scissorAlpha = 1.0;
#if SCISSOR_ENABLE
            scissorAlpha = isInsideAlpha(
                vLocalPos.xy,
                materialUniform.scissorRect,
                materialUniform.scissorCornerRadius,
                materialUniform.scissorFadeOutSize);

            if(scissorAlpha < EPSILON){
                discard;
            }
#endif

            uvSlice = vUvSlice;
            
            var uv:vec2<f32> = vUV;
            if(uvSlice.x > 1.0){ uv.x = sliceBorder(uv.x, uvSlice.x, vUvBorder.xz);}
            if(uvSlice.y > 1.0){ uv.y = sliceBorder(uv.y, uvSlice.y, vUvBorder.yw);}
            uv = uv * vUvRec.zw + vUvRec.xy;
            
            var color = vec4<f32>(0.0,0.0,0.0,1.0);
            let texId = i32(vTextureID + 0.5);
            
            var texSize = vec2<i32>(0);
            var coord = vec2<i32>(0);
            
            if(texId == 0){
                ${gt.sampleTexture(0)}
            }else if(texId == 1){
                ${gt.sampleTexture(1)}
            }else if(texId == 2){
                ${gt.sampleTexture(2)}
            }else if(texId == 3){            
                ${gt.sampleTexture(3)}
            }else if(texId == 4){            
                ${gt.sampleTexture(4)}
            }else if(texId == 5){            
                ${gt.sampleTexture(5)}
            }else if(texId == 6){            
                ${gt.sampleTexture(6)}
            }
            color *= vColor4;
            color.a *= scissorAlpha;
            if(color.a < EPSILON)
            { 
                discard;
            }

            fragmentOutput.color = color;
            return fragmentOutput ;
        }`),o(Ni,"GUI_common_vs",`
        ${Xa}
        ${Ts}

        struct VertexSpriteBuffer {
            vUvRec: vec4<f32>,
            vUvBorder: vec4<f32>,
            vUvSlice: vec2<f32>,
            vTextureID: f32,
            vVisible: f32
        }
                
        struct MaterialUniform{
            scissorRect:vec4<f32>,

            screenSize:vec2<f32>,
            guiSolution:vec2<f32>,
            
            scissorCornerRadius:f32,
            scissorFadeOutSize:f32,

            limitVertex:f32,
            pixelRatio:f32,
        }
        
        struct VertexOutput {
            @location(0) vUV: vec2<f32>,
            @location(1) vColor4: vec4<f32>,
            @location(2) vLocalPos: vec2<f32>,
            @location(3) vUvRec: vec4<f32>,
            @location(4) vUvBorder: vec4<f32>,
            @location(5) vUvSlice: vec2<f32>,
            @location(6) vTextureID: f32,
            
            @builtin(position) member: vec4<f32>
        };
        
         struct VertexInput{
            @builtin(instance_index) index : u32,
            @location(0) uv: vec2<f32>,
            @location(1) vIndex: f32,
        }

        @group(2) @binding(0)
        var<uniform> materialUniform : MaterialUniform;
        @group(3) @binding(1)
        var<storage, read> vPositionBuffer: array<vec4<f32>>;
        @group(3) @binding(2)
        var<storage, read> vSpriteBuffer: array<VertexSpriteBuffer>;
        @group(3) @binding(3)
        var<storage, read> vColorBuffer: array<vec4<f32>>;

        var<private> vertexOut: VertexOutput ;

        //quad: (left, bottom, right, top)
        //index: 0~3
        fn getVertexXY(quad:vec4<f32>, index:u32) -> vec2<f32>
        {
            var ret = vec2<f32>(0.0);
            if(index == 0 || index == 3){
                ret.x = quad.x;
            }else{
                ret.x = quad.z;
            }
            if(index == 0 || index == 1){
                ret.y = quad.w;
            }else{
                ret.y = quad.y;
            }
            return ret;
        }
    `),o(Ni,"GUI_shader_view",`
        ${gt.GUI_common_vs}

        @vertex
        fn VertMain( vertex:VertexInput ) -> VertexOutput {
            var _m = models.matrix[0];
            var _n = globalUniform.frame;
            
            let vertexIndex = vertex.vIndex;
            let quadIndex = u32(vertex.vIndex * 0.25);
            let vertexPosition = getVertexXY(vPositionBuffer[quadIndex], u32(vertexIndex) % 4u);
            var vSpriteData = vSpriteBuffer[quadIndex];
            
            var op = vec2<f32>(0.0001);
            let isValidVertex = vSpriteData.vVisible > 0.5 && vertexIndex < materialUniform.limitVertex;
            if(isValidVertex){
                op = 2.0 * vertexPosition * materialUniform.pixelRatio  / materialUniform.screenSize;
            }

            vertexOut.vLocalPos = vertexPosition;
            vertexOut.member = vec4<f32>(op.x, op.y, vertexIndex * 0.0001, 1.0);

            vertexOut.vUV = vec2<f32>(vertex.uv);
            vertexOut.vUvRec = vSpriteData.vUvRec;
            vertexOut.vUvBorder = vSpriteData.vUvBorder;
            vertexOut.vUvSlice = vSpriteData.vUvSlice;
            vertexOut.vTextureID = vSpriteData.vTextureID;
            vertexOut.vColor4 = vColorBuffer[quadIndex];

            return vertexOut;
         }
         
         ${gt.fs}
        `),o(Ni,"GUI_shader_world",`
        ${gt.GUI_common_vs}
        @vertex
        fn VertMain( vertex:VertexInput ) -> VertexOutput {
            var modelMatrix = models.matrix[vertex.index];
            
            let vertexIndex = vertex.vIndex;
            let quadIndex = u32(vertex.vIndex * 0.25);
            let vertexPosition = getVertexXY(vPositionBuffer[quadIndex], u32(vertexIndex) % 4u);
            var localPos = vec4<f32>(vertexPosition.xy, vertexIndex * 0.0001, 1.0) ;
            var op = vec4<f32>(0.0001);
            var vSpriteData = vSpriteBuffer[quadIndex];

            let isValidVertex = vSpriteData.vVisible > 0.5 && vertexIndex < materialUniform.limitVertex;
            if(isValidVertex){
                op = globalUniform.projMat * globalUniform.viewMat * modelMatrix * localPos ;
            }

            vertexOut.vLocalPos = vertexPosition;
            vertexOut.member = op;

            vertexOut.vUV = vec2<f32>(vertex.uv);
            vertexOut.vUvRec = vSpriteData.vUvRec;
            vertexOut.vUvBorder = vSpriteData.vUvBorder;
            vertexOut.vUvSlice = vSpriteData.vUvSlice;
            vertexOut.vTextureID = vSpriteData.vTextureID;
            vertexOut.vColor4 = vColorBuffer[quadIndex];

            return vertexOut;
         }
         
         ${gt.fs}

        `);class Gc extends _i{constructor(e){super(),o(this,"_scissorRect"),o(this,"_screenSize",new Z(1024,768)),o(this,"_scissorEnable",!1),o(this,"_videoTextureFlags",{}),N.register("GUI_shader_view",Ni.GUI_shader_view),N.register("GUI_shader_world",Ni.GUI_shader_world);let t=e==Nt.View?"GUI_shader_view":"GUI_shader_world",r=new We(t,t);r.setShaderEntry("VertMain","FragMain"),r.setUniformVector2("screenSize",this._screenSize),r.setUniformVector2("guiSolution",this._screenSize),r.setUniformVector4("scissorRect",new j),r.setUniformFloat("scissorCornerRadius",0),r.setUniformFloat("scissorFadeOutSize",0),r.setUniformFloat("limitVertex",0),r.setUniformFloat("pixelRatio",1);let s=r.shaderState;s.depthWriteEnabled=!1,r.blendMode=xe.ALPHA,r.depthCompare=e==Nt.View?vt.always:vt.less_equal,r.cullMode=ui.back,this.defaultPass=r}setLimitVertex(e){this.defaultPass.setUniformFloat("limitVertex",e)}setGUISolution(e,t){this.defaultPass.setUniformVector2("guiSolution",e),this.defaultPass.setUniformFloat("pixelRatio",t)}setScissorRect(e,t,r,s){this._scissorRect||(this._scissorRect=new j),this._scissorRect.set(e,t,r,s),this.defaultPass.setUniformVector4("scissorRect",this._scissorRect)}setScissorEnable(e){this._scissorEnable!=e&&(this._scissorEnable=e,e?this.defaultPass.setDefine("SCISSOR_ENABLE",!0):this.defaultPass.deleteDefine("SCISSOR_ENABLE"),this.defaultPass.noticeValueChange())}setScissorCorner(e,t){this.defaultPass.setUniformFloat("scissorCornerRadius",e),this.defaultPass.setUniformFloat("scissorFadeOutSize",t)}setScreenSize(e,t){return this._screenSize.set(e,t),this.defaultPass.setUniformVector2("screenSize",this._screenSize),this}setTextures(e){for(let t=0;t<7;t++){let r=e[t]||A.res.whiteTexture;this.defaultPass.setTexture(`tex_${t}`,r),this.setVideoTextureDefine(t,r.isVideoTexture)}}setVideoTextureDefine(e,t){let r=!1;t!=this._videoTextureFlags[e]&&(t?this.defaultPass.setDefine(`VideoTexture${e}`,!0):this.defaultPass.deleteDefine(`VideoTexture${e}`),this._videoTextureFlags[e]=t,r=!0),r&&this.defaultPass.noticeValueChange()}set envMap(e){}set shadowMap(e){}set baseMap(e){}set normalMap(e){}set emissiveMap(e){}set irradianceMap(e){}set irradianceDepthMap(e){}}class Qc extends ce{constructor(){super(...arguments),o(this,"_guiGeometry")}init(e){super.init(),this.addRendererMask(Ue.UI),this.removeRendererMask(Ue.Default),this.castGI=!1,this.castShadow=!1,this.alwaysRender=!0,this._ignoreEnvMap=this._ignorePrefilterMap=!0}get geometry(){return super.geometry}set geometry(e){super.geometry=e,this._guiGeometry=e}nodeUpdate(e,t,r,s){for(let a=0;a<this.materials.length;a++){let l=this.materials[a].getPass(t),h=this._guiGeometry.vPositionBuffer,u=this._guiGeometry.vSpriteBuffer,c=this._guiGeometry.vColorBuffer;if(l)for(let f=0;f<l.length;f++){const d=l[f];d.pipeline||(d.setStorageBuffer("vPositionBuffer",h),d.setStorageBuffer("vSpriteBuffer",u),d.setStorageBuffer("vColorBuffer",c))}}super.nodeUpdate(e,t,r,s)}onUpdate(e){}}class Vc{constructor(){o(this,"_use"),o(this,"_unUse"),this._use=[],this._unUse=[]}pushBack(e){let t=this._use.indexOf(e);t!=-1&&(this._use.splice(t,1),this._unUse.push(e))}getUseList(){return this._use}getOne(e,t){let r;return this._unUse.length>0?(r=this._unUse[0],this._unUse.splice(0,1),this._use.push(r),r):(r=new e(t),this._use.push(r),r)}hasFree(){return this._unUse.length>0}}let xr;const oa=class{constructor(){o(this,"x",0),o(this,"y",0),o(this,"z",0),o(this,"width",1),o(this,"height",1),o(this,"_globalX",0),o(this,"_globalY",0),o(this,"_globalWidth",0),o(this,"_globalHeight",0),o(this,"_visible",!0),o(this,"_offsetX",0),o(this,"_offsetY",0),o(this,"_sprite",A.res.defaultGUISprite),o(this,"_color",new z(1,1,1,1)),o(this,"_imageType",pr.Simple),o(this,"dirtyAttributes",Pe.MAX),o(this,"cacheTextureId",-1)}static get quadPool(){return this.textPool||(this.textPool=new Vc),this.textPool}static recycleQuad(i){i.sprite=null,i.dirtyAttributes=Pe.MAX,i.x=0,i.y=0,i.z=-1,i.cacheTextureId=-1,oa.quadPool.pushBack(i)}static spawnQuad(){return oa.quadPool.getOne(oa)}get imageType(){return this._imageType}set imageType(i){this._imageType=i,this.setAttrChange(Pe.SPRITE|Pe.POSITION)}get color(){return this._color}set color(i){this._color.copyFrom(i),this.setAttrChange(Pe.COLOR)}get visible(){return this._visible}set visible(i){i!=this._visible&&(this._visible=i,this.setAttrChange(Pe.SPRITE))}get sprite(){return this._sprite}set sprite(i){this._sprite!=i&&(this._sprite=i,this.setAttrChange(Pe.SPRITE|Pe.POSITION))}get left(){return this._globalX-this._offsetX}get right(){return this.left+this._globalWidth}get top(){return this._globalY-this._offsetY}get bottom(){return this.top+this._globalHeight}setSize(i,e){this.width=i,this.height=e,this.setAttrChange(Pe.POSITION)}setXY(i,e){this.x=i,this.y=e,this.setAttrChange(Pe.POSITION)}setAttrChange(i){this.dirtyAttributes=this.dirtyAttributes|i}applyTransform(i){this.setAttrChange(Pe.POSITION);let e=this._sprite,t=i.getWorldMatrix();(this.x!=0||this.y!=0)&&(t=this.getQuadMatrix(t));let r=t.getScaleX(),s=t.getScaleY(),a=e.isSliced&&this._imageType==pr.Sliced;if(this._offsetX=i.width*.5*r,this._offsetY=i.height*.5*s,a)this._globalWidth=r*(i.width-(e.offsetSize.z-e.trimSize.x)),this._globalHeight=s*(i.height-(e.offsetSize.w-e.trimSize.y)),this._globalX=t.tx+e.offsetSize.x*r,this._globalY=t.ty+e.offsetSize.y*s;else{let n=this.width/e.offsetSize.z,l=this.height/e.offsetSize.w;this._globalWidth=r*e.trimSize.x*n,this._globalHeight=s*e.trimSize.y*l,this._globalX=t.tx+e.offsetSize.x*n*r,this._globalY=t.ty+e.offsetSize.y*l*s}return this}getQuadMatrix(i){return xr||(xr=new Qi),xr.identity(),xr.setTranslate(this.x,this.y),xr.mul(i),xr}writeToGeometry(i,e){return i.fillQuad(this,e),this.dirtyAttributes=Pe.NONE,this}};let Fi=oa;o(Fi,"textPool");class ln extends Ee{constructor(){super(...arguments),o(this,"_uiTransform"),o(this,"_visible",!0)}destroy(){this._uiTransform.setNeedUpdateUIPanel(),super.destroy()}get uiTransform(){return this._uiTransform}get visible(){return this._visible}set visible(e){var t;this._visible!=e&&(this._visible=e,(t=this.onUIComponentVisible)==null||t.call(this,this._visible))}init(e){var t;(t=super.init)==null||t.call(this,e),this._uiTransform=this.object3D.getOrAddComponent(li),this._uiTransform.setNeedUpdateUIPanel()}copyComponent(e){return this.visible=e.visible,this}}class cs extends ln{constructor(){super(...arguments),o(this,"_mainQuads"),o(this,"_shadowRender"),o(this,"_shadowSource"),o(this,"isUIShadow"),o(this,"isShadowless"),o(this,"needUpdateShadow")}init(e){var t;(t=super.init)==null||t.call(this,e),this._mainQuads=[]}destroy(){var e,t;this.detachQuads(),(e=this._shadowRender)==null||e.setShadowSource(null),(t=this._shadowSource)==null||t.setShadowRenderer(null),super.destroy(),this._shadowRender=null,this._shadowSource=null}start(){var e;(e=super.start)==null||e.call(this),this.isUIShadow?this.autoBindShadow(null,this):this.isShadowless||this.autoBindShadow(this,null),this.setShadowDirty()}setShadowDirty(){this._shadowRender&&(this._shadowRender.needUpdateShadow=!0)}get mainQuads(){return this._mainQuads}setShadowRenderer(e){this._shadowRender=e}setShadowSource(e){this._shadowSource=e}getShadowRender(){return this._shadowRender}autoBindShadow(e,t){let r=this.object3D.components.values();if(!e)for(let s of r){let a=s;if(!(a.isShadowless||a.isUIShadow)&&a.mainQuads){e=a;break}}if(!t)for(let s of r){let a=s;if(a.isUIShadow&&a.mainQuads){t=a;break}}return e&&t?(e.setShadowRenderer(t),t.setShadowSource(e),!0):!1}recycleQuad(e){if(e&&this._mainQuads){let t=this._mainQuads.indexOf(e);t>=0?(this._mainQuads.splice(t,1),Fi.recycleQuad(e)):e=null}return e}attachQuad(e){return this._mainQuads&&this._mainQuads.push(e),this}detachQuads(){if(this._mainQuads)for(;this._mainQuads.length>0;){let e=this._mainQuads.shift();this.recycleQuad(e)}return this}copyComponent(e){return super.copyComponent(e),this.isUIShadow=e.isUIShadow,this.isShadowless=e.isShadowless,this}}class Vi extends cs{init(e){var t;(t=super.init)==null||t.call(this,e),this.attachQuad(Fi.spawnQuad()),this.sprite=A.res.defaultGUISprite}cloneTo(e){e.getOrAddComponent(Vi).copyComponent(this)}copyComponent(e){return super.copyComponent(e),this.sprite=e.sprite,this.color=e.color,this.imageType=e.imageType,this}set sprite(e){e||(e=A.res.defaultGUISprite);for(let t of this._mainQuads)t.sprite=e,t.setSize(this._uiTransform.width,this._uiTransform.height);this.setShadowDirty()}onTransformResize(){this.applyTransformSize()}applyTransformSize(){for(let e of this._mainQuads)e.setSize(this._uiTransform.width,this._uiTransform.height);this.setShadowDirty()}get sprite(){return this._mainQuads[0].sprite}onUIComponentVisible(e){this.applyComponentVisible()}onUITransformVisible(e){this.applyComponentVisible()}applyComponentVisible(){let e=!this._visible||!this._uiTransform.globalVisible;for(let t of this._mainQuads)t.visible=!e;this.setShadowDirty()}get color(){return this._mainQuads[0].color}set color(e){for(let t of this._mainQuads)t.color=e;this.setShadowDirty()}get imageType(){return this._mainQuads[0].imageType}set imageType(e){for(let t of this._mainQuads)t.imageType=e;this.setShadowDirty()}}class ws extends Vi{constructor(){super(...arguments),o(this,"space",Nt.World),o(this,"needUpdateGeometry",!0),o(this,"panelOrder",0),o(this,"needSortOnCameraZ"),o(this,"_billboard"),o(this,"_rebuild"),o(this,"scissorEnable",!1),o(this,"scissorCornerRadius",0),o(this,"scissorFadeOutSize",0),o(this,"_uiRenderer"),o(this,"_uiMaterial"),o(this,"_geometry"),o(this,"_limitVertexCount",0),o(this,"_maxCount",128),o(this,"isUIPanel",!0),o(this,"_collectTransform",[])}cloneTo(e){e.getOrAddComponent(ws).copyComponent(this)}copyComponent(e){return super.copyComponent(e),this.panelOrder=e.panelOrder,this.needSortOnCameraZ=e.needSortOnCameraZ,this.cullMode=e.cullMode,this.billboard=e.billboard,this.scissorEnable=e.scissorEnable,this.scissorCornerRadius=e.scissorCornerRadius,this.scissorFadeOutSize=e.scissorFadeOutSize,this}init(e){super.init(e),this.create(this.space),this.visible=!1}create(e){this._maxCount=this.space==Nt.World?ye.quadMaxCountForWorld:ye.quadMaxCountForView,this._uiRenderer=this.object3D.addComponent(Qc),this._geometry=this._uiRenderer.geometry=new Fc(this._maxCount).create(),this._uiMaterial=this._uiRenderer.material=new Gc(e),this._uiRenderer.renderOrder=ye.SortOrderStartWorld,this._rebuild=new zc,this.object3D.bound=new Be(new g,new g(1,1,1).multiplyScalar(Number.MAX_VALUE*.1))}get quadMaxCount(){return this._maxCount}set billboard(e){this.space==Nt.View?e=xi.None:console.warn("Cannot enable billboard in view space"),e==xi.BillboardXYZ||e==xi.BillboardY?(this._billboard=this.object3D.getOrAddComponent(ys),this._billboard.type=e):(this.object3D.removeComponent(ys),this._billboard=null)}get billboard(){return this._billboard?this._billboard.type:xi.None}set cullMode(e){this.space==Nt.World?this._uiRenderer.material.cullMode=e:console.warn("Cannot change cullMode in view space")}get cullMode(){return this._uiRenderer.material.cullMode}onUpdate(e){var t;(t=super.onUpdate)==null||t.call(this,e),this.rebuildGUIMesh(e)}rebuildGUIMesh(e){let t=this,r=t._collectTransform;if(r.length=0,t.object3D.getComponents(li,r),r.length>0){t._rebuild.build(r,t,t.needUpdateGeometry);for(const h of r)h.needUpdateQuads=!1}let s=t.object3D.getComponentFromParent(Cs),a=s?s.index:0;t._uiRenderer.enable=r.length>0;let n=t.isViewPanel?ye.SortOrderStartView:ye.SortOrderStartWorld;t._uiRenderer.renderOrder=a*ye.SortOrderCanvasSpan+n+t.panelOrder,t._uiRenderer.needSortOnCameraZ=t.needSortOnCameraZ;let l=t._uiMaterial;if(l.setGUISolution(ye.solution,ye.pixelRatio),l.setScreenSize(S.canvas.clientWidth,S.canvas.clientHeight),l.setLimitVertex(t._limitVertexCount),l.setScissorEnable(t.scissorEnable),t.scissorEnable){let h=t.mainQuads[0];l.setScissorRect(h.left,h.bottom,h.right,h.top),l.setScissorCorner(t.scissorCornerRadius,t.scissorFadeOutSize)}t.needUpdateGeometry=!1}}class Ca extends ws{constructor(){super(),o(this,"isViewPanel",!0),o(this,"space",Nt.View)}cloneTo(e){e.getOrAddComponent(Ca).copyComponent(this)}}class wa extends ws{constructor(){super(),o(this,"isWorldPanel",!0),o(this,"space",Nt.World),o(this,"_depthTest",!0)}cloneTo(e){e.getOrAddComponent(wa).copyComponent(this)}copyComponent(e){return super.copyComponent(e),this.depthTest=e.depthTest,this}get depthTest(){return this._depthTest}set depthTest(e){if(this._depthTest!=e){this._depthTest=e;let t=this.depthTest?vt.less_equal:vt.always;this._uiRenderer.material.depthCompare=t}}}let hn;class li extends Ee{constructor(){super(),o(this,"useParentPivot",!1),o(this,"parent"),o(this,"pivotX",.5),o(this,"pivotY",.5),o(this,"_width",100),o(this,"_height",100),o(this,"_localVisible",!0),o(this,"_globalVisible",!0),o(this,"_uiInteractiveList"),o(this,"_localMatrix"),o(this,"_worldMatrix"),o(this,"_onChange",!0),o(this,"needUpdateQuads",!0),o(this,"_tempTransforms",[]),this._localMatrix=new Qi,this._worldMatrix=new Qi}get uiInteractiveList(){return this._uiInteractiveList}init(e){var t;super.init(e),this.transform.eventDispatcher.addEventListener(this.transform.eventLocalChange.type,this.onTransformChange,this),this.onParentChange(null,(t=this.object3D.parent)==null?void 0:t.object3D)}onTransformChange(e){this.onChange=!0}addUIInteractive(e){return this._uiInteractiveList||(this._uiInteractiveList=[]),this._uiInteractiveList.push(e),this}removeUIInteractive(e){if(this._uiInteractiveList){let t=this._uiInteractiveList.indexOf(e);if(t>=0)return this._uiInteractiveList.slice(t,1),e}return null}get globalVisible(){return this._globalVisible}set visible(e){if(this._localVisible!=e){this._localVisible=e;let t=this.parent?this.parent._globalVisible:!0;this.onUITransformVisible(this._localVisible&&t)}}get visible(){return this._localVisible}onUITransformVisible(e){let t=this._localVisible&&e;t!=this._globalVisible&&(this._globalVisible=t,this.object3D.components.forEach((r,s)=>{let a=r;if(a.onUITransformVisible)if(a==this)for(let n of this.object3D.entityChildren){let l=n.getComponent(li);l&&l.onUITransformVisible(this._globalVisible)}else a.onUITransformVisible(this._globalVisible)}))}onParentChange(e,t){var r,s;(r=this.parent)==null||r.setNeedUpdateUIPanel(),this.parent=t?.getComponent(li),(s=this.parent)==null||s.setNeedUpdateUIPanel()}get width(){return this._width}get height(){return this._height}resize(e,t){var r;if(this._width!=e||this._height!=t){this._width=e,this._height=t,this.onChange=!0;for(let s of this.object3D.components.values())(r=s.onTransformResize)==null||r.call(s);return!0}return!1}get x(){return this.object3D.x}set x(e){e!=this.object3D.x&&(this.object3D.x=e,this.onChange=!0)}get y(){return this.object3D.y}set y(e){e!=this.object3D.y&&(this.object3D.y=e,this.onChange=!0)}setXY(e,t){let r=this.object3D.localPosition;r.set(e,t,r.z),this.object3D.localPosition=r,this.onChange=!0}get z(){return this.object3D.z}set z(e){e!=this.object3D.z&&(this.object3D.z=e,this.onChange=!0)}get scaleX(){return this.object3D.scaleX}set scaleX(e){this.onChange=!0,this.object3D.scaleX=e}get scaleY(){return this.object3D.scaleY}set scaleY(e){this.onChange=!0,this.object3D.scaleY=e}get scaleZ(){return this.object3D.scaleZ}set scaleZ(e){this.onChange=!0,this.object3D.scaleZ=e}get onChange(){return this._onChange}set onChange(e){if(this._onChange!=e&&(this._onChange=e,e)){this._tempTransforms.length=0;let t=this.object3D.getComponents(li,this._tempTransforms,!0);for(let r of t)r._onChange=!0,r.needUpdateQuads=!0}}onEnable(){this.setNeedUpdateUIPanel(),this.onChange=!0}onDisable(){this.setNeedUpdateUIPanel(),this.onChange=!0}setNeedUpdateUIPanel(){let e;e=this.object3D.getComponentFromParent(wa),e||(e=this.object3D.getComponentFromParent(Ca)),e&&(e.needUpdateGeometry=!0)}cloneTo(e){let t=e.getOrAddComponent(li);t.visible=this.visible,t.x=this.x,t.y=this.y,t.z=this.z,t.resize(this.width,this.height),t.pivotX=this.pivotX,t.pivotY=this.pivotY,t.scaleX=this.scaleX,t.scaleY=this.scaleY}matrix(){let e=this._localMatrix,t=this.object3D.rotationZ;return this.parent?(e.updateScaleAndRotation(this.object3D.scaleX,this.object3D.scaleY,t,t),e.tx=this.object3D.x,e.ty=this.object3D.y):e.updateScaleAndRotation(1,1,0,0),(this.pivotX!=.5||this.pivotY!=.5)&&(hn||(hn=new Qi().identity()),e.mul(hn.setTo(1,0,0,1,-(this.pivotX-.5)*this.width,-(this.pivotY-.5)*this.height))),e}getWorldMatrix(){let e=this,t=e._worldMatrix;return this._onChange&&(t.copyFrom(e.matrix()),e.parent&&t.mul(e.parent.getWorldMatrix()),e._onChange=!1),t}beforeDestroy(e){var t;this.transform.eventDispatcher.addEventListener(this.transform.eventLocalChange.type,this.onTransformChange,this),(t=super.beforeDestroy)==null||t.call(this,e)}}class Hc{constructor(){o(this,"_ray"),o(this,"_mouseCode"),o(this,"_clickEvent"),o(this,"_outEvent"),o(this,"_overEvent"),o(this,"_upEvent"),o(this,"_downEvent"),o(this,"_view"),o(this,"_lastDownTarget"),o(this,"_lastOverTarget"),o(this,"_lastDownPosition",new Z),o(this,"_calcDistanceVec2",new Z),o(this,"_lastDownTime",0),o(this,"_clickTimeSpan",200),o(this,"_clickDistanceSpan",10),o(this,"_colliderOut",[]),o(this,"_transformList",[]),o(this,"_sortWorldPanelList",[]),o(this,"_iteractive2PanelDict",new Map)}init(e){this._view=e,this._ray=new ci,this._clickEvent=new R(R.PICK_CLICK_GUI),this._outEvent=new R(R.PICK_OUT_GUI),this._overEvent=new R(R.PICK_OVER_GUI),this._upEvent=new R(R.PICK_UP_GUI),this._downEvent=new R(R.PICK_DOWN_GUI),A.inputSystem.addEventListener(R.POINTER_DOWN,this.onTouchDown,this,null,1),A.inputSystem.addEventListener(R.POINTER_UP,this.onTouchUp,this,null,1),A.inputSystem.addEventListener(R.POINTER_MOVE,this.onTouchMove,this,null,1),A.inputSystem.addEventListener(R.POINTER_CLICK,this.onTouchClick,this,null,1)}onTouchClick(e){this._lastOverTarget&&e.stopImmediatePropagation()}onTouchMove(e){this._mouseCode=e.mouseCode,this.collectEntities();let t=this.pick(this._colliderOut);t&&e.stopImmediatePropagation();let r=t?t.collider:null;r!=this._lastOverTarget&&(this._lastOverTarget&&this._lastOverTarget.enable&&(this._lastOverTarget.mouseStyle=De.NORMAL,this._outEvent.data=this._lastOverTarget,this._lastOverTarget.object3D.dispatchEvent(this._outEvent)),r&&(r.mouseStyle=De.OVER,this._overEvent.data=r,r.object3D.dispatchEvent(this._overEvent)),this._lastOverTarget=r)}onTouchDown(e){this._lastDownTime=he.time,this._lastDownPosition.set(e.mouseX,e.mouseY),this._mouseCode=e.mouseCode,this.collectEntities();let t=this.pick(this._colliderOut);t&&e.stopImmediatePropagation();let r=t?t.collider:null;r&&(r.mouseStyle=De.DOWN,this._overEvent.data=r,r.object3D.dispatchEvent(this._overEvent)),this._lastDownTarget=r}onTouchUp(e){this._calcDistanceVec2.set(e.mouseX,e.mouseY),this._mouseCode=e.mouseCode,this.collectEntities();let t=this.pick(this._colliderOut);t&&e.stopImmediatePropagation();let r=t?t.collider:null;this._lastDownTarget&&this._lastDownTarget.enable&&(this._lastDownTarget.mouseStyle=De.NORMAL),r&&r==this._lastDownTarget&&he.time-this._lastDownTime<=this._clickTimeSpan&&(this._calcDistanceVec2.set(e.mouseX,e.mouseY),this._calcDistanceVec2.distance(this._lastDownPosition)<=this._clickDistanceSpan&&(this._clickEvent.data={pick:r,pickInfo:t,mouseCode:this._mouseCode},r.object3D.dispatchEvent(this._clickEvent))),this._lastDownTarget=null}collectEntities(){return this._colliderOut.length=0,this._sortWorldPanelList.length=0,this._iteractive2PanelDict.clear(),this._view.canvasList.slice().reverse().forEach(t=>{if(t&&t.transform&&t.transform.parent){let r=t.object3D.getComponentsByProperty("isUIPanel",!0,!0);r.sort((s,a)=>{let n=s._uiRenderer.__renderOrder,l=a._uiRenderer.__renderOrder;return n>l?-1:1});for(let s of r){this._transformList.length=0,s.object3D.getComponents(li,this._transformList),this._transformList.reverse();for(const a of this._transformList){let n=a.uiInteractiveList;if(n&&n.length>0)for(let l of n)this._colliderOut.push(l),this._iteractive2PanelDict.set(l,s)}}}}),this._colliderOut}pick(e){this._ray=this._view.camera.screenPointToRay(A.inputSystem.mouseX,A.inputSystem.mouseY);let t=new Z(A.inputSystem.mouseX,A.inputSystem.mouseY),r=new Z(S.canvas.clientWidth,S.canvas.clientHeight),s;for(const a of e)if(a.interactive&&a.enable&&a.interactiveVisible){let n=this._iteractive2PanelDict.get(a);if(s=a.rayPick(this._ray,n,t,r),s)return s.collider=a,s}return null}}var Yc=(i=>(i[i.COLLINEAR=0]="COLLINEAR",i[i.LINES_INTERSECT=1]="LINES_INTERSECT",i[i.SEGMENTS_INTERSECT=2]="SEGMENTS_INTERSECT",i[i.A_BISECTS_B=3]="A_BISECTS_B",i[i.B_BISECTS_A=4]="B_BISECTS_A",i[i.PARALELL=5]="PARALELL",i))(Yc||{}),Xc=(i=>(i[i.ON_LINE=0]="ON_LINE",i[i.LEFT_SIDE=1]="LEFT_SIDE",i[i.RIGHT_SIDE=2]="RIGHT_SIDE",i))(Xc||{});const pt=class{constructor(i,e){o(this,"start"),o(this,"end"),o(this,"color",new z(1,1,1,1)),o(this,"_normal"),o(this,"_normalCalculated",!1),this.start=i,this.end=e}set(i,e){this.start=i,this.end=e}getCenter(){let i=g.HELP_0;return this.start.subtract(this.end,i),i.scaleBy(.5),i.add(this.end),i}inverse(){let i=this.start;this.start=this.end,this.end=i}equals(i){return this.start==i.start&&this.end==i.end||this.start==i.end&&this.end==i.start}toArray(){return[this.start.x,this.start.y,this.start.z,this.end.x,this.end.y,this.end.z]}static getLines(i){let e=[];for(let t=0;t<i.length;t++){let r=t,s=ro(t+1,i.length),a=i[r],n=i[s];e.push(new pt(a,n))}return e}intersection(i,e=null){var t=(i.end.z-i.start.z)*(this.end.x-this.start.x)-(i.end.x-i.start.x)*(this.end.z-this.start.z),r=(i.end.x-i.start.x)*(this.start.z-i.start.z)-(i.end.z-i.start.z)*(this.start.x-i.start.x),s=(i.start.x-this.start.x)*(this.end.z-this.start.z)-(i.start.z-this.start.z)*(this.end.x-this.start.x);if(t==0)return r==0&&s==0?0:5;r=r/t,s=s/t;var a=this.start.x+r*(this.end.x-this.start.x),n=this.start.z+r*(this.end.z-this.start.z);return e!=null&&(e.x=a,e.y=0,e.z=n),r>=0&&r<=1&&s>=0&&s<=1?2:s>=0&&s<=1?3:r>=0&&r<=1?4:1}getDirection(){var i=this.end.subtract(this.start),e=new g(i.x,i.y);return e.normalize()}copyFrom(i){this.start||(this.start=new g),this.end||(this.end=new g),this.start.copyFrom(i.start),this.end.copyFrom(i.end)}static IsEqual(i,e){return Math.abs(i-e)<1e-7}static squreDistanceSegmentToSegment(i,e,t){let r=i.start,s=i.end,a=e.start,n=e.end,l=r.x,h=r.y,u=r.z,c=s.x,f=s.y,d=s.z,p=a.x,m=a.y,_=a.z,v=n.x,y=n.y,C=n.z,B=c-l,T=f-h,M=d-u,D=v-p,P=y-m,L=C-_,I=l-p,O=h-m,k=u-_,H=B*B+T*T+M*M,W=B*D+T*P+M*L,ne=D*D+P*P+L*L,fe=B*I+T*O+M*k,we=D*I+P*O+L*k,ze=H*ne-W*W,Re=ze,ue=ze,de=0,Ge=0;this.IsEqual(ze,0)?(de=0,Re=1,Ge=we,ue=ne):(de=W*we-ne*fe,Ge=H*we-W*fe,de<0?(de=0,Ge=we,ue=ne):de>Re&&(de=Re,Ge=we+W,ue=ne)),Ge<0?(Ge=0,-fe<0?de=0:-fe>H?de=Re:(de=-fe,Re=H)):Ge>ue&&(Ge=ue,-fe+W<0?de=0:-fe+W>H?de=Re:(de=-fe+W,Re=H));let ot=0,nt=0;this.IsEqual(de,0)?ot=0:ot=de/Re,this.IsEqual(Ge,0)?nt=0:nt=Ge/ue;let Et=I+ot*B-nt*D,_t=O+ot*T-nt*P,xt=k+ot*M-nt*L;return Et*Et+_t*_t+xt*xt}isNear(i,e=0,t){let r=g.HELP_0,s=g.HELP_1;r.copyFrom(i.origin),s.copyFrom(i.direction),s.scaleBy(9999),s.add(r,s),pt.cacluteLine0.set(r,s),pt.cacluteLine1.copyFrom(this),t&&(t.perspectiveMultiplyPoint3(pt.cacluteLine1.start,pt.cacluteLine1.start),t.perspectiveMultiplyPoint3(pt.cacluteLine1.end,pt.cacluteLine1.end));let a=pt.squreDistanceSegmentToSegment(pt.cacluteLine0,pt.cacluteLine1,t);return a+1e-4<=e?(i.length=a,!0):(i.length=-999999,!1)}};let vr=pt;o(vr,"cacluteLine0",new pt(null,null)),o(vr,"cacluteLine1",new pt(null,null));const Wc=class{constructor(i,e,t){o(this,"v1"),o(this,"v2"),o(this,"v3"),o(this,"u1"),o(this,"u2"),o(this,"u3"),o(this,"n1"),o(this,"n2"),o(this,"n3"),o(this,"t0"),o(this,"t"),o(this,"u"),o(this,"v"),o(this,"min",new g),o(this,"max",new g),o(this,"id",0),this.id=Wc.ID+++200,i&&e&&t&&this.set(i,e,t)}set(i,e,t){this.v1=i,this.v2=e,this.v3=t;let r=this.min,s=this.max;return r.x=Math.min(this.v1.x,this.v2.x,this.v3.x),r.y=Math.min(this.v1.y,this.v2.y,this.v3.y),r.z=Math.min(this.v1.z,this.v2.z,this.v3.z),s.x=Math.max(this.v1.x,this.v2.x,this.v3.x),s.y=Math.max(this.v1.y,this.v2.y,this.v3.y),s.z=Math.max(this.v1.z,this.v2.z,this.v3.z),this}getNormal(){let i=this.v1,e=this.v2,t=this.v3,r=new g(e.x-i.x,e.y-i.y,e.z-i.z),a=new g(t.x-i.x,t.y-i.y,t.z-i.z).crossProduct(r);return a.normalize(),a}turnBack(){let i=this.v3;this.v3=this.v1,this.v1=i}getLines(){let i=this.v1,e=this.v2,t=this.v3;return[new vr(i,e),new vr(e,t),new vr(t,i)]}equals(i){let e=this.getLines(),t=i.getLines(),r=0;for(let s=0;s<e.length;s++)for(let a=0;a<t.length;a++)e[s].equals(t[a])&&r++;return r==3}getCenter(){let i=this.min,e=this.max,t=new g;return t.x=(i.x+e.x)*.5,t.y=(i.y+e.y)*.5,t.z=(i.z+e.z)*.5,t}intersects(i){var e=this.max,t=this.min,r=i.max,s=i.min;return t.x<=r.x&&e.x>=s.x&&t.y<=r.y&&e.y>=s.y&&t.z<=r.z&&e.z>=s.z}sign2D(i,e,t){return(i.x-t.x)*(e.z-t.z)-(e.x-t.x)*(i.z-t.z)}pointInTriangle2D(i){let e=this.v1,t=this.v2,r=this.v3,s,a,n,l,h;return s=this.sign2D(i,e,t),a=this.sign2D(i,t,r),n=this.sign2D(i,r,e),l=s<0||a<0||n<0,h=s>0||a>0||n>0,!(l&&h)}toArray(){return[this.v1.x,this.v1.y,this.v1.z,this.v2.x,this.v2.y,this.v2.z,this.v3.x,this.v3.y,this.v3.z]}};let na=Wc;o(na,"ID",-1);class Ft{static init(){this._pt0=new g,this._pt1=new g,this._pt2=new g,this._pt3=new g,this._ray=new ci,this._triangle=new na,this._hitPoint=new g,this._worldMatrix=new V}static rayPick(e,t,r,s,a,n){this._isInit||(this.init(),this._isInit=!0);let l=this._worldMatrix;if(s==Nt.World){let h;this.calculateHotArea_World(a,this._pt0,this._pt1,this._pt2,this._pt3),l.copyFrom(n).invert();let u=this._ray;if(u.copy(e).applyMatrix(l),this._triangle.set(this._pt0,this._pt1,this._pt2),h=u.intersectTriangle(u.origin,u.direction,this._triangle),h||(this._triangle.set(this._pt1,this._pt2,this._pt3),h=u.intersectTriangle(u.origin,u.direction,this._triangle)),h)return{distance:0,intersectPoint:h}}else{this.calculateHotArea_View(a,this._pt0,this._pt1,this._pt2,this._pt3);let h=r.x,u=r.y,c=Math.min(this._pt0.x,this._pt1.x,this._pt2.x,this._pt3.x)+h*.5,f=Math.min(this._pt0.y,this._pt1.y,this._pt2.y,this._pt3.y)+u*.5,d=Math.max(this._pt0.x,this._pt1.x,this._pt2.x,this._pt3.x)+h*.5,p=Math.max(this._pt0.y,this._pt1.y,this._pt2.y,this._pt3.y)+u*.5;return t.x<=d&&t.x>=c&&t.y<=p&&t.y>=f?(this._hitPoint.set(t.x,t.y,0),{distance:0,intersectPoint:this._hitPoint}):null}return null}static calculateHotArea_View(e,t,r,s,a){let n=e.getWorldMatrix(),l=n.getScaleX(),h=n.getScaleY(),u=e.width*.5*l,c=e.height*.5*h;t.set(-u,-c,0),r.set(u,-c,0),s.set(-u,c,0),a.set(u,c,0);let f=n.tx;t.x+=f,r.x+=f,s.x+=f,a.x+=f,f=n.ty,t.y-=f,r.y-=f,s.y-=f,a.y-=f,t.multiplyScalar(ye.pixelRatio),r.multiplyScalar(ye.pixelRatio),s.multiplyScalar(ye.pixelRatio),a.multiplyScalar(ye.pixelRatio)}static calculateHotArea_World(e,t,r,s,a){let n=e.getWorldMatrix(),l=n.getScaleX(),h=n.getScaleY(),u=e.width*.5*l,c=e.height*.5*h;t.set(-u,c,0),r.set(u,c,0),s.set(-u,-c,0),a.set(u,-c,0);let f=n.tx;t.x+=f,r.x+=f,s.x+=f,a.x+=f,f=n.ty,t.y+=f,r.y+=f,s.y+=f,a.y+=f}}o(Ft,"_pt0"),o(Ft,"_pt1"),o(Ft,"_pt2"),o(Ft,"_pt3"),o(Ft,"_hitPoint"),o(Ft,"_worldMatrix"),o(Ft,"_ray"),o(Ft,"_triangle"),o(Ft,"_isInit");var jc=(i=>(i[i.UpperLeft=0]="UpperLeft",i[i.UpperCenter=1]="UpperCenter",i[i.UpperRight=2]="UpperRight",i[i.MiddleLeft=3]="MiddleLeft",i[i.MiddleCenter=4]="MiddleCenter",i[i.MiddleRight=5]="MiddleRight",i[i.LowerLeft=6]="LowerLeft",i[i.LowerCenter=7]="LowerCenter",i[i.LowerRight=8]="LowerRight",i))(jc||{}),qc=(i=>(i[i.Upper=0]="Upper",i[i.Middle=1]="Middle",i[i.Lower=2]="Lower",i))(qc||{}),Kc=(i=>(i[i.Left=0]="Left",i[i.Center=1]="Center",i[i.Right=2]="Right",i))(Kc||{});class Jc{constructor(){o(this,"charList",[]),o(this,"quadList",[]),o(this,"width",0),o(this,"index",0)}}class Zc{layout(e){let t=[],r=e.originSize,s=gr.getFontData(e.font,r),a=e.fontSize/r;return this.makeTextLine(e.uiTransform,e.alignment,t,e.font,s,e.text,a,r,e.lineSpacing),t}makeTextLine(e,t,r,s,a,n,l,h,u){let c=-1,f=0,d=h*l,p=d*.5,m=e.width/l,_=e.height/l,v=0,y=e.height,C=()=>{f=0,c++;let D=new Jc;return D.index=c,r.push(D),D},B=(D,P)=>{const L=D.charCodeAt(0).toString();let I=gr.getFnt(s,h,L),O=null;return I?(O=Fi.spawnQuad(),O.sprite=I,O.x=(f+I.xoffset)*l-v,O.y=(a.base-I.height-I.yoffset-a.base)*l+y,O.width=I.offsetSize.width*l,O.height=I.offsetSize.height*l,f+=I.xadvance):D==`
`||(D=="	"?f+=d:f+=p),P.width=f,P.quadList.push(O),P.charList.push(D),O},T=()=>{let D=this.getAlignment(t);switch(D.v){case 0:for(let P=0,L=r.length;P<L;P++){let I=r[P];if(P>0){let O=P*d*u;for(let k=0,H=I.quadList.length;k<H;k++){let W=I.quadList[k];W&&(W.y-=O)}}}break;case 1:for(let P=0,L=r.length;P<L;P++){let I=r[P],O=(_-L*h*u)*.5*l+P*d*u;for(let k=0,H=I.quadList.length;k<H;k++){let W=I.quadList[k];W&&(W.y-=O)}}break;case 2:for(let P=0,L=r.length;P<L;P++){let I=r[P],O=(_-L*h*u)*l+P*d*u;for(let k=0,H=I.quadList.length;k<H;k++){let W=I.quadList[k];W&&(W.y-=O)}}break}switch(D.h){case 0:break;case 1:for(let P=0,L=r.length;P<L;P++){let I=r[P],O=(m-I.width)*.5*l;for(let k=0,H=I.quadList.length;k<H;k++){let W=I.quadList[k];W&&(W.x+=O)}}break;case 2:for(let P=0,L=r.length;P<L;P++){let I=r[P],O=(m-I.width)*l;for(let k=0,H=I.quadList.length;k<H;k++){let W=I.quadList[k];W&&(W.x+=O)}}break}};(()=>{let D=null,P=n.length,L=!1;for(let I=0;I<P;I++){D==null&&(D=C());let O=n.charAt(I);O==`
`||L?(D=null,L=!1):(B(O,D),L=D.width+d>=m)}})(),T()}getAlignment(e){let t={v:0,h:0};switch(e){case 1:t.v=0,t.h=1;break;case 0:t.v=0,t.h=0;break;case 2:t.v=0,t.h=2;break;case 4:t.v=1,t.h=1;break;case 3:t.v=1,t.h=0;break;case 5:t.v=1,t.h=2;break;case 7:t.v=2,t.h=1;break;case 6:t.v=2,t.h=0;break;case 8:t.v=2,t.h=2;break}return t}}class ba extends ln{constructor(){super(...arguments),o(this,"_style",De.NORMAL),o(this,"_interactive",!1)}set interactive(e){this._interactive=e}get interactive(){return this._interactive}set mouseStyle(e){this._style=e}get interactiveVisible(){return this._uiTransform.globalVisible&&this._visible}init(e){super.init(e),this._uiTransform.addUIInteractive(this)}destroy(){this._uiTransform.removeUIInteractive(this),super.destroy()}rayPick(e,t,r,s){return Ft.rayPick(e,r,s,t.space,this._uiTransform,t.transform.worldMatrix)}cloneTo(e){e.getOrAddComponent(ba).copyComponent(this)}copyComponent(e){return super.copyComponent(e),this.enable=e._enable,this.interactive=e._interactive,this.mouseStyle=e._style,this}}var $c=(i=>(i[i.NONE=0]="NONE",i[i.COLOR=1]="COLOR",i[i.SPRITE=2]="SPRITE",i))($c||{});class _n extends ba{constructor(){super(...arguments),o(this,"_spriteMap"),o(this,"_colorMap"),o(this,"_image"),o(this,"_isCreateImage"),o(this,"_transition",2)}init(e){super.init(e),this._interactive=!0,this._spriteMap=new Map,this._colorMap=new Map,this._image=this.object3D.getComponent(Vi),this._isCreateImage=this._image==null,this._image||(this._image=this.object3D.addComponent(Vi)),this.imageType=pr.Sliced}onEnable(){this.mouseStyle=De.NORMAL}onDisable(){this.mouseStyle=De.DISABLE}set transition(e){this._transition!=e&&(this._transition=e,this.validateStyle(this._style,!0))}get transition(){return this._transition}get imageType(){return this._image.imageType}set imageType(e){this._image.imageType=e}setStyleColor(e,t){return this._colorMap.set(e,t),this._style==e&&this.validateStyle(this._style,!0),this}getStyleColor(e){return this._colorMap.get(e)}set mouseStyle(e){super.mouseStyle=e,this.validateStyle(e,!0)}get normalSprite(){return this._spriteMap.get(De.NORMAL)}set normalSprite(e){this._spriteMap.set(De.NORMAL,e),this._style==De.NORMAL&&this.validateStyle(this._style,!0)}get overSprite(){return this._spriteMap.get(De.OVER)}set overSprite(e){this._spriteMap.set(De.OVER,e),this._style==De.OVER&&this.validateStyle(this._style,!0)}set downSprite(e){this._spriteMap.set(De.DOWN,e),this._style==De.DOWN&&this.validateStyle(this._style,!0)}get downSprite(){return this._spriteMap.get(De.DOWN)}set disableSprite(e){this._spriteMap.set(De.DISABLE,e),this._style==De.DISABLE&&this.validateStyle(this._style,!0)}get disableSprite(){return this._spriteMap.get(De.DISABLE)}validateStyle(e,t){if(this._transition&2){let r=this._spriteMap.get(e);this._image.sprite=r}if(this._transition&1){let r=this._colorMap.get(e);r&&(this._image.color=r)}}cloneTo(e){e.getOrAddComponent(_n).copyComponent(this)}copyComponent(e){return super.copyComponent(e),this.imageType=e.imageType,this.transition=e.transition,e._spriteMap.forEach((t,r)=>{t&&this._spriteMap.set(r,t)}),e._colorMap.forEach((t,r)=>{t&&this._colorMap.set(r,t.clone())}),this.mouseStyle=e.mouseStyle,this}destroy(){this._isCreateImage&&this._image&&(this.object3D.removeComponent(Vi),this._image=null),super.destroy()}}class xn extends cs{constructor(){super(),o(this,"_count",0)}init(e){var t;(t=super.init)==null||t.call(this,e),this._count=e?e.count:1;for(let r=0;r<this._count;r++)this.attachQuad(Fi.spawnQuad());this._uiTransform.resize(0,0)}getQuad(e){return this._mainQuads[e]}cloneTo(e){e.addComponent(xn,{count:this._count}).copyComponent(this)}copyComponent(e){super.copyComponent(e);for(let t=0;t<e._count;t++)this.setSprite(t,e.getSprite(t)),this.setColor(t,e.getColor(t)),this.setImageType(t,e.getImageType(t));return this}setSprite(e,t){this._mainQuads[e].sprite=t||A.res.defaultGUISprite,this.setShadowDirty()}getSprite(e){return this._mainQuads[e].sprite}onUIComponentVisible(e){this.applyComponentVisible()}onUITransformVisible(e){this.applyComponentVisible()}applyComponentVisible(){let e=!this._visible||!this._uiTransform.globalVisible;for(let t of this._mainQuads)t.visible=!e;this.setShadowDirty()}getColor(e){return this._mainQuads[e].color}setColor(e,t){this._mainQuads[e].color=t,this.setShadowDirty()}getImageType(e){return this._mainQuads[e].imageType}setImageType(e,t){this._mainQuads[e].imageType=t,this.setShadowDirty()}setSize(e,t,r){this._mainQuads[e].setSize(t,r),this.setShadowDirty()}setXY(e,t,r){this._mainQuads[e].setXY(t,r),this.setShadowDirty()}getXY(e,t){t||(t=new Z);let r=this._mainQuads[e];return t.x=r.x,t.y=r.y,t}}class vn extends cs{constructor(){super(...arguments),o(this,"_shadowQuality",1),o(this,"_shadowOffset"),o(this,"_shadowRadius"),o(this,"_shadowColor"),o(this,"_subShadowColor"),o(this,"needUpdateShadow",!1)}init(e){var t;(t=super.init)==null||t.call(this,e),this._shadowRadius=2,this._shadowQuality=1,this._shadowOffset=new Z(4,-4),this._shadowColor=new z(.1,.1,.1,.8),this._subShadowColor=this._shadowColor.clone(),this.isUIShadow=!0}cloneTo(e){e.getOrAddComponent(vn).copyComponent(this)}copyComponent(e){return super.copyComponent(this),this._shadowColor=e._shadowColor,this._shadowOffset=e._shadowOffset,this._shadowRadius=e._shadowRadius,this._shadowQuality=e.shadowQuality,this}get shadowColor(){return this._shadowColor}set shadowColor(e){this._shadowColor.copyFrom(e),this.needUpdateShadow=!0}set shadowQuality(e){e=K(e,0,4),this._shadowQuality!=e&&(this._shadowQuality=e,this.needUpdateShadow=!0)}get shadowQuality(){return this._shadowQuality}set shadowOffset(e){this._shadowOffset=e,this.needUpdateShadow=!0}get shadowOffset(){return this._shadowOffset||(this._shadowOffset=new Z(4,-4)),this._shadowOffset}set shadowRadius(e){this._shadowRadius!=e&&(this._shadowRadius=e,this.applyShadow())}get shadowRadius(){return this._shadowRadius}onUpdate(e){this.needUpdateShadow&&(this.applyShadow(),this.needUpdateShadow=!1)}applyShadow(){if(this.detachQuads(),this._shadowSource&&this._shadowQuality>0){let e=this._shadowSource.mainQuads;if(e.length>0)for(let t of e)this.createQuadShadow(t)}this._uiTransform.setNeedUpdateUIPanel()}createQuadShadow(e){let t=this._shadowQuality,r=Math.PI*2;this._subShadowColor.copyFrom(this._shadowColor),this._subShadowColor.a=1/Math.max(1,t);for(let s=0;s<t;s++){let a=Fi.spawnQuad(),n=0,l=0;if(s==0)a.color=this._shadowColor;else{let h=r*(s-1)/(t-1);n=Math.sin(h)*this._shadowRadius,l=Math.cos(h)*this._shadowRadius,a.color=this._subShadowColor}a.setXY(n+this._shadowOffset.x+e.x,l+this._shadowOffset.y+e.y),a.setSize(e.width,e.height),a.sprite=e.sprite,a.visible=e.visible,a.imageType=e.imageType,this.attachQuad(a)}}}class yn extends cs{constructor(){super(),o(this,"_font","\u5FAE\u8F6F\u96C5\u9ED1"),o(this,"_fontSize",14),o(this,"_originSize",42),o(this,"_alignment",0),o(this,"_lineSpacing",1),o(this,"_text",""),o(this,"_color",new z(1,1,1,1)),o(this,"textLine",null),o(this,"layoutProxy",new Zc)}cloneTo(e){e.getOrAddComponent(yn).copyComponent(this)}copyComponent(e){return super.copyComponent(e),this._font=e._font,this._fontSize=e._fontSize,this._originSize=e._originSize,this._alignment=e._alignment,this._lineSpacing=e._lineSpacing,this._color.copyFrom(e._color),this.text=e.text,this}get originSize(){return this._originSize}get font(){return this._font}set font(e){this._font=e}get fontSize(){return this._fontSize}set fontSize(e){this._fontSize!=e&&(this._fontSize=e,this.layoutText())}get text(){return this._text}set text(e){this._text!=e&&(e||(e=""),this._text=e,this.layoutText())}layoutText(){this.detachQuads(),this.textLine=this.layoutProxy.layout(this);for(let e=0,t=this.textLine.length;e<t;e++){let r=this.textLine[e];for(let s=0,a=r.quadList.length;s<a;s++){let n=r.quadList[s];n&&this.attachQuad(n)}}this.color=this._color,this._uiTransform.setNeedUpdateUIPanel(),this.onUIComponentVisible(this._visible),this.setShadowDirty()}onUIComponentVisible(e){this.applyComponentVisible()}onUITransformVisible(e){this.applyComponentVisible()}applyComponentVisible(){let e=!this._visible||!this._uiTransform.globalVisible;for(let t of this._mainQuads)t&&(t.visible=!e);this.setShadowDirty()}onTransformResize(){this.layoutText()}get color(){return this._color}set color(e){this._color.copyFrom(e);for(let t of this._mainQuads)t.color=e;this.setShadowDirty()}get alignment(){return this._alignment}set alignment(e){this._alignment!=e&&(this._alignment=e,this.layoutText())}get lineSpacing(){return this._lineSpacing}set lineSpacing(e){this._lineSpacing!=e&&(this._lineSpacing=e,this.layoutText())}}class bp extends Ee{constructor(){super(...arguments),o(this,"_postList")}init(e){this._postList=new Map}start(){}stop(){}onEnable(){this.activePost()}onDisable(){this.unActivePost()}activePost(){let e=this.transform.view3D,t=A.getRenderJob(e);this._postList.forEach(r=>{t.addPost(r)})}unActivePost(){let e=this.transform.view3D,t=A.getRenderJob(e);this._postList.forEach(r=>{t.removePost(r)})}addPost(e){if(this._postList.has(e.prototype))return;let t=new e;return this._postList.set(e.prototype,t),this._enable&&this.activePost(),t}removePost(e){if(!this._postList.has(e.prototype))return;let t=this._postList.get(e.prototype);this._postList.delete(e.prototype);let r=this.transform.view3D;A.getRenderJob(r).removePost(t)}getPost(e){return this._postList.has(e.prototype)?this._postList.get(e.prototype):null}}class ef extends te{constructor(){super(),o(this,"index",0),o(this,"drawCallFrame",-1)}}var un=(i=>(i[i.CastGI=0]="CastGI",i[i.ReceiveGI=1]="ReceiveGI",i[i.CastDepth=2]="CastDepth",i[i.Other=3]="Other",i))(un||{});class cn extends os{constructor(e=0,t=0){super(),N.register("GIProbeShader",yc),this.defaultPass=new We("GIProbeShader","GIProbeShader"),this.defaultPass.setDefine("USE_BRDF",!0),this.defaultPass.setShaderEntry("VertMain","FragMain"),this.defaultPass.setUniformVector4("probeUniform",new j(t,e,0,0));let r=this.defaultPass.shaderState;r.acceptShadow=!1,r.castShadow=!1,r.receiveEnv=!1,r.acceptGI=!1,r.useLight=!1;let s=A.res.getTexture("BRDFLUT");this.brdfLUT=s,this.baseMap=A.res.whiteTexture,this.normalMap=A.res.normalTexture,this.emissiveMap=A.res.blackTexture}debug(){}}o(cn,"count",0);class Sp extends Ee{constructor(){super(...arguments),o(this,"_probes"),o(this,"_volume"),o(this,"_debugMr",[])}init(){A.setting.gi.enable=!0}start(){this._volume=pe.getLightEntries(this.transform.scene3D).irradianceVolume,this.initProbe()}initProbe(){let e=this._volume.setting.probeXCount,t=this._volume.setting.probeYCount,r=this._volume.setting.probeZCount,s=new ls(4,16,16),a=new g;this._probes=[];for(let n=0;n<e;n++)for(let l=0;l<t;l++)for(let h=0;h<r;h++){let u=n+h*e+l*(e*r),c=new ef;c.index=u,c.name=`${n}_${l}_${h}`;let f=c.addComponent(ce);f.material=new cn(un.CastGI,u),f.geometry=s,f.castGI=!1,f.castShadow=!1,this._debugMr.push(f),this.object3D.addChild(c),this._volume.calcPosition(n,l,h,a),c.x=a.x,c.y=a.y,c.z=a.z,this._probes[u]=c,this._debugMr.push(f)}for(let n=0;n<this._probes.length;n++)Q.instance.addGIProbe(this.transform.scene3D,this._probes[n]);this.object3D.transform.enable=!1,this._volume.setting.debug&&this.debug()}debug(){}debugProbeRay(e,t){const r=A.setting.gi.rayNumber;let s=new q(0,-.7071067811865475,.7071067811865475,0);for(let a=0;a<r;a++){let n=e*r+a,l=new g(-t[n*4+0],-t[n*4+1],-t[n*4+2],0);s.transformVector(l,l);let h=t[n*4+3],u=this._probes[e].transform.worldPosition.clone(),c=l.scaleBy(h);c.add(u,c)}}changeProbesVolumeData(){this._volume.setVolumeDataChange()}changeProbesPosition(){this._volume.setVolumeDataChange();let e=this._volume.setting.probeXCount,t=this._volume.setting.probeYCount,r=this._volume.setting.probeZCount,s=new g;for(let a=0;a<e;a++)for(let n=0;n<t;n++)for(let l=0;l<r;l++){let h=a+l*e+n*(e*r),u=this._probes[h];this._volume.calcPosition(a,n,l,s),u.x=s.x,u.y=s.y,u.z=s.z}}onUpdate(){A.setting.gi.maxDistance=A.setting.gi.probeSpace*1.5;let e=this.transform.scene3D.view.camera,t=g.distance(e.transform.worldPosition,e.transform.targetPos)/300;if(this._debugMr&&this._debugMr.length>0)for(let r=0;r<this._debugMr.length;r++){const s=this._debugMr[r].transform;s.scaleX=t,s.scaleY=t,s.scaleZ=t}}}class Ip extends $t{constructor(){super(...arguments),o(this,"_keyRenderGroup"),o(this,"_keyBufferGroup"),o(this,"_keyIdsGroup")}init(e){this._keyRenderGroup=new Map,this._keyBufferGroup=new Map,this._keyIdsGroup=new Map}start(){let e=[];this.object3D.getComponents(ce,e,!0);for(let t=0;t<e.length;t++){const r=e[t];r.transform.updateWorldMatrix(!0),r.enable=!1;let s=r.geometry.instanceID;for(let a=0;a<r.materials.length;a++){const n=r.materials[a];s+=n.instanceID}if(this._keyRenderGroup.has(s))this._keyRenderGroup.get(s).push(r),this._keyIdsGroup.get(s).push(r.transform.worldMatrix.index);else{let a=new ge(e.length);a.visibility=GPUShaderStage.VERTEX,this._keyRenderGroup.set(s,[r]),this._keyBufferGroup.set(s,a),this._keyIdsGroup.set(s,[r.transform.worldMatrix.index])}}this._keyBufferGroup.forEach((t,r)=>{let s=this._keyIdsGroup.get(r),a=this._keyBufferGroup.get(r);a.setInt32Array("matrixIDs",new Int32Array(s)),a.apply()})}stop(){}nodeUpdate(e,t,r,s){this._keyRenderGroup.forEach((a,n)=>{let l=this._keyBufferGroup.get(n),h=a[0];for(let u=0;u<h.materials.length;u++){let f=h.materials[u].getPass(t);if(f)for(let d=0;d<f.length;d++){const p=f[d];p.setDefine("USE_INSTANCEDRAW",!0),p.setStorageBuffer("instanceDrawID",l)}}h.nodeUpdate(e,t,r,s)}),this.preInit=!1}renderPass(e,t,r){this._keyRenderGroup.forEach((s,a)=>{let n=s[0];n.instanceCount=s.length,this.renderItem(e,t,n,r)})}renderItem(e,t,r,s){let a=r.transform._worldMatrix;for(let n=0;n<r.materials.length;n++){let h=r.materials[n].getPass(t);if(!(!h||h.length==0))for(let u=0;u<h.length;u++){if(!h||h.length==0)continue;let c=h[u];w.bindGeometryBuffer(s.encoder,r.geometry);const f=c;f.shaderState.splitTexture&&(s.endRenderPass(),Fe.WriteSplitColorTexture(r.instanceID),s.beginRenderPass(),w.bindCamera(s.encoder,e.camera),w.bindGeometryBuffer(s.encoder,r.geometry)),w.bindPipeline(s.encoder,f);let _=r.geometry.subGeometries[n].lodLevels[r.lodLevel];r.instanceCount>0?w.drawIndexed(s.encoder,_.indexCount,r.instanceCount,_.indexStart,0,0):w.drawIndexed(s.encoder,_.indexCount,1,_.indexStart,0,a.index)}}}}class Ep extends Xe{constructor(){super(),o(this,"radius",2.5),o(this,"height",10),this._shapeType=mr.Capsule}}const la=class extends Xe{constructor(){super(),o(this,"mesh"),o(this,"_pickRet"),this._shapeType=mr.Mesh}rayPick(i,e){if(this.mesh){la.triangle||(la.triangle=new na(new g,new g,new g));let t=this.mesh.getAttribute("position"),r=this.mesh.getAttribute("indices"),s=Xe.helpMatrix;s.copyFrom(e).invert();let a=Xe.helpRay.copy(i);if(a.applyMatrix(s),a.intersectBox(this.mesh.bounds),!a.intersectBox(this.mesh.bounds,Xe.v3_help_0))return null;if(r&&t&&r.data.length>0){let l=t.data;for(let h=0,u=r.data.length/3;h<u;h++){let c=h*3;const f=r.data[c+0]*3,d=r.data[c+1]*3,p=r.data[c+2]*3;let m=la.triangle,_=m.v1.set(l[f+0],l[f+1],l[f+2]),v=m.v2.set(l[d+0],l[d+1],l[d+2]),y=m.v3.set(l[p+0],l[p+1],l[p+2]);m.set(_,v,y);let C=a.intersectTriangle(a.origin,a.direction,m);if(C)return this._pickRet||(this._pickRet={intersectPoint:new g,distance:0}),this._pickRet.intersectPoint=C,this._pickRet.distance=g.distance(a.origin,C),this._pickRet}}}return null}};let tf=la;o(tf,"triangle");class Sa{constructor(e,t){o(this,"center",new g),o(this,"extents"),o(this,"max"),o(this,"min"),o(this,"size"),o(this,"tmpVecA",new g),o(this,"tmpVecB",new g),o(this,"tmpVecC",new g),o(this,"tmpVecD",new g),o(this,"radius",0),o(this,"diffBetweenPoints",new g),o(this,"owner"),o(this,"forward",new g(0,0,1)),o(this,"worldCenter"),o(this,"worldSize"),o(this,"_center",new g),this.center=e||new g(0,0,0),this.radius=t===void 0?.5:t}updateBound(){throw new Error("Method not implemented.")}containsPoint(e){var t=this.tmpVecA.subtract(e,this.center).lengthSquared,r=this.radius;return t<r*r}intersectsRay(e,t){var r=this.tmpVecA.copyFrom(e.origin).subtract(this.center),s=r.dotProduct(this.tmpVecB.copyFrom(e.direction).normalize()),a=r.dotProduct(r)-this.radius*this.radius;if(a>0&&s>0)return null;var n=s*s-a;if(n<0)return!1;var l=Math.abs(-s-Math.sqrt(n));return t&&t.copyFrom(e.direction).scaleBy(l).add(e.origin),!0}intersectsBoundingSphere(e){this.tmpVecA.subtract(e.center,this.center);var t=e.radius+this.radius;return this.tmpVecA.lengthSquared<=t*t}calculateTransform(e){this.update(e)}inFrustum(e,t){return t.containsSphere(e)}clone(){return new Sa(this.center.clone(),this.radius)}update(e){this.owner=e,this._center.add(e.transform.worldMatrix.position,this.center),this.forward=e.transform.forward}merge(e){throw new Error("BoundingSphere merge is not ready!")}setFromCenterAndSize(e,t){this.center.copy(e),this.radius=t}}class Bp extends Xe{constructor(e){super(),o(this,"_pickRet"),o(this,"box"),o(this,"radius",.5),this._shapeType=mr.Sphere,this.radius=e,this.box=new Sa(new g,1)}rayPick(e,t){this.box.setFromCenterAndSize(this.center,this.radius);let s=Xe.helpMatrix;s.copyFrom(t).invert();let a=Xe.helpRay.copy(e);a.applyMatrix(s);let n=a.intersectSphere(a.origin,a.direction,this.box.center,this.box.radius);return n?(this._pickRet||(this._pickRet={intersect:!1,intersectPoint:new g,distance:0}),this._pickRet.intersect=!0,this._pickRet.intersectPoint=n,this._pickRet.distance=g.distance(a.origin,Xe.v3_help_0),this._pickRet):null}}class Tp extends te{constructor(){super(),o(this,"_envMap"),o(this,"skyObject"),o(this,"envMapChange",!0),o(this,"view"),this.transform.scene3D=this,this.skyObject=new te,this.addChild(this.skyObject),this._isScene3D=!0,this.envMap||(this.envMap=A.res.defaultSky)}get envMap(){return this._envMap}set envMap(e){this._envMap!=e&&(this.envMapChange=!0),this._envMap=e,Q.instance.sky&&"map"in Q.instance.sky&&(Q.instance.sky.map=e)}get exposure(){return Q.instance.sky&&"exposure"in Q.instance.sky?Q.instance.sky.exposure:0}set exposure(e){Q.instance.sky&&"exposure"in Q.instance.sky&&(Q.instance.sky.exposure=e,A.setting.sky.skyExposure=e)}get roughness(){if(Q.instance.sky&&"roughness"in Q.instance.sky)return Q.instance.sky.roughness}set roughness(e){Q.instance.sky&&"roughness"in Q.instance.sky&&(Q.instance.sky.roughness=e)}}class rf extends Us{constructor(){super(3,Ms.triangle_list)}}class sf extends Us{constructor(){super(2,Ms.line_list)}}class af extends te{constructor(){super(),o(this,"mLineRender"),o(this,"mFillRender"),this.mLineRender=this.addComponent(sf),this.mFillRender=this.addComponent(rf)}drawAxis(e,t=new g(0,0,0),r=10){this.createCustomShape(e).buildAxis(t,r)}drawLines(e,t,r=z.COLOR_WHITE){this.createCustomShape(e).buildLines(t,r)}drawCurve(e,t,r=10,s=.5,a=z.COLOR_WHITE){var n=[];let l=new g,h=new g;for(let u=0;u<t.length-1;++u){n.push(t[u]);const c=t[Math.max(u-1,0)],f=t[u],d=t[u+1],p=t[Math.min(u+2,t.length-1)];d.subtract(c,l).multiplyScalar(s/3).add(f,l),f.subtract(p,h).multiplyScalar(s/3).add(d,h),n.push(...this.calculateBezierCurve(f,l,h,d,r))}n.push(t[t.length-1]),this.drawLines(e,n,a)}calculateBezierCurve(e,t,r,s,a){var n=new Array(a);for(let l=0;l<a;++l){let h=(l+1)/(a+1),u=1-h,c=e.mul(u*u*u),f=t.mul(3*h*u*u),d=r.mul(3*h*h*u),p=s.mul(h*h*h);n[l]=c.add(f).add(d).add(p)}return n}drawRect(e,t,r,s,a=z.COLOR_WHITE){this.drawLines(e,[t,new g(t.x+r,t.y,t.z),new g(t.x+r,t.y+s,t.z),new g(t.x,t.y+s,t.z),t],a)}drawCircle(e,t,r,s=32,a=g.Y_AXIS,n=z.COLOR_WHITE){this.createCustomShape(e).buildCircle(t,r,s,a,n)}drawSector(e,t,r,s,a,n=16,l=g.Y_AXIS,h=z.COLOR_WHITE){const u=(a-s)*_e;s*=_e;var c=[];c.push(t);for(let m=0;m<=n;++m){m>0&&c.push(c[c.length-1]);var f=u*(m/n)+s,d=r*Math.cos(f),p=r*Math.sin(f);switch(l){case g.X_AXIS:c.push(t.add(new g(0,d,p)));break;case g.Y_AXIS:c.push(t.add(new g(d,0,p)));break;case g.Z_AXIS:c.push(t.add(new g(d,p,0)));break;default:c.push(t.add(new g(d,p,0)));break}}c.push(c[c.length-1]),c.push(t),this.mLineRender.fillShapeData(e,"line",h,c)}drawArcLine(e,t,r,s,a,n=16,l=g.Y_AXIS,h=z.COLOR_WHITE){this.mLineRender.allocGraphics3DShape(e,this.transform._worldMatrix.index).buildArcLine(t,r,s,a,n,l,h)}createCustomShape(e,t=this.transform){return this.mLineRender.allocGraphics3DShape(e,t._worldMatrix.index)}drawBox(e,t,r,s=z.COLOR_WHITE){var a=[];a.push(t),a.push(new g(r.x,t.y,t.z)),a.push(a[a.length-1]),a.push(new g(r.x,r.y,t.z)),a.push(a[a.length-1]),a.push(new g(t.x,r.y,t.z)),a.push(a[a.length-1]),a.push(t),a.push(a[a.length-1]),a.push(new g(t.x,t.y,r.z)),a.push(a[a.length-1]),a.push(new g(r.x,t.y,r.z)),a.push(a[a.length-1]),a.push(new g(r.x,r.y,r.z)),a.push(a[a.length-1]),a.push(new g(t.x,r.y,r.z)),a.push(a[a.length-1]),a.push(new g(t.x,t.y,r.z)),a.push(new g(t.x,r.y,t.z)),a.push(new g(t.x,r.y,r.z)),a.push(new g(r.x,r.y,t.z)),a.push(new g(r.x,r.y,r.z)),a.push(new g(r.x,t.y,t.z)),a.push(new g(r.x,t.y,r.z)),this.mLineRender.fillShapeData(e,"line",s,a)}drawFillRect(e,t,r,s,a=z.COLOR_WHITE){this.mFillRender.fillShapeData(e,"fill",a,[t,new g(t.x+r,t.y,t.z),new g(t.x+r,t.y+s,t.z),new g(t.x+r,t.y+s,t.z),new g(t.x,t.y+s,t.z),t])}drawFillCircle(e,t,r,s=32,a=g.Y_AXIS,n=z.COLOR_WHITE){var l=[];l.push(t);for(let f=0;f<=s;++f){f>=2&&(l.push(t),l.push(l[l.length-2]));var h=2*Math.PI*f/s,u=r*Math.cos(h),c=r*Math.sin(h);switch(a){case g.X_AXIS:l.push(t.add(new g(0,u,c)));break;case g.Y_AXIS:l.push(t.add(new g(u,0,c)));break;case g.Z_AXIS:l.push(t.add(new g(u,c,0)));break;default:l.push(t.add(new g(u,c,0)));break}}this.mFillRender.fillShapeData(e,"fill",n,l)}drawMeshWireframe(e,t,r,s=z.COLOR_WHITE){t&&this.createCustomShape(e,r||this.transform).fillShapeData(t.genWireframe(),s)}drawFillSector(e,t,r,s,a,n=16,l=g.Y_AXIS,h=z.COLOR_WHITE){const u=(a-s)*_e;s*=_e;var c=[];c.push(t);for(let m=0;m<=n;++m){m>=2&&(c.push(t),c.push(c[c.length-2]));var f=u*(m/n)+s,d=r*Math.cos(f),p=r*Math.sin(f);switch(l){case g.X_AXIS:c.push(t.add(new g(0,d,p)));break;case g.Y_AXIS:c.push(t.add(new g(d,0,p)));break;case g.Z_AXIS:c.push(t.add(new g(d,p,0)));break;default:c.push(t.add(new g(d,p,0)));break}}this.mFillRender.fillShapeData(e,"fill",h,c)}drawBoundingBox(e,t,r=z.COLOR_WHITE){this.drawBox(e,t.min,t.max,r)}drawCameraFrustum(e,t=z.COLOR_WHITE){if(e.type==Ie.perspective){let r=Math.tan(e.fov/2*_e),s=r*e.aspect,a=e.transform._worldMatrix,n=a.transformVector(new g(-s,-r,1)),l=a.transformVector(new g(-s,r,1)),h=a.transformVector(new g(s,-r,1)),u=a.transformVector(new g(s,r,1)),c=e.far,f=e.near,d=e.transform.worldPosition,p=new g().copyFrom(n).multiplyScalar(c).add(d),m=new g().copyFrom(l).multiplyScalar(c).add(d),_=new g().copyFrom(h).multiplyScalar(c).add(d),v=new g().copyFrom(u).multiplyScalar(c).add(d),y=new g().copyFrom(n).multiplyScalar(f).add(d),C=new g().copyFrom(l).multiplyScalar(f).add(d),B=new g().copyFrom(h).multiplyScalar(f).add(d),T=new g().copyFrom(u).multiplyScalar(f).add(d),M=this.createCustomShape(`CameraFrustum_${e.object3D.instanceID}`);M.buildLines([C,m],t),M.buildLines([y,p],t),M.buildLines([T,v],t),M.buildLines([B,_],t),M.buildLines([m,v,_,p,m],t),M.buildLines([C,T,B,y,C],t)}else if(e.type==Ie.ortho){e.viewPort,e.viewPort.height;let r=e.transform.worldMatrix,s=r.transformVector(new g(e.viewPort.width*-.5,e.viewPort.height*.5,e.far)),a=r.transformVector(new g(e.viewPort.width*-.5,e.viewPort.height*-.5,e.far)),n=r.transformVector(new g(e.viewPort.width*.5,e.viewPort.height*.5,e.far)),l=r.transformVector(new g(e.viewPort.width*.5,e.viewPort.height*-.5,e.far)),h=r.transformVector(new g(e.viewPort.width*-.5,e.viewPort.height*.5,e.near)),u=r.transformVector(new g(e.viewPort.width*-.5,e.viewPort.height*-.5,e.near)),c=r.transformVector(new g(e.viewPort.width*.5,e.viewPort.height*.5,e.near)),f=r.transformVector(new g(e.viewPort.width*.5,e.viewPort.height*-.5,e.near)),d=this.createCustomShape(`CameraFrustum_${e.object3D.instanceID}`);d.buildLines([h,s],t),d.buildLines([u,a],t),d.buildLines([c,n],t),d.buildLines([f,l],t),d.buildLines([s,n,l,a,s],t),d.buildLines([h,c,f,u,h],t)}}drawObjectBoundingBox(e,t=z.COLOR_WHITE){let r=Zt.genMeshBounds(e);this.drawBox(`Bounds_${e.instanceID}`,r.min,r.max,t)}Clear(e){this.mLineRender.shapes.has(e)?this.mLineRender.removeShape(e):this.mFillRender.shapes.has(e)&&this.mFillRender.removeShape(e)}ClearAll(){this.mLineRender.shapes.clear(),this.mFillRender.shapes.clear()}ChangeColor(e,t){var r;if(this.mLineRender.shapes.has(e))r=this.mLineRender.shapes.get(e);else if(this.mFillRender.shapes.has(e))r=this.mFillRender.shapes.get(e);else return;const s=r.shapeData;for(let a=0;a<s.length;a+=ei.ShapeVertexSize)s[a+4]=t.r,s[a+5]=t.g,s[a+6]=t.b,s[a+7]=t.a}}class of{constructor(){o(this,"_computeShader"),o(this,"_outBuffer")}init(){let e=wt.getGBufferFrame("ColorPassGBuffer");this._computeShader=new be(rc),this._outBuffer=new ir(32),this._computeShader.setStorageBuffer("outBuffer",this._outBuffer),this._computeShader.setSamplerTexture("visibleMap",e.getPositionMap())}compute(e){let t=pe.getCameraGroup(e.camera);this._computeShader.setStorageBuffer("globalUniform",t.uniformGPUBuffer);let r=w.beginCommandEncoder();w.computeCommand(r,[this._computeShader]),w.endCommandEncoder(r),this._outBuffer.readBuffer()}getPickMeshID(){var e=this._outBuffer.outFloat32Array[0]+.1;return Math.floor(e)}getPickWorldPosition(e){e||(e=new g);var t=this._outBuffer.outFloat32Array[4],r=this._outBuffer.outFloat32Array[5],s=this._outBuffer.outFloat32Array[6];return e.set(t,r,s),e}getPickScreenUV(e){e||(e=new Z);var t=this._outBuffer.outFloat32Array[2],r=this._outBuffer.outFloat32Array[3];return e.set(t,r),e}}class nf extends hi{constructor(e){super(),o(this,"ray"),o(this,"isTouching",!1),o(this,"_mouseCode"),o(this,"_pickEvent"),o(this,"_outEvent"),o(this,"_overEvent"),o(this,"_upEvent"),o(this,"_downEvent"),o(this,"_mouseMove"),o(this,"_pickCompute"),o(this,"_lastDownTarget"),o(this,"mouseEnableMap"),o(this,"_view"),o(this,"_lastFocus"),o(this,"_interestList",[]),this._view=e,this.init()}init(){this.ray=new ci,this.mouseEnableMap=new Map,this._pickEvent=new R(R.PICK_CLICK),this._outEvent=new R(R.PICK_OUT),this._overEvent=new R(R.PICK_OVER),this._mouseMove=new R(R.PICK_MOVE),this._upEvent=new R(R.PICK_UP),this._downEvent=new R(R.PICK_DOWN)}start(){A.setting.pick.enable&&(A.inputSystem.addEventListener(R.POINTER_DOWN,this.onTouchStart,this),A.inputSystem.addEventListener(R.POINTER_UP,this.onTouchEnd,this),A.inputSystem.addEventListener(R.POINTER_CLICK,this.onTouchOnce,this),A.inputSystem.addEventListener(R.POINTER_MOVE,this.onTouchMove,this)),A.setting.pick.mode=="pixel"&&(this._pickCompute=new of,this._pickCompute.init())}stop(){A.inputSystem.removeEventListener(R.POINTER_DOWN,this.onTouchStart,this),A.inputSystem.removeEventListener(R.POINTER_UP,this.onTouchEnd,this),A.inputSystem.removeEventListener(R.POINTER_CLICK,this.onTouchOnce,this),A.inputSystem.removeEventListener(R.POINTER_MOVE,this.onTouchMove,this)}onTouchStart(e){this.isTouching=!0,this._mouseCode=e.mouseCode,this.pick(this._view.camera);let t=this.findNearestObj(this._interestList,this._view.camera);this._lastDownTarget=t,t&&(this._downEvent.target=t.object3D,this._downEvent.ctrlKey=e.ctrlKey,this._downEvent.data={pick:t,pickInfo:this.getPickInfo(),mouseCode:this._mouseCode},this.dispatchEvent(this._downEvent),t.object3D.containEventListener(R.PICK_DOWN)&&t.object3D.dispatchEvent(this._downEvent))}onTouchEnd(e){this.isTouching=!1,this._mouseCode=e.mouseCode,this.pick(this._view.camera);let t=this.findNearestObj(this._interestList,this._view.camera);t&&(this._upEvent.target=t.object3D,this._upEvent.ctrlKey=e.ctrlKey,this._upEvent.data={pick:t,pickInfo:this.getPickInfo(),mouseCode:this._mouseCode},this.dispatchEvent(this._upEvent),t.object3D.containEventListener(R.PICK_UP)&&t.object3D.dispatchEvent(this._upEvent))}getPickInfo(){return{worldPos:this._pickCompute.getPickWorldPosition(),screenUv:this._pickCompute.getPickScreenUV(),meshID:this._pickCompute.getPickMeshID()}}onTouchMove(e){this.isTouching=!0,this._mouseCode=e.mouseCode,this.pick(this._view.camera);let t=this.findNearestObj(this._interestList,this._view.camera);t&&(this._mouseMove.target=t.object3D,this._mouseMove.ctrlKey=e.ctrlKey,this._mouseMove.data={pick:t,pickInfo:this.getPickInfo(),mouseCode:this._mouseCode},this.dispatchEvent(this._mouseMove),t.object3D.containEventListener(R.PICK_MOVE)&&t.object3D.dispatchEvent(this._mouseMove)),t!=this._lastFocus&&(this._lastFocus&&this._lastFocus.object3D&&(this._outEvent.target=this._lastFocus.object3D,this._outEvent.data={pick:this._lastFocus,pickInfo:this.getPickInfo(),mouseCode:this._mouseCode},this._outEvent.ctrlKey=e.ctrlKey,this.dispatchEvent(this._outEvent),this._lastFocus.object3D.containEventListener(R.PICK_OUT)&&this._lastFocus.object3D.dispatchEvent(this._outEvent)),t&&(this._overEvent.target=t.object3D,this._overEvent.ctrlKey=e.ctrlKey,this._overEvent.data={pick:t,pickInfo:this.getPickInfo(),mouseCode:this._mouseCode},this.dispatchEvent(this._overEvent),t.object3D.containEventListener(R.PICK_OVER)&&t.object3D.dispatchEvent(this._overEvent))),this._lastFocus=t}onTouchOnce(e){this.isTouching=!0,this._mouseCode=e.mouseCode,this.pick(this._view.camera);let t=this.findNearestObj(this._interestList,this._view.camera);if(t){let r=A.setting.pick.mode=="pixel"?this.getPickInfo():null;this._pickEvent.target=t.object3D,this._pickEvent.ctrlKey=e.ctrlKey,this._pickEvent.data={pick:t,pickInfo:r,mouseCode:this._mouseCode},this.dispatchEvent(this._pickEvent),t===this._lastDownTarget&&t.object3D.containEventListener(R.PICK_CLICK)&&t.object3D.dispatchEvent(this._pickEvent)}this._lastDownTarget=null}findNearestObj(e,t){var r;return e.sort((s,a)=>s.distance>a.distance?1:-1),(r=e[0])==null?void 0:r.collider}pick(e){if(this._interestList.length=0,A.setting.pick.mode=="pixel"){this._pickCompute.compute(this._view);let t=this._pickCompute.getPickMeshID(),r=this.mouseEnableMap.get(t);if(r){let s=this._pickCompute.getPickWorldPosition(),a=g.distance(s,this.ray.origin);this._interestList.push({distance:a,collider:r,intersectPoint:s})}}else if(A.setting.pick.mode=="bound"){this.ray=e.screenPointToRay(A.inputSystem.mouseX,A.inputSystem.mouseY);let t,r=ae.componentsEnablePickerList.get(this._view);if(r)for(const s of r){let a=s[0];a.enable&&(t=a.rayPick(this.ray),t&&(t.collider=a,this._interestList.push(t)))}}}}class Mp extends Lr{constructor(e=0,t=0,r=0,s=0){super(),o(this,"_camera"),o(this,"_scene"),o(this,"_viewPort"),o(this,"_enablePick",!1),o(this,"_enable",!0),o(this,"pickFire"),o(this,"guiPick"),o(this,"canvasList"),o(this,"graphic3D"),this.canvasList=[],this._viewPort=new j(e,t,r,s),this.enablePick=!0,this.graphic3D=new af}get enable(){return this._enable}set enable(e){this._enable=e}get enablePick(){return this._enablePick}set enablePick(e){this._enablePick!=e&&(this.pickFire=new nf(this),this.pickFire.start()),this._enablePick=e}get scene(){return this._scene}set scene(e){this._scene=e,e.view=this,Ve.createBuffer(e),this.graphic3D&&e.addChild(this.graphic3D),e&&this.canvasList.forEach(t=>{t&&e.addChild(t.object3D)})}get camera(){return this._camera}set camera(e){this._camera=e}get viewPort(){return this._viewPort}set viewPort(e){this._viewPort=e}enableUICanvas(e=0){let t=this.canvasList[e];if(!t){let r=new te;r.name="Canvas "+e,t=r.addComponent(Cs),t.index=e,this.canvasList[e]=t}return this.scene.addChild(t.object3D),this.guiPick||(this.guiPick=new Hc,this.guiPick.init(this)),t}disableUICanvas(e=0){let t=this.canvasList[e];t&&t.object3D&&t.object3D.removeFromParent()}}class Dp{constructor(e){o(this,"normal"),o(this,"fixNormal"),o(this,"center"),o(this,"rotateShape"),o(this,"distance",0),o(this,"index"),this.index=e,this.rotateShape=[]}}class Pp extends tt{constructor(){super(...arguments),o(this,"vScale"),o(this,"uNegate"),o(this,"sections")}build(e,t,r,s=1,a=!0){if(r.length<2)throw new Error("path length is not enough");return this.vScale=s,this.uNegate=a,e=e.slice(),t&&e.push(e[0]),this.sections=this.buildSections(e,r),this.buildGeometry(e,this.sections),this.bounds=new Be(g.ZERO.clone(),new g(100,100,100)),this}buildSections(e,t){let r,s,a,n=[],l=t.length;for(let u=0;u<l;u++){let c=new Dp(u);r=t[u],s=t[u+1],c.center=r.clone(),s==null?(c.normal=a.clone(),c.distance=0):(a=s.subtract(r),c.distance=a.length,c.normal=a.normalize()),n.push(c)}n[0].fixNormal=n[0].normal.clone();for(let u=1;u<l;u++){let c=n[u-1],f=n[u];f.fixNormal=f.normal.add(c.normal).normalize()}let h=new V().identity();for(let u=0;u<l;u++){let c=n[u],f,d;if(u==0)f=g.UP,d=e;else{let p=n[u-1];f=p.fixNormal,d=p.rotateShape}V.fromToRotation(f,c.fixNormal,h);for(let p=0,m=e.length;p<m;p++){let _=h.multiplyPoint3(d[p]);c.rotateShape.push(_)}}return n}buildGeometry(e,t){let r=t.length,s=e.length,a=r*s,n=r-1,l=new Float32Array(a*3),h=new Float32Array(a*3),u=new Float32Array(a*2),c=new Uint32Array(n*(s-1)*6),f=s-1,d=0,p=0,m=[0];for(let v=1;v<s;v++)p+=e[v-1].subtract(e[v]).length,m.push(p);for(let v=0;v<r;v++){let y=t[v];for(let C=0;C<s;C++){let B=(v*s+C)*3,T=y.rotateShape[C].add(y.center);l[B]=T.x,l[B+1]=T.y,l[B+2]=T.z,h[B+1]=1;let M=(v*s+C)*2,D=m[C]/p;u[M]=this.uNegate?1-D:D,u[M+1]=d*this.vScale}d+=y.distance}let _=0;for(let v=0;v<n;v++){let y=v*s;for(let C=0;C<f;C++){let B=C,T=C+1,M=B+s,D=T+s;c[_++]=B+y,c[_++]=T+y,c[_++]=M+y,c[_++]=T+y,c[_++]=D+y,c[_++]=M+y}}return this.setIndices(c),this.setAttribute(Y.position,l),this.setAttribute(Y.normal,h),this.setAttribute(Y.uv,u),this.setAttribute(Y.TEXCOORD_1,u),this.addSubGeometry({indexStart:0,indexCount:c.length,vertexStart:0,index:0}),this.computeNormals(),this}}class Rp{constructor(){o(this,"name"),o(this,"offset"),o(this,"size"),o(this,"arrayStride"),o(this,"stepMode"),o(this,"attributes")}}class Lp{constructor(){o(this,"name"),o(this,"format"),o(this,"offset"),o(this,"shaderLocation"),o(this,"stride")}}var lf=(i=>(i[i.position=3]="position",i[i.normal=3]="normal",i[i.TANGENT=4]="TANGENT",i[i.uv=2]="uv",i[i.TEXCOORD_1=2]="TEXCOORD_1",i[i.color=4]="color",i[i.joints0=4]="joints0",i[i.weights0=4]="weights0",i[i.joints1=4]="joints1",i[i.weights1=4]="weights1",i[i.vIndex=1]="vIndex",i[i.weight=1]="weight",i[i.a_morphPositions_0=3]="a_morphPositions_0",i))(lf||{});class Up{constructor(){}}class Op{constructor(){o(this,"entity")}get data(){return null}}class hf{constructor(){o(this,"min",0),o(this,"max",0)}set(e,t){return this.max=t,this.min=e,this}copy(e){return this.max=e.max,this.min=e.min,this}isInterestRange(e){return!(this.max>e.min||e.max<this.min)}}class uf{constructor(){o(this,"_spaceDesc")}getRange(e){return this._spaceDesc[e]}initSpace(e){this._spaceDesc={};for(let t of e)(this._spaceDesc[t]=new hf).set(-Number.MAX_VALUE,Number.MAX_VALUE);return this}isContain(e,t){let r=this._spaceDesc[e];return t>=r.min&&t<r.max}isInterestRange(e,t){let r=this._spaceDesc[e];return r?t.isInterestRange(r):!1}splitSpace(e,t,r){let s=this._spaceDesc[e];return t?s.max=r:s.min=r,this}copySpace(e){for(let t in e._spaceDesc){let r=e._spaceDesc[t];this._spaceDesc[t].copy(r)}return this}}const cf=class{};let yr=cf;o(yr,"MaxEntityCountInLeaf",4),o(yr,"MaxLayer",10),o(yr,"ClearLeafLayer",cf.MaxLayer-4);const ff=class{constructor(){o(this,"uuid","0"),this.uuid=(ff.UUID++).toString()}};let ha=ff;o(ha,"UUID",0);class Np{constructor(){o(this,"map",{}),o(this,"_count",0)}get count(){return this._count}push(e){return this.map[e.uuid]?!1:(this.map[e.uuid]=e,this._count++,!0)}remove(e){return this.map[e]?(delete this.map[e],this._count--,!0):!1}}const ki=class extends ha{constructor(i=0){super(),o(this,"_dimensionIndex",0),o(this,"_dimensions"),o(this,"_dimension"),o(this,"_left"),o(this,"_right"),o(this,"_space"),o(this,"_parent"),o(this,"_entities"),o(this,"layer"),o(this,"_splitEntityList",[]),o(this,"pointIntersect",new g),this.layer=i,ki.nodeCount++}get dimension(){return this._dimension}initNode(i,e,t){return this._dimensions=e,this._dimensionIndex=t,this._dimension=e[t],this._space=new uf().initSpace(e),i&&this._space.copySpace(i._space),this._parent=i,this._entities=new Np,this}updateEntity(i){if(i.isInNode(this,this._dimension)&&(i.attachTreeNode(this),this.autoSplit(),this._left&&this._right)){let e=(this._dimensionIndex+1)%this._dimensions.length,t=this._dimensions[e];i.isInNode(this._right,t)?this._right.updateEntity(i):i.isInNode(this._left,t)&&this._left.updateEntity(i)}}buildRoot(i){for(const e of i)e.entity.attachTreeNode(this);this.autoSplit()}autoSplit(){if(this._entities.count>yr.MaxEntityCountInLeaf&&!this._right&&!this._left&&this.layer<yr.MaxLayer){let i=this._splitEntityList,e=(this._dimensionIndex+1)%this._dimensions.length,t=this._dimensions[e],r=0;for(const s in this._entities.map){let a=this._entities.map[s];r+=a.centerValue(t),i.push(a)}r/=this._entities.count,this._left=new ki(this.layer+1),this._right=new ki(this.layer+1),this._left.initNode(this,this._dimensions,e),this._right.initNode(this,this._dimensions,e),this._left.setSpace(!0,r),this._right.setSpace(!1,r);for(let s of i)s.isInNode(this._right,t)?s.attachTreeNode(this._right):s.isInNode(this._left,t)&&s.attachTreeNode(this._left)}this._left&&this._left.autoSplit(),this._right&&this._right.autoSplit()}setSpace(i,e){return this._parent&&this._space.splitSpace(this._dimension,i,e),this}isEmpty(){return this._left==null&&this._right==null&&this._entities.count==0}pushEntity(i){return this._entities.push(i)}removeEntity(i){return this._entities.remove(i.uuid)}autoClear(){let i=this;for(;i&&i.layer>yr.ClearLeafLayer&&i.clearLeaf();)i=i._parent}clearLeaf(){let i=!this._left&&!this._right,e=!i&&this._left.isEmpty()&&this._right.isEmpty();return e&&(this._left=this._right=null,ki.nodeCount-=2),i||e}isContain(i){return this._space.isContain(this._dimension,i)}nodeIntersectsBox(i){let e=this._space.getRange("x"),t=this._space.getRange("y"),r=this._space.getRange("z"),s=ki.rangeBox;return s.min.set(e.min,t.min,r.min),s.max.set(e.max,t.max,r.max),s.intersectsBox(i)}nodeIntersectsRay(i){let e=this._space.getRange("x"),t=this._space.getRange("y"),r=this._space.getRange("z"),s=ki.rangeBox;return s.min.set(e.min,t.min,r.min),s.max.set(e.max,t.max,r.max),!0}pointCast(i,e=0,t){if(t=t||[],this._entities.count>0){let r=this._entities.map;for(let s in r){let a=r[s],n=a.entityContainPoint(i);!n&&e>0&&(n=a.squareDistanceTo(i,this._dimensions)<=e),n&&t.push(a)}}this._left&&this._left.isContain(i[this._left.dimension])&&this._left.pointCast(i,e,t),this._right&&this._right.isContain(i[this._right.dimension])&&this._right.pointCast(i,e,t)}boxCast(i,e){if(e=e||[],this._entities.count>0){let t=this._entities.map;for(let r in t){let s=t[r];s.entityIntersectsBox(i)&&e.push(s)}}this._left&&this._left.nodeIntersectsBox(i)&&this._left.boxCast(i,e),this._right&&this._right.nodeIntersectsBox(i)&&this._right.boxCast(i,e)}rayCast(i,e,t){e=e||[],t=t||[];let r=this.pointIntersect;if(this._entities.count>0){let s=this._entities.map;for(let a in s){let n=s[a];n.entityIntersectsRay(i,r)&&(t.push(new g().copyFrom(r)),e.push(n))}}this._left&&this._left.nodeIntersectsRay(i)&&this._left.rayCast(i,e,t),this._right&&this._right.nodeIntersectsRay(i)&&this._right.rayCast(i,e,t)}};let fn=ki;o(fn,"nodeCount",0),o(fn,"rangeBox",new Be(new g(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),new g(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE)));class Fp extends ha{constructor(e){super(),o(this,"userData"),o(this,"node"),this.userData=e}centerValue(e){return 0}isInNode(e,t){return!1}entityContainPoint(e){return!1}squareDistanceTo(e,t){return Number.MAX_VALUE}entityIntersectsBox(e){return!1}entityIntersectsRay(e,t){return!1}attachTreeNode(e){return this.node&&this.detachTreeNode(),this.node=e,this.node.pushEntity(this)}detachTreeNode(){let e=this.node.removeEntity(this);return this.node=null,e}updateNode(e){let t=this.node;t&&this.detachTreeNode(),e.updateEntity(this),t&&t.autoClear()}}class df extends je{}o(df,"RESIZE","resize");var gf=(i=>(i[i.MOUSE_LEFT=0]="MOUSE_LEFT",i[i.MOUSE_MID=1]="MOUSE_MID",i[i.MOUSE_RIGHT=2]="MOUSE_RIGHT",i))(gf||{});class dn extends je{}o(dn,"LOADER_PROGRESS","loaderProgress"),o(dn,"LOADER_COMPLETE","loaderComplete");class fs extends je{}o(fs,"ADDED","added"),o(fs,"REMOVED","removed"),o(fs,"CHILD_ADD_EVENT","childAddEvent"),o(fs,"CHILD_REMOVED","childRemoved");class ua extends je{}o(ua,"SHOW","show"),o(ua,"HIDE","hide"),o(ua,"UPDATE","update");class kp{static merge(e,t,r,s){let a=0,n=0;a=Math.max(e.width,a),a=Math.max(t.width,a),a=Math.max(r.width,a),a=Math.max(s.width,a),n=Math.max(e.height,n),n=Math.max(t.height,n),n=Math.max(r.height,n),n=Math.max(s.height,n);let l=new oe(a,n,G.rgba8unorm),h=new be($u);h.setSamplerTexture("textureR",e),h.setSamplerTexture("textureG",t),h.setSamplerTexture("textureB",r),h.setSamplerTexture("textureA",s),h.setStorageTexture("outTex",l),h.workerSizeX=Math.ceil(a/8),h.workerSizeY=Math.ceil(n/8);let u=w.beginCommandEncoder();return w.computeCommand(u,[h]),w.endCommandEncoder(u),l}}class zp extends Jt{constructor(e,t,r=0){super(),this.bufferType=Mt.StructStorageGPUBuffer,this.createBufferByStruct(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|r,e,t)}}class ds{static createMipmap(e,t){const r=S.device;this._pipelineMax||(this._pipelineMax=r.createComputePipeline({layout:"auto",compute:{module:r.createShaderModule({code:this.codeMax}),entryPoint:"main"}})),this._pipelineMin||(this._pipelineMin=r.createComputePipeline({layout:"auto",compute:{module:r.createShaderModule({code:this.codeMin}),entryPoint:"main"}}));let s=Math.ceil(e.width*.5),a=Math.ceil(e.height*.5),n={mipmapCount:t,texture:e,srcView:null,mipLevel:1,dstHeight:a,dstWidth:s};n.srcView=e.getGPUTexture().createView({format:e.format,dimension:"2d",baseMipLevel:0,mipLevelCount:1}),e.width>1024&&e.height>1024?this.mipmap(this._pipelineMax,n):this.mipmap(this._pipelineMin,n)}static mipmap(e,t){const r=S.device,s=w.beginCommandEncoder();let a=e==this._pipelineMax,n,l;for(let h=t.mipLevel;h<t.mipmapCount;h++){let u=[],c=0;u.push({binding:c++,resource:t.srcView}),u.push({binding:c++,resource:t.texture.gpuSampler}),n=t.texture.getGPUTexture().createView({format:t.texture.format,dimension:"2d",baseMipLevel:h,mipLevelCount:1}),u.push({binding:c++,resource:n});const f=r.createBindGroup({layout:e.getBindGroupLayout(0),entries:u}),d=s.beginComputePass();d.setPipeline(e),d.setBindGroup(0,f);let p=t.dstWidth,m=t.dstHeight;if(a&&(p=Math.max(1,Math.floor(t.dstWidth/8)),m=Math.max(1,Math.floor(t.dstHeight/8))),d.dispatchWorkgroups(p,m),t.dstHeight*=.5,t.dstWidth*=.5,t.srcView=n,t.mipLevel=h+1,l=a&&(t.dstWidth<8||t.dstHeight<8),d.end(),l)break}w.endCommandEncoder(s),l&&this.mipmap(this._pipelineMin,t)}}o(ds,"codeMax",`
        @group(0) @binding(0) var inputTexture : texture_2d<f32>;
        @group(0) @binding(1) var inputTextureSampler : sampler;
        @group(0) @binding(2) var outputTexture : texture_storage_2d<rgba8unorm, write>;
        
        @compute @workgroup_size(8, 8)
        fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {
            let dstSize = textureDimensions(outputTexture).xy;
            let uv01 = vec2<f32>(f32(GlobalInvocationID.x) / f32(dstSize.x - 1), f32(GlobalInvocationID.y) / f32(dstSize.y - 1));
            var fromColor = textureSampleLevel(inputTexture, inputTextureSampler, uv01, 0.0);
            let dstCoord = vec2<i32>(i32(GlobalInvocationID.x), i32(GlobalInvocationID.y));
            
            //fromColor = vec4<f32>(0.0, 0.0, 0.0, 1.0);
            //if(dstSize.x == 512){
            //    fromColor.x = 1.0;
            //}else  if(dstSize.x == 256){
            //    fromColor.y = 1.0;
            //}else if(dstSize.x == 128){
            //    fromColor.z = 1.0;
            //}
            
            textureStore(outputTexture, dstCoord, fromColor);
        }
    `),o(ds,"codeMin",`
        @group(0) @binding(0) var inputTexture : texture_2d<f32>;
        @group(0) @binding(1) var inputTextureSampler : sampler;
        @group(0) @binding(2) var outputTexture : texture_storage_2d<rgba8unorm, write>;
        
        @compute @workgroup_size(1, 1)
        fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {
            let dstSize = textureDimensions(outputTexture).xy;
            let uv01 = vec2<f32>(f32(GlobalInvocationID.x) / f32(dstSize.x - 1), f32(GlobalInvocationID.y) / f32(dstSize.y - 1));
            var fromColor = textureSampleLevel(inputTexture, inputTextureSampler, uv01, 0.0);
            let dstCoord = vec2<i32>(i32(GlobalInvocationID.x), i32(GlobalInvocationID.y));
            
            textureStore(outputTexture, dstCoord, fromColor);
        }
    `),o(ds,"_pipelineMax"),o(ds,"_pipelineMin");class pf{constructor(){o(this,"name",""),o(this,"passMap",new Map)}}class mf{constructor(){o(this,"passType",""),o(this,"shaderState",new Map),o(this,"vertexShader",""),o(this,"fragmentShader","")}}class Cr{static parser(e,t){e=ut.filterComment(e);let r=new pf,s=e.indexOf(this.shaderKeyword),a=e.indexOf("{",s),n=e.substring(s+this.shaderKeyword.length,a).trim();r.name=n.substring(1,n.length-1),n=e.substring(e.indexOf("{")+1,e.lastIndexOf("}"));let l=this.splitPassBlock(n);for(let h of l){let u=this.parserPassBlock(h),c;r.passMap.has(u.passType)?c=r.passMap.get(u.passType):(c=[],r.passMap.set(u.passType,c)),c.push(u),u.vertexShader.length>0&&(u.vertexShader=ut.parse(u.vertexShader,t)),u.fragmentShader.length>0&&(u.fragmentShader=ut.parse(u.fragmentShader,t))}return r}static splitPassBlock(e){let t=0,r=[];for(;t<e.length;){let s=e.indexOf(this.passKeyword,t);if(s==-1){r.push(e.substring(t));break}t!=0&&r.push(e.substring(t,s)),t=s+this.passKeyword.length}return r}static parserPassBlock(e){let t=new mf,r=e.indexOf(this.passTypeKeyword),s=e.indexOf('"',r);return r=e.indexOf('"',s+1),t.passType=e.substring(r+1,s).trim(),this.parserShaderState(t,e),r=e.indexOf(this.vertexKeyword),r!=-1&&(t.vertexShader=this.extractBlock(e.substring(r+this.vertexKeyword.length),"{","}")),r=e.indexOf(this.fragmentKeyword),r!=-1&&(t.fragmentShader=this.extractBlock(e.substring(r+this.fragmentKeyword.length),"{","}")),t}static parserShaderState(e,t){let r=t.indexOf("ShaderState");if(r==-1)return!1;r=t.indexOf("{",r);let s=t.indexOf("}",r),n=t.substring(r+1,s).split(",");for(let l of n){let h=l.split(":"),u=h[0].trim(),c=this.convertValue(h[1].trim());e.shaderState.set(u,c)}return!0}static convertValue(e){return e.length==4&&e.toLowerCase()=="true"?!0:e.length==5&&e.toLowerCase()=="false"?!1:e[0]=='"'?e.substring(1,e.length-1):Number.parseInt(e)}static extractBlock(e,t,r){let s=e.indexOf(t);if(s==-1)return"";let a=0,n=0;e=e.substring(s);for(let h of e){if(h==t?a++:h==r&&a--,a<=0)break;n++}return e.substring(1,n).trim()}}o(Cr,"passKeyword","pass"),o(Cr,"shaderKeyword","Shader"),o(Cr,"vertexKeyword","vertex"),o(Cr,"fragmentKeyword","fragment"),o(Cr,"passTypeKeyword","PassType");let Af=new je("IrradianceDataReaderCompleteEvent");class Es extends hi{constructor(){super(...arguments),o(this,"readFlag",!1),o(this,"probeRenderer"),o(this,"opColorBuffer"),o(this,"opDepthBuffer"),o(this,"srcColorMap"),o(this,"srcDepthMap"),o(this,"opDepthArray"),o(this,"opColorArray")}initReader(e,t,r){this.probeRenderer=e,this.srcColorMap=t,this.srcDepthMap=r;let s=A.setting.gi,a=s.octRTMaxSize*s.octRTMaxSize;this.opColorBuffer=S.device.createBuffer({size:a*4*4,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ,mappedAtCreation:!1}),this.opColorArray=new Float32Array(a*4),this.opDepthBuffer=S.device.createBuffer({size:a*4*4,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ,mappedAtCreation:!1}),this.opDepthArray=new Float32Array(a*4),this.probeRenderer.addEventListener(Co.type,()=>{this.onProbeRenderComplete()},this),this.probeRenderer.addEventListener(Hs.type,()=>{console.log("GIRenderStartEvent")},this)}async onProbeRenderComplete(){if(console.log("GIRenderCompleteEvent"),this.readFlag)console.log("irradianceDataReader is reading yet!!!");else{this.readFlag=!0;let e=Date.now();console.log("irradianceDataReader start reading "),await Es.read(this.srcColorMap.getGPUTexture(),this.opColorBuffer,this.opColorArray),await Es.read(this.srcDepthMap.getGPUTexture(),this.opDepthBuffer,this.opDepthArray),this.readFlag=!1,console.log("process time :",Date.now()-e),console.log("irradianceDataReader read complete"),this.dispatchEvent(Af)}}static async read(e,t,r){let s=w.beginCommandEncoder();s.copyTextureToBuffer({texture:e},{buffer:t,bytesPerRow:e.width*16},[e.width,e.height]),w.endCommandEncoder(s),await t.mapAsync(GPUMapMode.READ);const a=t.getMappedRange();r.set(new Float32Array(a),0),t.unmap()}}let Gp=new Es;class Qp{constructor(){o(this,"computeShader"),o(this,"visibleBuffer"),o(this,"texture"),this.computeShader=new be(pc),this.visibleBuffer=new ir(8192*2),this.computeShader.setStorageBuffer("visibleBuffer",this.visibleBuffer),this.texture=Fe.getTexture(Ae.zBufferTexture_NAME),this.computeShader.setSamplerTexture("zBufferTexture",this.texture),this.computeShader.workerSizeX=Math.ceil(this.texture.width/8),this.computeShader.workerSizeY=Math.ceil(this.texture.height/8),this.computeShader.workerSizeZ=1}compute(e,t){this.visibleBuffer.reset(!0,0),this.visibleBuffer.apply();let r=w.beginCommandEncoder();w.computeCommand(r,[this.computeShader]),this.visibleBuffer.readBuffer(),t.zVisibleList=this.visibleBuffer.outFloat32Array}}class Vp extends Ct{constructor(){super(),o(this,"blurTexture1"),o(this,"blurTexture2"),o(this,"rendererPassState"),o(this,"blurComputes"),o(this,"blurSettings"),o(this,"outTexture"),o(this,"rtFrame")}onAttach(e){A.setting.render.postProcessing.depthOfView.enable=!0}onDetach(e){A.setting.render.postProcessing.depthOfView.enable=!1}createGUI(){}get pixelOffset(){return A.setting.render.postProcessing.depthOfView.pixelOffset}set pixelOffset(e){e=Math.max(0,e);let t=A.setting.render.postProcessing.depthOfView;t.pixelOffset=e}get near(){return A.setting.render.postProcessing.depthOfView.near}set near(e){e=Math.max(0,e);let t=A.setting.render.postProcessing.depthOfView;t.near=e}get far(){return A.setting.render.postProcessing.depthOfView.far}set far(e){e=Math.max(0,e);let t=A.setting.render.postProcessing.depthOfView;t.far=e}createBlurCompute(){this.blurSettings=[],this.blurComputes=[];let e=A.setting.render.postProcessing.depthOfView;for(let t=0;t<e.iterationCount;t++){let r=new Dt(4),s=new be(Ku);this.blurComputes.push(s),this.blurSettings.push(r),s.setUniformBuffer("blurSetting",r);let a=wt.getGBufferFrame("ColorPassGBuffer");s.setSamplerTexture(Ae.positionBufferTex_NAME,a.attachments[1]),s.setSamplerTexture(Ae.normalBufferTex_NAME,a.attachments[2]);let n=t%2==0?this.blurTexture1:this.blurTexture2,l=t%2==1?this.blurTexture1:this.blurTexture2;s.setSamplerTexture("inTex",n),s.setStorageTexture("outTex",l),s.workerSizeX=Math.ceil(this.blurTexture1.width/8),s.workerSizeY=Math.ceil(this.blurTexture1.height/8),s.workerSizeZ=1,this.outTexture=l}}createResource(){let e=S.presentationSize,t=e[0],r=e[1];this.blurTexture1=new oe(t,r,G.rgba16float,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC|GPUTextureUsage.TEXTURE_BINDING),this.blurTexture1.name="dof1";let s=new Ce;s.clearValue=[0,0,0,1],s.loadOp="clear",this.blurTexture2=new oe(t,r,G.rgba16float,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC|GPUTextureUsage.TEXTURE_BINDING),this.blurTexture2.name="dof2";let a=new Ce;a.clearValue=[0,0,0,1],a.loadOp="clear",this.rtFrame=new Ze([this.blurTexture1,this.blurTexture2],[s,a])}render(e,t){if(!this.blurComputes){this.createResource(),this.createBlurCompute(),this.createGUI();let s=pe.getCameraGroup(e.camera);for(let a=0;a<this.blurComputes.length;a++)this.blurComputes[a].setUniformBuffer("standUniform",s.uniformGPUBuffer);this.rendererPassState=He.createRendererPassState(this.rtFrame,null)}this.autoSetColorTexture("inTex",this.blurComputes[0]);let r=A.setting.render.postProcessing.depthOfView;r.far=Math.max(r.near,r.far)+1e-4;for(let s=0;s<r.iterationCount;s++){let a=this.blurComputes[s],n=this.blurSettings[s];n.setFloat("near",r.near),n.setFloat("far",r.far),n.setFloat("pixelOffset",(s+1)*r.pixelOffset),n.apply(),a.setStorageBuffer("blurSetting",n)}w.computeCommand(t,this.blurComputes),w.lastRenderPassState=this.rendererPassState}}class Hp extends Ct{constructor(){super(),o(this,"gtaoTexture"),o(this,"rendererPassState"),o(this,"gtaoCompute"),o(this,"gtaoSetting"),o(this,"aoBuffer"),o(this,"directionsBuffer"),o(this,"directionsArray"),o(this,"rtFrame"),o(this,"Render"),o(this,"randomCount",0)}onAttach(e){A.setting.render.postProcessing.gtao.enable=!0,this.createGUI()}onDetach(e){A.setting.render.postProcessing.gtao.enable=!1,this.removeGUI()}get maxDistance(){return A.setting.render.postProcessing.gtao.maxDistance}set maxDistance(e){e=K(e,.1,50);let t=A.setting.render.postProcessing.gtao;t.maxDistance=e}get maxPixel(){return A.setting.render.postProcessing.gtao.maxPixel}set maxPixel(e){e=K(e,5,100);let t=A.setting.render.postProcessing.gtao;t.maxPixel=e}get darkFactor(){return A.setting.render.postProcessing.gtao.darkFactor}set darkFactor(e){e=K(e,.01,1);let t=A.setting.render.postProcessing.gtao;t.darkFactor=e}get rayMarchSegment(){return A.setting.render.postProcessing.gtao.rayMarchSegment}set rayMarchSegment(e){e=K(e,4,10);let t=A.setting.render.postProcessing.gtao;t.rayMarchSegment=e}get multiBounce(){return A.setting.render.postProcessing.gtao.multiBounce}set multiBounce(e){let t=A.setting.render.postProcessing.gtao;t.multiBounce=e}get blendColor(){return A.setting.render.postProcessing.gtao.blendColor}set blendColor(e){let t=A.setting.render.postProcessing.gtao;t.blendColor=e}get usePosFloat32(){return A.setting.render.postProcessing.gtao.usePosFloat32}set usePosFloat32(e){let t=A.setting.render.postProcessing.gtao;t.usePosFloat32=e}createGUI(){}removeGUI(){}createCompute(){A.setting.render.postProcessing.gtao,this.gtaoCompute=new be(Ju);let e=new Dt(4*2);this.gtaoCompute.setUniformBuffer("gtaoData",e),this.directionsArray=new Float32Array(8*2),this.directionsBuffer=new ge(8*2),this.directionsBuffer.setFloat32Array("array",this.randomDirection()),this.directionsBuffer.apply(),this.gtaoCompute.setStorageBuffer("directions",this.directionsBuffer),this.aoBuffer=new ge(this.gtaoTexture.width*this.gtaoTexture.height),this.gtaoCompute.setStorageBuffer("aoBuffer",this.aoBuffer);let t=wt.getGBufferFrame("ColorPassGBuffer"),r=t.attachments[1];this.gtaoCompute.setSamplerTexture("posTex",r),this.gtaoCompute.setSamplerTexture("normalTex",t.attachments[2]),this.autoSetColorTexture("inTex",this.gtaoCompute),this.gtaoCompute.setStorageTexture("outTex",this.gtaoTexture),this.gtaoCompute.workerSizeX=Math.ceil(this.gtaoTexture.width/8),this.gtaoCompute.workerSizeY=Math.ceil(this.gtaoTexture.height/8),this.gtaoCompute.workerSizeZ=1,this.gtaoSetting=e}createResource(){let e=S.presentationSize,t=e[0],r=e[1];this.gtaoTexture=new oe(t,r,G.rgba16float,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC|GPUTextureUsage.TEXTURE_BINDING),this.gtaoTexture.name="gtaoTex";let s=new Ce;s.loadOp="load",this.rtFrame=new Ze([this.gtaoTexture],[s])}randomDirection(){this.randomCount++,this.randomCount>1&&(this.randomCount=0);let e=Math.PI*2*this.randomCount/16,t=Math.PI*2/8;for(let r=0;r<8;r++){let s=e+r*t;this.directionsArray[r*2]=Math.sin(s),this.directionsArray[r*2+1]=Math.cos(s)}return this.directionsArray}render(e,t){if(!this.gtaoCompute){this.createResource(),this.createCompute(),this.rendererPassState=He.createRendererPassState(this.rtFrame,null),this.rendererPassState.label="GTAO";let h=pe.getCameraGroup(e.camera);this.gtaoCompute.setUniformBuffer("globalUniform",h.uniformGPUBuffer)}let r=A.setting.render.postProcessing.gtao;this.directionsBuffer.setFloat32Array("array",this.randomDirection()),this.directionsBuffer.apply();let s=1-.2*(he.frame%2),a=r.maxDistance*s,n=r.maxPixel*s;this.gtaoSetting.setFloat("maxDistance",a),this.gtaoSetting.setFloat("maxPixel",n),this.gtaoSetting.setFloat("darkFactor",r.darkFactor),this.gtaoSetting.setFloat("rayMarchSegment",r.rayMarchSegment);let l=e.camera;this.gtaoSetting.setFloat("cameraNear",l.near),this.gtaoSetting.setFloat("cameraFar",l.far),this.gtaoSetting.setFloat("multiBounce",r.multiBounce?1:0),this.gtaoSetting.setFloat("blendColor",r.blendColor?1:0),this.gtaoSetting.apply(),w.computeCommand(t,[this.gtaoCompute]),w.lastRenderPassState=this.rendererPassState}}class Yp extends Ct{constructor(){super(),o(this,"viewQuad"),o(this,"rtTexture"),o(this,"_globalFog"),o(this,"_lastSkyTexture");let e=this._globalFog=A.setting.render.postProcessing.globalFog,t=wt.getGBufferFrame("ColorPassGBuffer"),r=S.presentationSize;N.register("GlobalFog_shader",Ec);let s={fogColor:new $(new z(e.fogColor.r,e.fogColor.g,e.fogColor.b,e.fogColor.a)),fogType:new $(e.fogType),fogHeightScale:new $(e.fogHeightScale),start:new $(e.start),end:new $(e.end),density:new $(e.density),ins:new $(e.ins),falloff:new $(e.falloff),rayLength:new $(e.rayLength),scatteringExponent:new $(e.scatteringExponent),dirHeightLine:new $(e.dirHeightLine),skyFactor:new $(e.skyFactor),skyRoughness:new $(e.skyRoughness),overrideSkyFactor:new $(e.overrideSkyFactor),isSkyHDR:new $(0)};this.rtTexture=this.createRTTexture("GlobalFog",r[0],r[1],G.rgba16float),this.viewQuad=this.createViewQuad("GlobalFog","GlobalFog_shader",this.rtTexture,s);let a=t.getPositionMap(),n=t.getNormalMap();this.setInputTexture(a,n)}onAttach(e){A.setting.render.postProcessing.globalFog.enable=!0}onDetach(e){A.setting.render.postProcessing.globalFog.enable=!1}set fogType(e){this._globalFog.fogType=e,this.viewQuad.uniforms.fogType.value=e}get fogType(){return this._globalFog.fogType}set fogHeightScale(e){this._globalFog.fogHeightScale=e,this.viewQuad.uniforms.fogHeightScale.value=e}get fogHeightScale(){return this.viewQuad.uniforms.fogHeightScale.value}set start(e){this._globalFog.start=e,this.viewQuad.uniforms.start.value=e}get start(){return this.viewQuad.uniforms.start.value}set end(e){this._globalFog.end=e,this.viewQuad.uniforms.end.value=e}get end(){return this.viewQuad.uniforms.end.value}set ins(e){this._globalFog.ins=e,this.viewQuad.uniforms.ins.value=e}get ins(){return this.viewQuad.uniforms.ins.value}set density(e){this._globalFog.density=e,this.viewQuad.uniforms.density.value=e}get density(){return this.viewQuad.uniforms.density.value}set skyRoughness(e){this._globalFog.skyRoughness=e,this.viewQuad.uniforms.skyRoughness.value=e}get skyRoughness(){return this._globalFog.skyRoughness}set skyFactor(e){this._globalFog.skyFactor=e,this.viewQuad.uniforms.skyFactor.value=e}get skyFactor(){return this._globalFog.skyFactor}set overrideSkyFactor(e){this._globalFog.overrideSkyFactor=e,this.viewQuad.uniforms.overrideSkyFactor.value=e}get overrideSkyFactor(){return this._globalFog.overrideSkyFactor}get fogColor(){return this._globalFog.fogColor}set fogColor(e){this._globalFog.fogColor.copyFrom(e),this.viewQuad.uniforms.fogColor.color=e,this.viewQuad.uniforms.fogColor.onChange()}set falloff(e){this._globalFog.falloff=e,this.viewQuad.uniforms.falloff.value=e}get falloff(){return this.viewQuad.uniforms.falloff.value}set rayLength(e){this._globalFog.rayLength=e,this.viewQuad.uniforms.rayLength.value=e}get rayLength(){return this._globalFog.rayLength}set scatteringExponent(e){this._globalFog.scatteringExponent=e,this.viewQuad.uniforms.scatteringExponent.value=e}get scatteringExponent(){return this._globalFog.scatteringExponent}set dirHeightLine(e){this._globalFog.dirHeightLine=e,this.viewQuad.uniforms.dirHeightLine.value=e}get dirHeightLine(){return this._globalFog.dirHeightLine}setInputTexture(e,t){const r=this.viewQuad.pass;r.setTexture("positionMap",e),r.setTexture("normalMap",t),this._lastSkyTexture=this.getSkyTexture(),r.setTexture("prefilterMap",this._lastSkyTexture)}getSkyTexture(){let e=A.res.defaultSky;return Q.instance.sky instanceof sa&&(e=Q.instance.sky.map),e}render(e,t){const r=this.viewQuad.pass;let s=this.getSkyTexture();s!=this._lastSkyTexture&&(this._lastSkyTexture=s,r.setTexture("prefilterMap",this._lastSkyTexture)),r.setTexture("colorMap",this.getOutTexture()),r.setUniformFloat("isSkyHDR",s.isHDRTexture?1:0),this.viewQuad.renderTarget(e,this.viewQuad,t)}}class Xp extends Ct{constructor(){super(),o(this,"godRayTexture"),o(this,"rendererPassState"),o(this,"godRayCompute"),o(this,"historyGodRayData"),o(this,"godRaySetting"),o(this,"rtFrame"),o(this,"Render"),o(this,"blendColor",!0),o(this,"rayMarchCount",16),o(this,"scatteringExponent",5),o(this,"intensity",.5)}onAttach(e){this.createGUI()}onDetach(e){this.removeGUI()}createGUI(){}removeGUI(){}createCompute(e){A.setting.render.postProcessing.gtao,this.godRayCompute=new be(Zu);let t=new Dt(4*3);this.godRayCompute.setUniformBuffer("godRayUniform",t),this.historyGodRayData=new ge(4*this.godRayTexture.width*this.godRayTexture.height),this.godRayCompute.setStorageBuffer("historyGodRayData",this.historyGodRayData);let r=wt.getGBufferFrame("ColorPassGBuffer");this.godRayCompute.setSamplerTexture("posTex",r.attachments[1]),this.godRayCompute.setSamplerTexture("normalTex",r.attachments[2]),this.autoSetColorTexture("inTex",this.godRayCompute),this.godRayCompute.setStorageTexture("outTex",this.godRayTexture);let s=A.getRenderJob(e).shadowMapPassRenderer;this.godRayCompute.setSamplerTexture("shadowMap",s.depth2DArrayTexture),this.godRayCompute.workerSizeX=Math.ceil(this.godRayTexture.width/8),this.godRayCompute.workerSizeY=Math.ceil(this.godRayTexture.height/8),this.godRayCompute.workerSizeZ=1,this.godRaySetting=t}createResource(){let e=S.presentationSize,t=e[0],r=e[1];this.godRayTexture=new oe(t,r,G.rgba16float,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC|GPUTextureUsage.TEXTURE_BINDING),this.godRayTexture.name="godRayTexture";let s=new Ce;s.loadOp="load",this.rtFrame=new Ze([this.godRayTexture],[s])}render(e,t){if(!this.godRayCompute){this.createResource(),this.createCompute(e);let s=pe.getLightEntries(e.scene);this.godRayCompute.setStorageBuffer("lightBuffer",s.storageGPUBuffer),this.godRayCompute.setStorageBuffer("models",pe.modelMatrixBindGroup.matrixBufferDst),this.rendererPassState=He.createRendererPassState(this.rtFrame,null),this.rendererPassState.label="GodRay";let a=pe.getCameraGroup(e.camera);this.godRayCompute.setUniformBuffer("globalUniform",a.uniformGPUBuffer),bt.addFolder("GodRay"),bt.add(this,"blendColor",0,1,.1),bt.add(this,"scatteringExponent",1,10,.1),bt.add(this,"rayMarchCount",10,30,1),bt.add(this,"intensity",.01,2,.01),bt.endFolder()}this.godRaySetting.setFloat("intensity",this.intensity),this.godRaySetting.setFloat("rayMarchCount",this.rayMarchCount);let r=e.camera;this.godRaySetting.setFloat("viewPortWidth",r.viewPort.width),this.godRaySetting.setFloat("viewPortHeight",r.viewPort.height),this.godRaySetting.setFloat("blendColor",this.blendColor?1:0),this.godRaySetting.setFloat("scatteringExponent",this.scatteringExponent),this.godRaySetting.apply(),w.computeCommand(t,[this.godRayCompute]),w.lastRenderPassState=this.rendererPassState}}class Wp extends Ct{constructor(){super(),o(this,"brightnessView"),o(this,"compositeView"),o(this,"blurList"),o(this,"blurX",1),o(this,"blurY",1);const e=A.setting.render.postProcessing.bloom;e.enable=!0;let t=S.presentationSize,r=this.createRTTexture("HDRBloomPost-outTextures",t[0],t[1],G.rgba16float,!1);Fe.createRTTexture(Ae.colorBufferTex_NAME,t[0],t[1],G.rgba16float,!1);{let l=this.createRTTexture("brightnessTextures",t[0],t[1],G.rgba16float,!1);this.brightnessView=this.createViewQuad("brightnessView","Bloom_Brightness_frag_wgsl",l,{luminosityThreshold:new $(e.luminosityThreshold)})}let s=5,a=t[0],n=t[1];this.blurList=[];for(let l=0;l<s;l++){let h=this.createRTTexture(`tex_l${l}`,a,n,G.rgba16float),u=this.createRTTexture(`tex_r${l}`,a,n,G.rgba16float),c=this.createViewQuad(`ql${l}`,"Bloom_blur_frag_wgsl",h,{texSize:new $(new Z(a*2,n*2)),hScale:new $(l),vScale:new $(l),horizontal:new $(.5)}),f=this.createViewQuad(`qr${l}`,"Bloom_blur_frag_wgsl",u,{texSize:new $(new Z(a*2,n*2)),hScale:new $(l),vScale:new $(l),horizontal:new $(1)});this.blurList.push({ql:c,qr:f}),a/=2,n/=2}this.compositeView=this.createViewQuad("compositeView","Bloom_composite_frag_wgsl",r,{tintColor:new $(new z(1,1,1)),bloomStrength:new $(e.strength),exposure:new $(e.exposure),bloomRadius:new $(1)}),this.blurX=e.blurX,this.blurY=e.blurY,this.luminosityThreshold=e.luminosityThreshold,this.strength=e.strength,this.radius=e.radius}onAttach(e){this.debug()}onDetach(e){}debug(){}get tintColor(){return this.compositeView.uniforms.tintColor.color}set tintColor(e){this.compositeView.uniforms.tintColor.color=e}get strength(){return this.compositeView.uniforms.bloomStrength.value}set strength(e){this.compositeView.uniforms.bloomStrength.value=e}get exposure(){return this.compositeView.uniforms.exposure.value}set exposure(e){this.compositeView.uniforms.exposure.value=e}get radius(){return this.compositeView.uniforms.bloomRadius.value}set radius(e){this.compositeView.uniforms.bloomRadius.value=e}get luminosityThreshold(){return this.brightnessView.uniforms.luminosityThreshold.value}set luminosityThreshold(e){this.brightnessView.uniforms.luminosityThreshold.value=e}render(e,t){{let r=this.getOutTexture();this.brightnessView.renderToViewQuad(e,this.brightnessView,t,r);{let s=this.brightnessView.rendererPassState.renderTargets[0];for(let a=0;a<this.blurList.length;a++){let n=this.blurList[a].ql,l=this.blurList[a].qr;n.pass.setUniformFloat("horizontal",.5),n.pass.setUniformFloat("vScale",a*this.blurX),n.renderToViewQuad(e,n,t,s),s=n.rendererPassState.renderTargets[0],l.pass.setUniformFloat("horizontal",2),l.pass.setUniformFloat("hScale",a*this.blurY),l.renderToViewQuad(e,l,t,s),s=l.rendererPassState.renderTargets[0]}}{let s=this.compositeView.pass;s.setTexture("blurTex1",this.blurList[0].qr.rendererPassState.renderTargets[0]),s.setTexture("blurTex2",this.blurList[1].qr.rendererPassState.renderTargets[0]),s.setTexture("blurTex3",this.blurList[2].qr.rendererPassState.renderTargets[0]),s.setTexture("blurTex4",this.blurList[3].qr.rendererPassState.renderTargets[0]),s.setTexture("blurTex5",this.blurList[4].qr.rendererPassState.renderTargets[0]),this.compositeView.renderToViewQuad(e,this.compositeView,t,r)}}}}class _f{constructor(){o(this,"indexList"),o(this,"color"),o(this,"count")}}class xf{constructor(){o(this,"SlotCount",8),o(this,"MaxEntities",16),o(this,"defaultColor",new z(.2,1,1,1)),o(this,"slots",[]),o(this,"dataDirty",!0);let e=A.setting.render.postProcessing.outline.groupCount;this.SlotCount=Math.max(1,Math.min(e,this.SlotCount));for(let t=0;t<this.SlotCount;t++){let r=this.slots[t]=new _f;r.indexList=new Float32Array(this.MaxEntities),r.color=this.defaultColor.clone(),r.count=0}}clear(){for(let e=0;e<this.SlotCount;e++)this.clearAt(e)}clearAt(e){this.dataDirty=!0;let t=this.slots[e];return t.color.copyFrom(this.defaultColor),t.indexList.fill(-1),t.count=0,this}fillDataAt(e,t,r){this.dataDirty=!0;let s=this.slots[e];if(s){s.indexList.fill(-1);for(let a=0,n=t.length;a<n;a++)s.indexList[a]=t[a];s.count=t.length,s.color.copyFrom(r)}return this}fetchData(e){return e.dirty=this.dataDirty,e.slots=this.slots,this.dataDirty=!1,this}}let kt=new xf;class jp extends Ct{constructor(){super(),o(this,"outlineTex"),o(this,"lowTex"),o(this,"rendererPassState"),o(this,"calcWeightCompute"),o(this,"outlineCompute"),o(this,"blendCompute"),o(this,"outlineSetting"),o(this,"slotsBuffer"),o(this,"slotsArray"),o(this,"entitiesArray"),o(this,"entitiesBuffer"),o(this,"weightBuffer"),o(this,"lowTexSize"),o(this,"oldOutlineColor"),o(this,"rtFrame"),o(this,"fetchData"),o(this,"computeList")}onAttach(e){A.setting.render.postProcessing.outline.enable=!0}onDetach(e){A.setting.render.postProcessing.outline.enable=!1}set outlinePixel(e){e=K(e,0,8);let t=A.setting.render.postProcessing.outline;t.outlinePixel!=e&&(t.outlinePixel=e)}get outlinePixel(){return A.setting.render.postProcessing.outline.outlinePixel}set fadeOutlinePixel(e){let t=A.setting.render.postProcessing.outline;e=K(e,0,8),t.fadeOutlinePixel!=e&&(t.fadeOutlinePixel=e)}get fadeOutlinePixel(){return A.setting.render.postProcessing.outline.fadeOutlinePixel}set strength(e){e=K(e,0,1);let t=A.setting.render.postProcessing.outline;t.strength!=e&&(t.strength=e)}get strength(){return A.setting.render.postProcessing.outline.strength}set useAddMode(e){A.setting.render.postProcessing.outline.useAddMode=e}get useAddMode(){return A.setting.render.postProcessing.outline.useAddMode}createGUI(){}createCompute(){let t=wt.getGBufferFrame("ColorPassGBuffer").getPositionMap();this.calcWeightCompute=new be(tc),this.calcWeightCompute.setStorageBuffer("outlineSetting",this.outlineSetting),this.calcWeightCompute.setStorageBuffer("slotsBuffer",this.slotsBuffer),this.calcWeightCompute.setStorageBuffer("weightBuffer",this.weightBuffer),this.calcWeightCompute.setStorageBuffer("entitiesBuffer",this.entitiesBuffer),this.calcWeightCompute.setSamplerTexture("indexTexture",t),this.calcWeightCompute.workerSizeX=Math.ceil(this.lowTex.width/8),this.calcWeightCompute.workerSizeY=Math.ceil(this.lowTex.height/8),this.calcWeightCompute.workerSizeZ=1,this.outlineCompute=new be(ic),this.outlineCompute.setStorageBuffer("outlineSetting",this.outlineSetting),this.outlineCompute.setStorageBuffer("slotsBuffer",this.slotsBuffer),this.outlineCompute.setStorageBuffer("weightBuffer",this.weightBuffer),this.outlineCompute.setStorageBuffer("oldOutlineColor",this.oldOutlineColor),this.outlineCompute.setStorageTexture("lowTex",this.lowTex),this.outlineCompute.workerSizeX=Math.ceil(this.lowTex.width/8),this.outlineCompute.workerSizeY=Math.ceil(this.lowTex.height/8),this.outlineCompute.workerSizeZ=1,this.blendCompute=new be(ec),this.blendCompute.setStorageBuffer("outlineSetting",this.outlineSetting),this.autoSetColorTexture("inTex",this.blendCompute),this.blendCompute.setSamplerTexture("lowTex",this.lowTex),this.blendCompute.setStorageTexture("outlineTex",this.outlineTex),this.blendCompute.workerSizeX=Math.ceil(this.outlineTex.width/8),this.blendCompute.workerSizeY=Math.ceil(this.outlineTex.height/8),this.blendCompute.workerSizeZ=1}createResource(){let e=S.presentationSize,t=e[0],r=e[1],s=A.setting.render.postProcessing.outline.textureScale;this.lowTexSize=new Z(Math.ceil(t*s),Math.ceil(r*s)),this.lowTex=new oe(this.lowTexSize.x,this.lowTexSize.y,G.rgba16float,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC|GPUTextureUsage.TEXTURE_BINDING),this.lowTex.name="lowTex";let a=new Ce;a.clearValue=[0,0,0,1],a.loadOp="clear",this.outlineTex=new oe(t,r,G.rgba16float,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC|GPUTextureUsage.TEXTURE_BINDING),this.outlineTex.name="outlineTex";let n=new Ce;n.clearValue=[0,0,0,1],n.loadOp="clear",this.rtFrame=new Ze([this.outlineTex],[n]),this.outlineSetting=new Dt(8),this.weightBuffer=new ge(this.lowTexSize.x*this.lowTexSize.y*4,GPUBufferUsage.COPY_SRC),this.oldOutlineColor=new ge(this.lowTexSize.x*this.lowTexSize.y*4,GPUBufferUsage.COPY_SRC),this.slotsArray=new Float32Array(kt.SlotCount*4),this.slotsBuffer=new ge(this.slotsArray.length),this.slotsBuffer.setFloat32Array("slotsArray",this.slotsArray),this.slotsBuffer.apply(),this.entitiesArray=new Float32Array(kt.SlotCount*kt.MaxEntities),this.entitiesBuffer=new ge(this.entitiesArray.length),this.entitiesBuffer.setFloat32Array("entitiesArray",this.entitiesArray),this.slotsBuffer.apply(),this.fetchData||(this.fetchData={})}fetchOutlineData(){if(kt.fetchData(this.fetchData),this.fetchData.dirty){let e=kt.SlotCount,t=kt.MaxEntities;for(let r=0;r<e;r++){let s=4*r,a=this.fetchData.slots[r];this.slotsArray[s+0]=a.color.r,this.slotsArray[s+1]=a.color.g,this.slotsArray[s+2]=a.color.b,this.slotsArray[s+3]=a.count,s=t*r,this.entitiesArray.set(a.indexList,s)}this.slotsBuffer.setFloat32Array("slotsArray",this.slotsArray),this.slotsBuffer.apply(),this.entitiesBuffer.setFloat32Array("entitiesArray",this.entitiesArray),this.entitiesBuffer.apply()}}render(e,t){this.calcWeightCompute||(this.createResource(),this.createCompute(),this.createGUI(),this.rendererPassState=He.createRendererPassState(this.rtFrame,null)),this.computeList||(this.computeList=[this.calcWeightCompute,this.outlineCompute,this.blendCompute]);let r=A.setting.render.postProcessing.outline;this.outlineSetting.setFloat("strength",r.strength),this.outlineSetting.setFloat("useAddMode",r.useAddMode?1:0),this.outlineSetting.setFloat("outlinePixel",r.outlinePixel),this.outlineSetting.setFloat("fadeOutlinePixel",r.fadeOutlinePixel),this.outlineSetting.setFloat("lowTexWidth",this.lowTexSize.x),this.outlineSetting.setFloat("lowTexHeight",this.lowTexSize.y),this.outlineSetting.apply(),this.fetchOutlineData(),w.computeCommand(t,this.computeList),w.lastRenderPassState=this.rendererPassState}}class qp extends Ct{constructor(){super(),o(this,"SSR_RayTraceCompute"),o(this,"SSR_IS_Compute"),o(this,"SSR_Blend_Compute"),o(this,"isRetTexture"),o(this,"finalTexture"),o(this,"rendererPassState"),o(this,"ssrUniformBuffer"),o(this,"rayTraceData"),o(this,"ssrColorData"),o(this,"isKernelFloat32Array"),o(this,"rtFrame"),o(this,"historyPosition"),o(this,"reflectionRatio",.5)}onAttach(e){A.setting.render.postProcessing.ssr.enable=!0,this.debug()}onDetach(e){A.setting.render.postProcessing.ssr.enable=!1}get fadeEdgeRatio(){return A.setting.render.postProcessing.ssr.fadeEdgeRatio}set fadeEdgeRatio(e){e=K(e,0,1);let t=A.setting.render.postProcessing.ssr;t.fadeEdgeRatio=e}get rayMarchRatio(){return A.setting.render.postProcessing.ssr.rayMarchRatio}set rayMarchRatio(e){e=K(e,0,1);let t=A.setting.render.postProcessing.ssr;t.rayMarchRatio=e}get roughnessThreshold(){return A.setting.render.postProcessing.ssr.roughnessThreshold}set roughnessThreshold(e){e=K(e,0,1);let t=A.setting.render.postProcessing.ssr;t.roughnessThreshold=e}get fadeDistanceMin(){return A.setting.render.postProcessing.ssr.fadeDistanceMin}set fadeDistanceMin(e){e=K(e,0,1e4);let t=A.setting.render.postProcessing.ssr;t.fadeDistanceMin=e}get fadeDistanceMax(){return A.setting.render.postProcessing.ssr.fadeDistanceMax}set fadeDistanceMax(e){e=K(e,0,1e4);let t=A.setting.render.postProcessing.ssr;t.fadeDistanceMax=e}get powDotRN(){return A.setting.render.postProcessing.ssr.powDotRN}set powDotRN(e){e=K(e,0,1);let t=A.setting.render.postProcessing.ssr;t.powDotRN=e}debug(){}createRayTraceShader(){this.SSR_RayTraceCompute=new be(oc),this.SSR_RayTraceCompute.setStorageBuffer("ssrUniform",this.ssrUniformBuffer),this.SSR_RayTraceCompute.setStorageBuffer("rayTraceBuffer",this.rayTraceData),this.SSR_RayTraceCompute.setStorageBuffer("historyPosition",this.historyPosition);let e=wt.getGBufferFrame("ColorPassGBuffer");this.SSR_RayTraceCompute.setSamplerTexture("zBufferTexture",e.getPositionMap()),this.SSR_RayTraceCompute.setSamplerTexture(Ae.normalBufferTex_NAME,e.attachments[2]),this.SSR_RayTraceCompute.setSamplerTexture(Ae.materialBufferTex_NAME,e.attachments[3]),Q.instance.sky instanceof sa&&this.SSR_RayTraceCompute.setSamplerTexture("prefilterMap",Q.instance.sky.map),this.SSR_RayTraceCompute.workerSizeX=Math.ceil(this.isRetTexture.width/8),this.SSR_RayTraceCompute.workerSizeY=Math.ceil(this.isRetTexture.height/8),this.SSR_RayTraceCompute.workerSizeZ=1}createISShader(){this.SSR_IS_Compute=new be(ac),this.SSR_IS_Compute.setStorageBuffer("ssrUniform",this.ssrUniformBuffer),this.SSR_IS_Compute.setStorageBuffer("rayTraceBuffer",this.rayTraceData),this.SSR_IS_Compute.setStorageBuffer("ssrColorData",this.ssrColorData),this.SSR_IS_Compute.setStorageBuffer("historyPosition",this.historyPosition),this.autoSetColorTexture("colorMap",this.SSR_IS_Compute),this.SSR_IS_Compute.setStorageTexture("outTex",this.isRetTexture),this.SSR_IS_Compute.workerSizeX=Math.ceil(this.isRetTexture.width/8),this.SSR_IS_Compute.workerSizeY=Math.ceil(this.isRetTexture.height/8),this.SSR_IS_Compute.workerSizeZ=1}createBlendShader(e){this.SSR_Blend_Compute=new be(sc),this.SSR_Blend_Compute.setStorageBuffer("rayTraceBuffer",this.rayTraceData),this.autoSetColorTexture("colorMap",this.SSR_Blend_Compute),this.SSR_Blend_Compute.setSamplerTexture("ssrMap",e),this.SSR_Blend_Compute.setStorageTexture("outTex",this.finalTexture),this.SSR_Blend_Compute.workerSizeX=Math.ceil(this.finalTexture.width/8),this.SSR_Blend_Compute.workerSizeY=Math.ceil(this.finalTexture.height/8),this.SSR_Blend_Compute.workerSizeZ=1}createResource(){let e=S.presentationSize,t=e[0],r=e[1];this.finalTexture=new oe(t,r,G.rgba16float,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING),this.finalTexture.name="ssrOutTex";let s=new Ce;s.clearValue=[0,0,0,0],s.loadOp="clear";let a=Math.ceil(t*A.setting.render.postProcessing.ssr.pixelRatio),n=Math.ceil(r*A.setting.render.postProcessing.ssr.pixelRatio);this.isRetTexture=new oe(a,n,G.rgba16float,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING),this.isRetTexture.name="ssrTextureIn";let l=new Ce;l.clearValue=[0,0,0,0],l.loadOp="clear",this.rtFrame=new Ze([this.finalTexture,this.isRetTexture],[s,l]),this.rayTraceData=new ge(a*n*8,GPUBufferUsage.COPY_SRC),this.ssrColorData=new ge(a*n*4,GPUBufferUsage.COPY_SRC),this.historyPosition=new ge(a*n*4,GPUBufferUsage.COPY_SRC),this.ssrUniformBuffer=new Dt(4*8),this.ssrUniformBuffer.setFloat("ssrBufferSizeX",this.isRetTexture.width),this.ssrUniformBuffer.setFloat("ssrBufferSizeY",this.isRetTexture.height),this.ssrUniformBuffer.setFloat("colorMapSizeX",this.finalTexture.width),this.ssrUniformBuffer.setFloat("colorMapSizeY",this.finalTexture.height),this.ssrUniformBuffer.apply()}render(e,t){if(!this.SSR_RayTraceCompute){this.createResource(),this.createISShader(),this.createRayTraceShader(),this.createBlendShader(this.isRetTexture),this.finalTexture,this.rendererPassState=He.createRendererPassState(this.rtFrame,null);let a=pe.getCameraGroup(e.camera);this.SSR_RayTraceCompute.setUniformBuffer("standUniform",a.uniformGPUBuffer)}let r=A.setting.render.postProcessing.ssr;this.ssrUniformBuffer.setFloat("fadeEdgeRatio",r.fadeEdgeRatio),this.ssrUniformBuffer.setFloat("rayMarchRatio",r.rayMarchRatio),this.ssrUniformBuffer.setFloat("fadeDistanceMin",r.fadeDistanceMin),this.ssrUniformBuffer.setFloat("fadeDistanceMax",r.fadeDistanceMax),this.ssrUniformBuffer.setFloat("mixThreshold",r.mixThreshold),this.ssrUniformBuffer.setFloat("roughnessThreshold",r.roughnessThreshold),this.ssrUniformBuffer.setFloat("reflectionRatio",this.reflectionRatio),this.ssrUniformBuffer.setFloat("powDotRN",r.powDotRN),this.ssrUniformBuffer.setFloat("randomSeedX",Math.random()),this.ssrUniformBuffer.setFloat("randomSeedY",Math.random()),this.ssrUniformBuffer.apply();let s=[this.SSR_RayTraceCompute,this.SSR_IS_Compute,this.SSR_Blend_Compute];w.computeCommand(t,s),w.lastRenderPassState=this.rendererPassState}}class Kp{static createSeeds(){let e=20,t=32,r=[new g(0,0,e)],s=0,a=.02;for(let n=1;n<t;n++){let l=new g;r.push(l),s+=1-(1-.618)*n/t,a+=n*.01,l.x=Math.sin(s)*a,l.y=Math.cos(s)*a,l.z=1-n/t,l.multiplyScalar(e)}return r}}class Jp extends Ct{constructor(){super(),o(this,"taaTexture"),o(this,"outTexture"),o(this,"rendererPassState"),o(this,"taaCompute"),o(this,"copyTexCompute"),o(this,"sharpCompute"),o(this,"taaSetting"),o(this,"preColorBuffer"),o(this,"preColorTex"),o(this,"preProjMatrix"),o(this,"preViewMatrix"),o(this,"rtFrame")}onAttach(e){A.setting.render.postProcessing.taa.enable=!0,e.camera.enableJitterProjection(!0),this.createGUI()}onDetach(e){A.setting.render.postProcessing.taa.enable=!1,e.camera.enableJitterProjection(!1)}get jitterSeedCount(){return A.setting.render.postProcessing.taa.jitterSeedCount}set jitterSeedCount(e){e=K(e,2,8),e=Math.round(e);let t=A.setting.render.postProcessing.taa;t.jitterSeedCount=e}get blendFactor(){return A.setting.render.postProcessing.taa.blendFactor}set blendFactor(e){e=K(e,0,1);let t=A.setting.render.postProcessing.taa;t.blendFactor=e}get sharpFactor(){return A.setting.render.postProcessing.taa.sharpFactor}set sharpFactor(e){e=K(e,.1,.9);let t=A.setting.render.postProcessing.taa;t.sharpFactor=e}get sharpPreBlurFactor(){return A.setting.render.postProcessing.taa.sharpPreBlurFactor}set sharpPreBlurFactor(e){e=K(e,.1,.9);let t=A.setting.render.postProcessing.taa;t.sharpPreBlurFactor=e}get temporalJitterScale(){return A.setting.render.postProcessing.taa.temporalJitterScale}set temporalJitterScale(e){e=K(e,0,1);let t=A.setting.render.postProcessing.taa;t.temporalJitterScale=e}createGUI(){}createCompute(e){let t=new be(hc);A.setting.render.postProcessing.taa;let r=new Dt(16*2+4*3),s=pe.getCameraGroup(e.camera);t.setUniformBuffer("standUniform",s.uniformGPUBuffer),t.setUniformBuffer("taaData",r),t.setStorageBuffer("preColorBuffer",this.preColorBuffer);let a=wt.getGBufferFrame("ColorPassGBuffer");t.setSamplerTexture("preColorTex",this.preColorTex),t.setSamplerTexture("posTex",a.getPositionMap()),this.autoSetColorTexture("inTex",t),t.setStorageTexture("outTex",this.taaTexture),t.workerSizeX=Math.ceil(this.taaTexture.width/8),t.workerSizeY=Math.ceil(this.taaTexture.height/8),t.workerSizeZ=1,this.taaCompute=t,this.taaSetting=r,this.copyTexCompute=new be(nc),this.copyTexCompute.setStorageBuffer("preColor",this.preColorBuffer),this.copyTexCompute.setStorageTexture("preColorTex",this.preColorTex),this.copyTexCompute.workerSizeX=Math.ceil(this.taaTexture.width/8),this.copyTexCompute.workerSizeY=Math.ceil(this.taaTexture.height/8),this.copyTexCompute.workerSizeZ=1,this.sharpCompute=new be(lc),this.sharpCompute.setUniformBuffer("taaData",r),this.sharpCompute.setSamplerTexture("inTex",this.taaTexture),this.sharpCompute.setStorageTexture("outTex",this.outTexture),this.sharpCompute.workerSizeX=Math.ceil(this.outTexture.width/8),this.sharpCompute.workerSizeY=Math.ceil(this.outTexture.height/8),this.sharpCompute.workerSizeZ=1}createResource(){this.preProjMatrix=new V().identity(),this.preViewMatrix=new V().identity();let e=S.presentationSize,t=e[0],r=e[1];this.preColorBuffer=new ge(t*r*4,GPUBufferUsage.COPY_SRC),this.preColorTex=new oe(t,r,G.rgba16float,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC|GPUTextureUsage.TEXTURE_BINDING),this.preColorTex.name="taaTex";let s=new Ce;s.clearValue=[0,0,0,1],s.loadOp="clear",this.taaTexture=new oe(t,r,G.rgba16float,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC|GPUTextureUsage.TEXTURE_BINDING),this.taaTexture.name="taaTex";let a=new Ce;a.clearValue=[0,0,0,1],a.loadOp="clear",this.outTexture=new oe(t,r,G.rgba16float,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC|GPUTextureUsage.TEXTURE_BINDING),this.outTexture.name="sharpTaaTex";let n=new Ce;n.clearValue=[0,0,0,1],n.loadOp="clear",this.rtFrame=new Ze([this.preColorTex,this.taaTexture,this.outTexture],[s,a,n])}render(e,t){this.taaCompute||(this.createResource(),this.createCompute(e),this.rendererPassState=He.createRendererPassState(this.rtFrame,null));let r=A.setting.render.postProcessing.taa;this.taaSetting.setMatrix("preProjMatrix",this.preProjMatrix),this.taaSetting.setMatrix("preViewMatrix",this.preViewMatrix),this.taaSetting.setFloat("jitterFrameIndex",e.camera.jitterFrameIndex),this.taaSetting.setFloat("blendFactor",r.blendFactor),this.taaSetting.setFloat("sharpFactor",r.sharpFactor),this.taaSetting.setFloat("sharpPreBlurFactor",r.sharpPreBlurFactor),this.taaSetting.setFloat("jitterX",e.camera.jitterX),this.taaSetting.setFloat("jitterY",e.camera.jitterY),this.taaSetting.apply(),w.computeCommand(t,[this.copyTexCompute,this.taaCompute,this.sharpCompute]),w.lastRenderPassState=this.rendererPassState,this.preProjMatrix.copyFrom(e.camera.projectionMatrix),this.preViewMatrix.copyFrom(e.camera.viewMatrix)}}class vf{constructor(){o(this,"_tempIndexArray",[]),o(this,"_rendererList",[])}setOutline(e,t){this.setOutlineList([e],t?[t]:null)}setOutlineList(e,t){e||(e=[]);let r=kt.defaultColor,s=kt.SlotCount;for(let a=0;a<s;a++){this._tempIndexArray.length=0;let n=e[a],l=(t?t[a]:null)||r;if(n)for(const h of n)this.getEntityIdList(h,this._tempIndexArray);kt.fillDataAt(a,this._tempIndexArray,l)}}clearOutline(){return kt.clear(),this}getEntityIdList(e,t){this._rendererList.length=0;let r=e.getComponents(ce,this._rendererList);for(const s of r)t.push(s.object3D.transform._worldMatrix.index)}}let Zp=new vf;class yf{constructor(){o(this,"localPosition",new g),o(this,"worldPosition",new g),o(this,"uv",new Z),o(this,"faceIndex"),o(this,"isIn",!1),o(this,"t",0),o(this,"u",0),o(this,"v",0),o(this,"triangle"),o(this,"v0"),o(this,"v1"),o(this,"v2"),o(this,"pickList"),o(this,"color")}}const gs=class{static distPtTri(i,e,t,r){let s=new g,a=new g,n=new g;r.subtract(e,s),t.subtract(e,a),i.subtract(e,n);let l=et(s,s),h=et(s,a),u=et(s,n),c=et(a,a),f=et(a,n),d=1/(l*c-h*h),p=(c*u-h*f)*d,m=(l*f-h*u)*d;if(p>=-gs.EPS&&m>=-gs.EPS&&p+m<=1+gs.EPS){let _=e[1]+s[1]*p+a[1]*m;return Math.abs(_-i[1])}return gs.FLT_MAX}static IntersectTriangle(i,e,t){let r=e.v1,s=e.v2,a=e.v3,n=s.subtract(r,g.HELP_3),l=a.subtract(r,g.HELP_4),h=i.direction.crossProduct(l,g.HELP_5),u=et(n,h),c;if(u>0){if(t)return null;c=i.origin.subtract(r,g.HELP_2)}else c=r.subtract(i.origin,g.HELP_2),u=-u;if(u<1e-4)return this._info.isIn=!1,this._info.t=0,this._info.u=0,this._info.v=0,this._info;let f=et(c,h);if(f<0||f>u)return this._info.isIn=!1,this._info.t=0,this._info.u=0,this._info.v=0,this._info;let d=c.crossProduct(n,g.HELP_1),p=et(i.direction,d);if(p<0||f+p>u)return this._info.isIn=!1,this._info.t=0,this._info.u=0,this._info.v=0,this._info;let m=et(l,d),_=1/u;m*=_,f*=_,p*=_,this._info.isIn=!0,this._info.t=m,this._info.u=f,this._info.v=p;let v=1-f-p;return this._u0.copyFrom(e.u1),this._u0.scale(v),this._u1.copyFrom(e.u2),this._u1.scale(f),this._u2.copyFrom(e.u3),this._u2.scale(p),this._info.uv.copyFrom(this._u0),this._info.uv.add(this._u1,this._info.uv),this._info.uv.add(this._u2,this._info.uv),this._info.localPosition.copyFrom(i.direction).multiplyScalar(m),this._info.localPosition.add(i.origin,this._info.localPosition),this._info}};let zi=gs;o(zi,"EPS",1e-4),o(zi,"FLT_MAX",3402823466e29),o(zi,"_info",new yf),o(zi,"_u0",new Z),o(zi,"_u1",new Z),o(zi,"_u2",new Z);const gn=class extends hi{constructor(){if(super(),o(this,"_maxRetry",3),gn._instance)throw new Error("LoadManager is singleton class...")}loadAll(i,e){return new Promise((t,r)=>{let s=i.length,a=[];i.forEach((n,l)=>{let h=new e;this.load(n,e).then(u=>{h.parse(u),a.push(h),s--,s===0&&t(a)})})})}static getInstance(){return this._instance||(this._instance=new gn)}loadUrls(i,e){return new Promise((t,r)=>{let s=i.length,a=[];i.forEach((n,l)=>{this.load(n,e).then(h=>{a.push(h),s--,s===0&&t(a),s<0&&console.error(`loadUrls ${i} error`)})})})}get maxRetry(){return this._maxRetry}set maxRetry(i){this._maxRetry=i}load(i,e){return new Promise((t,r)=>{switch(e.format){}})}};let Cf=gn;o(Cf,"_instance");class $p{}class em{}class tm{}class im{}class rm{}class sm{}class am{}class om{}class nm{}class lm{}class hm{constructor(){o(this,"asset"),o(this,"extras"),o(this,"geometricError"),o(this,"properties"),o(this,"refine"),o(this,"root")}}class um{constructor(){o(this,"boundingVolume"),o(this,"children"),o(this,"geometricError"),o(this,"transform")}}class cm{constructor(){o(this,"boundingVolume"),o(this,"geometricError"),o(this,"refine"),o(this,"content"),o(this,"contents")}}class fm{constructor(){o(this,"uri"),o(this,"group"),o(this,"metadata")}}class dm{constructor(){o(this,"class"),o(this,"properties")}}class Cn{constructor(){o(this,"group"),o(this,"_modelList"),o(this,"_tileSet"),o(this,"_rootPath"),this.group=new te}async loadTileSet(e,t){this._modelList=[],this._rootPath=e;let r=e+"/"+t;if(this._tileSet=await A.res.loadJSON(r),this._tileSet.root.transform){let l=new V;for(let h=0;h<16;h++)l.rawData[h]=this._tileSet.root.transform[h]}let s=new V;switch((this._tileSet.asset&&this._tileSet.asset.gltfUpAxis||"y").toLowerCase()){case"x":s.makeRotationAxis(g.Y_AXIS,-Math.PI/2);break;case"y":s.makeRotationAxis(g.X_AXIS,Math.PI/2);break;case"z":s.identity();break}let n=s.clone();n.invert(),this.applyTransform(this.group.transform,n);for(let l of this._tileSet.root.children){let h=[];if(l.content&&l.content.uri&&h.push(l.content.uri),l.contents)for(let u of l.contents)h.push(u.uri);for(let u of h){let c=this._rootPath+"/"+u,f={onProgress:p=>this.onLoadProgress(p),onComplete:p=>this.onComplete(p)},d;if(c.endsWith(".glb"))d=await A.res.loadGltf(c,f),this.applyTransform(d.transform,s);else if(c.endsWith("tileset.json")){let p=c.replace("/tileset.json",""),m=new Cn;await m.loadTileSet(p,"tileset.json"),d=m.group}else c.endsWith(".i3dm")?d=await A.res.loadI3DM(c,f,s):c.endsWith(".b3dm")&&(d=await A.res.loadB3DM(c,f,s));d&&(this._modelList.push(d),this.group.addChild(d))}}}onLoadProgress(e){}onComplete(e){}applyTransform(e,t){let r=t.decompose(yt.QUATERNION);e.localRotQuat.copyFrom(r[1]),e.localRotQuat=e.localRotQuat,e.localPosition.copyFrom(r[0]),e.localPosition=e.localPosition,e.localScale.copyFrom(r[2]),e.localScale=e.localScale}}class wf extends os{constructor(){super(),N.register("ColorLitShader",en.Ori_AllShader);let e=new We("ColorLitShader","ColorLitShader");e.setDefine("USE_BRDF",!0),e.setShaderEntry("VertMain","FragMain"),e.setUniformColor("baseColor",new z),e.setUniformColor("emissiveColor",new z),e.setUniformFloat("envIntensity",1),e.setUniformFloat("normalScale",1),e.setUniformFloat("roughness",0),e.setUniformFloat("metallic",0),e.setUniformFloat("ao",1),e.setUniformFloat("alphaCutoff",0);let t=e.shaderState;t.acceptShadow=!0,t.receiveEnv=!0,t.acceptGI=!0,t.useLight=!0,e.setTexture("normalMap",A.res.normalTexture),e.setTexture("emissiveMap",A.res.blackTexture)}clone(){return null}debug(){}}o(wf,"count",0);function gm(i,e){}class wn extends os{constructor(){super(),N.register("GlassShader",Cc);let e=new We("GlassShader","GlassShader");this.defaultPass=e,e.setDefine("USE_BRDF",!0),e.setShaderEntry("VertMain","FragMain");let t=e.shaderState;t.acceptShadow=!0,t.castShadow=!0,t.receiveEnv=!0,t.acceptGI=!0,t.useLight=!0;let r=A.res.getTexture("BRDFLUT");this.brdfLUT=r,this.baseMap=A.res.whiteTexture,this.normalMap=A.res.normalTexture,this.emissiveMap=A.res.blackTexture}clone(){console.log(`clone material ${this.name}`);let e=new wn;return e.baseMap=this.baseMap,e.normalMap=this.normalMap,e.aoMap=this.aoMap,this.maskMap&&(e.maskMap=this.maskMap),e.emissiveMap=this.emissiveMap,this.uvTransform_1&&(e.uvTransform_1=new j().copyFrom(this.uvTransform_1)),this.uvTransform_2&&(e.uvTransform_2=new j().copyFrom(this.uvTransform_2)),e.baseColor=this.baseColor.clone(),e.emissiveColor=this.emissiveColor.clone(),this.materialF0&&(e.materialF0=new j().copyFrom(this.materialF0)),e.envIntensity=this.envIntensity,e.normalScale=this.normalScale,e.roughness=this.roughness,e.metallic=this.metallic,e.ao=this.ao,e.roughness_min=this.roughness_min,e.roughness_max=this.roughness_max,e.metallic_min=this.metallic_min,e.metallic_max=this.metallic_max,e.emissiveIntensity=this.emissiveIntensity,e.alphaCutoff=this.alphaCutoff,e.ior=this.ior,e.clearcoatFactor=this.clearcoatFactor,e.clearcoatRoughnessFactor=this.clearcoatRoughnessFactor,e}}class pm extends _i{constructor(){super();let e=new We("LambertShader","LambertShader");e.setShaderEntry("VertMain","FragMain"),e.setUniformVector4("transformUV1",new j(0,0,1,1)),e.setUniformVector4("transformUV2",new j(0,0,1,1)),e.setUniformColor("baseColor",new z(1,1,1,1)),e.setUniformFloat("alphaCutoff",.5);let t=e.shaderState;t.acceptShadow=!1,t.castShadow=!1,t.receiveEnv=!1,t.acceptGI=!1,t.useLight=!1,this.defaultPass=e,this.baseMap=A.res.grayTexture}set baseMap(e){this.defaultPass.setTexture("baseMap",e)}get baseMap(){return this.defaultPass.getTexture("baseMap")}set baseColor(e){this.defaultPass.setUniformColor("baseColor",e)}get baseColor(){return this.defaultPass.uniforms.baseColor.color}set envMap(e){}set shadowMap(e){}}class mm extends _i{constructor(){super(),N.register("UnLitShader",tn),N.register("PointShadowDebug",bc);let e=new We("UnLitShader","PointShadowDebug");this.defaultPass=e,e.setShaderEntry("VertMain","FragMain"),e.setUniformVector4("transformUV1",new j(0,0,1,1)),e.setUniformVector4("transformUV2",new j(0,0,1,1)),e.setUniformColor("baseColor",new z),e.setUniformFloat("alphaCutoff",.5);let t=e.shaderState;t.acceptShadow=!1,t.receiveEnv=!1,t.acceptGI=!1,t.useLight=!1,this.baseMap=A.res.whiteTexture}set baseMap(e){this.defaultPass.setTexture("baseMap",e)}set envMap(e){}set shadowMap(e){}debug(){}}class bf extends We{constructor(){super("castPointShadowMap_vert","shadowCastMap_frag"),this.setShaderEntry("main","main"),this.setUniformFloat("cameraFar",5e3),this.setUniformVector3("lightWorldPos",g.ZERO),this.shaderState.receiveEnv=!1,this.shaderState.castShadow=!1,this.shaderState.acceptShadow=!1,this.setDefine("USE_ALPHACUT",!0)}}class Sf extends We{constructor(){super("shadowCastMap_vert","directionShadowCastMap_frag"),this.setShaderEntry("main"),this.setUniformFloat("cameraFar",5e3),this.setUniformVector3("lightWorldPos",g.ZERO),this.shaderState.receiveEnv=!1,this.shaderState.castShadow=!1,this.shaderState.acceptShadow=!1,this.setDefine("USE_ALPHACUT",!0)}setTexture(e,t){super.setTexture(e,t)}}class If extends We{constructor(){super("ZPass_shader_vs","ZPass_shader_vs"),this.setShaderEntry("main"),this.useRz=!1;let e=this.shaderState;e.receiveEnv=!1}}class Ef extends We{constructor(){super("gbuffer_vs","gbuffer_fs"),o(this,"transparency"),this.setShaderEntry("VertMain","FragMain"),this.shaderState,this.setUniformColor("baseColor",new z),this.setUniformColor("emissiveColor",new z),this.setUniformFloat("emissiveIntensity",1),this.setUniformFloat("normalScale",1),this.setUniformFloat("alphaCutoff",1),this.blendMode=xe.NONE,this.setTexture("normalMap",A.res.normalTexture)}}class Bf extends We{constructor(){super("sky_vs_frag_wgsl","SkyGBuffer_fs"),this.setUniformFloat("exposure",1),this.setUniformFloat("roughness",0);let e=this.shaderState;e.frontFace="ccw",e.cullMode=ui.front,e.depthWriteEnabled=!1,e.depthCompare=vt.less}}class Ia{constructor(e=[]){o(this,"_points"),o(this,"_cacheValue"),this.points=e,this._cacheValue=new Z}get points(){return this._points}set points(e){this._points=e}getValue(e){e<0&&(e=0),e>1&&(e=1);let t=this.points.length-1,r=Math.floor(t*e),s=r+1,a=st.fract((t+1)*e);return s>=t&&(s=r,a=0),this._cacheValue.x=this.points[r].x+(this.points[s].x-this.points[r].x)*a,this._cacheValue.y=this.points[r].y+(this.points[s].y-this.points[r].y)*a,this._cacheValue}static createBezierPoints(e,t){for(var r=new Ia,s=0;s<t;s++){var a=Ia.multiPointBezier(e,s/t);r.points.push(a)}return r}static multiPointBezier(e,t){for(var r=e.length,s=0,a=0,n=function(u,c){for(var f=1,d=1;c>0;)f*=u,d*=c,u--,c--;return f/d},l=0;l<r;l++){var h=e[l];s+=h.x*Math.pow(1-t,r-1-l)*Math.pow(t,l)*n(r-1,l),a+=h.y*Math.pow(1-t,r-1-l)*Math.pow(t,l)*n(r-1,l)}return new Z(s,a)}}class Tf{static calculateCubicBezierPoint(e,t,r,s,a){e>1&&(e=1),e<0&&(e=0);let n=1-e,l=n*n,h=n*n*n,u=e*e,c=e*e*e,f=t.mul(h),d=r.mul(3);d=d.mul(e),d=d.mul(l);let p=s.mul(3);p=p.mul(u),p=p.mul(n);let m=a.mul(c);return f=f.add(d),f=f.add(p),f=f.add(m),f}static bezierPoint(e,t,r,s){e>1&&(e=1),e<0&&(e=0);let a=1-e,n=a*a,l=e*e,h=t.mul(n),u=r.mul(2);u.scaleBy(a),u.scaleBy(e);let c=s.mul(l);return h=h.add(u),h=h.add(c),h}static calculateCubicBezierPoints(e,t,r){e>1&&(e=1),e<0&&(e=0);let s=1-e,a=s*s,n=s*s*s,l=e*e,h=e*e*e,u=t[r].mul(n),c=t[r+1].mul(3);c=c.mul(e),c=c.mul(a);let f=t[r+2].mul(3);f=f.mul(l),f=f.mul(s);let d=t[r+3].mul(h);return u=u.add(c),u=u.add(f),u=u.add(d),u}static bezierPathValue(e,t){e>1&&(e=1),e<0&&(e=0);let r=t.length,s=this.tmp_points;s.length=0;for(let a=1;a<r;++a)for(let n=0;n<r-a;++n){if(a==1){let h=new g;h.x=t[n].x*(1-e)+t[n+1].x*e,h.y=t[n].y*(1-e)+t[n+1].y*e,h.z=t[n].z*(1-e)+t[n+1].z*e,this.tmp_points.push(h);continue}let l=new g;l.x=s[n].x*(1-e)+s[n+1].x*e,l.y=s[n].y*(1-e)+s[n+1].y*e,l.z=s[n].z*(1-e)+s[n+1].z*e,s.push(l)}return s[0]}}o(Tf,"tmp_points",[]);class ca{constructor(e){o(this,"controlVertices"),this.setControlVertices(e)}setControlVertices(e){e.length==4&&(this.controlVertices=e.concat())}getPoint(e){if(!(e>=0&&e<=1))return g.ZERO;let t=1-e,r=t*t*t,s=3*e*t*t,a=3*e*e*t,n=e*e*e;return this.controlVertices[0].mul(r).add(this.controlVertices[1].mul(s)).add(this.controlVertices[2].mul(a)).add(this.controlVertices[3].mul(n))}getTangent(e){if(!(e>=0&&e<=1))return g.ZERO;let t=this.controlVertices,r=t[0].add(t[1].add(t[0]).mul(e)),s=t[1].add(t[2].add(t[1]).mul(e)),a=t[2].add(t[3].add(t[2]).mul(e)),n=r.add(s.subtract(r).mul(e));return s.add(a.subtract(s).mul(e)).subtract(n)}getClosestParam(e,t=1e-6){return this.getClosestParamRec(e,0,1,t)}getClosestParamRec(e,t,r,s){let a=(t+r)/2;if(r-t<s)return a;let n=(t+a)/2,l=(a+r)/2,h=this.getPoint(n),u=this.getPoint(l),c=h.subtract(e).lengthSquared,f=u.subtract(e).lengthSquared;return c<f?r=a:t=a,this.getClosestParamRec(e,t,r,s)}}var Mf=(i=>(i[i.Open=0]="Open",i[i.Closed=1]="Closed",i))(Mf||{});class Am{constructor(e,t=0){o(this,"type",0),o(this,"numCurveSegments",0),o(this,"numControlVertices",0),o(this,"controlVertices",[]),this.setControlVertices(e,t)}getPathType(){return this.type}isClosed(){return this.type==1}isValid(){return this.numCurveSegments>0}clear(){this.controlVertices.length=0,this.type=0,this.numCurveSegments=0,this.numControlVertices=0}computeApproxLength(){if(!this.isValid())return 0;let e=this.numCurveSegments+1;if(e<2)return 0;let t=0,r=this.controlVertices;for(let s=1;s<e;s++){let a=r[(s-1)*3],n=r[s*3];t+=a.subtract(n).lengthSquared}return t==0?0:t}computeApproxParamPerUnitLength(){let e=this.computeApproxLength();return this.numCurveSegments/e}computeApproxNormParamPerUnitLength(){return 1/this.computeApproxLength()}interpolatePoints(e,t){let r=e.length;r<2&&console.error("point count must great 1"),this.clear(),this.type=t;let s=this.controlVertices;switch(t){case 0:{this.numCurveSegments=r-1,this.numControlVertices=3*r-2,s.length=this.numControlVertices;for(let l=0;l<r;l++)s[l*3]=e[l];let a=e[1].subtract(e[0]).mul(.25);s[1]=e[0].add(a);let n=e[r-2].subtract(e[r-1]).mul(.25);s[this.numControlVertices-2]=e[r-1].add(n);for(let l=1;l<this.numCurveSegments;l++){let h=e[l-1].subtract(e[l]),u=e[l+1].subtract(e[l]),c=h.lengthSquared,f=u.lengthSquared;if(c>0&&f>0){let d=(c+f)/8,p=u.div(f).subtract(h.div(c));p.normalize(),p=p.mul(d),s[l*3-1]=e[l].subtract(p),s[l*3+1]=e[l].add(p)}else s[l*3-1]=e[l],s[l*3+1]=e[l]}break}case 1:{this.numCurveSegments=r,this.numControlVertices=3*r+1,s.length=this.numControlVertices;for(let a=0;a<r;a++)s[a*3]=e[a];s[this.numControlVertices-1]=e[0];for(let a=1;a<=this.numCurveSegments;a++){let n=a-1,l=(a+1)%this.numCurveSegments,h=a%this.numCurveSegments,u=e[n].subtract(e[h]),c=e[l].subtract(e[h]),f=u.lengthSquared,d=c.lengthSquared,p=3*a-1,m=(3*a+1)%(this.numControlVertices-1);if(f>0&&d>0){let _=(f+d)/8,v=c.div(d).subtract(u.div(f));v.normalize(),v=v.mul(_),s[p]=e[h].subtract(v),s[m]=e[h].add(v)}else s[p]=e[h],s[m]=e[h]}break}}}setControlVertices(e,t){let r=e.length;r<=0||t==0&&r<4||t==1&&r<7||(r-1)%3==0&&(this.clear(),this.type=t,this.numControlVertices=r,this.numCurveSegments=(r-1)/3,this.controlVertices=e)}getPoint(e){if(this.type==1){for(;e<0;)e+=this.numCurveSegments;for(;e>this.numCurveSegments;)e-=this.numCurveSegments}else e=st.clampf(e,0,this.numCurveSegments);if(!(e>=0)&&e<=this.numCurveSegments)return;let t=Math.floor(e);t>=this.numCurveSegments&&(t=this.numCurveSegments-1);let r=[],s=this.controlVertices;return r[0]=s[3*t+0],r[1]=s[3*t+1],r[2]=s[3*t+2],r[3]=s[3*t+3],new ca(r).getPoint(e-t)}getPointNorm(e){return this.getPoint(e*this.numCurveSegments)}getTangent(e){if(this.type==1){for(;e<0;)e+=this.numCurveSegments;for(;e>this.numCurveSegments;)e-=this.numCurveSegments}else e=st.clampf(e,0,this.numCurveSegments);if(!(e>=0)&&e<=this.numCurveSegments)return;let t=Math.floor(e);t>=this.numCurveSegments&&(t=this.numCurveSegments-1);let r=this.controlVertices,s=[];return s[0]=r[3*t+0],s[1]=r[3*t+1],s[2]=r[3*t+2],s[3]=r[3*t+3],new ca(s).getTangent(e-t)}getTangentNorm(e){return this.getTangent(e*this.numCurveSegments)}computeClosestParam(e,t){let r=Number.MAX_SAFE_INTEGER,s=0,a=[],n=new ca(a);for(let l=0;l<this.controlVertices.length-1;l+=3){for(let f=0;f<4;f++)a[f]=this.controlVertices[l+f];n.setControlVertices(a);let h=n.getClosestParam(e,t),c=n.getPoint(h).subtract(e).lengthSquared;c<r&&(r=c,s=l/3+h)}return s}computeClosestNormParam(e,t){return this.computeClosestParam(e,t*this.numCurveSegments)}}var Df=(i=>(i[i.kParticleSystemClampVelocityCurveId=322376503]="kParticleSystemClampVelocityCurveId",i[i.kParticleSystemForceCurveId=306581307]="kParticleSystemForceCurveId",i[i.kParticleSystemRotationCurveId=1793934638]="kParticleSystemRotationCurveId",i[i.kParticleSystemRotationBySpeedCurveId=3737431713]="kParticleSystemRotationBySpeedCurveId",i[i.kParticleSystemStartSpeedCurveId=2527743459]="kParticleSystemStartSpeedCurveId",i[i.kParticleSystemSizeCurveId=2368504881]="kParticleSystemSizeCurveId",i[i.kParticleSystemSizeBySpeedCurveId=4085612399]="kParticleSystemSizeBySpeedCurveId",i[i.kParticleSystemVelocityCurveId=3774601268]="kParticleSystemVelocityCurveId",i[i.kParticleSystemUVCurveId=326370691]="kParticleSystemUVCurveId",i[i.kParticleSystemColorGradientId=1494990940]="kParticleSystemColorGradientId",i[i.kParticleSystemColorByVelocityGradientId=1089181156]="kParticleSystemColorByVelocityGradientId",i[i.kParticleSystemMeshSelectionId=3159510623]="kParticleSystemMeshSelectionId",i[i.kParticleSystemUVRowSelectionId=2941263940]="kParticleSystemUVRowSelectionId",i))(Df||{});const _m=3.141592653589793;class xm{}function Pf(i,e,t){let r=.3333333333333333,s=.5,a=i*r,n=a*a,h=n*a-a*e*s+t*s,u=-n+e*r,c=u*u*u,f=c+h*h;if(f>=0){let m=Math.sqrt(f)-h;return m=m>0?Math.pow(m,r):-Math.pow(-m,r),-a-u/m+m}let d=Math.sqrt(-c),p=Math.acos(-h/d);return d=Math.pow(d,r),d=d-u/d,p=-a+d*Math.cos(p*r),p}function fa(i,e,t,r){let s=1e-5;if(Math.abs(i)<s)return Math.abs(e)>s?(r.r0=-t/e,1):0;let a=e*e-4*i*t;if(a<0)return 0;let n=.5/i,l=Math.sqrt(a);return r.r0=(l-e)*n,r.r1=(-l-e)*n,2}function Rf(i,e,t,r,s){let a=0;if(Math.abs(e)>=1e-4){let n=t/e,l=r/e,h=s/e;i[0]=Pf(n,l,h),a++;let u=e,c=t+e*i[0],f=r+t*i[0]+e*i[0]*i[0];a+=fa(u,c,f,{r0:i[1],r1:i[2]})}else a+=fa(t,r,s,{r0:i[1],r1:i[2]});return a}class jt{constructor(){o(this,"coeff",[])}static EvalSegment(e,t){return e*(e*(e*t[0]+t[1])+t[2])+t[3]}}const wr=class{constructor(){o(this,"segments",[]),o(this,"integrationCache",[]),o(this,"doubleIntegrationCache",[]),o(this,"times",[]),o(this,"segmentCount"),this.segments[wr.kMaxNumSegments]=new jt,this.integrationCache[wr.kMaxNumSegments]=0,this.doubleIntegrationCache[wr.kMaxNumSegments]=0,this.times[wr.kMaxNumSegments]=0}calculateMinMax(i,e){i.x=Math.min(i.x,e),i.y=Math.max(i.y,e)}findMinMaxDoubleIntegrated(){let i=Z.ZERO.clone(),e=20,t=1/e,r=t;for(let s=0;s<e;s++)this.calculateMinMax(i,this.evaluateDoubleIntegrated(r)),r+=t;return i}findMinMaxIntegrated(){let i=Z.ZERO.clone(),e=[],t=[];for(let r=0;r<this.segmentCount;r++){let s=4*this.segments[r].coeff[0],a=3*this.segments[r].coeff[1],n=2*this.segments[r].coeff[2],l=1*this.segments[r].coeff[3],h=[],u=Rf(h,s,a,n,l);for(let c=0;c<u;c++){let f=h[c]+e[r];f>=e[r]&&f<t[r]&&this.calculateMinMax(i,this.evaluateIntegrated(f))}this.calculateMinMax(i,this.evaluateIntegrated(t[r])),this.times[r]}return i}generateIntegrationCache(i){i.integrationCache[0]=0;let e=i.times[0],t=0;for(let r=1;r<i.segmentCount;r++){let s=i.segments[r-1].coeff;pn(s);let a=e-t;i.integrationCache[r]=i.integrationCache[r-1]+jt.EvalSegment(a,s)*a,t=e,e=i.times[r]}}generateDoubleIntegrationCache(i){let e=0,t=0;for(let r=0;r<i.segmentCount;r++){i.doubleIntegrationCache[r]=e;let s=i.times[r]-t;s=Math.max(s,0),e+=jt.EvalSegment(s,i.segments[r].coeff)*s*s+i.integrationCache[r]*s,t=i.times[r]}}integrate(){this.generateIntegrationCache(this);for(let i=0;i<this.segmentCount;i++)pn(this.segments[i].coeff)}doubleIntegrate(){this.generateIntegrationCache(this);for(let i=0;i<this.segmentCount;i++)Lf(this.segments[i].coeff);this.generateDoubleIntegrationCache(this)}static isValidCurve(i){let e=i.getKeyCount(),t=e-1;return i.getKey(0).time!=0&&t++,i.getKey(e-1).time!=1&&t++,t<=wr.kMaxNumSegments}evaluateDoubleIntegrated(i){let e=0;for(let t=0;t<this.segmentCount;t++){if(i<=this.times[t]){let r=i-e;return this.doubleIntegrationCache[t]+this.integrationCache[t]*r+jt.EvalSegment(r,this.segments[t].coeff)*r*r}e=this.times[t]}return 1}evaluateIntegrated(i){let e=0;for(let t=0;t<this.segmentCount;t++){if(i<=this.times[t]){let r=i-e;return this.integrationCache[t]+jt.EvalSegment(r,this.segments[t].coeff)*r}e=this.times[t]}return 1}evaluate(i){let e=0;for(let t=0;t<this.segmentCount;t++){if(i<=this.times[t])return jt.EvalSegment(i-e,this.segments[t].coeff);e=this.times[t]}return 1}buildCurve(i,e){let t=i.getKeyCount();this.segmentCount=1;let r=1.01;if(this.segments.length=0,this.integrationCache.length=0,this.doubleIntegrationCache.length=0,this.times.length=0,this.times[0]=r,t!=0)if(t==1)this.segments[0]=new jt,this.segments[0].coeff[3]=i.getKey(0).value*e;else{this.segmentCount=t-1;let s=0;i.getKey(0).time!=0&&(this.segments[0].coeff[3]=i.getKey(0).value,this.times[0]=i.getKey(0).time,s=1);for(let a=0;a<this.segmentCount;a++){let n;i.calculateCacheData(n,a,a+1,0),this.segments[a+s].coeff=n.coeff.concat(),this.times[a+s]=i.getKey(a+1).time}this.segmentCount+=s,i.getKey(t-1).time!=1&&(this.segments[this.segmentCount].coeff[3]=i.getKey(t-1).value,this.segmentCount++),this.times[this.segmentCount-1]=r;for(let a=0;a<this.segmentCount;a++)this.segments[a].coeff[0]*=e,this.segments[a].coeff[1]*=e,this.segments[a].coeff[2]*=e,this.segments[a].coeff[3]*=e}return!0}};let da=wr;o(da,"kMaxNumSegments",8);function Lf(i){i[0]/=20,i[1]/=12,i[2]/=6,i[3]/=2}function pn(i){i[0]/=4,i[1]/=3,i[2]/=2,i[3]/=1}var Uf=(i=>(i[i.kEMScalar=0]="kEMScalar",i[i.kEMOptimized=1]="kEMOptimized",i[i.kEMOptimizedMinMax=2]="kEMOptimizedMinMax",i[i.kEMSlow=3]="kEMSlow",i))(Uf||{}),Of=(i=>(i[i.kMMCScalar=0]="kMMCScalar",i[i.kMMCCurve=1]="kMMCCurve",i[i.kMMCTwoCurves=2]="kMMCTwoCurves",i[i.kMMCTwoConstants=3]="kMMCTwoConstants",i))(Of||{});class vm{constructor(){o(this,"max"),o(this,"min")}}class ym{constructor(){o(this,"max"),o(this,"min")}integrate(){this.max.integrate(),this.min.integrate()}doubleIntegrate(){this.max.doubleIntegrate(),this.min.doubleIntegrate()}findMinMaxIntegrated(){return null}findMinMaxDoubleIntegrated(){return null}}class Nf{constructor(e=1){o(this,"minMaxState"),o(this,"minCurve"),o(this,"maxCurve"),o(this,"_scalar",1),o(this,"_minScalar"),this._scalar=e,this.minMaxState=0,this.minCurve=new aa,this.maxCurve=new aa}setScalar(e){this._scalar=e}getScalar(){return this._scalar}static evaluateSlow(e,t,r){let s=e.maxCurve.getValue(t)*e.getScalar();return e.minMaxState==2?Ii(e.minCurve.getValue(t)*e.getScalar(),s,r):s}static evaluate(e,t,r=1){if(e.minMaxState==0)return e.getScalar();let s=e.maxCurve.getValue(t)*e.getScalar();return e.minMaxState==1?Ii(e.minCurve.getValue(t)*e.getScalar(),s,r):e.minMaxState==3?Ii(e._minScalar,e._scalar,r):e.minMaxState==2?Ii(e.minCurve.getValue(t)*e.getScalar(),s,1*Math.random()):this.evaluateSlow(e,t,1)}unSerialized(e){this.minMaxState=e.minMaxState,this._scalar=e.scalar,this._minScalar=e.minScalar,this.maxCurve.unSerialized(e.maxCurve),this.minCurve.unSerialized(e.minCurve)}}class Cm{constructor(){o(this,"value",0),o(this,"mode",0),o(this,"spread",0),o(this,"speed",new Nf)}unSerialized(e){this.value=e.value,this.mode=e.mode,this.spread=e.spread,this.speed.unSerialized(e.speed)}}function wm(i,e){let t=da.isValidCurve(i.max);return e!=2&&e!=3?t:t&&da.isValidCurve(i.min)}function bm(i,e,t,r){i.max.buildCurve(e.max,t),r!=2&&r!=3?i.min.buildCurve(e.max,t):i.min.buildCurve(e.min,t)}function Sm(i,e){let t=e.getKeyCount();if(t!=0)if(t==1)ps(i,e.getKey(0).value);else{let r=t-1;ps(i,e.getKey(0).value);for(let s=0;s<r;s++){let a=new an;e.calculateCacheData(a,s,s+1,0);let n=3*a.coeff[0],l=2*a.coeff[1],h=1*a.coeff[2],u=e.getKey(s).time,c=e.getKey(s+1).time,f=[],d=fa(n,l,h,{r0:f[0],r1:f[1]});for(let p=0;p<d;p++)f[p]>=0&&f[p]+u<c&&ps(i,jt.EvalSegment(f[p],a.coeff));ps(i,jt.EvalSegment(c-u,a.coeff))}}}function ps(i,e){i.x=Math.min(i.x,e),i.y=Math.max(i.y,e)}class bn{constructor(e,t){o(this,"point",new g),o(this,"normal",g.UP),o(this,"_tmpVecA",new g),this.point=e,this.normal=t}clone(){return new bn(this.point.clone(),this.normal.clone())}intersectsLine(e,t,r){var s=-this.normal.dotProduct(this.point),a=this.normal.dotProduct(e)+s,n=this.normal.dotProduct(t)+s,l=a/(a-n),h=l>=0&&l<=1;return h&&r&&r.lerp(e,t,l),h}intersectsRay(e,t){t||(t=this._tmpVecA),t.copy(this.point).subtract(e.origin,t);var r=this.normal.dotProduct(t)/this.normal.dotProduct(e.direction),s=r>=0;return s&&t.copyFrom(e.direction).multiplyScalar(r).add(e.origin,t),s}}function Im(i,e){return Math.random()*e+Math.random()*i+(e-i)*Math.random()}function Em(i,e,t){let r=t*Math.random();return Math.random()*e*r+Math.random()*i*r+(e-i)*Math.random()*r}function Ff(i,e,t){let r=0,s=0;for(;r===0;)r=Math.random();for(;s===0;)s=Math.random();let a=Math.sqrt(-2*Math.log(r))*Math.cos(2*Math.PI*s);return a=a/10+.5,(a>1||a<0)&&(a=Ff(i,e,t)),a=Math.pow(a,t),a*=e-i,a+=i,a}function zt(i){return i>0?Math.floor(i):Math.floor(i)-1}let J=[151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180,151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180];function mn(i,e){let t=i&15,r=1+(t&7);return t&8&&(r=-r),r*e}function ga(i,e,t){let r=i&7,s=r<4?e:t,a=r<4?t:e;return(r&1?-s:s)+(r&2?-2*a:2*a)}function ms(i,e,t,r){let s=i&15,a=s<8?e:t,n=s<4?t:s==12||s==14?e:r;return(s&1?-a:a)+(s&2?-n:n)}function br(i,e,t,r,s){let a=i&31,n=a<24?e:t,l=a<16?t:r,h=a<8?r:s;return(a&1?-n:n)+(a&2?-l:l)+(a&4?-h:h)}let mt=[[0,1,2,3],[0,1,3,2],[0,0,0,0],[0,2,3,1],[0,0,0,0],[0,0,0,0],[0,0,0,0],[1,2,3,0],[0,2,1,3],[0,0,0,0],[0,3,1,2],[0,3,2,1],[0,0,0,0],[0,0,0,0],[0,0,0,0],[1,3,2,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[1,2,0,3],[0,0,0,0],[1,3,0,2],[0,0,0,0],[0,0,0,0],[0,0,0,0],[2,3,0,1],[2,3,1,0],[1,0,2,3],[1,0,3,2],[0,0,0,0],[0,0,0,0],[0,0,0,0],[2,0,3,1],[0,0,0,0],[2,1,3,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[2,0,1,3],[0,0,0,0],[0,0,0,0],[0,0,0,0],[3,0,1,2],[3,0,2,1],[0,0,0,0],[3,1,2,0],[2,1,0,3],[0,0,0,0],[0,0,0,0],[0,0,0,0],[3,1,0,2],[0,0,0,0],[3,2,0,1],[3,2,1,0]];function Bm(i){let e=zt(i),t=e+1,r=i-e,s=r-1,a,n,l=1-r*r;l*=l,a=l*l*mn(J[e&255],r);let h=1-s*s;return h*=h,n=h*h*mn(J[t&255],s),.25*(a+n)}function Tm(i,e){const t=.366025403,r=.211324865;let s,a,n,l=(i+e)*t,h=i+l,u=e+l,c=zt(h),f=zt(u),d=(c+f)*r,p=c-d,m=f-d,_=i-p,v=e-m,y,C;_>v?(y=1,C=0):(y=0,C=1);let B=_-y+r,T=v-C+r,M=_-1+2*r,D=v-1+2*r,P=c&255,L=f&255,I=.5-_*_-v*v;I<0?s=0:(I*=I,s=I*I*ga(J[P+J[L]],_,v));let O=.5-B*B-T*T;O<0?a=0:(O*=O,a=O*O*ga(J[P+y+J[L+C]],B,T));let k=.5-M*M-D*D;return k<0?n=0:(k*=k,n=k*k*ga(J[P+1+J[L+1]],M,D)),40*(s+a+n)}function Mm(i,e,t){const r=.333333333,s=.166666667;let a,n,l,h,u=(i+e+t)*r,c=i+u,f=e+u,d=t+u,p=zt(c),m=zt(f),_=zt(d),v=(p+m+_)*s,y=p-v,C=m-v,B=_-v,T=i-y,M=e-C,D=t-B,P,L,I,O,k,H;T>=M?M>=D?(P=1,L=0,I=0,O=1,k=1,H=0):T>=D?(P=1,L=0,I=0,O=1,k=0,H=1):(P=0,L=0,I=1,O=1,k=0,H=1):M<D?(P=0,L=0,I=1,O=0,k=1,H=1):T<D?(P=0,L=1,I=0,O=0,k=1,H=1):(P=0,L=1,I=0,O=1,k=1,H=0);let W=T-P+s,ne=M-L+s,fe=D-I+s,we=T-O+2*s,ze=M-k+2*s,Re=D-H+2*s,ue=T-1+3*s,de=M-1+3*s,Ge=D-1+3*s,ot=p&255,nt=m&255,Et=_&255,_t=.6-T*T-M*M-D*D;_t<0?a=0:(_t*=_t,a=_t*_t*ms(J[ot+J[nt+J[Et]]],T,M,D));let xt=.6-W*W-ne*ne-fe*fe;xt<0?n=0:(xt*=xt,n=xt*xt*ms(J[ot+P+J[nt+L+J[Et+I]]],W,ne,fe));let qt=.6-we*we-ze*ze-Re*Re;qt<0?l=0:(qt*=qt,l=qt*qt*ms(J[ot+O+J[nt+k+J[Et+H]]],we,ze,Re));let Kt=.6-ue*ue-de*de-Ge*Ge;return Kt<0?h=0:(Kt*=Kt,h=Kt*Kt*ms(J[ot+1+J[nt+1+J[Et+1]]],ue,de,Ge)),32*(a+n+l+h)}function Dm(i,e,t,r){const s=.309016994,a=.138196601;let n,l,h,u,c,f=(i+e+t+r)*s,d=i+f,p=e+f,m=t+f,_=r+f,v=zt(d),y=zt(p),C=zt(m),B=zt(_),T=(v+y+C+B)*a,M=v-T,D=y-T,P=C-T,L=B-T,I=i-M,O=e-D,k=t-P,H=r-L,W=I>O?32:0,ne=I>k?16:0,fe=O>k?8:0,we=I>H?4:0,ze=O>H?2:0,Re=k>H?1:0,ue=W+ne+fe+we+ze+Re,de,Ge,ot,nt,Et,_t,xt,qt,Kt,Ea,Ba,Ta;de=mt[ue][0]>=3?1:0,Ge=mt[ue][1]>=3?1:0,ot=mt[ue][2]>=3?1:0,nt=mt[ue][3]>=3?1:0,Et=mt[ue][0]>=2?1:0,_t=mt[ue][1]>=2?1:0,xt=mt[ue][2]>=2?1:0,qt=mt[ue][3]>=2?1:0,Kt=mt[ue][0]>=1?1:0,Ea=mt[ue][1]>=1?1:0,Ba=mt[ue][2]>=1?1:0,Ta=mt[ue][3]>=1?1:0;let Ma=I-de+a,Da=O-Ge+a,Pa=k-ot+a,Ra=H-nt+a,La=I-Et+2*a,Ua=O-_t+2*a,Oa=k-xt+2*a,Na=H-qt+2*a,Fa=I-Kt+3*a,ka=O-Ea+3*a,za=k-Ba+3*a,Ga=H-Ta+3*a,Qa=I-1+4*a,Va=O-1+4*a,Ha=k-1+4*a,Ya=H-1+4*a,Sr=v&255,Ir=y&255,Er=C&255,Br=B&255,Tr=.6-I*I-O*O-k*k-H*H;Tr<0?n=0:(Tr*=Tr,n=Tr*Tr*br(J[Sr+J[Ir+J[Er+J[Br]]]],I,O,k,H));let Mr=.6-Ma*Ma-Da*Da-Pa*Pa-Ra*Ra;Mr<0?l=0:(Mr*=Mr,l=Mr*Mr*br(J[Sr+de+J[Ir+Ge+J[Er+ot+J[Br+nt]]]],Ma,Da,Pa,Ra));let Dr=.6-La*La-Ua*Ua-Oa*Oa-Na*Na;Dr<0?h=0:(Dr*=Dr,h=Dr*Dr*br(J[Sr+Et+J[Ir+_t+J[Er+xt+J[Br+qt]]]],La,Ua,Oa,Na));let Pr=.6-Fa*Fa-ka*ka-za*za-Ga*Ga;Pr<0?u=0:(Pr*=Pr,u=Pr*Pr*br(J[Sr+Kt+J[Ir+Ea+J[Er+Ba+J[Br+Ta]]]],Fa,ka,za,Ga));let Rr=.6-Qa*Qa-Va*Va-Ha*Ha-Ya*Ya;return Rr<0?c=0:(Rr*=Rr,c=Rr*Rr*br(J[Sr+1+J[Ir+1+J[Er+1+J[Br+1]]]],Qa,Va,Ha,Ya)),27*(n+l+h+u+c)}const kf=class extends Z{constructor(i=0,e=0){super(i,e),o(this,"u",0),o(this,"v",0),this.u=i,this.v=e}length(){return 0}};let zf=kf;o(zf,"uv_0",new kf);class Pm extends tt{constructor(e=1,t=1,r=1,s=8,a=8,n=!1,l=0,h=Math.PI*2){super(),o(this,"radiusTop"),o(this,"radiusBottom"),o(this,"height"),o(this,"radialSegments"),o(this,"heightSegments"),o(this,"openEnded"),o(this,"thetaStart"),o(this,"thetaLength"),this.radiusTop=e,this.radiusBottom=t,this.height=r,this.radialSegments=s,this.heightSegments=a,this.openEnded=n,this.thetaStart=l,this.thetaLength=h,this.instanceID=Pt(),this.buildGeometry()}addGroup(e,t,r){this.addSubGeometry({indexStart:e,indexCount:t,vertexStart:e,index:r})}buildGeometry(){const e=this;this.radialSegments=Math.floor(this.radialSegments),this.heightSegments=Math.floor(this.heightSegments);const t=[],r=[],s=[],a=[];let n=0;const l=[],h=this.height/2;let u=0;m(),this.openEnded===!1&&(this.radiusTop>0&&_(!0),this.radiusBottom>0&&_(!1));let c=new Float32Array(t),f=new Float32Array(r),d=new Float32Array(s),p=new Uint16Array(a);this.setAttribute(Y.position,c),this.setAttribute(Y.normal,f),this.setAttribute(Y.uv,d),this.setAttribute(Y.TEXCOORD_1,d),this.setIndices(p);function m(){const v=new g,y=new g;let C=0;const B=(e.radiusBottom-e.radiusTop)/e.height;for(let T=0;T<=e.heightSegments;T++){const M=[],D=T/e.heightSegments,P=D*(e.radiusBottom-e.radiusTop)+e.radiusTop;for(let L=0;L<=e.radialSegments;L++){const I=L/e.radialSegments,O=I*e.thetaLength+e.thetaStart,k=Math.sin(O),H=Math.cos(O);y.x=P*k,y.y=-D*e.height+h,y.z=P*H,t.push(y.x,y.y,y.z),v.set(k,B,H).normalize(),r.push(v.x,v.y,v.z),s.push(I,1-D),M.push(n++)}l.push(M)}for(let T=0;T<e.radialSegments;T++)for(let M=0;M<e.heightSegments;M++){const D=l[M][T],P=l[M+1][T],L=l[M+1][T+1],I=l[M][T+1];a.push(D,P,I),a.push(P,L,I),C+=6}e.addGroup(u,C,0),u+=C}function _(v){const y=n,C=new Z,B=new g;let T=0;const M=v===!0?e.radiusTop:e.radiusBottom,D=v===!0?1:-1;for(let L=1;L<=e.radialSegments;L++)t.push(0,h*D,0),r.push(0,D,0),s.push(.5,.5),n++;const P=n;for(let L=0;L<=e.radialSegments;L++){const O=L/e.radialSegments*e.thetaLength+e.thetaStart,k=Math.cos(O),H=Math.sin(O);B.x=M*H,B.y=h*D,B.z=M*k,t.push(B.x,B.y,B.z),r.push(0,D,0),C.x=k*.5+.5,C.y=H*.5*D+.5,s.push(C.x,C.y),n++}for(let L=0;L<e.radialSegments;L++){const I=y+L,O=P+L;v===!0?a.push(O,O+1,I):a.push(O+1,O,I),T+=3}e.addGroup(u,T,v===!0?1:2),u+=T}}}class Rm extends tt{constructor(e=.4,t=.1,r=32,s=32){super(),o(this,"radius"),o(this,"tube"),o(this,"radialSegments"),o(this,"tubularSegments"),this.radius=e,this.tube=t,this.radialSegments=r,this.tubularSegments=s,this.initVertex()}initVertex(){const e=2*Math.PI,t=this.radius,r=this.tube,s=this.radialSegments,a=this.tubularSegments;this.bounds=new Be(g.ZERO.clone(),new g(t*2,r*2,t*2));var n=(s+1)*(a+1);let l=new Float32Array(n*3),h=new Float32Array(n*3),u=new Float32Array(n*2),c=new Uint16Array(s*a*2*3),f=0,d=0,p=0,m=0;for(let _=0;_<=s;_++)for(let v=0;v<=a;v++){const y=v/a,C=_/s,B=y*e,T=C*Math.PI*2;if(l[f++]=(t+r*Math.cos(T))*Math.sin(B),l[f++]=r*Math.sin(T),l[f++]=(t+r*Math.cos(T))*Math.cos(B),h[d++]=Math.sin(B)*Math.cos(T),h[d++]=Math.sin(T),h[d++]=Math.cos(B)*Math.cos(T),u[p++]=y,u[p++]=C,v<a&&_<s){const M=a+1,D=M*_+v,P=M*(_+1)+v,L=M*(_+1)+v+1,I=M*_+v+1;c[m++]=D,c[m++]=I,c[m++]=P,c[m++]=I,c[m++]=L,c[m++]=P}}this.setIndices(c),this.setAttribute(Y.position,l),this.setAttribute(Y.normal,h),this.setAttribute(Y.uv,u),this.setAttribute(Y.TEXCOORD_1,u),this.addSubGeometry({indexStart:0,indexCount:c.length,vertexStart:0,index:0})}}class Lm extends at{constructor(e,t){super(e,t,6),o(this,"width",4),o(this,"height",4),o(this,"depthOrArrayLayers",6),o(this,"visibility",GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE),this.format=G.depth24plus,this.mipmapCount=1,this.init()}internalCreateBindingLayoutDesc(){this.samplerBindingLayout.type="non-filtering",this.textureBindingLayout.sampleType="unfilterable-float",this.textureBindingLayout.viewDimension="cube"}internalCreateTexture(){this.textureDescriptor={format:"depth24plus",size:{width:this.width,height:this.height,depthOrArrayLayers:6},dimension:"2d",usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING},this.gpuTexture=S.device.createTexture(this.textureDescriptor)}internalCreateView(){this.viewDescriptor={dimension:"cube"},this.view=this.gpuTexture.createView(this.viewDescriptor)}internalCreateSampler(){this.gpuSampler=S.device.createSampler({}),this.gpuSampler_comparison=S.device.createSampler({compare:"less",label:"sampler_comparison"})}}class Gf extends at{constructor(){super(...arguments),o(this,"uint16Array"),o(this,"floatArray"),o(this,"_dataBuffer")}create(e,t,r=null,s=!0){if(r==null){r=[];for(let a=0,n=e*t*4;a<n;a++)r[a]=0}return this.updateTexture(e,t,r,s),this}updateTexture(e,t,r,s=!0){(e!=this.width||t!=this.height)&&(this._dataBuffer&&this._dataBuffer.destroy(),this._dataBuffer=null,this.gpuTexture&&this.gpuTexture.destroy(),this.gpuTexture=null),this.floatArray=r;let a=S.device;const n=e*4*2;this.format=G.rgba16float,this.mipmapCount=Math.floor(s?Math.log2(e):1),this.createTextureDescriptor(e,t,this.mipmapCount,this.format),(!this.uint16Array||this.uint16Array.length!=r.length)&&(this.uint16Array=new Uint16Array(r.length));let l=this.uint16Array;for(let c=0,f=l.length;c<f;c++)l[c]=ur(r[c]);const h=this._dataBuffer=a.createBuffer({size:l.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC});a.queue.writeBuffer(h,0,l);const u=w.beginCommandEncoder();u.copyBufferToTexture({buffer:h,bytesPerRow:n},{texture:this.getGPUTexture()},{width:e,height:t,depthOrArrayLayers:1}),this.useMipmap||(this.samplerBindingLayout.type="filtering",this.textureBindingLayout.sampleType="float"),w.endCommandEncoder(u),this.gpuSampler=a.createSampler(this),this.gpuTexture=this.getGPUTexture(),this.mipmapCount>1&&Ht.webGPUGenerateMipmap(this)}}class Um extends at{create(e,t,r,s=!0){let a=S.device;const n=e*4*4;this.format=G.rgba32float;let l=1;this.createTextureDescriptor(e,t,l,this.format);const h=a.createBuffer({size:r.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC});a.queue.writeBuffer(h,0,r);const u=w.beginCommandEncoder();u.copyBufferToTexture({buffer:h,bytesPerRow:n},{texture:this.getGPUTexture()},{width:e,height:t,depthOrArrayLayers:1}),w.endCommandEncoder(u),s&&(this.samplerBindingLayout.type="non-filtering",this.textureBindingLayout.sampleType="unfilterable-float"),this.gpuSampler=a.createSampler({})}fromBuffer(e,t,r){let s=S.device;const a=e*4*4;this.format=G.rgba32float,this.mipmapCount=1,this.createTextureDescriptor(e,t,this.mipmapCount,this.format);const n=w.beginCommandEncoder();return n.copyBufferToTexture({buffer:r,bytesPerRow:a},{texture:this.getGPUTexture()},{width:e,height:t,depthOrArrayLayers:1}),w.endCommandEncoder(n),this.samplerBindingLayout.type="non-filtering",this.textureBindingLayout.sampleType="unfilterable-float",this.gpuSampler=s.createSampler({}),this}}class Om extends ra{constructor(e){super(),o(this,"_internalTexture"),o(this,"_minSize",32),o(this,"_skyColor"),this._skyColor=e,this._internalTexture=new Gf;let t=[];return A.res.fillColor(t,this._minSize,this._minSize,this.color.r,this.color.g,this.color.b,this.color.a),this._internalTexture.create(this._minSize,this._minSize,t,!1),this.createFromTexture(this._minSize,this._internalTexture),this}changeColor(e){return this._skyColor=e,A.res.fillColor(this._internalTexture.floatArray,this._minSize,this._minSize,this.color.r,this.color.g,this.color.b,this.color.a),this._internalTexture.updateTexture(this._minSize,this._minSize,this._internalTexture.floatArray,!1),this._faceData.uploadTexture(0,this._internalTexture),this}get color(){return this._skyColor}set color(e){this.changeColor(e)}}class Nm extends at{create(e,t,r,s=!0){let a=S.device;const n=e*4*4;this.format=G.rgba16float,this.mipmapCount=Math.floor(s?Math.log2(e):1),this.createTextureDescriptor(e,t,this.mipmapCount,this.format);const l=a.createBuffer({size:r.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC});a.queue.writeBuffer(l,0,r);const h=w.beginCommandEncoder();h.copyBufferToTexture({buffer:l,bytesPerRow:n},{texture:this.getGPUTexture()},{width:e,height:t,depthOrArrayLayers:1}),w.endCommandEncoder(h),this.minFilter="nearest",this.magFilter="nearest",this.mipmapFilter="nearest",this.samplerBindingLayout.type="non-filtering",this.textureBindingLayout.sampleType="unfilterable-float",this.minFilter="linear",this.magFilter="linear",this.mipmapFilter="nearest",this.samplerBindingLayout.type="filtering",this.textureBindingLayout.sampleType="float",this.gpuSampler=a.createSampler(this),this.mipmapCount>1&&Ht.webGPUGenerateMipmap(this)}}class Fm extends te{constructor(e,t=.1){super(),o(this,"length",100),o(this,"thickness",.1),this.length=e,this.thickness=t}}class km extends DataView{constructor(e,t,r){super(e,t,r),o(this,"position",0)}}class zm{static merge(e,t,r){}static generateNormal(){}static generateTangent(){}static packUV(){}}class Gm{static color_temperature_to_rgb(e){e<1e3?e=1e3:e>4e4&&(e=4e4);let t=e/100,r=this.get_red(t),s=this.get_green(t),a=this.get_blue(t);return new z(r/255,s/255,a/255,1)}static get_red(e){if(e<=66)return 255;let t=329.698727446*Math.pow(e-60,-.1332047592);return this.bound(t)}static get_green(e){let t=0;return e<=66?t=99.4708025861*Math.log(e)-161.1195681661:t=288.1221695283*Math.pow(e-60,-.0755148492),this.bound(t)}static get_blue(e){let t=0;return e>=66?255:e<=19?0:(t=138.5177312231*Math.log(e-10)-305.0447927307,this.bound(t))}static bound(e,t=0,r=255){let s=Math.max(e,t);return Math.min(s,r)}}class pa{static initHeap(){this.boxGeo||(this.boxGeo=new us),this.sphere||(this.sphere=new ls(1,35,35)),this.material||(this.material=new yi)}static get CubeMesh(){return this.initHeap(),this.boxGeo}static get SphereMesh(){return this.initHeap(),this.sphere}static GetCube(){this.initHeap();let e=new te,t=e.addComponent(ce);return t.geometry=this.boxGeo,t.material=this.material.clone(),t.castShadow=!0,e}static GetSingleCube(e,t,r,s,a,n){this.initHeap();let l=new yi;l.baseColor=new z(s,a,n,1);let h=new te,u=h.addComponent(ce);return u.castGI=!0,u.geometry=new us(e,t,r),u.material=l,h}static GetSingleSphere(e,t,r,s){this.initHeap();let a=new yi;a.baseColor=new z(t,r,s,1);let n=new te,l=n.addComponent(ce);return l.castGI=!0,l.geometry=new ls(e,20,20),l.material=a,n}static get Sphere(){this.initHeap();let e=new te,t=e.addComponent(ce);return t.geometry=this.sphere,t.material=this.material,e}static GetSingleCube2(e,t=10){this.initHeap();let r=new te,s=r.addComponent(ce);return s.castShadow=!1,s.geometry=new us(t,t,t),s.material=e,r}}o(pa,"boxGeo"),o(pa,"sphere"),o(pa,"material");class Qm extends Number{}class Vm extends Number{}class Hm extends Number{}class Ym extends wi{constructor(){super(...arguments),o(this,"x",0),o(this,"y",0),o(this,"z",0),o(this,"w",0)}}export{Hh as AccelerateDecelerateInterpolator,Qh as AccelerateInterpolator,aa as AnimationCurve,_r as AnimationMonitor,ap as AnimatorEventKeyframe,Wh as AnticipateInterpolator,Ss as AnticipateOvershootInterpolator,Jf as ArrayHas,Zf as ArrayItemIndex,Zo as AtlasParser,ip as AtmosphericComponent,Tc as AtmosphericScatteringSky,Bc as AtmosphericScatteringSkySetting,rn as AtmosphericScatteringSky_shader,Rc as AttributeAnimCurve,dp as AudioListener,Fm as AxisObject,Pi as B3DMLoader,Uu as B3DMLoaderBase,jo as B3DMParseUtil,Xo as B3DMParser,Yg as BLUR_CsShader,Gu as BRDFLUT,Qu as BRDFLUTGenerate,jn as BRDF_frag,Ho as BatchTable,Ia as Bezier2D,Tf as Bezier3D,ys as BillboardComponent,xi as BillboardType,ii as BitmapTexture2D,Tl as BitmapTexture2DArray,ko as BitmapTextureCube,Dl as Blend,no as BlendFactor,xe as BlendMode,Ci as Bloom_shader,Su as BlurEffectCreatorBlur_cs,bu as BlurEffectCreatorSample_cs,Iu as BlurTexture2DBufferCreator,At as BounceInterpolator,Zt as BoundUtil,Be as BoundingBox,Sa as BoundingSphere,Dc as BoxColliderShape,us as BoxGeometry,Fn as BrdfLut_frag,qn as BxDF_frag,$n as BxdfDebug_frag,km as BytesStream,je as CEvent,hi as CEventDispatcher,Lr as CEventListener,df as CResizeEvent,lt as CSM,Zi as Camera3D,pp as CameraControllerBase,Ie as CameraType,Ne as CameraUtil,Ep as CapsuleColliderShape,bf as CastPointShadowMaterialPass,Sf as CastShadowMaterialPass,Kn as Clearcoat_frag,ih as ClusterBoundsSource_cs,ke as ClusterConfig,En as ClusterDebug_frag,_c as ClusterLight,th as ClusterLightingBuffer,wh as ClusterLightingRender,rh as ClusterLighting_cs,Ul as CollectInfo,rp as ColliderComponent,Xe as ColliderShape,mr as ColliderShapeType,z as Color,wf as ColorLitMaterial,en as ColorLitShader,Wa as ColorPassFragmentOutput,eh as ColorPassRenderer,ja as ColorUtil,On as Common_frag,Nn as Common_vert,Ee as ComponentBase,ae as ComponentCollect,ir as ComputeGPUBuffer,be as ComputeShader,Rh as CubeCamera,Bu as CubeMapFaceEnum,Ur as CubeSky_Shader,ca as CubicBezierCurve,Am as CubicBezierPath,Mf as CubicBezierType,jh as CycleInterpolator,Pm as CylinderGeometry,Oh as DDGIIrradianceComputePass,Es as DDGIIrradianceGPUBufferReader,kl as DDGIIrradianceVolume,Uh as DDGIIrradiance_shader,zh as DDGILightingPass,kh as DDGILighting_shader,Fh as DDGIMultiBouncePass,Gh as DDGIProbeRenderer,_e as DEGREES_TO_RADIANS,Vh as DecelerateInterpolator,Eh as Depth2DTextureArray,Sh as DepthCubeArrayTexture,Lm as DepthCubeTexture,If as DepthMaterialPass,Vp as DepthOfFieldPost,Ku as DepthOfView_cs,ou as DirectLight,Vt as EditorInspector,A as Engine3D,bl as Entity,Ol as EntityBatchCollect,Q as EntityCollect,kn as EnvMap_frag,Di as ErpImage2CubeMap,Tu as ErpImage2CubeMapCreateCube_cs,Mu as ErpImage2CubeMapRgbe2rgba_cs,Pp as ExtrudeGeometry,zt as FASTFLOOR,uo as FXAAPost,Ic as FXAAShader,Gn as FastMathShader,ta as FeatureTable,ht as FileLoader,mp as FirstPersonCameraController,Gf as Float16ArrayTexture,Um as Float32ArrayTexture,Ap as FlyCameraController,Xu as FontChar,Hu as FontInfo,Yu as FontPage,Jo as FontParser,wo as ForwardRenderJob,Vn as FragmentVarying,an as FrameCache,yl as Frustum,Cl as FrustumCSM,Wg as FrustumCulling_cs,el as FullQuad_vert_wgsl,wt as GBufferFrame,Ef as GBufferPass,$o as GBuffer_pass,Xs as GILighting,cn as GIProbeMaterial,un as GIProbeMaterialType,yc as GIProbeShader,Co as GIRenderCompleteEvent,Hs as GIRenderStartEvent,gu as GLBChunk,du as GLBHeader,qs as GLBParser,pu as GLSLLexer,as as GLSLLexerToken,mu as GLSLPreprocessor,vu as GLSLSyntax,Fu as GLTFBinaryExtension,Ke as GLTFParser,js as GLTFSubParser,Jh as GLTFSubParserCamera,fu as GLTFSubParserConverter,eu as GLTFSubParserMaterial,$h as GLTFSubParserMesh,Lo as GLTFSubParserSkeleton,tu as GLTFSubParserSkin,le as GLTFType,Cg as GLTF_Accessors,Ys as GLTF_Info,_g as GLTF_Light,yg as GLTF_Mesh,xg as GLTF_Node,vg as GLTF_Primitives,Ag as GLTF_Scene,Bt as GPUAddressMode,Wf as GPUBlendFactor,Jt as GPUBufferBase,Mt as GPUBufferType,vt as GPUCompareFunction,w as GPUContext,ui as GPUCullMode,Nr as GPUFilterMode,Ms as GPUPrimitiveTopology,G as GPUTextureFormat,Fr as GPUVertexFormat,Kf as GPUVertexStepMode,Hp as GTAOPost,Ju as GTAO_cs,ju as GUIAtlasTexture,Cs as GUICanvas,ye as GUIConfig,Fc as GUIGeometry,zc as GUIGeometryRebuild,Gc as GUIMaterial,Hc as GUIPick,Ft as GUIPickHelper,Fi as GUIQuad,Pe as GUIQuadAttrEnum,Qc as GUIRenderer,Ni as GUIShader,Nt as GUISpace,fr as GUISprite,dr as GUITexture,al as GenerayRandomDir,tt as GeometryBase,Kl as GeometryIndicesBuffer,zm as GeometryUtil,jl as GeometryVertexBuffer,ti as GeometryVertexType,qa as GetCountInstanceID,od as GetRepeat,wn as GlassMaterial,Cc as GlassShader,pe as GlobalBindGroup,Hr as GlobalBindGroupLayout,Yp as GlobalFog,Ec as GlobalFog_shader,Sp as GlobalIlluminationComponent,Ts as GlobalUniform,Sl as GlobalUniformGroup,Xp as GodRayPost,Zu as GodRay_cs,af as Graphic3D,Us as Graphic3DBatchRenderer,rf as Graphic3DFillRenderer,Ll as Graphic3DFixedRenderPipeline,sf as Graphic3DLineBatchRenderer,Rl as Graphic3DShader_fs,Pl as Graphic3DShader_vs,ei as GraphicConfig,lo as Graphics3DShape,Wp as HDRBloomPost,Go as HDRTexture,ea as HDRTextureCube,Ls as HaltonSeq,Kc as Horizontal,_p as HoverCameraController,si as I3DMLoader,ku as I3DMLoaderBase,qo as I3DMParser,cr as IBLEnvMapCreator,Ru as IBLEnvMapCreator_cs,Bi as IESProfiles,Yn as IESProfiles_frag,Op as IKDTreeUserData,pr as ImageType,ql as IndicesGPUBuffer,Un as Inline_vert,In as InputSystem,Ip as InstanceDrawComponent,zn as InstanceUniform,zu as InstancedMesh,So as Interpolator,bo as InterpolatorEnum,Af as IrradianceDataReaderCompleteEvent,Ln as IrradianceVolumeData_frag,Wn as Irradiance_frag,Qd as IsEditorInspector,Gd as IsNonSerialize,iu as Joint,Ro as JointPose,Xh as JumperInterpolator,Fp as KDTreeEntity,fn as KDTreeNode,hf as KDTreeRange,uf as KDTreeSpace,ha as KDTreeUUID,rs as KHR_draco_mesh_compression,$p as KHR_lights_punctual,hu as KHR_materials_clearcoat,uu as KHR_materials_emissive_strength,em as KHR_materials_ior,tm as KHR_materials_sheen,im as KHR_materials_specular,rm as KHR_materials_transmission,cu as KHR_materials_unlit,sm as KHR_materials_variants,am as KHR_materials_volume,om as KHR_mesh_quantization,nm as KHR_texture_basisu,lm as KHR_texture_transform,Gm as KelvinUtil,Je as KeyCode,Qt as KeyEvent,sn as Keyframe,ra as LDRTextureCube,Kg as LUT_glsl,pm as LambertMaterial,wc as LambertShader,Ws as LightBase,Gr as LightData,zl as LightEntries,Qe as LightType,Bn as LightingFunction_frag,vr as Line,Yc as LineClassification,Yh as LinearInterpolator,yi as LitMaterial,Jn as LitShader,ji as LoaderBase,dn as LoaderEvent,Cf as LoaderManager,td as MAX_VALUE,id as MIN_VALUE,_i as Material,wu as MaterialDataUniformGPUBuffer,$g as MaterialUniform,Bs as MathShader,st as MathUtil,Qi as Matrix3,V as Matrix4,Vl as MatrixBindGroup,Up as MatrixDO,Ql as MatrixGPUBuffer,Sc as MatrixShader,zr as MemoryDO,ol as MemoryInfo,kp as MergeRGBACreator,$u as MergeRGBA_cs,tf as MeshColliderShape,ce as MeshRenderer,vm as MinMaxAnimationCurves,Nf as MinMaxCurve,Of as MinMaxCurveState,ym as MinMaxPolyCurves,Cr as MorePassParser,pf as MorePassShader,op as MorphTargetBlender,Yl as MorphTargetData,np as MorphTargetFrame,Le as MorphTarget_shader,gf as MouseCode,Nh as MultiBouncePass_cs,zd as NonSerialize,Qn as NormalMap_frag,su as OAnimationEvent,Fo as OBJParser,te as Object3D,fs as Object3DEvent,pa as Object3DUtil,Lc as ObjectAnimClip,ks as OcclusionSystem,er as Octree,Ml as OctreeEntity,xp as OrbitController,yt as Orientation3D,ec as OutLineBlendColor_cs,tc as OutlineCalcOutline_cs,Jg as OutlinePass,jp as OutlinePost,xf as OutlinePostData,vf as OutlinePostManager,_f as OutlinePostSlot,ic as Outline_cs,qh as OvershootInterpolator,Zn as PBRLItShader,Xt as ParserBase,Uf as ParticleSystemCurveEvalMode,Df as ParticleSystemRandomnessIds,Xr as PassGenerate,mf as PassShader,Zg as PavementShader,os as PhysicMaterial,Tn as PhysicMaterialUniform_frag,of as PickCompute,nf as PickFire,yf as PickResult,rc as Picker_cs,Ja as PingPong,Js as PipelinePool,bn as Plane,Zl as PlaneGeometry,Xc as PointClassification,nu as PointLight,Ih as PointLightShadowRenderer,mm as PointMaterial,bh as PointShadowCubeCamera,bc as PointShadowDebug,R as PointerEvent3D,jt as Polynomial,da as PolynomialCurve,xm as Polynomials,Vc as PoolNode,gp as PositionAudio,Ct as PostBase,bp as PostProcessingComponent,Dh as PostRenderer,Th as PreDepthPassRenderer,ut as Preprocessor,ef as Probe,Gl as ProbeEntries,Lh as ProbeGBufferFrame,ft as ProfilerUtil,sp as PropertyAnimClip,Uc as PropertyAnimTag,An as PropertyAnimation,Ui as PropertyAnimationEvent,Wt as PropertyHelp,vc as QuadGlsl_fs,xc as QuadGlsl_vs,Xf as Quad_depth2dArray_frag_wgsl,rl as Quad_depth2d_frag_wgsl,sl as Quad_depthCube_frag_wgsl,il as Quad_frag_wgsl,tl as Quad_vert_wgsl,q as Quaternion,qi as RADIANS_TO_DEGREES,Pu as RGBEErrorCode,Qo as RGBEHeader,$s as RGBEParser,Ce as RTDescriptor,Ze as RTFrame,Ae as RTResourceConfig,Fe as RTResourceMap,As as Rand,nd as RandomSeed,ci as Ray,zi as RayCastMeshDetail,nr as Reader,bs as Rect,se as Reference,Vd as RegisterComponent,$l as RenderContext,Yr as RenderLayer,oo as RenderLayerUtil,$t as RenderNode,We as RenderShader,Nl as RenderShaderCollect,di as RendererBase,Ph as RendererJob,Mh as RendererMap,Ue as RendererMask,Tt as RendererMaskUtil,Wl as RendererPassState,re as RendererType,Za as RepeatSE,qu as Res,Is as SN_ArrayConstant,Ai as SN_BinaryOperation,zg as SN_Break,Gt as SN_CodeBlock,ni as SN_Constant,va as SN_Continue,Te as SN_Declaration,Gg as SN_Discard,kg as SN_DoWhileLoop,ie as SN_Expression,Yi as SN_ForLoop,_a as SN_Function,xa as SN_FunctionArgs,Hi as SN_FunctionCall,Gi as SN_IFBranch,ri as SN_Identifier,Wi as SN_IndexOperation,vs as SN_Layout,_u as SN_ParenExpression,ya as SN_Precision,_s as SN_Return,xs as SN_SelectOperation,oi as SN_Struct,xu as SN_TernaryOperation,lr as SN_UnaryOperation,Xi as SN_WhileLoop,Xg as SSAO_cs,qp as SSRPost,sc as SSR_BlendColor_cs,Kp as SSR_IS_Kernel,ac as SSR_IS_cs,oc as SSR_RayTrace_cs,Tp as Scene3D,No as ShaderAttributeInfo,Ka as ShaderBase,Ks as ShaderConverter,yu as ShaderConverterResult,N as ShaderLib,ct as ShaderReflection,Ut as ShaderStage,Cu as ShaderState,Oo as ShaderUniformInfo,Ot as ShaderUtil,Hn as ShadingInput,Ve as ShadowLightsCollect,Bh as ShadowMapPassRenderer,Xn as ShadowMapping_frag,ru as Skeleton,ma as SkeletonAnimationClip,au as SkeletonAnimationClipState,vi as SkeletonAnimationComponent,lp as SkeletonAnimationCompute,Or as SkeletonAnimation_shader,hp as SkeletonBlendComputeArgs,ss as SkeletonPose,up as SkeletonTransformComputeArgs,Aa as SkinnedMeshRenderer,Bf as SkyGBufferPass,gc as SkyGBuffer_pass,Mc as SkyMaterial,sa as SkyRenderer,qg as Sky_glsl_fs,jg as Sky_glsl_vs,Om as SolidColorSky,Bp as SphereColliderShape,ls as SphereGeometry,lu as SpotLight,me as StatementNode,Oc as StaticAudio,ge as StorageGPUBuffer,it as StringUtil,wi as Struct,zp as StructStorageGPUBuffer,Jl as SubGeometry,nc as TAACopyTex_cs,Jp as TAAPost,lc as TAASharpTex_cs,hc as TAA_cs,jc as TextAnchor,Zc as TextFieldLayout,Jc as TextFieldLine,at as Texture,Zs as TextureCube,Vo as TextureCubeFaceData,hr as TextureCubeStdCreator,zo as TextureCubeUtils,ds as TextureMipmapCompute,Ht as TextureMipmapGenerator,yp as ThirdPersonCameraController,hm as TileSet,cm as TileSetChild,fm as TileSetChildContent,dm as TileSetChildContentMetaData,um as TileSetRoot,Cn as TilesRenderer,he as Time,x as TokenType,Rm as TorusGeometry,Sn as TouchData,Oe as Transform,Uo as TranslatorContext,na as Triangle,_n as UIButton,$c as UIButtonTransition,ln as UIComponentBase,ua as UIEvent,Vi as UIImage,xn as UIImageGroup,ba as UIInteractive,De as UIInteractiveStyle,ws as UIPanel,cs as UIRenderAble,vn as UIShadow,yn as UITextField,li as UITransform,Pt as UUID,zf as UV,Nm as Uint16Texture,Vu as Uint8ArrayTexture,tn as UnLit,hs as UnLitMaterial,Mn as UnLitMaterialUniform_frag,Dn as UnLit_frag,Dt as UniformGPUBuffer,$ as UniformNode,$e as UniformType,Cm as ValueSpread,Z as Vector2,g as Vector3,Oi as Vector3Ex,Ym as Vector3Struct,j as Vector4,Lp as VertexAttribute,Y as VertexAttributeName,bi as VertexAttributeSize,lf as VertexAttributeStride,Pn as VertexAttributes,Rp as VertexBufferLayout,ll as VertexFormat,ho as VertexGPUBuffer,qc as Vertical,Rn as VideoUniform_frag,Mp as View3D,Ca as ViewPanel,Ns as ViewQuad,oe as VirtualTexture,Au as WGSLTranslator,He as WebGPUDescriptorCreator,Xa as WorldMatrixUniform,wa as WorldPanel,Ar as WrapMode,Pc as WrapTimeMode,Qp as ZCullingCompute,pc as ZPassShader_cs,mc as ZPassShader_fs,Ac as ZPassShader_vs,Il as ZSorterUtil,xl as append,Lu as arrayToString,jf as blendComponent,bm as buildCurves,Sm as calculateCurveRangesValue,ps as calculateMinMax,cc as castPointShadowMap_vert,K as clamp,Td as clampRepeat,cp as compute_skeleton_blend,fp as compute_skeleton_transform,vd as cos,Id as crossProduct,Pf as cubicPolynomialRoot,Rf as cubicPolynomialRootsGeneric,wm as curvesSupportProcedural,Ad as deg2Rad,dc as directionShadowCastMap_frag,et as dot,Lf as doubleIntegrateSegment,Qm as f32,Al as fastInvSqrt,ml as floorfToIntPos,gr as fonts,Ed as generateRandom,Bd as generateRandom3,fl as getFloatFromInt,Lg as getGLTypeFromTypedArray,Rg as getGLTypeFromTypedArrayType,yd as getGlobalRandomSeed,Ug as getTypedArray,Po as getTypedArrayTypeFromGLType,mn as grad1,ga as grad2,ms as grad3,br as grad4,Vm as i32,pn as integrateSegment,Gp as irradianceDataReader,_m as kPI,Ii as lerp,ad as lerpByte,sd as lerpColor,rd as lerpVector3,eo as magnitude,Hg as makeAloneSprite,Wu as makeGUISprite,Rs as makeMatrix44,so as matrixMultiply,Rd as matrixRotate,Pd as matrixRotateY,_l as multiplyMatrices4x4REF,Ff as normal_distribution,Sd as normalizeFast,cl as normalizeSafe,bd as normalizedToByte,wd as normalizedToWord,kt as outlinePostData,Zp as outlinePostManager,J as perm,fa as quadraticPolynomialRootsGeneric,_d as rad2Deg,Ki as random01,md as randomBarycentricCoord,pd as randomPointBetweenEllipsoid,dd as randomPointBetweenSphere,cd as randomPointInsideCube,fd as randomPointInsideEllipsoid,gd as randomPointInsideUnitCircle,gl as randomPointInsideUnitSphere,hd as randomQuaternion,ud as randomQuaternionUniformDistribution,pl as randomSeed,Ps as randomUnitVector,dl as randomUnitVector2,qe as rangedRandomFloat,ld as rangedRandomInt,Yo as readMagicBytes,gm as registerMaterial,ro as repeat,Dd as rotMatrix,ed as rotateVectorByQuat,to as roundfToIntPos,$a as scale,fc as shadowCastMap_frag,uc as shadowCastMap_vert,mt as simplex,xd as sin,Bm as snoise1,Tm as snoise2,Mm as snoise3,Dm as snoise4,io as sqrMagnitude,ul as sqrtImpl,qf as stencilStateFace,Cd as swap,ur as toHalfFloat,Hm as u32,Im as uniform_real_distribution,Em as uniform_real_distribution2,S as webGPUContext,El as zSorterUtil};