<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>PlayCanvas Hello Cube</title>
    <meta name='viewport' content='width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no' />
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
    </style>
    <script src='./src/playcanvas-stable.min.js'></script>
</head>
<body>
    <input  id="button" type="button" value="start" >  
    <canvas id='application'></canvas>
    <script>
        // create a PlayCanvas application
        const canvas = document.getElementById('application');
        
        function example(canvas, deviceType) {
            let initTime = ( performance || Date ).now()
			let loaded=false;
			let startFlag = true;
			let frameCount = 0;
			let startTime = null;
			let shouldLog = true;
			let first = true;
			let frameSum=0;
            const gfxOptions = {
                deviceTypes: [deviceType],
                glslangUrl: "./src/glslang.js",
                twgslUrl: "./src/twgsl.js",
            };

            pc.createGraphicsDevice(canvas, gfxOptions)
                .then((device) => {
                const createOptions = new pc.AppOptions();
                createOptions.graphicsDevice = device;

                createOptions.componentSystems = [
                    // @ts-ignore
                    pc.RenderComponentSystem,
                    // @ts-ignore
                    pc.CameraComponentSystem,
                ];

                createOptions.resourceHandlers = [
                    // @ts-ignore
                    pc.TextureHandler,
                ];

                const app = new pc.AppBase(canvas);
                app.init(createOptions);

                // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size
                app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);
                app.setCanvasResolution(pc.RESOLUTION_AUTO);
            
                app.start();

                // setup skydome
                app.scene.skyboxMip = 2;
                app.scene.exposure = 0.3;
                // set up some general scene rendering properties
                app.scene.toneMapping = pc.TONEMAP_ACES;

                app.scene.ambientLight = new pc.Color(0.1, 0.1, 0.1);

                // Create an Entity with a camera component
                const camera = new pc.Entity();
                camera.addComponent("camera", {});

                app.root.addChild(camera);

                // Move the camera back to see the cubes
                camera.translate(0, 0, 10);

                // create standard material and enable instancing on it
                const material = new pc.StandardMaterial();
                material.onUpdateShader = function (options) {
                    options.litOptions.useInstancing = true;
                    return options;
                };
                material.gloss = 0.6;
                material.metalness = 0.7;
                material.useMetalness = true;
                material.update();

                // Create a Entity with a cylinder render component and the instancing material
                const box = new pc.Entity("InstancingEntity");
                box.addComponent("render", {
                    material: material,
                    type: "box",
                });

                // add the box entity to the hierarchy
                app.root.addChild(box);

                if (app.graphicsDevice.supportsInstancing) {
                    // number of instances to render
                    const instanceCount = 32768;

                    // store matrices for individual instances into array
                    const matrices = new Float32Array(instanceCount * 16);
                    let matrixIndex = 0;

                    const radius = 5;
                    const pos = new pc.Vec3();
                    const rot = new pc.Quat();
                    const scl = new pc.Vec3();
                    const matrix = new pc.Mat4();

                    for (let i = 0; i < instanceCount; i++) {
                        // generate random positions / scales and rotations
                        pos.set(
                            Math.random() * radius - radius * 0.5,
                            Math.random() * radius - radius * 0.5,
                            Math.random() * radius - radius * 0.5
                        );
                        scl.set(
                            0.1 + Math.random() * 0.1,
                            0.1 + Math.random() * 0.3,
                            0.1 + Math.random() * 0.1
                        );
                        rot.setFromEulerAngles(i * 30, i * 50, i * 70);
                        matrix.setTRS(pos, rot, scl);

                        // copy matrix elements into array of floats
                        for (let m = 0; m < 16; m++)
                            matrices[matrixIndex++] = matrix.data[m];
                    }

                    // create static vertex buffer containing the matrices
                    const vertexBuffer = new pc.VertexBuffer(
                        app.graphicsDevice,
                        pc.VertexFormat.getDefaultInstancingFormat(
                            app.graphicsDevice
                        ),
                        instanceCount,
                        pc.BUFFER_STATIC,
                        matrices
                    );

                    // initialize instancing using the vertex buffer on meshInstance of the created box
                    const boxMeshInst = box.render.meshInstances[0];
                    boxMeshInst.setInstancing(vertexBuffer);
                }
                loaded=true;

                // Set an update function on the app's update event
                let angle = 0;
                app.on("update", function (dt) {
                    // orbit camera around
                    angle += dt * 0.2;
                    camera.setLocalPosition(
                        8 * Math.sin(angle),
                        0,
                        8 * Math.cos(angle)
                    );
                    camera.lookAt(pc.Vec3.ZERO);
                    if (loaded){
					let time = performance.now();
					if (startFlag) {
						startTime = time;
						startFlag = false;
						console.log('startTime',startTime,'duration',startTime-initTime);
						// console.log(renderer.info)
						// let programs=renderer.info.programs
						// console.log(programs[0].vertexShader)
					}
					frameCount += 1;
					if(frameCount % 1000 === 0) {
						let fps = 1000 * frameCount / (time - startTime);
						console.log(frameCount,fps,'fps');
					} 
					if ((time - startTime) /1000 > 60 && shouldLog){
						shouldLog = false;
						let fps = 1000 * frameCount / (time - startTime);
						console.log('1min', (time - startTime)/1000, frameCount,fps,'fps');
					}
            	}
                });
            });
          
    }
    var btn = document.getElementById("button");  
    btn.onclick = function conduct(){
        example(canvas, "webgpu");
    }
    </script>
</body>
</html> 